<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS AFNetWorking源码详解（六） · 宫城</title><meta name="description" content="iOS AFNetWorking源码详解（六） - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS AFNetWorking源码详解（六）</h1><div class="post-info">2016年5月27日</div><div class="post-content"><p><code>AFURLResponseSerialization</code>是用来将返回的response处理成相应的格式，它通过协议对特定response的data进行解码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response&#10;                           data:(nullable NSData *)data&#10;                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>AFHTTPResponseSerializer</code>可以通过<code>+ serializer</code>和<code>- init</code>方法进行初始化，实际上<code>+ serializer</code>内只是调用了<code>- init</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)serializer &#123;&#10;    return [[self alloc] init];&#10;&#125;&#10;&#10;- (instancetype)init &#123;&#10;    self = [super init];&#10;    if (!self) &#123;&#10;        return nil;&#10;    &#125;&#10;&#9;// &#35774;&#32622;&#23383;&#31526;&#20018;&#32534;&#30721;&#31867;&#22411;&#65292;&#21487;&#25509;&#21463;&#30340;&#29366;&#24577;&#30721;&#65292;&#21487;&#25509;&#21463;&#30340;MIME&#31867;&#22411;&#10;    self.stringEncoding = NSUTF8StringEncoding;&#10;&#9;self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];&#10;    self.acceptableContentTypes = nil;&#10;&#10;    return self;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>acceptableStatusCodes和acceptableContentTypes可以通过外部进行设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy, nullable) NSIndexSet *acceptableStatusCodes;&#10;@property (nonatomic, copy, nullable) NSSet &#60;NSString *&#62; *acceptableContentTypes;</span><br></pre></td></tr></table></figure>
<p>然后可以调用<code>- [validateResponse:data:error:]</code>检查这个response是否包含可接受的状态码和可接受MIME类型来验证response的有效性，子类也可以增加特定域名检查，<code>- [responseObjectForResponse:data:error]</code>也是调用了这个方法，返回data</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response&#10;                           data:(NSData *)data&#10;                          error:(NSError *__autoreleasing *)error&#10;&#123;&#10;    // &#35843;&#29992;- [validateResponse:data:error:]&#26041;&#27861;&#65292;&#36820;&#22238;data &#10;    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];&#10;&#10;    return data;&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response&#10;                    data:(NSData *)data&#10;                   error:(NSError * __autoreleasing *)error&#10;&#123;&#10;    // &#35774;&#32622;&#21021;&#22987;&#20540;&#10;    BOOL responseIsValid = YES;&#10;    NSError *validationError = nil;&#10;&#10;    // &#26816;&#26597;&#36825;&#20010;response&#26159;&#21542;&#21253;&#21547;&#21487;&#25509;&#21463;&#30340;&#29366;&#24577;&#30721;&#21644;&#21487;&#25509;&#21463;MIME&#31867;&#22411;&#10;&#10;    if (error &#38;&#38; !responseIsValid) &#123;&#10;        *error = validationError;&#10;    &#125;&#10;    // &#36820;&#22238;response&#26159;&#21542;&#26377;&#25928;&#24615;&#10;    return responseIsValid;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>检查这个response是否包含可接受的状态码和可接受MIME类型</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#26816;&#26597;response&#26159;&#21542;&#20026;&#31354;&#65292;&#20197;&#21450;response&#26159;&#21542;&#26159;NSHTTPURLResponse&#31867;&#10;    if (response &#38;&#38; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;&#10;        // acceptableContentTypes&#19981;&#20026;&#31354;&#24182;&#19988;response&#30340;MIME&#31867;&#22411;&#19981;&#22312;&#21487;&#25509;&#21463;&#30340;&#33539;&#22260;&#37324;&#10;        if (self.acceptableContentTypes &#38;&#38; ![self.acceptableContentTypes containsObject:[response MIMEType]]) &#123;&#10;            &#10;            // &#21253;&#35013;&#38169;&#35823;&#20449;&#24687;&#10;            if ([data length] &#62; 0 &#38;&#38; [response URL]) &#123;&#10;                NSMutableDictionary *mutableUserInfo = [@&#123;&#10;                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&#34;Request failed: unacceptable content-type: %@&#34;, @&#34;AFNetworking&#34;, nil), [response MIMEType]],&#10;                                                          NSURLErrorFailingURLErrorKey:[response URL],&#10;                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,&#10;                                                        &#125; mutableCopy];&#10;                if (data) &#123;&#10;                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;&#10;                &#125;&#10;&#10;                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);&#10;            &#125;&#10;            &#10;            responseIsValid = NO;&#10;        &#125;&#10;        // acceptableStatusCodes&#19981;&#20026;&#31354;&#24182;&#19988;acceptableStatusCodes&#21253;&#21547;response&#30340;&#29366;&#24577;&#30721;&#65292;response&#30340;URL&#20063;&#23384;&#22312;&#10;        if (self.acceptableStatusCodes &#38;&#38; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &#38;&#38; [response URL]) &#123;&#10;            // &#21253;&#35013;&#38169;&#35823;&#20449;&#24687;&#10;            NSMutableDictionary *mutableUserInfo = [@&#123;&#10;                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&#34;Request failed: %@ (%ld)&#34;, @&#34;AFNetworking&#34;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],&#10;                                               NSURLErrorFailingURLErrorKey:[response URL],&#10;                                               AFNetworkingOperationFailingURLResponseErrorKey: response,&#10;                                       &#125; mutableCopy];&#10;&#10;            if (data) &#123;&#10;                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;&#10;            &#125;&#10;&#10;            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);&#10;&#10;            responseIsValid = NO;&#10;        &#125;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<p>但是这里有个疑问，假如response为nil或者response不是<code>NSHTTPURLResponse</code>类，那下面的操作均不会对responseIsValid布尔值进行修改，最后返回的是个YES，但是这样的response不应该是NO么？</p>
<hr>
<p><code>AFJSONResponseSerializer</code>是继承于<code>AFHTTPResponseSerializer</code></p>
<p>外部可以设置<code>NSJSONReadingOptions</code>和是否移除空值的key</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) NSJSONReadingOptions readingOptions;&#10;@property (nonatomic, assign) BOOL removesKeysWithNullValues;</span><br></pre></td></tr></table></figure>
<p>转换object的时候，会检查data是否是空格，这个是Safari的一个bug，具体请看<a href="https://github.com/rails/rails/issues/1742" target="_blank" rel="external">Workaround for behavior of Rails to return a single space for <code>head :ok</code> (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response&#10;                           data:(NSData *)data&#10;                          error:(NSError *__autoreleasing *)error&#10;&#123;&#10;    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;&#10;        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;&#10;            return nil;&#10;        &#125;&#10;    &#125;&#10;&#10;    id responseObject = nil;&#10;    NSError *serializationError = nil;&#10;    // &#21028;&#26029;&#26159;&#21542;&#26159;&#31354;&#26684;&#10;    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&#34; &#34; length:1]];&#10;    if (data.length &#62; 0 &#38;&#38; !isSpace) &#123;&#10;        responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&#38;serializationError];&#10;    &#125; else &#123;&#10;        return nil;&#10;    &#125;&#10;    // &#35843;&#29992;AFJSONObjectByRemovingKeysWithNullValues&#25226;&#31354;&#20540;&#30340;key&#37117;&#31227;&#38500;&#25481;&#65292;&#36820;&#22238;object&#10;    if (self.removesKeysWithNullValues &#38;&#38; responseObject) &#123;&#10;        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);&#10;    &#125;&#10;&#10;    if (error) &#123;&#10;        *error = AFErrorWithUnderlyingError(serializationError, *error);&#10;    &#125;&#10;&#10;    return responseObject;&#10;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>AFXMLParserResponseSerializer</code>则是直接校验response后，用data初始化NSXMLParser对象并返回</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSHTTPURLResponse *)response&#10;                           data:(NSData *)data&#10;                          error:(NSError *__autoreleasing *)error&#10;&#123;&#10;    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;&#10;        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;&#10;            return nil;&#10;        &#125;&#10;    &#125;&#10;&#10;    return [[NSXMLParser alloc] initWithData:data];&#10;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>AFPropertyListResponseSerializer</code>也是类似的处理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response&#10;                           data:(NSData *)data&#10;                          error:(NSError *__autoreleasing *)error&#10;&#123;&#10;    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;&#10;        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;&#10;            return nil;&#10;        &#125;&#10;    &#125;&#10;&#10;    id responseObject;&#10;    NSError *serializationError = nil;&#10;&#10;    if (data) &#123;&#10;        responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&#38;serializationError];&#10;    &#125;&#10;&#10;    if (error) &#123;&#10;        *error = AFErrorWithUnderlyingError(serializationError, *error);&#10;    &#125;&#10;&#10;    return responseObject;&#10;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>AFImageResponseSerializer</code>在验证response之后，会根据设置是否自动解压automaticallyInflatesResponseImage布尔值，来对imageData按图片比例返回UIImage对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) CGFloat imageScale;&#10;@property (nonatomic, assign) BOOL automaticallyInflatesResponseImage;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response&#10;                           data:(NSData *)data&#10;                          error:(NSError *__autoreleasing *)error&#10;&#123;&#10;    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;&#10;        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;&#10;            return nil;&#10;        &#125;&#10;    &#125;&#10;&#10;#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH&#10;    // iOS&#38656;&#35201;&#25163;&#21160;&#35299;&#21387;&#22270;&#29255;&#10;    if (self.automaticallyInflatesResponseImage) &#123;&#10;        return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);&#10;    &#125; else &#123;&#10;        return AFImageWithDataAtScale(data, self.imageScale);&#10;    &#125;&#10;#else&#10;    // MacOS&#21487;&#20197;&#30452;&#25509;&#20351;&#29992;NSBitmapImageRep&#26469;&#35299;&#21387;&#10;    NSBitmapImageRep *bitimage = [[NSBitmapImageRep alloc] initWithData:data];&#10;    NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize([bitimage pixelsWide], [bitimage pixelsHigh])];&#10;    [image addRepresentation:bitimage];&#10;&#10;    return image;&#10;#endif&#10;&#10;    return nil;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果不解压的话，就直接根据imageData和scale来创建Image，但是这有个疑问是，AF为什么要创建两次image，我觉得可以直接使用- [imageWithData:scale:]方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) &#123;&#10;    UIImage *image = [UIImage af_safeImageWithData:data];&#10;    if (image.images) &#123;&#10;        return image;&#10;    &#125;&#10;    &#10;    return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果用imageWithData转成UIImage对象后，由于网络图片PNG和JPG都是压缩格式，需要解压成bitmap后才能渲染到屏幕，这时会在主线程对图片进行解压操作，这是比较耗时的，可能还会对主线程造成阻塞，所以AF还提供了<code>AFInflatedImageFromResponseWithDataAtScale</code>方法，对PNG和JPG解压后，返回UIImage对象，这样避免了在主线程的解压操作，不会对主线程造成卡顿</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) &#123;&#10;    if (!data || [data length] == 0) &#123;&#10;        return nil;&#10;    &#125;&#10;&#9;// &#21019;&#24314;CGImageRef&#10;    CGImageRef imageRef = NULL;&#10;    // &#29992;data&#21019;&#24314;CGDataProviderRef&#10;    CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);&#10;&#10;    if ([response.MIMEType isEqualToString:@&#34;image/png&#34;]) &#123;&#10;        imageRef = CGImageCreateWithPNGDataProvider(dataProvider,  NULL, true, kCGRenderingIntentDefault);&#10;    &#125; else if ([response.MIMEType isEqualToString:@&#34;image/jpeg&#34;]) &#123;&#10;        imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);&#10;&#10;        if (imageRef) &#123;&#10;            CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);&#10;            CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);&#10;&#10;            // &#22914;&#26524;&#33394;&#24425;&#31354;&#38388;&#26159;CMKY&#65292;CGImageCreateWithJPEGDataProvider&#26159;&#19981;&#20250;&#36827;&#34892;&#22788;&#29702;&#30340;&#65292;&#20063;&#23601;&#26159;&#19981;&#36827;&#34892;&#35299;&#21387;&#65292;&#23558;&#35843;&#29992;AFImageWithDataAtScale&#36820;&#22238;image&#10;            if (imageColorSpaceModel == kCGColorSpaceModelCMYK) &#123;&#10;                CGImageRelease(imageRef);&#10;                imageRef = NULL;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#10;    CGDataProviderRelease(dataProvider);&#10;&#9;// &#19981;&#31526;&#21512;&#35299;&#21387;&#26465;&#20214;&#30340;&#65292;&#23558;&#35843;&#29992;AFImageWithDataAtScale&#36820;&#22238;image&#65292;&#20294;&#26159;&#36825;&#37324;&#22914;&#26524;&#31526;&#21512;&#35299;&#21387;&#26465;&#20214;&#30340;&#20063;&#20250;&#35843;&#29992;&#65292;&#20197;&#21450;&#19979;&#38754;&#20250;&#23545;&#36229;&#20986;&#22823;&#23567;&#30340;&#65292;&#30452;&#25509;&#36820;&#22238;image&#65292;&#36825;&#37324;&#25105;&#35273;&#24471;&#24212;&#35813;&#32479;&#19968;&#23545;&#19981;&#31526;&#21512;&#26465;&#20214;&#30340;&#36820;&#22238;image&#65292;&#31526;&#21512;&#26465;&#20214;&#30340;&#23601;&#19981;&#38656;&#35201;&#35843;&#29992;AFImageWithDataAtScale&#10;    UIImage *image = AFImageWithDataAtScale(data, scale);&#10;    if (!imageRef) &#123;&#10;        if (image.images || !image) &#123;&#10;            return image;&#10;        &#125;&#10;&#9;&#9;// &#36825;&#37324;&#35843;&#29992;CGImageCreateCopy&#65292;&#21482;&#20250;&#23545;&#22270;&#24418;&#26412;&#36523;&#32467;&#26500;&#36827;&#34892;&#25335;&#36125;&#65292;&#24213;&#23618;&#30340;&#25968;&#25454;&#26159;&#19981;&#20250;&#25335;&#36125;&#30340;&#10;        imageRef = CGImageCreateCopy([image CGImage]);&#10;        if (!imageRef) &#123;&#10;            return nil;&#10;        &#125;&#10;    &#125;&#10;&#9;// &#35774;&#32622;&#22270;&#29255;&#30340;&#23485;&#21644;&#39640;&#21644;&#23384;&#20648;&#19968;&#20010;&#20687;&#32032;&#25152;&#38656;&#35201;&#29992;&#21040;&#30340;&#23383;&#33410;&#10;    size_t width = CGImageGetWidth(imageRef);&#10;    size_t height = CGImageGetHeight(imageRef);&#10;    size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);&#10;&#9;// &#22914;&#26524;&#22270;&#29255;&#22823;&#23567;&#23485;&#39640;&#20056;&#31215;&#36229;&#36807;1024*1024&#25110;&#32773;bitsPerComponent&#22823;&#20110;8&#37117;&#19981;&#35299;&#21387;&#20102;&#65292;&#22240;&#20026;bitmap&#26159;&#19968;&#30452;&#23384;&#22312;UIImage&#23545;&#35937;&#37324;&#30340;&#65292;&#21487;&#33021;&#20250;&#25226;&#20869;&#23384;&#29190;&#20102;&#10;    if (width * height &#62; 1024 * 1024 || bitsPerComponent &#62; 8) &#123;&#10;        CGImageRelease(imageRef);&#10;&#10;        return image;&#10;    &#125;&#10;&#10;    // &#30011;&#24067;&#21442;&#25968;&#10;    size_t bytesPerRow = 0;&#10;    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();&#10;    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);&#10;    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);&#10;&#10;    if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;&#10;        uint32_t alpha = (bitmapInfo &#38; kCGBitmapAlphaInfoMask);&#10;#pragma clang diagnostic push&#10;#pragma clang diagnostic ignored &#34;-Wassign-enum&#34;&#10;        if (alpha == kCGImageAlphaNone) &#123;&#10;            bitmapInfo &#38;= ~kCGBitmapAlphaInfoMask;&#10;            bitmapInfo |= kCGImageAlphaNoneSkipFirst;&#10;        &#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;&#10;            bitmapInfo &#38;= ~kCGBitmapAlphaInfoMask;&#10;            bitmapInfo |= kCGImageAlphaPremultipliedFirst;&#10;        &#125;&#10;#pragma clang diagnostic pop&#10;    &#125;&#10;&#9;// &#21019;&#24314;&#30011;&#24067;&#10;    CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);&#10;&#10;    CGColorSpaceRelease(colorSpace);&#10;&#10;    if (!context) &#123;&#10;        CGImageRelease(imageRef);&#10;&#10;        return image;&#10;    &#125;&#10;&#9;// &#22312;&#30011;&#24067;&#19978;&#30011;&#20986;&#22270;&#29255;&#10;    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);&#10;    // &#20445;&#23384;&#25104;CGImageRef&#10;  &#9;CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);&#10;&#10;    CGContextRelease(context);&#10;&#9;// &#20877;&#36716;&#25104;UIImage&#23545;&#35937;&#10;    UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];&#10;&#10;    CGImageRelease(inflatedImageRef);&#10;    CGImageRelease(imageRef);&#10;&#10;    return inflatedImage;&#10;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>AFCompoundResponseSerializer</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response&#10;                           data:(NSData *)data&#10;                          error:(NSError *__autoreleasing *)error&#10;&#123;&#10;    // &#36941;&#21382;responseSerializers                    &#10;    for (id &#60;AFURLResponseSerialization&#62; serializer in self.responseSerializers) &#123;&#10;        // &#22914;&#26524;serializer&#19981;&#26159;AFHTTPResponseSerializer&#31867;&#65292;&#21017;&#32487;&#32493;&#10;      &#9;if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) &#123;&#10;            continue;&#10;        &#125;&#10;&#10;        NSError *serializerError = nil;&#10;        // &#19968;&#23618;&#19968;&#23618;&#30340;&#35843;&#29992;&#33258;&#24049;&#30340;- [responseObjectForResponse:data:error:]&#65292;&#30452;&#21040;&#36820;&#22238;responseObject&#10;        id responseObject = [serializer responseObjectForResponse:response data:data error:&#38;serializerError];&#10;        if (responseObject) &#123;&#10;            if (error) &#123;&#10;                *error = AFErrorWithUnderlyingError(serializerError, *error);&#10;            &#125;&#10;&#10;            return responseObject;&#10;        &#125;&#10;    &#125;&#10;&#10;    return [super responseObjectForResponse:response data:data error:error];&#10;&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2016/06/11/iOS-card-animation/" class="prev">上一篇</a><a href="/2016/05/25/AFNetWorking-five/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/05/27/AFNetWorking-six/';
var disqus_title = 'iOS AFNetWorking源码详解（六）';
var disqus_url = 'http://yuzeyang.github.io/2016/05/27/AFNetWorking-six/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>