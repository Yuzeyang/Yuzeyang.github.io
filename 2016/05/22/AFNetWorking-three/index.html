<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS AFNetWorking源码详解（三） · 宫城</title><meta name="description" content="iOS AFNetWorking源码详解（三） - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS AFNetWorking源码详解（三）</h1><div class="post-info">2016年5月22日</div><div class="post-content"><p>在iOS9之后，在默认情况下是不能发送HTTP请求，推荐使用HTTPS，当然你可以在plist里面设置<code>NSAppTransportSecurity</code>的NSAllowsArbitraryLoads为true，App就依然支持HTTP请求</p>
<p>而AFSecurityPolicy主要的作用就是验证HTTPS请求的证书的有效性</p>
<a id="more"></a>
<p>AFSecurityPolicy是安全策略类，有三种SSL Pinning模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123;&#10;    AFSSLPinningModeNone,// &#22312;&#35777;&#20070;&#21015;&#34920;&#20013;&#26657;&#39564;&#26381;&#21153;&#31471;&#36820;&#22238;&#30340;&#35777;&#20070;&#10;    AFSSLPinningModePublicKey,// &#23458;&#25143;&#31471;&#35201;&#26377;&#26381;&#21153;&#31471;&#30340;&#35777;&#20070;&#25335;&#36125;&#65292;&#21482;&#26159;&#39564;&#35777;&#26102;&#21482;&#39564;&#35777;&#35777;&#20070;&#37324;&#30340;&#20844;&#38053;&#10;    AFSSLPinningModeCertificate,// &#23458;&#25143;&#31471;&#35201;&#26377;&#26381;&#21153;&#31471;&#30340;&#35777;&#20070;&#25335;&#36125;&#65292;&#31532;&#19968;&#27493;&#20808;&#39564;&#35777;&#35777;&#20070;&#22495;&#21517;/&#26377;&#25928;&#26399;&#31561;&#20449;&#24687;&#65292;&#31532;&#20108;&#27493;&#23545;&#26381;&#21153;&#31471;&#36820;&#22238;&#30340;&#35777;&#20070;&#21644;&#23458;&#25143;&#31471;&#36820;&#22238;&#30340;&#26159;&#21542;&#19968;&#33268;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>这个是证书集合，泛型里面表示了集合里面是NSData类型，表明这个是用来存证书数据的集合，这些证书根据SSL Pinning模式来和服务器进行校验，默认是没有证书的，我们需要调用+ certificatesInBundle:方法将bundle里面的证书文件转成里面是data类型的集合</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong, nullable) NSSet &#60;NSData *&#62; *pinnedCertificates;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123;&#10;    // &#33719;&#21462;&#35777;&#20070;&#10;  &#9;NSArray *paths = [bundle pathsForResourcesOfType:@&#34;cer&#34; inDirectory:@&#34;.&#34;];&#10;&#10;    NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]];&#10;    // &#23558;&#35777;&#20070;&#25991;&#20214;&#36716;&#25104;data&#10;  &#9;for (NSString *path in paths) &#123;&#10;        NSData *certificateData = [NSData dataWithContentsOfFile:path];&#10;        [certificates addObject:certificateData];&#10;    &#125;&#10;&#10;    return [NSSet setWithSet:certificates];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>有三种初始化的方法，一种是默认策略，AFSSLPinningModeNone</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)defaultPolicy &#123;&#10;    AFSecurityPolicy *securityPolicy = [[self alloc] init];&#10;    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;&#10;&#10;    return securityPolicy;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是自定义一个安全策略，然后读取cer文件放到集合里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;&#10;    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)defaultPinnedCertificates &#123;&#10;    static NSSet *_defaultPinnedCertificates = nil;&#10;    static dispatch_once_t onceToken;&#10;    dispatch_once(&#38;onceToken, ^&#123;&#10;        NSBundle *bundle = [NSBundle bundleForClass:[self class]];&#10;        _defaultPinnedCertificates = [self certificatesInBundle:bundle];&#10;    &#125;);&#10;&#10;    return _defaultPinnedCertificates;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>第三种则是需要我们多传入一个证书集合</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123;&#10;    AFSecurityPolicy *securityPolicy = [[self alloc] init];&#10;    securityPolicy.SSLPinningMode = pinningMode;&#10;&#10;    [securityPolicy setPinnedCertificates:pinnedCertificates];&#10;&#10;    return securityPolicy;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>设置证书的时候，就是把上面初始化时传入的证书取出公钥，再把公钥保存到mutablePinnedPublicKeys集合中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123;&#10;    _pinnedCertificates = pinnedCertificates;&#10;&#10;    if (self.pinnedCertificates) &#123;&#10;        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];&#10;        for (NSData *certificate in self.pinnedCertificates) &#123;&#10;            // &#21462;&#20986;&#20844;&#38053;&#10;          &#9;id publicKey = AFPublicKeyForCertificate(certificate);&#10;            if (!publicKey) &#123;&#10;                continue;&#10;            &#125;&#10;            // &#23558;&#20844;&#38053;&#23384;&#21040;&#38598;&#21512;&#10;            [mutablePinnedPublicKeys addObject:publicKey];&#10;        &#125;&#10;        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];&#10;    &#125; else &#123;&#10;        self.pinnedPublicKeys = nil;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>AFPublicKeyForCertificate</code>方法里面，做了一系列操作后返回公钥，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static id AFPublicKeyForCertificate(NSData *certificate) &#123;&#10;    id allowedPublicKey = nil;&#10;    SecCertificateRef allowedCertificate;&#10;    SecCertificateRef allowedCertificates[1];&#10;    CFArrayRef tempCertificates = nil;&#10;    SecPolicyRef policy = nil;&#10;    SecTrustRef allowedTrust = nil;&#10;    SecTrustResultType result;&#10;&#10;  &#9;// &#21462;&#20986;&#35777;&#20070;SecCertificateRef&#10;    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);&#10;    __Require_Quiet(allowedCertificate != NULL, _out);&#10;&#9;&#10;  &#9;// &#29983;&#25104;&#35777;&#20070;&#25968;&#32452;&#10;    allowedCertificates[0] = allowedCertificate;&#10;    tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);&#10;&#10;  &#9;// &#29983;&#25104;SecPolicyRef&#10;    policy = SecPolicyCreateBasicX509();&#10;    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &#38;allowedTrust), _out);&#10;    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &#38;result), _out);&#10;&#9;&#10;  &#9;// &#20174;SecPolicyRef&#20013;&#21462;&#20986;&#20844;&#38053;&#10;    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);&#10;&#10;_out:&#10;    // &#19968;&#20123;&#36164;&#28304;&#30340;&#37322;&#25918;&#10;&#10;    return allowedPublicKey;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><code>-[evaluateServerTrust:forDomain:]</code>方法是<code>AFSecurityPolicy</code>类最长也是最重要的方法，它用来验证服务端是否是受信的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust&#10;                  forDomain:(NSString *)domain&#10;&#123;&#10;    // &#33529;&#26524;&#25991;&#26723;&#20013;&#34920;&#31034;&#19981;&#35201;&#38544;&#24335;&#22320;&#20449;&#20219;&#33258;&#24049;&#31614;&#21517;&#30340;&#35777;&#20070;&#65292;&#21462;&#32780;&#20195;&#20043;&#30340;&#26159;&#24212;&#35813;&#22686;&#21152;&#33258;&#24049;&#30340;CA&#35777;&#20070;&#21040;&#21463;&#20449;&#21015;&#34920;&#37324;&#10;    if (domain &#38;&#38; self.allowInvalidCertificates &#38;&#38; self.validatesDomainName &#38;&#38; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;&#10;        NSLog(@&#34;In order to validate a domain name for self signed certificates, you MUST use pinning.&#34;);&#10;        return NO;&#10;    &#125;&#10;&#10;    // policies&#22686;&#21152;SecPolicyRef&#10;    NSMutableArray *policies = [NSMutableArray array];&#10;    if (self.validatesDomainName) &#123;&#10;        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];&#10;    &#125; else &#123;&#10;        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];&#10;    &#125;&#10;&#9;&#10;    // &#35774;&#32622;&#20449;&#20219;&#30340;policies&#24212;&#24403;&#34987;&#39564;&#35777;&#10;    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);&#10;&#9;&#10;    // &#21521;&#31995;&#32479;&#20869;&#32622;&#30340;&#26681;&#35777;&#20070;&#39564;&#35777;&#26381;&#21153;&#31471;&#36820;&#22238;&#30340;&#35777;&#20070;&#26159;&#21542;&#21512;&#27861;&#10;    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;&#10;        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);&#10;    &#125; else if (!AFServerTrustIsValid(serverTrust) &#38;&#38; !self.allowInvalidCertificates) &#123;&#10;        return NO;&#10;    &#125;&#10;&#9;&#10;    // &#26681;&#25454;SSLPinningMode&#23545;&#26381;&#21153;&#31471;&#26159;&#21542;&#21463;&#20449;&#36827;&#34892;&#26657;&#39564;&#10;    switch (self.SSLPinningMode) &#123;&#10;        case AFSSLPinningModeNone:&#10;        default:&#10;            return NO;&#10;        case AFSSLPinningModeCertificate: &#123;&#10;            NSMutableArray *pinnedCertificates = [NSMutableArray array];&#10;            for (NSData *certificateData in self.pinnedCertificates) &#123;&#10;                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];&#10;            &#125;&#10;            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);&#10;&#10;            if (!AFServerTrustIsValid(serverTrust)) &#123;&#10;                return NO;&#10;            &#125;&#10;&#10;            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&#39;s the Root CA)&#10;            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);&#10;            &#10;            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;&#10;                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;&#10;                    return YES;&#10;                &#125;&#10;            &#125;&#10;            &#10;            return NO;&#10;        &#125;&#10;        case AFSSLPinningModePublicKey: &#123;&#10;            NSUInteger trustedPublicKeyCount = 0;&#10;            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);&#10;&#10;            for (id trustChainPublicKey in publicKeys) &#123;&#10;                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;&#10;                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;&#10;                        trustedPublicKeyCount += 1;&#10;                    &#125;&#10;                &#125;&#10;            &#125;&#10;            return trustedPublicKeyCount &#62; 0;&#10;        &#125;&#10;    &#125;&#10;    &#10;    return NO;&#10;&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2016/05/23/AFNetWorking-four/" class="prev">上一篇</a><a href="/2016/04/29/hexo_build_github_blog/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/05/22/AFNetWorking-three/';
var disqus_title = 'iOS AFNetWorking源码详解（三）';
var disqus_url = 'http://yuzeyang.github.io/2016/05/22/AFNetWorking-three/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>