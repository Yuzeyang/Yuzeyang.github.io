<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 抽屉式效果列表 · 宫城</title><meta name="description" content="iOS 抽屉式效果列表 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 抽屉式效果列表</h1><div class="post-info">2016年9月8日</div><div class="post-content"><p>之前很喜欢收藏<a href="https://dribbble.com/shots" target="_blank" rel="external">dribbble</a>里面的一些动效gif，里面不仅是动效还是配色等等都非常的美，作为一个视觉动物，真的想把他们一个一个都实现出来，作为自己的一个作品，那真的是一件赏心悦目的事情，看着G20也快结束了，赶紧趁还闲着，先实现一个，我先挑选了一个比较简单的动效—–<strong>抽屉式效果列表</strong></p>
<p>我们先来看下效果:</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCDrawerTableView.gif!500x500" alt=""></p>
<a id="more"></a>
<p>原来的动效地址找不到了…有知道的请留言给我…</p>
<p>代码地址：<a href="https://github.com/Yuzeyang/GCDrawerTableView" target="_blank" rel="external">https://github.com/Yuzeyang/GCDrawerTableView</a></p>
<p>老样子，我们来分析下步骤</p>
<h2 id="0x00_cell_u7684_u5904_u7406"><a href="#0x00_cell_u7684_u5904_u7406" class="headerlink" title="0x00 cell的处理"></a>0x00 cell的处理</h2><p>我们将<code>cell</code>和<code>详情界面</code>分开来处理</p>
<p>我们可以看到，当我们选中其中一个<code>cell</code>的时候，该<code>cell</code>会移动到列表上方的某一个位置，其他<code>cell</code>则不显示，点击<code>x</code>的时候，<code>cell</code>返回为原位，其他<code>cell</code>又重新显示</p>
<p>选中处理：首先是先将其他<code>cell</code>隐藏，我们取出<code>tableview</code>的可见<code>cell</code>，然后将除了选中的<code>cell</code>之外的透明度都设置为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GCTableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];</div><div class="line">[self.tableView bringSubviewToFront:cell];</div><div class="line">for (UIView *subcell in tableView.visibleCells) &#123;</div><div class="line">    if (subcell != cell) &#123;</div><div class="line">        subcell.alpha = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后改变选中<code>cell</code>的原点值，并且给<code>cell</code>增加阴影，这里我偷懒没有做按钮的动画，只是用文字表示了按钮的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">    CGRect rect = self.frame;</div><div class="line">    self.originCellFrame = rect;</div><div class="line">    CGPoint origin = CGPointMake(0, contentOffsetY + 30);</div><div class="line">    rect.origin = origin;</div><div class="line">    self.frame = rect;</div><div class="line"></div><div class="line">    // 详情页处理</div><div class="line"></div><div class="line">    [self addShadowWithView:self];</div><div class="line">    [self addShadowWithView:self.detailView];</div><div class="line">    [self.detailButton setTitle:@&quot;×&quot; forState:UIControlStateNormal];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>由于cell的动画处理是放在自定义cell里面做的，所以在点击关闭的时候，需要在动画结束之后回调给视图控制器，所以这里就用了block来回调关闭的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)deselectCell &#123;</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        self.frame = self.originCellFrame;</div><div class="line">        </div><div class="line">        self.layer.shadowColor = [UIColor clearColor].CGColor;</div><div class="line">        self.layer.shadowRadius = 0;</div><div class="line">        self.layer.shadowOpacity = 0.0;</div><div class="line">        </div><div class="line">        // 详情页处理</div><div class="line">        [self.detailButton setTitle:@&quot;...&quot; forState:UIControlStateNormal];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [self.helperHideView removeFromSuperview];</div><div class="line">        [self.detailView removeFromSuperview];</div><div class="line">        if (_deselectBlock) &#123;</div><div class="line">            _deselectBlock();</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在试图控制器里面，将其他的cell透明度改成1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[cell addDeselectBlock:^() &#123;</div><div class="line">    for (UIView *subcell in tableView.visibleCells) &#123;</div><div class="line">        if (subcell != cell) &#123;</div><div class="line">            subcell.alpha = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    tableView.allowsSelection = YES;</div><div class="line">    tableView.scrollEnabled = YES;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="0x01__u8BE6_u60C5_u9875"><a href="#0x01__u8BE6_u60C5_u9875" class="headerlink" title="0x01 详情页"></a>0x01 详情页</h2><p>可以看到<code>详情页</code>是类似于从上掉落的感觉，可能会联想到电商的那些筛选栏，但是筛选栏点击的时候，是上部分开始出现一直到下面，展示的顺序是反过来的，后面想了很久，只能想到利用视觉错误的效果，将详情页添加到cell的下一层，然后<code>cell</code>动画时候，详情页也做相应的动画，但是由于详情页的<code>size</code>比<code>cell</code>肯定是要大的，所以如果加到<code>cell</code>下一层时，是遮挡不住的，所以就需要一个遮挡的view来遮住详情页</p>
<p>首先我们需要将<code>cell</code>移到最前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.tableView bringSubviewToFront:cell];</div></pre></td></tr></table></figure>
<p>然后在cell的下一层加上<code>遮挡视图</code>和<code>详情页</code>，并根据cell的origin做frame的变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">UIView *superview = self.superview;</div><div class="line">    </div><div class="line">CGFloat height = CGRectGetMinY(self.frame) - contentOffsetY + 30;</div><div class="line">[self.helperHideView setFrame:CGRectMake(0, contentOffsetY, CGRectGetWidth(self.frame), height)];</div><div class="line">[superview insertSubview:self.helperHideView belowSubview:self];</div><div class="line"></div><div class="line">[self.detailView setFrame:CGRectMake(0, CGRectGetMaxY(self.frame) - (GCDeviceHeight - 100 - 30*2),</div><div class="line">                                     CGRectGetWidth(self.frame), GCDeviceHeight - 100 - 30*2)];</div><div class="line">[superview insertSubview:self.detailView belowSubview:self.helperHideView];</div><div class="line"></div><div class="line">[UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">  	// cell处理  </div><div class="line">  </div><div class="line">  	CGRect rect2 = self.helperHideView.frame;</div><div class="line">    self.originHelperViewFrame = rect2;</div><div class="line">    CGPoint origin2 = CGPointMake(0, contentOffsetY + 30 - height);</div><div class="line">    rect2.origin = origin2;</div><div class="line">    self.helperHideView.frame = rect2;</div><div class="line"></div><div class="line">    CGRect rect1 = self.detailView.frame;</div><div class="line">    self.originDetailViewFrame = rect1;</div><div class="line">    CGPoint origin1 = CGPointMake(0, 100 + 30 + contentOffsetY);</div><div class="line">    rect1.origin = origin1;</div><div class="line">    self.detailView.frame = rect1;</div><div class="line"></div><div class="line">    [self addShadowWithView:self];</div><div class="line">    [self addShadowWithView:self.detailView];</div><div class="line">    [self.detailButton setTitle:@&quot;×&quot; forState:UIControlStateNormal];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>然后在关闭的时候，移除掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)deselectCell &#123;</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        // cell处理</div><div class="line">        </div><div class="line">        self.detailView.layer.shadowColor = [UIColor clearColor].CGColor;</div><div class="line">        self.detailView.layer.shadowRadius = 0;</div><div class="line">        self.detailView.layer.shadowOpacity = 0.0;</div><div class="line">        </div><div class="line">        self.detailView.frame = self.originDetailViewFrame;</div><div class="line">        self.helperHideView.frame = self.originHelperViewFrame;</div><div class="line">        </div><div class="line">        [self.detailButton setTitle:@&quot;...&quot; forState:UIControlStateNormal];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [self.helperHideView removeFromSuperview];</div><div class="line">        [self.detailView removeFromSuperview];</div><div class="line">        if (_deselectBlock) &#123;</div><div class="line">            _deselectBlock();</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就实现了抽屉式的效果，但是总感觉还有更好的办法实现，如果有思路的，欢迎交流~</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/09/02/loadingAniamtion-0902/" class="prev">上一篇</a><a href="/2016/10/09/react-native/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/09/08/iOS-Drawer-Table-View/';
var disqus_title = 'iOS 抽屉式效果列表';
var disqus_url = 'http://yuzeyang.github.io/2016/09/08/iOS-Drawer-Table-View/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>