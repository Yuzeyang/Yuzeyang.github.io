<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 抽屉式效果列表 · 宫城</title><meta name="description" content="iOS 抽屉式效果列表 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 抽屉式效果列表</h1><div class="post-info">2016年9月8日</div><div class="post-content"><p>之前很喜欢收藏<a href="https://dribbble.com/shots" target="_blank" rel="external">dribbble</a>里面的一些动效gif，里面不仅是动效还是配色等等都非常的美，作为一个视觉动物，真的想把他们一个一个都实现出来，作为自己的一个作品，那真的是一件赏心悦目的事情，看着G20也快结束了，赶紧趁还闲着，先实现一个，我先挑选了一个比较简单的动效—–<strong>抽屉式效果列表</strong></p>
<p>我们先来看下效果:</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCDrawerTableView.gif!500x500" alt=""></p>
<a id="more"></a>
<p>原来的动效地址找不到了…有知道的请留言给我…</p>
<p>老样子，我们来分析下步骤</p>
<h2 id="0x00_cell_u7684_u5904_u7406"><a href="#0x00_cell_u7684_u5904_u7406" class="headerlink" title="0x00 cell的处理"></a>0x00 cell的处理</h2><p>我们将<code>cell</code>和<code>详情界面</code>分开来处理</p>
<p>我们可以看到，当我们选中其中一个<code>cell</code>的时候，该<code>cell</code>会移动到列表上方的某一个位置，其他<code>cell</code>则不显示，点击<code>x</code>的时候，<code>cell</code>返回为原位，其他<code>cell</code>又重新显示</p>
<p>选中处理：首先是先将其他<code>cell</code>隐藏，我们取出<code>tableview</code>的可见<code>cell</code>，然后将除了选中的<code>cell</code>之外的透明度都设置为0</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCTableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];&#10;[self.tableView bringSubviewToFront:cell];&#10;for (UIView *subcell in tableView.visibleCells) &#123;&#10;    if (subcell != cell) &#123;&#10;        subcell.alpha = 0;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后改变选中<code>cell</code>的原点值，并且给<code>cell</code>增加阴影，这里我偷懒没有做按钮的动画，只是用文字表示了按钮的状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:0.3 animations:^&#123;&#10;    CGRect rect = self.frame;&#10;    self.originCellFrame = rect;&#10;    CGPoint origin = CGPointMake(0, contentOffsetY + 30);&#10;    rect.origin = origin;&#10;    self.frame = rect;&#10;&#10;    // &#35814;&#24773;&#39029;&#22788;&#29702;&#10;&#10;    [self addShadowWithView:self];&#10;    [self addShadowWithView:self.detailView];&#10;    [self.detailButton setTitle:@&#34;&#215;&#34; forState:UIControlStateNormal];&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>由于cell的动画处理是放在自定义cell里面做的，所以在点击关闭的时候，需要在动画结束之后回调给视图控制器，所以这里就用了block来回调关闭的状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)deselectCell &#123;&#10;    [UIView animateWithDuration:0.3 animations:^&#123;&#10;        self.frame = self.originCellFrame;&#10;        &#10;        self.layer.shadowColor = [UIColor clearColor].CGColor;&#10;        self.layer.shadowRadius = 0;&#10;        self.layer.shadowOpacity = 0.0;&#10;        &#10;        // &#35814;&#24773;&#39029;&#22788;&#29702;&#10;        [self.detailButton setTitle:@&#34;...&#34; forState:UIControlStateNormal];&#10;    &#125; completion:^(BOOL finished) &#123;&#10;        [self.helperHideView removeFromSuperview];&#10;        [self.detailView removeFromSuperview];&#10;        if (_deselectBlock) &#123;&#10;            _deselectBlock();&#10;        &#125;&#10;    &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后在试图控制器里面，将其他的cell透明度改成1</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[cell addDeselectBlock:^() &#123;&#10;    for (UIView *subcell in tableView.visibleCells) &#123;&#10;        if (subcell != cell) &#123;&#10;            subcell.alpha = 0;&#10;        &#125;&#10;    &#125;&#10;    tableView.allowsSelection = YES;&#10;    tableView.scrollEnabled = YES;&#10;&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="0x01__u8BE6_u60C5_u9875"><a href="#0x01__u8BE6_u60C5_u9875" class="headerlink" title="0x01 详情页"></a>0x01 详情页</h2><p>可以看到<code>详情页</code>是类似于从上掉落的感觉，可能会联想到电商的那些筛选栏，但是筛选栏点击的时候，是上部分开始出现一直到下面，展示的顺序是反过来的，后面想了很久，只能想到利用视觉错误的效果，将详情页添加到cell的下一层，然后<code>cell</code>动画时候，详情页也做相应的动画，但是由于详情页的<code>size</code>比<code>cell</code>肯定是要大的，所以如果加到<code>cell</code>下一层时，是遮挡不住的，所以就需要一个遮挡的view来遮住详情页</p>
<p>首先我们需要将<code>cell</code>移到最前</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.tableView bringSubviewToFront:cell];</span><br></pre></td></tr></table></figure>
<p>然后在cell的下一层加上<code>遮挡视图</code>和<code>详情页</code>，并根据cell的origin做frame的变化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIView *superview = self.superview;&#10;    &#10;CGFloat height = CGRectGetMinY(self.frame) - contentOffsetY + 30;&#10;[self.helperHideView setFrame:CGRectMake(0, contentOffsetY, CGRectGetWidth(self.frame), height)];&#10;[superview insertSubview:self.helperHideView belowSubview:self];&#10;&#10;[self.detailView setFrame:CGRectMake(0, CGRectGetMaxY(self.frame) - (GCDeviceHeight - 100 - 30*2),&#10;                                     CGRectGetWidth(self.frame), GCDeviceHeight - 100 - 30*2)];&#10;[superview insertSubview:self.detailView belowSubview:self.helperHideView];&#10;&#10;[UIView animateWithDuration:0.3 animations:^&#123;&#10;  &#9;// cell&#22788;&#29702;  &#10;  &#10;  &#9;CGRect rect2 = self.helperHideView.frame;&#10;    self.originHelperViewFrame = rect2;&#10;    CGPoint origin2 = CGPointMake(0, contentOffsetY + 30 - height);&#10;    rect2.origin = origin2;&#10;    self.helperHideView.frame = rect2;&#10;&#10;    CGRect rect1 = self.detailView.frame;&#10;    self.originDetailViewFrame = rect1;&#10;    CGPoint origin1 = CGPointMake(0, 100 + 30 + contentOffsetY);&#10;    rect1.origin = origin1;&#10;    self.detailView.frame = rect1;&#10;&#10;    [self addShadowWithView:self];&#10;    [self addShadowWithView:self.detailView];&#10;    [self.detailButton setTitle:@&#34;&#215;&#34; forState:UIControlStateNormal];&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>然后在关闭的时候，移除掉</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)deselectCell &#123;&#10;    [UIView animateWithDuration:0.3 animations:^&#123;&#10;        // cell&#22788;&#29702;&#10;        &#10;        self.detailView.layer.shadowColor = [UIColor clearColor].CGColor;&#10;        self.detailView.layer.shadowRadius = 0;&#10;        self.detailView.layer.shadowOpacity = 0.0;&#10;        &#10;        self.detailView.frame = self.originDetailViewFrame;&#10;        self.helperHideView.frame = self.originHelperViewFrame;&#10;        &#10;        [self.detailButton setTitle:@&#34;...&#34; forState:UIControlStateNormal];&#10;    &#125; completion:^(BOOL finished) &#123;&#10;        [self.helperHideView removeFromSuperview];&#10;        [self.detailView removeFromSuperview];&#10;        if (_deselectBlock) &#123;&#10;            _deselectBlock();&#10;        &#125;&#10;    &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这样就实现了抽屉式的效果，但是总感觉还有更好的办法实现，如果有思路的，欢迎交流~</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/09/02/loadingAniamtion-0902/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/09/08/iOS-Drawer-Table-View/';
var disqus_title = 'iOS 抽屉式效果列表';
var disqus_url = 'http://yuzeyang.github.io/2016/09/08/iOS-Drawer-Table-View/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>