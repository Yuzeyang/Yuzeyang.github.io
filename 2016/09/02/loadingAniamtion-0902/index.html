<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 果冻效果下拉刷新控件 · 宫城</title><meta name="description" content="果冻效果下拉刷新控件 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">果冻效果下拉刷新控件</h1><div class="post-info">2016年9月2日</div><div class="post-content"><p>这个下拉控件是在<a href="http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/?sukey=3997c0719f151520e178bb5175f11bfb983f5560c51261103fafb276bac79e1371d16e07ede0cca9f23d826405507a3c" target="_blank" rel="external">Elastic view animation using UIBezierPath</a>这篇博客上看到的，觉得效果还不错，自己也就OC简单实现了一下（原作者是用Swift写的），控件效果如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationTwo.gif!700x700" alt=""></p>
<p>这是代码地址：<a href="https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo" target="_blank" rel="external">https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo</a></p>
<p>这个控件的动画效果分为两个部分：</p>
<p>1.下拉的果冻效果</p>
<p>2.下拉进度圆圈的显示及旋转</p>
<a id="more"></a>
<h2 id="0x00__u4E0B_u62C9_u679C_u51BB_u72B6_u6001_u5B9E_u73B0_u601D_u8DEF"><a href="#0x00__u4E0B_u62C9_u679C_u51BB_u72B6_u6001_u5B9E_u73B0_u601D_u8DEF" class="headerlink" title="0x00 下拉果冻状态实现思路"></a>0x00 下拉果冻状态实现思路</h2><p>对于下拉的状态，我将其分为三种，然后在初始化的时候，将状态设置为正常状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, GCLoadingState) &#123;</div><div class="line">    GCLoadingStateNormal,	// 正常状态</div><div class="line">    GCLoadingStateLoading,	// 加载中状态</div><div class="line">    GCLoadingStateCancelled	// 取消加载状态</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>并且在初始化的时候，绘制曲线的初始样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)drawOriginPath &#123;</div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:CGPointMake(0, 0)];</div><div class="line">    [path addLineToPoint:CGPointMake(0, kGCLoadingViewMinHeight)];</div><div class="line">    [path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), kGCLoadingViewMinHeight)];</div><div class="line">    [path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), 0)];</div><div class="line">    </div><div class="line">    self.loadLayer.path = path.CGPath;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那在手指拖动的过程中，我们该如果实现果冻拉伸的效果呢？</p>
<p>我们需要一个辅助视图<code>centerHelperView</code>，这个辅助视图是加在下面这条线的中间的，如图的小黑点：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/centerHelperView.png!500x500" alt=""></p>
<p>在下拉时我们就根据这个<code>centerHelperView</code>的变化来不断的绘制我们的曲线，所以我们用到了<code>CADisplayLink</code>，这个应该在写动画的时候用的也是比较多了，是根据屏幕的刷新频率将内容绘制到屏幕的定时器，当我们将定时器加到<code>runLoop</code>里时，我们需要注意在设置<code>mode</code>时，如果将<code>mode</code>设置为<code>NSDefaultRunLoopMode</code>，那么在滑动的时候，定时器会暂停，直到停止滑动才会继续工作，所以我们需要将<code>mode</code>设置为<code>NSRunLoopCommonModes</code>，这样能保证定时器在滑动的过程中也能正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (CADisplayLink *)displayLink &#123;</div><div class="line">    if (!_displayLink) &#123;</div><div class="line">        _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkAction:)];</div><div class="line">        [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line">        _displayLink.paused = YES;</div><div class="line">    &#125;</div><div class="line">    return _displayLink;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在取出<code>centerHelperView</code>的原点，来不断绘制果冻的曲线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)displayLinkAction:(CADisplayLink *)displayLink &#123;</div><div class="line">    CALayer *centerHelperViewLayer = (CALayer *)[self.centerHelperView.layer presentationLayer];</div><div class="line">    CGRect centerHelperViewRect = [[centerHelperViewLayer valueForKey:@&quot;frame&quot;] CGRectValue];</div><div class="line">    [self drawLoadLayerWithCenter:centerHelperViewRect.origin];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然我们能够获取到<code>centerHelperView</code>在不同时间里的位置，那么我们就可以根据它来绘制我们的曲线</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/loadingPoint.png!300x300" alt=""></p>
<p>我们可以看到左右两边都是直线，调用<code>- addLineToPoint</code>方法即可，重要的是底下这条线，我们获取到<code>centerHelperView</code>的位置后，暂且用<code>c</code>来表示，我们在绘制曲线时，需要用到<code>controlPoint1</code>和<code>controlPoint2</code>，那我们就把底下的线分为三段，并且以<code>c</code>为中心店，左边取出<code>l3</code>、<code>l2</code>、<code>l1</code>，右边取出<code>r3</code>、<code>r2</code>、<code>r1</code>，曲线分为三条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">[path moveToPoint:CGPointMake(0, 0)];</div><div class="line">[path addLineToPoint:l3];</div><div class="line">[path addCurveToPoint:l1 controlPoint1:l3 controlPoint2:l2];</div><div class="line">[path addCurveToPoint:r1 controlPoint1:l1 controlPoint2:c];</div><div class="line">[path addCurveToPoint:r3 controlPoint1:r1 controlPoint2:r2];</div><div class="line">[path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), 0)];</div></pre></td></tr></table></figure>
<p>果冻的曲线我们就完成了，然后我们就要开始对手势的状态来进行处理</p>
<p>在写控件调试的时候，你可以通过给目标视图添加<code>UIPanGestureRecognizer</code>，调用<code>- translationInView:</code>来获取到手指在屏幕上拖动时位置的变化，但是下拉刷新控件一般都是加在ScrollView上的，ScrollView自己是有一个只读的<code>UIPanGestureRecognizer</code>属性，所以我们不必自己再添加一个，我们只需要观察<code>UIPanGestureRecognizer</code>的<code>state</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.associatedScrollView addObserver:self forKeyPath:@&quot;panGestureRecognizer.state&quot; options:NSKeyValueObservingOptionNew context:nil];</div></pre></td></tr></table></figure>
<p>在取消拖动时，我们根据<code>ScrollView</code>的<code>contentOffset</code>来判断，是否是取消加载还是加载</p>
<h2 id="0x01__u4E0B_u62C9_u8FDB_u5EA6_u5706_u5708_u7684_u663E_u793A_u53CA_u65CB_u8F6C"><a href="#0x01__u4E0B_u62C9_u8FDB_u5EA6_u5706_u5708_u7684_u663E_u793A_u53CA_u65CB_u8F6C" class="headerlink" title="0x01 下拉进度圆圈的显示及旋转"></a>0x01 下拉进度圆圈的显示及旋转</h2><p>进度圆圈的显示主要是依赖于下拉的进度，然后改变<code>progress</code>，圆圈随之绘制就好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (contentOffset.y &lt; 0) &#123;</div><div class="line">    self.progress = MAX(0.0, MIN(fabs(contentOffset.y/kGCPullMaxDistance), 1.0));</div><div class="line">&#125; else &#123;</div><div class="line">    self.progress = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    UIBezierPath *circlePath = [UIBezierPath bezierPath];</div><div class="line">    [circlePath moveToPoint:CGPointMake(0, - kGCLoadingCircleRadius)];</div><div class="line">    [circlePath addArcWithCenter:CGPointMake(0, 0) radius:kGCLoadingCircleRadius startAngle:-M_PI/2 endAngle:((M_PI*17/9)*self.progess - M_PI/2) clockwise:YES];</div><div class="line">    </div><div class="line">    self.circleLayer.path = circlePath.CGPath;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>progress</code>达到1之后，就开始旋转动画了，这个我们使用<code>CABasicAnimation</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">rotationAnimation.toValue = @(M_PI*2);</div><div class="line">rotationAnimation.beginTime = CACurrentMediaTime();</div><div class="line">rotationAnimation.duration = 1.0;</div><div class="line">rotationAnimation.fillMode = kCAFillModeForwards;</div><div class="line">rotationAnimation.repeatCount = HUGE_VALF;</div><div class="line">[self.circleLayer addAnimation:rotationAnimation forKey:nil];</div></pre></td></tr></table></figure>
<p>ok，大功告成~</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/08/07/get-protocol-methods/" class="prev">PREV</a><a href="/2016/09/08/iOS-Drawer-Table-View/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/09/02/loadingAniamtion-0902/';
var disqus_title = '果冻效果下拉刷新控件';
var disqus_url = 'http://yuzeyang.github.io/2016/09/02/loadingAniamtion-0902/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"></div><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>