<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS AFNetWorking源码详解（一） · 宫城</title><meta name="description" content="iOS AFNetWorking源码详解（一） - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS AFNetWorking源码详解（一）</h1><div class="post-info">2016年2月21日</div><div class="post-content"><p>首先来介绍下AFNetWorking，官方介绍如下：</p>
<blockquote>
<p>AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">Foundation URL Loading System</a>, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p>
<p>Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.</p>
<p>Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did!</p>
</blockquote>
<p>翻译过来简单来说就是</p>
<p>AFNetworking是一个适用于iOS和Mac OS X两个平台的网络库，它是基于<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">Foundation URL Loading System</a>上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking.png" alt=""></p>
<p>相信从star数和fork数来看，大家都能明白这个库是多么的受欢迎了，所以了解这个库对于一个iOS开发来说是极为重要的！</p>
<p>这个是AFNetworking的github地址：<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">GitHub - AFNetworking/AFNetworking: A delightful networking framework for iOS</a></p>
<p>在使用前阅读README是非常重要的，里面往往包括了这个库的介绍、安装和使用等等，对于快速了解一个库来说，这是非常有帮助的</p>
<hr>
<p>首先我们在<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetWorking源码地址</a>里download下来，打开工程文件，可以看到里面内容分为两个部分，一个是AFNetworking，另一个是UIKit+AFNetworking</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking_file.png" alt=""></p>
<p>很明显，第一个是用来做网络请求相关的，第二个则是和UI使用相关的，我们先看第一个</p>
<p>在看完头文件和README之后，你会发现AFURLSessionManager和AFHTTPSessionManager是里面比较重要的两个类</p>
<p>这里我先讲<strong>AFURLSessionManager</strong>这个类</p>
<p>首先浏览完这个类从API，发现其主要提供了数据的请求、上传和下载功能</p>
<p>在属性方面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(readonly,nonatomic,strong)NSArray *tasks;&#10;&#10;@property(readonly,nonatomic,strong)NSArray *dataTasks;&#10;&#10;@property(readonly,nonatomic,strong)NSArray *uploadTasks;&#10;&#10;@property(readonly,nonatomic,strong)NSArray *downloadTasks;</span><br></pre></td></tr></table></figure>
<p>通过这四个属性，我们分别可以拿到总的任务集合、数据任务集合、上传任务集合和下载任务集合</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,assign)BOOL attemptsToRecreateUploadTasksForBackgroundSessions;</span><br></pre></td></tr></table></figure>
<p>这个属性非常重要，注释里面写到，在iOS7中存在一个bug，在创建后台上传任务时，有时候会返回nil，所以为了解决这个问题，AFNetworking遵照了苹果的建议，在创建失败的时候，会重新尝试创建，次数默认为3次，所以你的应用如果有场景会有在后台上传的情况的话，记得将该值设为YES，避免出现上传失败的问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;</span><br></pre></td></tr></table></figure>
<p>在对外提供的notification key里面，使用了FOUNDATION_EXPORT来定义常量，使用FOUNDATION_EXPORT和extern或者define有什么区别呢？</p>
<p>FOUNDATION_EXPORT在c文件编译下是和extern等同，在c++文件编译下是和extern “C”等同，在32位机的环境下又是另外编译情况，在兼容性方面，FOUNDATION_EXPORT做的会更好。</p>
<p>这里还提到了效率方面的问题：<a href="http://www.jianshu.com/p/f547eb0368c4" target="_blank" rel="external">iOS开发的一些奇巧淫技3</a></p>
<hr>
<p>进入到实现文件里面，我们可以看到在外部API调用dataTask、uploadTask、downloadTask方法实际上都是completionHanlder block返回出来的，但是我们知道网络请求是delegate返回结果的，AF内部做了巧妙的操作，他对每个task都增加代理设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request&#10;                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock&#10;                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock&#10;                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;&#10;&#9;__block NSURLSessionDataTask *dataTask = nil;&#10;    url_session_manager_create_task_safely(^&#123;&#10;        dataTask = [self.session dataTaskWithRequest:request];&#10;    &#125;);&#10;    &#10;&#9;// &#27599;&#20010;task&#37324;&#38754;&#37117;&#20250;&#35843;&#29992;addDelegate&#26041;&#27861;&#10;    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];&#10;&#10;    return dataTask;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在设置里面，每个task会在内部创建AFURLSessionManagerTaskDelegate对象，并设置completionHandler、uploadProgressBlock、downloadProgressBlock回调</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask&#10;                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock&#10;              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock&#10;             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#10;&#123;&#10;    // &#21021;&#22987;&#21270;delegate&#23545;&#35937;&#10;    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];&#10;    delegate.manager = self;&#10;    // &#23558;task&#30340;completionHandler&#36171;&#32473;delegate&#65292;&#31995;&#32479;&#32593;&#32476;&#35831;&#27714;delegate &#35843;&#29992;&#35813;block&#65292;&#36820;&#22238;&#32467;&#26524;&#10;    delegate.completionHandler = completionHandler;&#10;&#10;    dataTask.taskDescription = self.taskDescriptionForSessionTasks;&#10;    // &#23545;task&#36827;&#34892;delegate&#10;    [self setDelegate:delegate forTask:dataTask];&#10;&#9;// &#35774;&#32622;&#19978;&#20256;&#21644;&#19979;&#36733;&#36827;&#24230;&#22238;&#35843;&#10;    delegate.uploadProgressBlock = uploadProgressBlock;&#10;    delegate.downloadProgressBlock = downloadProgressBlock;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后delegate对象利用kvo将task对一些方法进行监听，并且监听到变化时，通过block返回，将delegate转成block出去</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate&#10;            forTask:(NSURLSessionTask *)task&#10;&#123;&#10;    // &#26029;&#35328;&#10;    NSParameterAssert(task);&#10;    NSParameterAssert(delegate);&#10;&#10;    [self.lock lock];&#10;    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;&#10;    // task&#20351;&#29992;kvo&#23545;&#19968;&#20123;&#26041;&#27861;&#30417;&#21548;&#65292;&#36820;&#22238;&#19978;&#20256;&#25110;&#32773;&#19979;&#36733;&#30340;&#36827;&#24230;&#10;    [delegate setupProgressForTask:task];&#10;    // sessionManager&#23545;&#26242;&#20572;task&#21644;&#24674;&#22797;task&#36827;&#34892;&#27880;&#20876;&#36890;&#30693;&#10;    [self addNotificationObserverForTask:task];&#10;    [self.lock unlock];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在原先IM的设计时，因为接口的数量并不多，所以在AsyncSocket的delegate回调后，我们依旧是采用delegate回调给业务层，但是随着接口数量的增加，业务层对于回调的处理更加困难和不可控，在重构IM的时候，我们也参考学习了AF的做法，我们通过对唯一标识和每个请求做一一绑定，将请求的上下文关联起来，这样让socket长连接的请求的也想http请求一样，都由block回去，对于业务层的处理也方便更多</p>
<p>setupProgressForTask方法主要是对task和progress设置监听</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;&#10;    __weak __typeof__(task) weakTask = task;&#10;&#10;    // &#35774;&#32622;&#19978;&#20256;&#21644;&#19979;&#36733;&#30340;&#22823;&#23567;&#10;    &#10;    // &#35774;&#32622;&#19978;&#20256;&#21644;&#19979;&#36733;&#20013;&#20801;&#35768;&#21462;&#28040;&#21644;&#26242;&#20572;&#10;  &#10;  &#9;// &#35774;&#32622;&#19978;&#20256;&#21644;&#19979;&#36733;&#21709;&#24212;&#24674;&#22797;&#22788;&#29702;&#26041;&#27861;&#21518;&#24674;&#22797;&#19978;&#20256;&#25110;&#19979;&#36733;&#10;    &#10;    // task&#23545;&#25509;&#25910;&#21040;&#30340;&#23383;&#33410;&#25968;&#12289;&#26399;&#26395;&#25509;&#25910;&#21040;&#30340;&#23383;&#33410;&#25968;&#12289;&#21457;&#36865;&#30340;&#23383;&#33410;&#25968;&#12289;&#26399;&#26395;&#21457;&#36865;&#30340;&#23383;&#33410;&#25968;&#35774;&#32622;&#30417;&#21548;&#10;    [task addObserver:self&#10;           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))&#10;              options:NSKeyValueObservingOptionNew&#10;              context:NULL];&#10;    [task addObserver:self&#10;          forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))&#10;              options:NSKeyValueObservingOptionNew&#10;              context:NULL];&#10;&#10;    [task addObserver:self&#10;           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))&#10;              options:NSKeyValueObservingOptionNew&#10;              context:NULL];&#10;    [task addObserver:self&#10;           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))&#10;              options:NSKeyValueObservingOptionNew&#10;              context:NULL];&#10;&#9;// &#19978;&#20256;&#21644;&#19979;&#36733;&#35774;&#32622;&#23436;&#25104;&#30340;&#20998;&#25968;&#30417;&#21548;&#10;    [self.downloadProgress addObserver:self&#10;                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))&#10;                               options:NSKeyValueObservingOptionNew&#10;                               context:NULL];&#10;    [self.uploadProgress addObserver:self&#10;                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))&#10;                             options:NSKeyValueObservingOptionNew&#10;                             context:NULL];&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&#60;NSString *,id&#62; *)change context:(void *)context &#123;&#10;    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;&#10;        // &#35774;&#32622;&#19978;&#20256;&#21644;&#19979;&#36733;&#30340;&#26032;&#20540;&#10;    &#125;&#10;    else if ([object isEqual:self.downloadProgress]) &#123;&#10;        if (self.downloadProgressBlock) &#123;&#10;            self.downloadProgressBlock(object);&#10;        &#125;&#10;    &#125;&#10;    else if ([object isEqual:self.uploadProgress]) &#123;&#10;        if (self.uploadProgressBlock) &#123;&#10;            self.uploadProgressBlock(object);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个if判断里面，object判断是否是NSURLSessionTask类或者是否是NSURLSessionDownloadTask类，但是进到NSURLSessionDownloadTask的时候，我们可以看到NSURLSessionDownloadTask是NSURLSessionTask的子类，那为什么还要判断这个呢？</p>
<p>NSURLSessionTask实际上是<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ClassCluster.html" target="_blank" rel="external">Class cluster</a>，通过NSURLSession生成的task返回的并不一定是指定的task类型。因此kindOfClass并不总会生效，具体可以参见<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L382~L414" target="_blank" rel="external">AFURLSessionManager.m在load方法中的说明</a>。<br>特定于当前问题，是由于iOS 7上<strong>NSCFURLSessionDownloadTask的基类并不是</strong>NSCFURLSessionTask，因此isKindOfClass会出错。查看对应的<a href="https://github.com/AFNetworking/AFNetworking/commit/a745be4fcd75de75b560dce1d689b6bcc11f42ba#diff-dd81ac1f455a60ac8065ade41f06881f" target="_blank" rel="external">commit</a>就可以知道了。</p>
<p>在NSURLSessionTaskDelegate的代理里面，只是做了两件事情，第一个是获取数据，将responseSerializer和downloadFileURL或data存到userInfo里面，第二个是根据error是否为空值，做下一步处理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - NSURLSessionTaskDelegate&#10;&#10;- (void)URLSession:(__unused NSURLSession *)session&#10;              task:(NSURLSessionTask *)task&#10;didCompleteWithError:(NSError *)error&#10;&#123;&#10;#pragma clang diagnostic push&#10;#pragma clang diagnostic ignored &#34;-Wgnu&#34;&#10;    // &#33719;&#21462;&#25968;&#25454;&#65292;&#23558;responseSerializer&#21644;downloadFileURL&#25110;data&#23384;&#21040;userInfo&#37324;&#38754;&#10;    __strong AFURLSessionManager *manager = self.manager;&#10;&#10;    __block id responseObject = nil;&#10;&#10;    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];&#10;    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;&#10;&#10;    //Performance Improvement from #2672&#10;    NSData *data = nil;&#10;    if (self.mutableData) &#123;&#10;        data = [self.mutableData copy];&#10;        //We no longer need the reference, so nil it out to gain back some memory.&#10;        self.mutableData = nil;&#10;    &#125;&#10;&#10;    if (self.downloadFileURL) &#123;&#10;        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;&#10;    &#125; else if (data) &#123;&#10;        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;&#10;    &#125;&#10;&#10;    if (error) &#123;&#10;      // &#26377;error&#26102;&#22788;&#29702;&#10;    &#125; else &#123;&#10;      // &#26080;error&#26102;&#27491;&#24120;&#22788;&#29702;&#10;    &#125;&#10;#pragma clang diagnostic pop&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在有error时，userInfo先存储error，然后检查manager是否有completionGroup和completionQueue，没有的话，就创建一个dispatch_group_t和在主线程上做completionHandler的操作，并在主线程中发送一个AFNetworkingTaskDidCompleteNotification通知，这个通知在UIKit+AFNetworking里UIRefreshControl +AFNetworking里也会接收到，用来停止刷新，如果你不使用AF的UI部分，你可以通过接收这个通知来做操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;&#10;&#10;dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;&#10;            if (self.completionHandler) &#123;&#10;                self.completionHandler(task.response, responseObject, error);&#10;            &#125;&#10;&#10;            dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];&#10;            &#125;);&#10;        &#125;);</span><br></pre></td></tr></table></figure>
<p>在没有error时，会先对数据进行一次序列化操作，然后下面的处理就和有error的那部分一样了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(url_session_manager_processing_queue(), ^&#123;&#10;            NSError *serializationError = nil;&#10;            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&#38;serializationError];&#10;&#10;            if (self.downloadFileURL) &#123;&#10;                responseObject = self.downloadFileURL;&#10;            &#125;&#10;&#10;            if (responseObject) &#123;&#10;                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;&#10;            &#125;&#10;&#10;            if (serializationError) &#123;&#10;                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;&#10;            &#125;&#10;&#10;            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;&#10;                if (self.completionHandler) &#123;&#10;                    self.completionHandler(task.response, responseObject, serializationError);&#10;                &#125;&#10;&#10;                dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];&#10;                &#125;);&#10;            &#125;);&#10;        &#125;);</span><br></pre></td></tr></table></figure>
<p>一开始我们就看到了clang命令，这个的作用是用来消除特定区域的clang的编译警告，-Wgnu则是消除?:警告，这个是clang的警告message列表<a href="http://fuckingclangwarnings.com/" target="_blank" rel="external">Which Clang Warning Is Generating This Message?</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session&#10;              task:(NSURLSessionTask *)task&#10;didCompleteWithError:(NSError *)error&#10;&#123;&#10;#pragma clang diagnostic push&#10;&#10;#pragma clang diagnostic ignored &#34;-Wgnu&#34;&#10;&#10;// some codes&#10;&#10;#pragma clang diagnostic pop&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>再下面两个则是收到数据和下载文件的回调处理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - NSURLSessionDataTaskDelegate&#10;&#10;- (void)URLSession:(__unused NSURLSession *)session&#10;          dataTask:(__unused NSURLSessionDataTask *)dataTask&#10;    didReceiveData:(NSData *)data&#10;&#123;&#10;    [self.mutableData appendData:data];&#10;&#125;&#10;&#10;#pragma mark - NSURLSessionDownloadTaskDelegate&#10;&#10;- (void)URLSession:(NSURLSession *)session&#10;      downloadTask:(NSURLSessionDownloadTask *)downloadTask&#10;didFinishDownloadingToURL:(NSURL *)location&#10;&#123;&#10;    NSError *fileManagerError = nil;&#10;    self.downloadFileURL = nil;&#10;&#10;    if (self.downloadTaskDidFinishDownloading) &#123;&#10;        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);&#10;        if (self.downloadFileURL) &#123;&#10;            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&#38;fileManagerError];&#10;&#10;            if (fileManagerError) &#123;&#10;                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在刚才说到的load方法里面，对系统的resume和suspend方法进行了替换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;&#10;    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));&#10;    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));&#10;&#10;    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;&#10;        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));&#10;    &#125;&#10;&#10;    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;&#10;        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>替换之后，只是增加了通知处理而已</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)af_resume &#123;&#10;    NSAssert([self respondsToSelector:@selector(state)], @&#34;Does not respond to state&#34;);&#10;    NSURLSessionTaskState state = [self state];&#10;    [self af_resume];&#10;    &#10;    if (state != NSURLSessionTaskStateRunning) &#123;&#10;        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];&#10;    &#125;&#10;&#125;&#10;&#10;- (void)af_suspend &#123;&#10;    NSAssert([self respondsToSelector:@selector(state)], @&#34;Does not respond to state&#34;);&#10;    NSURLSessionTaskState state = [self state];&#10;    [self af_suspend];&#10;    &#10;    if (state != NSURLSessionTaskStateSuspended) &#123;&#10;        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在调用替换和增加方法时候，用到了关键字inline，inline是为了防止反汇编之后，在符号表里面看不到你所调用的该方法，否则别人可以通过篡改你的返回值来造成攻击，<a href="http://www.blogfshare.com/ioss-static-inline.html" target="_blank" rel="external">iOS安全–使用static inline方式编译函数，防止静态分析</a>，特别是在使用swizzling的时候，那除了使用swizzling动态替换函数方法之外，还有别的方法么？有，修改IMP指针指向的方法，<a href="http://www.cocoachina.com/ios/20150717/12623.html" target="_blank" rel="external">轻松学习之 IMP指针的作用 - CocoaChina_让移动开发更简单</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;&#10;    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);&#10;    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);&#10;    method_exchangeImplementations(originalMethod, swizzledMethod);&#10;&#125;&#10;&#10;static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;&#10;    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在+ load方法中，我们又看到了GCC命令，那clang和GCC在使用的时机有没有什么区别？<a href="http://stackoverflow.com/questions/11838379/should-i-use-pragma-gcc-or-pragma-clang-in-xcode" target="_blank" rel="external">通常情况下，在GCC特有的处理或者是在GCC，clang和其他兼容GCC的编译器时，尽量使用<strong>#pragma GCC</strong>，clang特有的处理时，使用<strong>#pragma clang</strong></a>，这个是<a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html" target="_blank" rel="external">GCC的message表</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;&#10;    // ...&#10;#pragma GCC diagnostic push&#10;#pragma GCC diagnostic ignored &#34;-Wnonnull&#34;&#10;        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];&#10;#pragma clang diagnostic pop&#10;    // ...&#10;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>看完之后，有个疑问，查了资料也没有找到：</p>
<p>在NSURLSessionDelegate的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L974~L979" target="_blank" rel="external">URLSession:didReceiveChallenge:completionHandler:方法里面disposition会对credential对象做非空判断然后再赋值校验类型</a>，但是NSURLSessionTaskDelegate的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L1025~L1026" target="_blank" rel="external">-  [URLSession:task:didReceiveChallenge:completionHandler:]方法里面disposition并不对credential对象做判断，而是直接就赋值校验类型</a>，有知道的，欢迎留言交流</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/15/AFNetWorking-two/" class="prev">PREV</a><a href="/2016/01/26/red-packet/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/02/21/AFNetWorking-one/';
var disqus_title = 'iOS AFNetWorking源码详解（一）';
var disqus_url = 'http://yuzeyang.github.io/2016/02/21/AFNetWorking-one/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>