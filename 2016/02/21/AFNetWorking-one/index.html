<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS AFNetWorking源码详解（一） · 宫城</title><meta name="description" content="iOS AFNetWorking源码详解（一） - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS AFNetWorking源码详解（一）</h1><div class="post-info">2016年2月21日</div><div class="post-content"><p>首先来介绍下AFNetWorking，官方介绍如下：</p>
<blockquote>
<p>AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="noopener">Foundation URL Loading System</a>, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p>
<p>Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.</p>
<p>Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did!</p>
</blockquote>
<p>翻译过来简单来说就是</p>
<p>AFNetworking是一个适用于iOS和Mac OS X两个平台的网络库，它是基于<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="noopener">Foundation URL Loading System</a>上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking.png" alt=""></p>
<p>相信从star数和fork数来看，大家都能明白这个库是多么的受欢迎了，所以了解这个库对于一个iOS开发来说是极为重要的！</p>
<p>这个是AFNetworking的github地址：<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">GitHub - AFNetworking/AFNetworking: A delightful networking framework for iOS</a></p>
<p>在使用前阅读README是非常重要的，里面往往包括了这个库的介绍、安装和使用等等，对于快速了解一个库来说，这是非常有帮助的</p>
<hr>
<p>首先我们在<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetWorking源码地址</a>里download下来，打开工程文件，可以看到里面内容分为两个部分，一个是AFNetworking，另一个是UIKit+AFNetworking</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking_file.png" alt=""></p>
<p>很明显，第一个是用来做网络请求相关的，第二个则是和UI使用相关的，我们先看第一个</p>
<p>在看完头文件和README之后，你会发现<code>AFURLSessionManager</code>和<code>AFHTTPSessionManager</code>是里面比较重要的两个类</p>
<p>这里我先讲<code>AFURLSessionManager</code>这个类</p>
<p>首先浏览完这个类从API，发现其主要提供了数据的请求、上传和下载功能</p>
<p>在属性方面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property(readonly,nonatomic,strong)NSArray *tasks;</span><br><span class="line"></span><br><span class="line">@property(readonly,nonatomic,strong)NSArray *dataTasks;</span><br><span class="line"></span><br><span class="line">@property(readonly,nonatomic,strong)NSArray *uploadTasks;</span><br><span class="line"></span><br><span class="line">@property(readonly,nonatomic,strong)NSArray *downloadTasks;</span><br></pre></td></tr></table></figure>
<p>通过这四个属性，我们分别可以拿到总的任务集合、数据任务集合、上传任务集合和下载任务集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,assign)BOOL attemptsToRecreateUploadTasksForBackgroundSessions;</span><br></pre></td></tr></table></figure>
<p>这个属性非常重要，注释里面写到，在iOS7中存在一个bug，在创建后台上传任务时，有时候会返回nil，所以为了解决这个问题，AFNetworking遵照了苹果的建议，在创建失败的时候，会重新尝试创建，次数默认为3次，所以你的应用如果有场景会有在后台上传的情况的话，记得将该值设为YES，避免出现上传失败的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;</span><br></pre></td></tr></table></figure>
<p>在对外提供的notification key里面，使用了<code>FOUNDATION_EXPORT</code>来定义常量，使用<code>FOUNDATION_EXPORT</code>和<code>extern</code>或者<code>define</code>有什么区别呢？</p>
<p><code>FOUNDATION_EXPORT</code>在c文件编译下是和extern等同，在c++文件编译下是和extern “C”等同，在32位机的环境下又是另外编译情况，在兼容性方面，<code>FOUNDATION_EXPORT</code>做的会更好。</p>
<p>这里还提到了效率方面的问题：<a href="http://www.jianshu.com/p/f547eb0368c4" target="_blank" rel="noopener">iOS开发的一些奇巧淫技3</a></p>
<hr>
<p>进入到实现文件里面，我们可以看到在外部API调用dataTask、uploadTask、downloadTask方法实际上都是completionHanlder block返回出来的，但是我们知道网络请求是delegate返回结果的，AF内部做了巧妙的操作，他对每个task都增加代理设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line">	__block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">	// 每个task里面都会调用addDelegate方法</span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在设置里面，每个task会在内部创建<code>AFURLSessionManagerTaskDelegate</code>对象，并设置completionHandler、uploadProgressBlock、downloadProgressBlock回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化delegate对象</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    // 将task的completionHandler赋给delegate，系统网络请求delegate 调用该block，返回结果</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    // 对task进行delegate</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line">	// 设置上传和下载进度回调</span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后delegate对象利用kvo将task对一些方法进行监听，并且监听到变化时，通过block返回，将delegate转成block出去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    // 断言</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    // task使用kvo对一些方法监听，返回上传或者下载的进度</span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    // sessionManager对暂停task和恢复task进行注册通知</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在原先IM的设计时，因为接口的数量并不多，所以在AsyncSocket的delegate回调后，我们依旧是采用delegate回调给业务层，但是随着接口数量的增加，业务层对于回调的处理更加困难和不可控，在重构IM的时候，我们也参考学习了AF的做法，我们通过对唯一标识和每个请求做一一绑定，将请求的上下文关联起来，这样让socket长连接的请求的也想http请求一样，都由block回去，对于业务层的处理也方便更多</p>
<p><code>setupProgressForTask</code>方法主要是对task和progress设置监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    __weak __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line">    // 设置上传和下载的大小</span><br><span class="line">    </span><br><span class="line">    // 设置上传和下载中允许取消和暂停</span><br><span class="line">  </span><br><span class="line">  	// 设置上传和下载响应恢复处理方法后恢复上传或下载</span><br><span class="line">    </span><br><span class="line">    // task对接收到的字节数、期望接收到的字节数、发送的字节数、期望发送的字节数设置监听</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">    [task addObserver:self</span><br><span class="line">          forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line"></span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">	// 上传和下载设置完成的分数监听</span><br><span class="line">    [self.downloadProgress addObserver:self</span><br><span class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                               options:NSKeyValueObservingOptionNew</span><br><span class="line">                               context:NULL];</span><br><span class="line">    [self.uploadProgress addObserver:self</span><br><span class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                             options:NSKeyValueObservingOptionNew</span><br><span class="line">                             context:NULL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</span><br><span class="line">        // 设置上传和下载的新值</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</span><br><span class="line">        if (self.downloadProgressBlock) &#123;</span><br><span class="line">            self.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</span><br><span class="line">        if (self.uploadProgressBlock) &#123;</span><br><span class="line">            self.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个if判断里面，object判断是否是<code>NSURLSessionTask</code>类或者是否是<code>NSURLSessionDownloadTask</code>类，但是进到<code>NSURLSessionDownloadTask</code>的时候，我们可以看到<code>NSURLSessionDownloadTask</code>是<code>NSURLSessionTask</code>的子类，那为什么还要判断这个呢？</p>
<p><code>NSURLSessionTask</code>实际上是<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ClassCluster.html" target="_blank" rel="noopener">Class cluster</a>，通过<code>NSURLSession</code>生成的task返回的并不一定是指定的task类型。因此kindOfClass并不总会生效，具体可以参见<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L382~L414" target="_blank" rel="noopener">AFURLSessionManager.m在load方法中的说明</a>。<br>特定于当前问题，是由于iOS 7上<strong>NSCFURLSessionDownloadTask的基类并不是</strong><code>NSCFURLSessionTask</code>，因此isKindOfClass会出错。查看对应的<a href="https://github.com/AFNetworking/AFNetworking/commit/a745be4fcd75de75b560dce1d689b6bcc11f42ba#diff-dd81ac1f455a60ac8065ade41f06881f" target="_blank" rel="noopener">commit</a>就可以知道了。</p>
<p>在<code>NSURLSessionTaskDelegate</code>的代理里面，只是做了两件事情，第一个是获取数据，将responseSerializer和downloadFileURL或data存到userInfo里面，第二个是根据error是否为空值，做下一步处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - NSURLSessionTaskDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">    // 获取数据，将responseSerializer和downloadFileURL或data存到userInfo里面</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    //Performance Improvement from #2672</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy];</span><br><span class="line">        //We no longer need the reference, so nil it out to gain back some memory.</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">      // 有error时处理</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 无error时正常处理</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有error时，userInfo先存储error，然后检查manager是否有completionGroup和completionQueue，没有的话，就创建一个dispatch_group_t和在主线程上做completionHandler的操作，并在主线程中发送一个AFNetworkingTaskDidCompleteNotification通知，这个通知在UIKit+AFNetworking里UIRefreshControl +AFNetworking里也会接收到，用来停止刷新，如果你不使用AF的UI部分，你可以通过接收这个通知来做操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>在没有error时，会先对数据进行一次序列化操作，然后下面的处理就和有error的那部分一样了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>一开始我们就看到了clang命令，这个的作用是用来消除特定区域的clang的编译警告，-Wgnu则是消除?:警告，这个是clang的警告message列表<a href="http://fuckingclangwarnings.com/" target="_blank" rel="noopener">Which Clang Warning Is Generating This Message?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line"></span><br><span class="line">// some codes</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再下面两个则是收到数据和下载文件的回调处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - NSURLSessionDataTaskDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    [self.mutableData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSURLSessionDownloadTaskDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSError *fileManagerError = nil;</span><br><span class="line">    self.downloadFileURL = nil;</span><br><span class="line"></span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (self.downloadFileURL) &#123;</span><br><span class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            if (fileManagerError) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在刚才说到的load方法里面，对系统的resume和suspend方法进行了替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换之后，只是增加了通知处理而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)af_resume &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state = [self state];</span><br><span class="line">    [self af_resume];</span><br><span class="line">    </span><br><span class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)af_suspend &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state = [self state];</span><br><span class="line">    [self af_suspend];</span><br><span class="line">    </span><br><span class="line">    if (state != NSURLSessionTaskStateSuspended) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用替换和增加方法时候，用到了关键字inline，inline是为了防止反汇编之后，在符号表里面看不到你所调用的该方法，否则别人可以通过篡改你的返回值来造成攻击，<a href="http://www.blogfshare.com/ioss-static-inline.html" target="_blank" rel="noopener">iOS安全–使用static inline方式编译函数，防止静态分析</a>，特别是在使用swizzling的时候，那除了使用swizzling动态替换函数方法之外，还有别的方法么？有，修改IMP指针指向的方法，<a href="http://www.cocoachina.com/ios/20150717/12623.html" target="_blank" rel="noopener">轻松学习之 IMP指针的作用 - CocoaChina_让移动开发更简单</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在+ load方法中，我们又看到了GCC命令，那clang和GCC在使用的时机有没有什么区别？<a href="http://stackoverflow.com/questions/11838379/should-i-use-pragma-gcc-or-pragma-clang-in-xcode" target="_blank" rel="noopener">通常情况下，在GCC特有的处理或者是在GCC，clang和其他兼容GCC的编译器时，尽量使用<strong>#pragma GCC</strong>，clang特有的处理时，使用<strong>#pragma clang</strong></a>，这个是<a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html" target="_blank" rel="noopener">GCC的message表</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    // ...</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</span><br><span class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>看完之后，有个疑问，查了资料也没有找到：</p>
<p>在NSURLSessionDelegate的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L974~L979" target="_blank" rel="noopener">URLSession:didReceiveChallenge:completionHandler:方法里面disposition会对credential对象做非空判断然后再赋值校验类型</a>，但是NSURLSessionTaskDelegate的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L1025~L1026" target="_blank" rel="noopener">-  [URLSession:task:didReceiveChallenge:completionHandler:]方法里面disposition并不对credential对象做判断，而是直接就赋值校验类型</a>，有知道的，欢迎留言交流</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/03/15/AFNetWorking-two/" class="prev">PREV</a><a href="/2016/01/26/red-packet/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/02/21/AFNetWorking-one/';
var disqus_title = 'iOS AFNetWorking源码详解（一）';
var disqus_url = 'http://yuzeyang.github.io/2016/02/21/AFNetWorking-one/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code. <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>