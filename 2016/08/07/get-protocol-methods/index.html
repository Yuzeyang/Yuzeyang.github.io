<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 根据协议名获取所有代理方法 · 宫城</title><meta name="description" content="根据协议名获取所有代理方法 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">根据协议名获取所有代理方法</h1><div class="post-info">2016年8月7日</div><div class="post-content"><p>因为一直在用<a href="https://github.com/markohlebar/Peckham" target="_blank" rel="external">Peckham</a>这个插件，能够在编辑器的任意位置使用快捷键快速引用头文件，所以后来在想能不能也写一个类似的插件快速引入什么东西，细细一想平时自己在引用代理协议的时候，基本都是要跑到文件顶部添加好之后，再回到原来的位置继续写，如果有必须实现的代理方法没注意实现的话，可能又要回到implementation看warnings或者跳转到协议里面看哪些是必须实现，拷贝过来，粘贴到自己的实现里面，这样的操作实在是太麻烦了，所以我想可以写个插件，使用快捷键将必须实现的代理方法到implementation底部，这样对于开发者来说能避免很多不必要操作，也能快速明白哪些代理方法必须实现，好，接下来我来构思下怎么实现这个插件（但是后面这个实现出来的效果并不是很完美，所以还是放弃了…原因看更多）</p>
<a id="more"></a>
<p>1.在写完协议名之后，双击或者单击拖动选中协议名<br>2.使用快捷键，根据选中的协议名，查找协议里面的所有代理方法<br>3.再筛选出里面require标记的代理方法<br>4.将这些代理方法，添加到当前类的实现文件里面</p>
<p>我接下去讲的都是默认你已经了解了插件的配置以及调试</p>
<h2 id="u9009_u4E2D_u534F_u8BAE_u540D"><a href="#u9009_u4E2D_u534F_u8BAE_u540D" class="headerlink" title="选中协议名"></a>选中协议名</h2><p>首先我们在初始化bundle的时候，注册<code>NSTextViewDidChangeSelectionNotification</code>通知，<code>- selectString :</code>用来接收选中文本改变时通知</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(selectString:)&#10;name:NSTextViewDidChangeSelectionNotification object:nil];</span><br></pre></td></tr></table></figure>
<p>然后在接收方法里面，我们获取到当前操作的编辑页面<code>NSTextView</code>对象，然后获取到选中的<code>range</code>，取出选中的文本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)selectString:(NSNotification *)notification &#123;&#10;    if ([notification.object isKindOfClass:[NSTextView class]]) &#123;&#10;        NSTextView* textView = (NSTextView *)notification.object;&#10;        NSArray* selectedRanges = [textView selectedRanges];&#10;        if (selectedRanges.count == 0) &#123;&#10;            return;&#10;        &#125;&#10;        NSRange selectedRange = [[selectedRanges objectAtIndex:0] rangeValue];&#10;        NSString* text = textView.textStorage.string;&#10;        self.selectedString = [text substringWithRange:selectedRange];&#10;        NSLog(@&#34;%s %@&#34;,__func__,self.selectedString);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528_u5FEB_u6377_u952E_uFF0C_u67E5_u627E_u534F_u8BAE_u91CC_u9762_u7684_u6240_u6709_u4EE3_u7406_u65B9_u6CD5"><a href="#u4F7F_u7528_u5FEB_u6377_u952E_uFF0C_u67E5_u627E_u534F_u8BAE_u91CC_u9762_u7684_u6240_u6709_u4EE3_u7406_u65B9_u6CD5" class="headerlink" title="使用快捷键，查找协议里面的所有代理方法"></a>使用快捷键，查找协议里面的所有代理方法</h2><p>快捷键的设置在增加<code>NSMenuItem</code>对象时就已经设置了，并且设置其快捷键为<code>^⎇G</code>，以及对应的<code>- searchProtocol:</code>方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[menuItem submenu] addItem:[NSMenuItem separatorItem]];&#10;        &#10;NSMenuItem *protolMenuItem = [[NSMenuItem alloc] initWithTitle:@&#34;Protol Helper&#34; action:@selector(searchProtocol:) keyEquivalent:@&#34;g&#34;];&#10;[protolMenuItem setKeyEquivalentModifierMask:NSAlternateKeyMask|NSControlKeyMask];&#10;protolMenuItem.target = self;&#10;[[menuItem submenu] addItem:protolMenuItem];</span><br></pre></td></tr></table></figure>
<p>然后我们怎么查找到选中文本对应的协议和里面的代理方法呢？</p>
<p>我们先找怎么获取到代理方法，然后倒推回来，首先我们需要用到<code>runtime</code>，我们进到<code>runtime.h</code>里，通过搜索<code>protocol</code>关键字，我们找了<code>protocol_copyMethodDescriptionList</code>这个方法，<code>p</code>是一个<code>Protocol</code>对象，<code>isRequiredMethod</code>筛选是否是必须的方法，这样的话，我们就可以直接通过这个方法来获取必须实现的代理方法，<code>isInstanceMethod</code>筛选是否是实例方法，<code>outCount</code>这个表示返回方法的数量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount)&#10;     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);</span><br></pre></td></tr></table></figure>
<p><code>Protocol</code>对象我们可以通过<code>objc_getProtocol</code>方法，通过传入协议名来创建</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *protocolName = self.selectedString.UTF8String;&#10;Protocol *protocol = objc_getProtocol(protocolName);</span><br></pre></td></tr></table></figure>
<p>然后我们开始调用<code>protocol_copyMethodDescriptionList</code>方法，打印出方法信息，这里我就先不管代码简洁性了，我拿<code>NSTextViewDelegate</code>来测试</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count = 999;&#10;struct objc_method_description *methods1;&#10;struct objc_method_description *methods2;&#10;struct objc_method_description *methods3;&#10;struct objc_method_description *methods4;&#10;methods1 = protocol_copyMethodDescriptionList(protocol, NO, YES, &#38;count);&#10;methods2 = protocol_copyMethodDescriptionList(protocol, NO, NO, &#38;count);&#10;methods3 = protocol_copyMethodDescriptionList(protocol, YES, YES, &#38;count);&#10;methods4 = protocol_copyMethodDescriptionList(protocol, YES, NO, &#38;count);&#10;&#10;if (methods1 != NULL) &#123;&#10;    NSLog(@&#34;---------------------methods1&#34;);&#10;    [self logMethods:methods1];&#10;&#125;&#10;&#10;if (methods2 != NULL) &#123;&#10;    NSLog(@&#34;---------------------methods2&#34;);&#10;    [self logMethods:methods2];&#10;&#125;&#10;&#10;if (methods3 != NULL) &#123;&#10;    NSLog(@&#34;---------------------methods3&#34;);&#10;    [self logMethods:methods3];&#10;&#125;&#10;&#10;if (methods4 != NULL) &#123;&#10;    NSLog(@&#34;---------------------methods4&#34;);&#10;    [self logMethods:methods4];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下打印的方法信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] ---------------------methods1&#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:shouldChangeTextInRange:replacementString: c48@0:8@16&#123;_NSRange=QQ&#125;24@40&#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:willChangeSelectionFromCharacterRange:toCharacterRange: &#123;_NSRange=QQ&#125;56@0:8@16&#123;_NSRange=QQ&#125;24&#123;_NSRange=QQ&#125;40&#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textViewDidChangeSelection: v24@0:8@16&#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:completions:forPartialWordRange:indexOfSelectedItem: @56@0:8@16@24&#123;_NSRange=QQ&#125;32^q48&#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doCommandBySelector: c32@0:8@16:24&#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnLink:atIndex: c40@0:8@16@24Q32&#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnCell:inRect:atIndex: v72@0:8@16@24&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;32Q64&#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doubleClickedOnCell:inRect:atIndex: v72@0:8@16@24&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;32Q64&#10;...</span><br></pre></td></tr></table></figure>
<p>what？方法名居然不是完整的，不是我们看到<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>这样的，但是想想也对，方法名应该是这样的，不包含参数名和参数类型，虽然参数类型可以通过<code>objc_method_description</code>结构体里面<code>types</code>拿到，但是参数名怎么办…我总不能用abc来代替吧，虽然做是可以做，但是用起来还是要改参数名，这不是很麻烦…感觉在这里遇到瓶颈了</p>
<p>然后我想看到<code>objc_class</code>结构体里面也有存放协议信息，那他里面是怎么样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;&#10;    Class isa  OBJC_ISA_AVAILABILITY;&#10;&#10;#if !__OBJC2__&#10;    Class super_class                                        OBJC2_UNAVAILABLE;&#10;    const char *name                                         OBJC2_UNAVAILABLE;&#10;    long version                                             OBJC2_UNAVAILABLE;&#10;    long info                                                OBJC2_UNAVAILABLE;&#10;    long instance_size                                       OBJC2_UNAVAILABLE;&#10;    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;&#10;    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;&#10;    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;&#10;    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;&#10;#endif&#10;&#10;&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_protocol_list &#123;&#10;    struct objc_protocol_list *next;&#10;    long count;&#10;    Protocol *list[1];&#10;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface Protocol : Object&#10;&#123;&#10;@private&#10;    char *protocol_name OBJC2_UNAVAILABLE;&#10;    struct objc_protocol_list *protocol_list OBJC2_UNAVAILABLE;&#10;    struct objc_method_description_list *instance_methods OBJC2_UNAVAILABLE;&#10;    struct objc_method_description_list *class_methods OBJC2_UNAVAILABLE;&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method_description_list &#123;&#10;        int count;&#10;        struct objc_method_description list[1];&#10;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method_description &#123;&#10;&#9;SEL name;               /**&#60; The name of the method */&#10;&#9;char *types;            /**&#60; The types of the method arguments */&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>通过一系列的查找，我们又回到了<code>objc_method_description</code>，what？这<code>objc_class</code>最终拿到的数据还是从<code>objc_method_description</code>来的，那就是说明我们没有办法直接获得<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>….这样就不能达到我们所预期的那样了</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我们可以通过<code>protocol_copyMethodDescriptionList</code>方法获取到协议里面所有的代理方法，分为方法名和类型，但是不能获取到<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>这样的，如果用a，b，c这样的来填充参数名，这样在使用起来，使用方还要自己再替换参数名，这样会比较麻烦，解决不了我们的需求，gg…..</p>
<p>2016年8月10日补充：</p>
<p>后来西兰花提出说根据协议名称去爬开发文档上相关的代理方法或者找本地开发包里面的相关头文件，不考虑是否可行，但是有个共同的问题是只能获取到官方的，自己创建的不行，而且前者没有require标记</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/09/02/loadingAniamtion-0902/" class="prev">上一篇</a><a href="/2016/07/27/loadingAnimation-0727/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/08/07/get-protocol-methods/';
var disqus_title = '根据协议名获取所有代理方法';
var disqus_url = 'http://yuzeyang.github.io/2016/08/07/get-protocol-methods/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>