<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 根据协议名获取所有代理方法 · 宫城</title><meta name="description" content="根据协议名获取所有代理方法 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">根据协议名获取所有代理方法</h1><div class="post-info">2016年8月7日</div><div class="post-content"><p>因为一直在用<a href="https://github.com/markohlebar/Peckham" target="_blank" rel="external">Peckham</a>这个插件，能够在编辑器的任意位置使用快捷键快速引用头文件，所以后来在想能不能也写一个类似的插件快速引入什么东西，细细一想平时自己在引用代理协议的时候，基本都是要跑到文件顶部添加好之后，再回到原来的位置继续写，如果有必须实现的代理方法没注意实现的话，可能又要回到implementation看warnings或者跳转到协议里面看哪些是必须实现，拷贝过来，粘贴到自己的实现里面，这样的操作实在是太麻烦了，所以我想可以写个插件，使用快捷键将必须实现的代理方法到implementation底部，这样对于开发者来说能避免很多不必要操作，也能快速明白哪些代理方法必须实现，好，接下来我来构思下怎么实现这个插件（但是后面这个实现出来的效果并不是很完美，所以还是放弃了…原因看更多）</p>
<a id="more"></a>
<p>1.在写完协议名之后，双击或者单击拖动选中协议名<br>2.使用快捷键，根据选中的协议名，查找协议里面的所有代理方法<br>3.再筛选出里面require标记的代理方法<br>4.将这些代理方法，添加到当前类的实现文件里面</p>
<p>我接下去讲的都是默认你已经了解了插件的配置以及调试</p>
<h2 id="u9009_u4E2D_u534F_u8BAE_u540D"><a href="#u9009_u4E2D_u534F_u8BAE_u540D" class="headerlink" title="选中协议名"></a>选中协议名</h2><p>首先我们在初始化bundle的时候，注册<code>NSTextViewDidChangeSelectionNotification</code>通知，<code>- selectString :</code>用来接收选中文本改变时通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(selectString:)</div><div class="line">name:NSTextViewDidChangeSelectionNotification object:nil];</div></pre></td></tr></table></figure>
<p>然后在接收方法里面，我们获取到当前操作的编辑页面<code>NSTextView</code>对象，然后获取到选中的<code>range</code>，取出选中的文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)selectString:(NSNotification *)notification &#123;</div><div class="line">    if ([notification.object isKindOfClass:[NSTextView class]]) &#123;</div><div class="line">        NSTextView* textView = (NSTextView *)notification.object;</div><div class="line">        NSArray* selectedRanges = [textView selectedRanges];</div><div class="line">        if (selectedRanges.count == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        NSRange selectedRange = [[selectedRanges objectAtIndex:0] rangeValue];</div><div class="line">        NSString* text = textView.textStorage.string;</div><div class="line">        self.selectedString = [text substringWithRange:selectedRange];</div><div class="line">        NSLog(@&quot;%s %@&quot;,__func__,self.selectedString);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528_u5FEB_u6377_u952E_uFF0C_u67E5_u627E_u534F_u8BAE_u91CC_u9762_u7684_u6240_u6709_u4EE3_u7406_u65B9_u6CD5"><a href="#u4F7F_u7528_u5FEB_u6377_u952E_uFF0C_u67E5_u627E_u534F_u8BAE_u91CC_u9762_u7684_u6240_u6709_u4EE3_u7406_u65B9_u6CD5" class="headerlink" title="使用快捷键，查找协议里面的所有代理方法"></a>使用快捷键，查找协议里面的所有代理方法</h2><p>快捷键的设置在增加<code>NSMenuItem</code>对象时就已经设置了，并且设置其快捷键为<code>^⎇G</code>，以及对应的<code>- searchProtocol:</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[menuItem submenu] addItem:[NSMenuItem separatorItem]];</div><div class="line">        </div><div class="line">NSMenuItem *protolMenuItem = [[NSMenuItem alloc] initWithTitle:@&quot;Protol Helper&quot; action:@selector(searchProtocol:) keyEquivalent:@&quot;g&quot;];</div><div class="line">[protolMenuItem setKeyEquivalentModifierMask:NSAlternateKeyMask|NSControlKeyMask];</div><div class="line">protolMenuItem.target = self;</div><div class="line">[[menuItem submenu] addItem:protolMenuItem];</div></pre></td></tr></table></figure>
<p>然后我们怎么查找到选中文本对应的协议和里面的代理方法呢？</p>
<p>我们先找怎么获取到代理方法，然后倒推回来，首先我们需要用到<code>runtime</code>，我们进到<code>runtime.h</code>里，通过搜索<code>protocol</code>关键字，我们找了<code>protocol_copyMethodDescriptionList</code>这个方法，<code>p</code>是一个<code>Protocol</code>对象，<code>isRequiredMethod</code>筛选是否是必须的方法，这样的话，我们就可以直接通过这个方法来获取必须实现的代理方法，<code>isInstanceMethod</code>筛选是否是实例方法，<code>outCount</code>这个表示返回方法的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount)</div><div class="line">     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);</div></pre></td></tr></table></figure>
<p><code>Protocol</code>对象我们可以通过<code>objc_getProtocol</code>方法，通过传入协议名来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const char *protocolName = self.selectedString.UTF8String;</div><div class="line">Protocol *protocol = objc_getProtocol(protocolName);</div></pre></td></tr></table></figure>
<p>然后我们开始调用<code>protocol_copyMethodDescriptionList</code>方法，打印出方法信息，这里我就先不管代码简洁性了，我拿<code>NSTextViewDelegate</code>来测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">unsigned int count = 999;</div><div class="line">struct objc_method_description *methods1;</div><div class="line">struct objc_method_description *methods2;</div><div class="line">struct objc_method_description *methods3;</div><div class="line">struct objc_method_description *methods4;</div><div class="line">methods1 = protocol_copyMethodDescriptionList(protocol, NO, YES, &amp;count);</div><div class="line">methods2 = protocol_copyMethodDescriptionList(protocol, NO, NO, &amp;count);</div><div class="line">methods3 = protocol_copyMethodDescriptionList(protocol, YES, YES, &amp;count);</div><div class="line">methods4 = protocol_copyMethodDescriptionList(protocol, YES, NO, &amp;count);</div><div class="line"></div><div class="line">if (methods1 != NULL) &#123;</div><div class="line">    NSLog(@&quot;---------------------methods1&quot;);</div><div class="line">    [self logMethods:methods1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (methods2 != NULL) &#123;</div><div class="line">    NSLog(@&quot;---------------------methods2&quot;);</div><div class="line">    [self logMethods:methods2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (methods3 != NULL) &#123;</div><div class="line">    NSLog(@&quot;---------------------methods3&quot;);</div><div class="line">    [self logMethods:methods3];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (methods4 != NULL) &#123;</div><div class="line">    NSLog(@&quot;---------------------methods4&quot;);</div><div class="line">    [self logMethods:methods4];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看下打印的方法信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] ---------------------methods1</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:shouldChangeTextInRange:replacementString: c48@0:8@16&#123;_NSRange=QQ&#125;24@40</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:willChangeSelectionFromCharacterRange:toCharacterRange: &#123;_NSRange=QQ&#125;56@0:8@16&#123;_NSRange=QQ&#125;24&#123;_NSRange=QQ&#125;40</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textViewDidChangeSelection: v24@0:8@16</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:completions:forPartialWordRange:indexOfSelectedItem: @56@0:8@16@24&#123;_NSRange=QQ&#125;32^q48</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doCommandBySelector: c32@0:8@16:24</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnLink:atIndex: c40@0:8@16@24Q32</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnCell:inRect:atIndex: v72@0:8@16@24&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;32Q64</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doubleClickedOnCell:inRect:atIndex: v72@0:8@16@24&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;32Q64</div><div class="line">...</div></pre></td></tr></table></figure>
<p>what？方法名居然不是完整的，不是我们看到<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>这样的，但是想想也对，方法名应该是这样的，不包含参数名和参数类型，虽然参数类型可以通过<code>objc_method_description</code>结构体里面<code>types</code>拿到，但是参数名怎么办…我总不能用abc来代替吧，虽然做是可以做，但是用起来还是要改参数名，这不是很麻烦…感觉在这里遇到瓶颈了</p>
<p>然后我想看到<code>objc_class</code>结构体里面也有存放协议信息，那他里面是怎么样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_protocol_list &#123;</div><div class="line">    struct objc_protocol_list *next;</div><div class="line">    long count;</div><div class="line">    Protocol *list[1];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface Protocol : Object</div><div class="line">&#123;</div><div class="line">@private</div><div class="line">    char *protocol_name OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocol_list OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_description_list *instance_methods OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_description_list *class_methods OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct objc_method_description_list &#123;</div><div class="line">        int count;</div><div class="line">        struct objc_method_description list[1];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct objc_method_description &#123;</div><div class="line">	SEL name;               /**&lt; The name of the method */</div><div class="line">	char *types;            /**&lt; The types of the method arguments */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过一系列的查找，我们又回到了<code>objc_method_description</code>，what？这<code>objc_class</code>最终拿到的数据还是从<code>objc_method_description</code>来的，那就是说明我们没有办法直接获得<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>….这样就不能达到我们所预期的那样了</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我们可以通过<code>protocol_copyMethodDescriptionList</code>方法获取到协议里面所有的代理方法，分为方法名和类型，但是不能获取到<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>这样的，如果用a，b，c这样的来填充参数名，这样在使用起来，使用方还要自己再替换参数名，这样会比较麻烦，解决不了我们的需求，gg…..</p>
<p>2016年8月10日补充：</p>
<p>后来西兰花提出说根据协议名称去爬开发文档上相关的代理方法或者找本地开发包里面的相关头文件，不考虑是否可行，但是有个共同的问题是只能获取到官方的，自己创建的不行，而且前者没有require标记</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/27/loadingAnimation-0727/" class="prev">上一篇</a><a href="/2016/09/02/loadingAniamtion-0902/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/08/07/get-protocol-methods/';
var disqus_title = '根据协议名获取所有代理方法';
var disqus_url = 'http://yuzeyang.github.io/2016/08/07/get-protocol-methods/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>