<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 加载动画分析 · 宫城</title><meta name="description" content="加载动画分析 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">加载动画分析</h1><div class="post-info">2016年7月27日</div><div class="post-content"><p>好久没写动画了…最近扒了下以前没有写的动画效果，想想从最老的开始写吧，之前看到的版本是用Swift写的，没仔细找有没有OC版的，所以干脆自己练习一下吧，我们先来看看效果：</p>
<p>(这里三角形是旋转动画，但是Gif录出来看上去是抖了两下…)</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationOne.gif!500x500" alt=""></p>
<p>可以直接run下代码，看下效果：<a href="https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne" target="_blank" rel="external">https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne</a></p>
<p>下面我来分析下过程</p>
<a id="more"></a>
<p>这个动画的实现只用到了<code>UIBezierPath</code>、<code>CABasicAnimation</code>和<code>CALayer</code></p>
<p>从Gif里面可以看到这个动画分为以下几个步骤：</p>
<p>1.从无到圆</p>
<p>2.圆x轴方向拉伸和y轴方向拉伸</p>
<p>3.“长出”三角形的三个角</p>
<p>4.三角形旋转</p>
<p>5.画两条边框</p>
<p>6.水面上涨动画</p>
<p>7.中间矩形放大至全屏</p>
<p>8.中间logo跟着出现</p>
<h2 id="0x00__u4ECE_u65E0_u5230_u5706"><a href="#0x00__u4ECE_u65E0_u5230_u5706" class="headerlink" title="0x00 从无到圆"></a>0x00 从无到圆</h2><p>这个比较简单，只要设定起始的size为0和设定默认圆半径大小，用<code>+ bezierPathWithOvalInRect:</code>方法画圆<code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *startPath = [self circleStartPath];</div><div class="line">UIBezierPath *endPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2, GCCircleRadius*2)];</div></pre></td></tr></table></figure>
<p>将最后圆的<code>path</code>设为<code>circleLayer</code>的<code>path</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.circleLayer = [CAShapeLayer layer];</div><div class="line">self.circleLayer.path = endPath.CGPath;</div><div class="line">self.circleLayer.fillColor = [UIColor orangeColor].CGColor;</div><div class="line">[self addSublayer:self.circleLayer];</div></pre></td></tr></table></figure>
<p>然后加上动画，因为我们修改的是<code>path</code>，所以我们<code>animation</code>的<code>keyPath</code>是<code>path</code>（后面也是），设定起始值为<code>startPath.CGPath</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *circleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">circleAnimation.fromValue = (__bridge id _Nullable)(startPath.CGPath);</div><div class="line">circleAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</div><div class="line">circleAnimation.duration = 0.2f;</div><div class="line">circleAnimation.fillMode = kCAFillModeForwards;</div><div class="line">circleAnimation.delegate = self;</div><div class="line">circleAnimation.removedOnCompletion = NO;</div><div class="line">[circleAnimation setValue:@&quot;circleAnimation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">[self.circleLayer addAnimation:circleAnimation forKey:nil];</div></pre></td></tr></table></figure>
<h2 id="0x01__u5706x_u8F74_u65B9_u5411_u62C9_u4F38_u548Cy_u8F74_u65B9_u5411_u62C9_u4F38"><a href="#0x01__u5706x_u8F74_u65B9_u5411_u62C9_u4F38_u548Cy_u8F74_u65B9_u5411_u62C9_u4F38" class="headerlink" title="0x01 圆x轴方向拉伸和y轴方向拉伸"></a>0x01 圆x轴方向拉伸和y轴方向拉伸</h2><p>这里我们的<code>keyPath</code>不用<code>transform.scale.x/y</code>，因为缩放之后，圆心会改变，看上去有偏移，这样动画写起来更复杂，所以我们干脆直接用拉伸后的<code>path</code>来做动画</p>
<p>创建x轴、y轴拉伸后的<code>path</code>，然后加到<code>animation</code>里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *scaleXPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius*1.1, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2.2, GCCircleRadius*2)];</div><div class="line">UIBezierPath *scaleYPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius*1.1, GCCircleRadius*2, GCCircleRadius*2.2)];</div><div class="line"></div><div class="line">CABasicAnimation *circleScaleXOneAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">circleScaleXOneAnimation.fromValue = (__bridge id _Nullable)(self.circleLayer.path);</div><div class="line">circleScaleXOneAnimation.toValue = (__bridge id _Nullable)(scaleXPath.CGPath);</div><div class="line">circleScaleXOneAnimation.duration = 0.2f;</div><div class="line">circleScaleXOneAnimation.beginTime = 0.0;</div></pre></td></tr></table></figure>
<p>一共四个<code>CABasicAnimation</code>对象，然后我们将这些动画加到<code>CAAnimationGroup</code>里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CAAnimationGroup *animationGroup = [CAAnimationGroup animation];</div><div class="line">animationGroup.animations = @[circleScaleXOneAnimation,circleScaleXTwoAnimation,circleScaleYOneAnimation,circleScaleYTwoAnimation];</div><div class="line">animationGroup.duration = circleScaleYTwoAnimation.beginTime + circleScaleYTwoAnimation.duration;</div><div class="line">animationGroup.delegate = self;</div><div class="line">[animationGroup setValue:@&quot;circleScaleAnimation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">[self.circleLayer addAnimation:animationGroup forKey:nil];</div></pre></td></tr></table></figure>
<h2 id="0x02__u201C_u957F_u51FA_u201D_u4E09_u89D2_u5F62_u7684_u4E09_u4E2A_u89D2"><a href="#0x02__u201C_u957F_u51FA_u201D_u4E09_u89D2_u5F62_u7684_u4E09_u4E2A_u89D2" class="headerlink" title="0x02 “长出”三角形的三个角"></a>0x02 “长出”三角形的三个角</h2><p>实际上三角形在等到圆形出现或者圆形拉伸完之后就已经在那了，“长出角”的感觉实际上只是改变了绘制的三个点的位置，首先我们根据圆的半径画出三角形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *originTrianglePath = [UIBezierPath bezierPath];</div><div class="line">[originTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.0]];</div><div class="line">[originTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];</div><div class="line">[originTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];</div><div class="line">[originTrianglePath closePath];</div><div class="line"></div><div class="line">self.triangleLayer = [CAShapeLayer layer];</div><div class="line">self.triangleLayer.path = originTrianglePath.CGPath;</div><div class="line">self.triangleLayer.fillColor = [UIColor orangeColor].CGColor;</div><div class="line">[self addSublayer:self.triangleLayer];</div></pre></td></tr></table></figure>
<p>然后改变左边点的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *blowUpLeftTrianglePath = [UIBezierPath bezierPath];</div><div class="line">[blowUpLeftTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.2]];</div><div class="line">[blowUpLeftTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];</div><div class="line">[blowUpLeftTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];</div><div class="line">[blowUpLeftTrianglePath closePath];</div></pre></td></tr></table></figure>
<p>也加上<code>path</code>的动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *blowUpLeftAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">blowUpLeftAnimation.fromValue = (__bridge id _Nullable)(self.triangleLayer.path);</div><div class="line">blowUpLeftAnimation.toValue = (__bridge id _Nullable)(blowUpLeftTrianglePath.CGPath);</div><div class="line">blowUpLeftAnimation.duration = 0.2f;</div><div class="line">blowUpLeftAnimation.beginTime = 0.0;</div></pre></td></tr></table></figure>
<p>右边和上边的点同理，然后也一起加到<code>CAAnimationGroup</code>里</p>
<h2 id="0x03__u4E09_u89D2_u5F62_u65CB_u8F6C"><a href="#0x03__u4E09_u89D2_u5F62_u65CB_u8F6C" class="headerlink" title="0x03 三角形旋转"></a>0x03 三角形旋转</h2><p>旋转就比较简单了，只要根据z轴旋转设定的角度即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *rotationAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">rotationAniamtion.toValue = @(M_PI*2);</div><div class="line">rotationAniamtion.duration = 0.4;</div><div class="line">rotationAniamtion.fillMode = kCAFillModeForwards;</div><div class="line">rotationAniamtion.delegate = self;</div><div class="line">rotationAniamtion.beginTime = CACurrentMediaTime();</div><div class="line">[rotationAniamtion setValue:@&quot;rotationAniamtion&quot; forKey:@&quot;animationName&quot;];</div><div class="line">[self.triangleLayer addAnimation:rotationAniamtion forKey:nil];</div></pre></td></tr></table></figure>
<h2 id="0x04__u753B_u4E24_u6761_u8FB9_u6846"><a href="#0x04__u753B_u4E24_u6761_u8FB9_u6846" class="headerlink" title="0x04 画两条边框"></a>0x04 画两条边框</h2><p>这两个边框绘制方法是一模一样的，只是中间有个时间间隔而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (CABasicAnimation *)drawRectWithLineColor:(CGColorRef)color animationValue:(NSString *)animationValue &#123;</div><div class="line">    CGPoint startPoint = [self triangleLeftPointWithScale:1.2];</div><div class="line">    UIBezierPath *rectPath = [UIBezierPath bezierPath];</div><div class="line">    [rectPath moveToPoint:startPoint];</div><div class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x, startPoint.y - GCCircleRadius*2.4)];</div><div class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - GCCircleRadius*2.4)];</div><div class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - 2)];</div><div class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x - 2.5, startPoint.y - 2)];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer = [CAShapeLayer layer];</div><div class="line">    layer.path = rectPath.CGPath;</div><div class="line">    layer.lineWidth = 5;</div><div class="line">    layer.strokeColor = color;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    [self addSublayer:layer];</div><div class="line">    </div><div class="line">    CABasicAnimation *rectAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</div><div class="line">    rectAniamtion.fromValue = @(0.0);</div><div class="line">    rectAniamtion.toValue = @(1.0);</div><div class="line">    rectAniamtion.duration = 0.8;</div><div class="line">    rectAniamtion.delegate = self;</div><div class="line">    if (animationValue.length) &#123;</div><div class="line">        [rectAniamtion setValue:@&quot;rectAniamtion&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    &#125;</div><div class="line">    [layer addAnimation:rectAniamtion forKey:nil];</div><div class="line">    </div><div class="line">    return rectAniamtion;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>间隔的话，我们直接调用<code>- performSelector: withObject: afterDelay:</code>来延迟执行第二条边框的绘制就好</p>
<h2 id="0x05__u6C34_u9762_u4E0A_u6DA8_u52A8_u753B"><a href="#0x05__u6C34_u9762_u4E0A_u6DA8_u52A8_u753B" class="headerlink" title="0x05 水面上涨动画"></a>0x05 水面上涨动画</h2><p>这个动画的关键就是用<code>- addCurveToPoint: controlPoint1: controlPoint2:</code>方法来画出水波的线，这个方法主要是利用<code>controlPoint1</code>和<code>controlPoint2</code>这两个点来控制弧度方向，如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/addCurveToPoint.png" alt=""></p>
<p>然后我们只需要交叉改变<code>controlPoint1</code>和<code>controlPoint2</code>这两个点在上下的位置和<code>startPoint</code>和<code>endPoint</code>的位置，就能感觉水面上涨的感觉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableArray &lt;UIBezierPath *&gt; *waterPathArray = [NSMutableArray array];</div><div class="line">for (NSInteger i = 0; i &lt; 11; i++) &#123;</div><div class="line">    UIBezierPath *water = [self water:i % 2 == 0 ? YES : NO withProgress:0.1*i];</div><div class="line">    [waterPathArray addObject:water];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建完毕<code>path</code>之后，将<code>anmations</code>放到<code>CAAnimationGroup</code>里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)addWaterAnimation:(NSMutableArray &lt;UIBezierPath *&gt; *)waterArray &#123;</div><div class="line">    NSMutableArray &lt;CABasicAnimation *&gt; *animationArray = [NSMutableArray array];</div><div class="line">    for (NSInteger i = 0; i &lt; waterArray.count - 1; i++) &#123;</div><div class="line">        CABasicAnimation *waterAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">        waterAniamtion.fromValue = (__bridge id _Nullable)(waterArray[i].CGPath);</div><div class="line">        waterAniamtion.toValue = (__bridge id _Nullable)(waterArray[i + 1].CGPath);</div><div class="line">        waterAniamtion.duration = 0.2;</div><div class="line">        waterAniamtion.beginTime = i == 0 ? 0.0 : animationArray[i - 1].beginTime + animationArray[i - 1].duration;</div><div class="line">        [animationArray addObject:waterAniamtion];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CAAnimationGroup *group = [CAAnimationGroup animation];</div><div class="line">    group.animations = animationArray;</div><div class="line">    group.duration = [animationArray lastObject].beginTime + [animationArray lastObject].duration;</div><div class="line">    group.fillMode = kCAFillModeForwards;</div><div class="line">    group.removedOnCompletion = NO;</div><div class="line">    group.delegate = self;</div><div class="line">    [group setValue:@&quot;waterAnimation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    [self.waterLayer addAnimation:group forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x06__u4E2D_u95F4_u77E9_u5F62_u653E_u5927_u81F3_u5168_u5C4F"><a href="#0x06__u4E2D_u95F4_u77E9_u5F62_u653E_u5927_u81F3_u5168_u5C4F" class="headerlink" title="0x06 中间矩形放大至全屏"></a>0x06 中间矩形放大至全屏</h2><p>和前面一样，创建好全屏大小的<code>path</code>之后，然后加上动画即可</p>
<h2 id="0x07__u4E2D_u95F4logo_u8DDF_u7740_u51FA_u73B0"><a href="#0x07__u4E2D_u95F4logo_u8DDF_u7740_u51FA_u73B0" class="headerlink" title="0x07 中间logo跟着出现"></a>0x07 中间logo跟着出现</h2><p>这个改变<code>bounds</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CALayer *logoLayer = [CALayer layer];</div><div class="line">logoLayer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;logo.jpg&quot;].CGImage);</div><div class="line"></div><div class="line">logoLayer.frame = CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 0, 0);</div><div class="line">[self addSublayer:logoLayer];</div><div class="line"></div><div class="line">CABasicAnimation *logoAnimation = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;];</div><div class="line">logoAnimation.toValue = [NSValue valueWithCGRect:CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 100, 120)];</div><div class="line">logoAnimation.duration = 0.2;</div><div class="line">logoAnimation.beginTime = 0.0;</div><div class="line">logoAnimation.removedOnCompletion = NO;</div><div class="line">logoAnimation.fillMode = kCAFillModeForwards;</div><div class="line">[logoLayer addAnimation:logoAnimation forKey:nil];</div></pre></td></tr></table></figure>
<p>这个加载动画的缺点就是在加载时没有可定制化的形状，只能修改圆形等的颜色，如果要改变形状，可能会涉及到动效的改动，所以这个动画只能作为学习分析参考</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/23/FMDB-two/" class="prev">上一篇</a><a href="/2016/08/07/get-protocol-methods/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/07/27/loadingAnimation-0727/';
var disqus_title = '加载动画分析';
var disqus_url = 'http://yuzeyang.github.io/2016/07/27/loadingAnimation-0727/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>