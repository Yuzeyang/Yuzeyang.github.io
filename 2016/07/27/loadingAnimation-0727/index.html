<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 加载动画分析 · 宫城</title><meta name="description" content="加载动画分析 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">加载动画分析</h1><div class="post-info">2016年7月27日</div><div class="post-content"><p>好久没写动画了…最近扒了下以前没有写的动画效果，想想从最老的开始写吧，之前看到的版本是用Swift写的，没仔细找有没有OC版的，所以干脆自己练习一下吧，我们先来看看效果：</p>
<p>(这里三角形是旋转动画，但是Gif录出来看上去是抖了两下…)</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationOne.gif!500x500" alt=""></p>
<p>可以直接run下代码，看下效果：<a href="https://github.com/Yuzeyang/GCLoadingAnimationOne" target="_blank" rel="external">https://github.com/Yuzeyang/GCLoadingAnimationOne</a></p>
<p>下面我来分析下过程</p>
<a id="more"></a>
<p>这个动画的实现只用到了<code>UIBezierPath</code>、<code>CABasicAnimation</code>和<code>CALayer</code></p>
<p>从Gif里面可以看到这个动画分为以下几个步骤：</p>
<p>1.从无到圆</p>
<p>2.圆x轴方向拉伸和y轴方向拉伸</p>
<p>3.“长出”三角形的三个角</p>
<p>4.三角形旋转</p>
<p>5.画两条边框</p>
<p>6.水面上涨动画</p>
<p>7.中间矩形放大至全屏</p>
<p>8.中间logo跟着出现</p>
<h2 id="0x00__u4ECE_u65E0_u5230_u5706"><a href="#0x00__u4ECE_u65E0_u5230_u5706" class="headerlink" title="0x00 从无到圆"></a>0x00 从无到圆</h2><p>这个比较简单，只要设定起始的size为0和设定默认圆半径大小，用<code>+ bezierPathWithOvalInRect:</code>方法画圆<code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *startPath = [self circleStartPath];&#10;UIBezierPath *endPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2, GCCircleRadius*2)];</span><br></pre></td></tr></table></figure>
<p>将最后圆的<code>path</code>设为<code>circleLayer</code>的<code>path</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.circleLayer = [CAShapeLayer layer];&#10;self.circleLayer.path = endPath.CGPath;&#10;self.circleLayer.fillColor = [UIColor orangeColor].CGColor;&#10;[self addSublayer:self.circleLayer];</span><br></pre></td></tr></table></figure>
<p>然后加上动画，因为我们修改的是<code>path</code>，所以我们<code>animation</code>的<code>keyPath</code>是<code>path</code>（后面也是），设定起始值为<code>startPath.CGPath</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *circleAnimation = [CABasicAnimation animationWithKeyPath:@&#34;path&#34;];&#10;circleAnimation.fromValue = (__bridge id _Nullable)(startPath.CGPath);&#10;circleAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];&#10;circleAnimation.duration = 0.2f;&#10;circleAnimation.fillMode = kCAFillModeForwards;&#10;circleAnimation.delegate = self;&#10;circleAnimation.removedOnCompletion = NO;&#10;[circleAnimation setValue:@&#34;circleAnimation&#34; forKey:@&#34;animationName&#34;];&#10;[self.circleLayer addAnimation:circleAnimation forKey:nil];</span><br></pre></td></tr></table></figure>
<h2 id="0x01__u5706x_u8F74_u65B9_u5411_u62C9_u4F38_u548Cy_u8F74_u65B9_u5411_u62C9_u4F38"><a href="#0x01__u5706x_u8F74_u65B9_u5411_u62C9_u4F38_u548Cy_u8F74_u65B9_u5411_u62C9_u4F38" class="headerlink" title="0x01 圆x轴方向拉伸和y轴方向拉伸"></a>0x01 圆x轴方向拉伸和y轴方向拉伸</h2><p>这里我们的<code>keyPath</code>不用<code>transform.scale.x/y</code>，因为缩放之后，圆心会改变，看上去有偏移，这样动画写起来更复杂，所以我们干脆直接用拉伸后的<code>path</code>来做动画</p>
<p>创建x轴、y轴拉伸后的<code>path</code>，然后加到<code>animation</code>里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *scaleXPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius*1.1, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2.2, GCCircleRadius*2)];&#10;UIBezierPath *scaleYPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius*1.1, GCCircleRadius*2, GCCircleRadius*2.2)];&#10;&#10;CABasicAnimation *circleScaleXOneAnimation = [CABasicAnimation animationWithKeyPath:@&#34;path&#34;];&#10;circleScaleXOneAnimation.fromValue = (__bridge id _Nullable)(self.circleLayer.path);&#10;circleScaleXOneAnimation.toValue = (__bridge id _Nullable)(scaleXPath.CGPath);&#10;circleScaleXOneAnimation.duration = 0.2f;&#10;circleScaleXOneAnimation.beginTime = 0.0;</span><br></pre></td></tr></table></figure>
<p>一共四个<code>CABasicAnimation</code>对象，然后我们将这些动画加到<code>CAAnimationGroup</code>里</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAAnimationGroup *animationGroup = [CAAnimationGroup animation];&#10;animationGroup.animations = @[circleScaleXOneAnimation,circleScaleXTwoAnimation,circleScaleYOneAnimation,circleScaleYTwoAnimation];&#10;animationGroup.duration = circleScaleYTwoAnimation.beginTime + circleScaleYTwoAnimation.duration;&#10;animationGroup.delegate = self;&#10;[animationGroup setValue:@&#34;circleScaleAnimation&#34; forKey:@&#34;animationName&#34;];&#10;[self.circleLayer addAnimation:animationGroup forKey:nil];</span><br></pre></td></tr></table></figure>
<h2 id="0x02__u201C_u957F_u51FA_u201D_u4E09_u89D2_u5F62_u7684_u4E09_u4E2A_u89D2"><a href="#0x02__u201C_u957F_u51FA_u201D_u4E09_u89D2_u5F62_u7684_u4E09_u4E2A_u89D2" class="headerlink" title="0x02 “长出”三角形的三个角"></a>0x02 “长出”三角形的三个角</h2><p>实际上三角形在等到圆形出现或者圆形拉伸完之后就已经在那了，“长出角”的感觉实际上只是改变了绘制的三个点的位置，首先我们根据圆的半径画出三角形</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *originTrianglePath = [UIBezierPath bezierPath];&#10;[originTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.0]];&#10;[originTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];&#10;[originTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];&#10;[originTrianglePath closePath];&#10;&#10;self.triangleLayer = [CAShapeLayer layer];&#10;self.triangleLayer.path = originTrianglePath.CGPath;&#10;self.triangleLayer.fillColor = [UIColor orangeColor].CGColor;&#10;[self addSublayer:self.triangleLayer];</span><br></pre></td></tr></table></figure>
<p>然后改变左边点的位置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *blowUpLeftTrianglePath = [UIBezierPath bezierPath];&#10;[blowUpLeftTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.2]];&#10;[blowUpLeftTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];&#10;[blowUpLeftTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];&#10;[blowUpLeftTrianglePath closePath];</span><br></pre></td></tr></table></figure>
<p>也加上<code>path</code>的动画</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *blowUpLeftAnimation = [CABasicAnimation animationWithKeyPath:@&#34;path&#34;];&#10;blowUpLeftAnimation.fromValue = (__bridge id _Nullable)(self.triangleLayer.path);&#10;blowUpLeftAnimation.toValue = (__bridge id _Nullable)(blowUpLeftTrianglePath.CGPath);&#10;blowUpLeftAnimation.duration = 0.2f;&#10;blowUpLeftAnimation.beginTime = 0.0;</span><br></pre></td></tr></table></figure>
<p>右边和上边的点同理，然后也一起加到<code>CAAnimationGroup</code>里</p>
<h2 id="0x03__u4E09_u89D2_u5F62_u65CB_u8F6C"><a href="#0x03__u4E09_u89D2_u5F62_u65CB_u8F6C" class="headerlink" title="0x03 三角形旋转"></a>0x03 三角形旋转</h2><p>旋转就比较简单了，只要根据z轴旋转设定的角度即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *rotationAniamtion = [CABasicAnimation animationWithKeyPath:@&#34;transform.rotation.z&#34;];&#10;rotationAniamtion.toValue = @(M_PI*2);&#10;rotationAniamtion.duration = 0.4;&#10;rotationAniamtion.fillMode = kCAFillModeForwards;&#10;rotationAniamtion.delegate = self;&#10;rotationAniamtion.beginTime = CACurrentMediaTime();&#10;[rotationAniamtion setValue:@&#34;rotationAniamtion&#34; forKey:@&#34;animationName&#34;];&#10;[self.triangleLayer addAnimation:rotationAniamtion forKey:nil];</span><br></pre></td></tr></table></figure>
<h2 id="0x04__u753B_u4E24_u6761_u8FB9_u6846"><a href="#0x04__u753B_u4E24_u6761_u8FB9_u6846" class="headerlink" title="0x04 画两条边框"></a>0x04 画两条边框</h2><p>这两个边框绘制方法是一模一样的，只是中间有个时间间隔而已</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (CABasicAnimation *)drawRectWithLineColor:(CGColorRef)color animationValue:(NSString *)animationValue &#123;&#10;    CGPoint startPoint = [self triangleLeftPointWithScale:1.2];&#10;    UIBezierPath *rectPath = [UIBezierPath bezierPath];&#10;    [rectPath moveToPoint:startPoint];&#10;    [rectPath addLineToPoint:CGPointMake(startPoint.x, startPoint.y - GCCircleRadius*2.4)];&#10;    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - GCCircleRadius*2.4)];&#10;    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - 2)];&#10;    [rectPath addLineToPoint:CGPointMake(startPoint.x - 2.5, startPoint.y - 2)];&#10;    &#10;    CAShapeLayer *layer = [CAShapeLayer layer];&#10;    layer.path = rectPath.CGPath;&#10;    layer.lineWidth = 5;&#10;    layer.strokeColor = color;&#10;    layer.fillColor = [UIColor clearColor].CGColor;&#10;    [self addSublayer:layer];&#10;    &#10;    CABasicAnimation *rectAniamtion = [CABasicAnimation animationWithKeyPath:@&#34;strokeEnd&#34;];&#10;    rectAniamtion.fromValue = @(0.0);&#10;    rectAniamtion.toValue = @(1.0);&#10;    rectAniamtion.duration = 0.8;&#10;    rectAniamtion.delegate = self;&#10;    if (animationValue.length) &#123;&#10;        [rectAniamtion setValue:@&#34;rectAniamtion&#34; forKey:@&#34;animationName&#34;];&#10;    &#125;&#10;    [layer addAnimation:rectAniamtion forKey:nil];&#10;    &#10;    return rectAniamtion;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>间隔的话，我们直接调用<code>- performSelector: withObject: afterDelay:</code>来延迟执行第二条边框的绘制就好</p>
<h2 id="0x05__u6C34_u9762_u4E0A_u6DA8_u52A8_u753B"><a href="#0x05__u6C34_u9762_u4E0A_u6DA8_u52A8_u753B" class="headerlink" title="0x05 水面上涨动画"></a>0x05 水面上涨动画</h2><p>这个动画的关键就是用<code>- addCurveToPoint: controlPoint1: controlPoint2:</code>方法来画出水波的线，这个方法主要是利用<code>controlPoint1</code>和<code>controlPoint2</code>这两个点来控制弧度方向，如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/addCurveToPoint.png" alt=""></p>
<p>然后我们只需要交叉改变<code>controlPoint1</code>和<code>controlPoint2</code>这两个点在上下的位置和<code>startPoint</code>和<code>endPoint</code>的位置，就能感觉水面上涨的感觉</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray &#60;UIBezierPath *&#62; *waterPathArray = [NSMutableArray array];&#10;for (NSInteger i = 0; i &#60; 11; i++) &#123;&#10;    UIBezierPath *water = [self water:i % 2 == 0 ? YES : NO withProgress:0.1*i];&#10;    [waterPathArray addObject:water];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>创建完毕<code>path</code>之后，将<code>anmations</code>放到<code>CAAnimationGroup</code>里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addWaterAnimation:(NSMutableArray &#60;UIBezierPath *&#62; *)waterArray &#123;&#10;    NSMutableArray &#60;CABasicAnimation *&#62; *animationArray = [NSMutableArray array];&#10;    for (NSInteger i = 0; i &#60; waterArray.count - 1; i++) &#123;&#10;        CABasicAnimation *waterAniamtion = [CABasicAnimation animationWithKeyPath:@&#34;path&#34;];&#10;        waterAniamtion.fromValue = (__bridge id _Nullable)(waterArray[i].CGPath);&#10;        waterAniamtion.toValue = (__bridge id _Nullable)(waterArray[i + 1].CGPath);&#10;        waterAniamtion.duration = 0.2;&#10;        waterAniamtion.beginTime = i == 0 ? 0.0 : animationArray[i - 1].beginTime + animationArray[i - 1].duration;&#10;        [animationArray addObject:waterAniamtion];&#10;    &#125;&#10;    &#10;    CAAnimationGroup *group = [CAAnimationGroup animation];&#10;    group.animations = animationArray;&#10;    group.duration = [animationArray lastObject].beginTime + [animationArray lastObject].duration;&#10;    group.fillMode = kCAFillModeForwards;&#10;    group.removedOnCompletion = NO;&#10;    group.delegate = self;&#10;    [group setValue:@&#34;waterAnimation&#34; forKey:@&#34;animationName&#34;];&#10;    [self.waterLayer addAnimation:group forKey:nil];&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x06__u4E2D_u95F4_u77E9_u5F62_u653E_u5927_u81F3_u5168_u5C4F"><a href="#0x06__u4E2D_u95F4_u77E9_u5F62_u653E_u5927_u81F3_u5168_u5C4F" class="headerlink" title="0x06 中间矩形放大至全屏"></a>0x06 中间矩形放大至全屏</h2><p>和前面一样，创建好全屏大小的<code>path</code>之后，然后加上动画即可</p>
<h2 id="0x07__u4E2D_u95F4logo_u8DDF_u7740_u51FA_u73B0"><a href="#0x07__u4E2D_u95F4logo_u8DDF_u7740_u51FA_u73B0" class="headerlink" title="0x07 中间logo跟着出现"></a>0x07 中间logo跟着出现</h2><p>这个改变<code>bounds</code>即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALayer *logoLayer = [CALayer layer];&#10;logoLayer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&#34;logo.jpg&#34;].CGImage);&#10;&#10;logoLayer.frame = CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 0, 0);&#10;[self addSublayer:logoLayer];&#10;&#10;CABasicAnimation *logoAnimation = [CABasicAnimation animationWithKeyPath:@&#34;bounds&#34;];&#10;logoAnimation.toValue = [NSValue valueWithCGRect:CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 100, 120)];&#10;logoAnimation.duration = 0.2;&#10;logoAnimation.beginTime = 0.0;&#10;logoAnimation.removedOnCompletion = NO;&#10;logoAnimation.fillMode = kCAFillModeForwards;&#10;[logoLayer addAnimation:logoAnimation forKey:nil];</span><br></pre></td></tr></table></figure>
<p>这个加载动画的缺点就是在加载时没有可定制化的形状，只能修改圆形等的颜色，如果要改变形状，可能会涉及到动效的改动，所以这个动画只能作为学习分析参考</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/08/07/get-protocol-methods/" class="prev">上一篇</a><a href="/2016/07/23/FMDB-two/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/07/27/loadingAnimation-0727/';
var disqus_title = '加载动画分析';
var disqus_url = 'http://yuzeyang.github.io/2016/07/27/loadingAnimation-0727/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>