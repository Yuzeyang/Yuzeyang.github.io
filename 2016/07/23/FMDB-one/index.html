<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> FMDB初探（一） · 宫城</title><meta name="description" content="FMDB初探（一） - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">FMDB初探（一）</h1><div class="post-info">2016年7月23日</div><div class="post-content"><p>在之前的<a href="http://zeeyang.com/2016/06/22/GCDAsyncSocket-socket-optimize/" target="_blank" rel="noopener">iOS Socket重构设计</a>里面我有提到我们使用了FMDB做消息缓存，在数据库选型方面，我们<a href="http://broccoliii.me/" target="_blank" rel="noopener">西兰花</a>也对目前比较流行和成熟的<code>Realm</code>、<code>FMDB</code>和<code>Core Data</code>做了调查，里面包括了安装、使用和性能比较，是个不错的参考例子</p>
<p>在选型时，我们应该多选取几个作为对比，从使用方面评估学习成本，通过测试不同数据库操作来比较性能差异，了解有哪些大型的App使用了该数据库以及评价来侧面说明该数据库的成熟度和在使用过程中出现的问题，最后根据自己实际的业务需求来选型</p>
<p>在选定使用<code>FMDB</code>之后，我也只是简单的了解下<code>FMDB</code>的使用，并未对内部的实现和设计思路做深入了解，但是在阅读了代码之后，<code>FMDB</code>确实像其他博客里面提到的那样，是对原生的SQLite API进行了包装，暴露出相对友好的对外接口，只需传入SQL语句即可(但是对于习惯于使用Model操作的我们来说，直接写SQL语句还是比较麻烦的，所以GitHub上也就库对<code>FMDB</code>进行了封装，省去写SQL语句，直接对Model进行操作)，并且<code>FMDB</code>内部对SQL语句进行了缓存，再配合上多线程并发执行，在提高效率方面做了不少的优化，另外还扩展了内存/文件的IO操作和虚表的操作</p>
<p>下面我会将API使用和源码结合起来讲，方便了解<code>FMDB</code>以及对复习下原生的SQLite API</p>
<a id="more"></a>
<h2 id="FMDatabase"><a href="#FMDatabase" class="headerlink" title="FMDatabase"></a>FMDatabase</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数据库的初始化对外有两种方法<code>+ databaseWithPath:</code>和<code>- initWithPath:</code>，内部实际上<code>+ databaseWithPath:</code>只是对<code>- initWithPath:</code>包装，代码里很多类似<code>FMDBReturnAutoreleased</code>等等这一类宏定义是为了兼容ARC和MRC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)databaseWithPath:(NSString*)aPath &#123;</span><br><span class="line">    return FMDBReturnAutoreleased([[self alloc] initWithPath:aPath]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithPath:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithPath:(NSString*)aPath &#123;</span><br><span class="line">    // SQLite支持三种线程模式，分别为单线程模式、多线程模式和串行模式</span><br><span class="line">    // sqlite3_threadsafe()的返回值可以确定编译时指定的线程模式，其中对于单线程模式，sqlite3_threadsafe()返回false，对于另外两个模式，则返回true。这是因为单线程模式下没有进行互斥，所以多线程下是不安全的</span><br><span class="line">    assert(sqlite3_threadsafe()); // whoa there big boy- gotta make sure sqlite it happy with what we&apos;re going to do.</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _databasePath               = [aPath copy];</span><br><span class="line">        _openResultSets             = [[NSMutableSet alloc] init];</span><br><span class="line">        // 此时并不创建数据库，真正创建是在open的时候</span><br><span class="line">      	_db                         = nil;</span><br><span class="line">        _logsErrors                 = YES;</span><br><span class="line">        _crashOnErrors              = NO;</span><br><span class="line">        _maxBusyRetryTimeInterval   = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 给定database路径</span><br><span class="line">NSString *dbPath = @&quot;/tmp/tmp.db&quot;;</span><br><span class="line">// 调用[+ databaseWithPath:]方法</span><br><span class="line">FMDatabase *db = [FMDatabase databaseWithPath:dbPath];</span><br></pre></td></tr></table></figure>
<h4 id="打开数据连接"><a href="#打开数据连接" class="headerlink" title="打开数据连接"></a>打开数据连接</h4><p>打开连接提供了三种方法，这时候才开始创建数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)open &#123;</span><br><span class="line">    if (_db) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据数据库路径打开数据库，如果数据库不存在就新建一个</span><br><span class="line">    int err = sqlite3_open([self sqlitePath], (sqlite3**)&amp;_db );</span><br><span class="line">    if(err != SQLITE_OK) &#123;</span><br><span class="line">        NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置最大繁忙重试时间间隔，默认为2秒</span><br><span class="line">    if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">        // set the handler</span><br><span class="line">        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 根据标记打开一个新的数据库连接</span><br><span class="line">// flag可以是以下三种值之一：</span><br><span class="line">// SQLITE_OPEN_READONLY，只读模式，如果数据库不存在会报错</span><br><span class="line">// SQLITE_OPEN_READWRITE，读写模式，如果该文件在操作系统中是写保护的，那就是以只读方式打开，如果数据库不存在会报错</span><br><span class="line">// SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE，以读写方式打开，如果数据不存在则新建一个，这个用于open方法里面</span><br><span class="line">// 以上还可以可选组合`SQLITE_OPEN_NOMUTEX`, `SQLITE_OPEN_FULLMUTEX`, `SQLITE_OPEN_SHAREDCACHE`, `SQLITE_OPEN_PRIVATECACHE`, and/or `SQLITE_OPEN_URI`</span><br><span class="line">- (BOOL)openWithFlags:(int)flags &#123;</span><br><span class="line">    return [self openWithFlags:flags vfs:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName &#123;</span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3005000</span><br><span class="line">    if (_db) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    // 比sqlite3_open多传入了flags和vfsName，vfsName为使用的VFS模块的名称</span><br><span class="line">    // sqlite3_open_v2里zVfs参数允许客户应用程序命名一个虚拟文件系统（Virtual File System）模块，用来与数据库连接。VFS作为SQlite library和底层存储系统（如某个文件系统）之间的一个抽象层，通常客户应用程序可以简单的给该参数传递一个NULL指针，以使用默认的VFS模块。</span><br><span class="line">    // sqlite3_open_v2比sqlite3_open和sqlite3_open16强大在它可以指定连接方式</span><br><span class="line">    int err = sqlite3_open_v2([self sqlitePath], (sqlite3**)&amp;_db, flags, [vfsName UTF8String]);</span><br><span class="line">    if(err != SQLITE_OK) &#123;</span><br><span class="line">        NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">        // set the handler</span><br><span class="line">        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">#else</span><br><span class="line">    NSLog(@&quot;openWithFlags requires SQLite 3.5&quot;);</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open时会根据<code>_maxBusyRetryTimeInterval</code>来设置繁忙处理<code>busy handler</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout &#123;</span><br><span class="line">    </span><br><span class="line">    _maxBusyRetryTimeInterval = timeout;</span><br><span class="line">    </span><br><span class="line">    if (!_db) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);</span><br><span class="line">     第二个参数是回调函数（busy handler），如果设置了回调函数，那就需要设置sqlite3_busy_handler的第三个参数，这里传递给它的是一个void*的参数的拷贝；如果回调函数返回０时，将不再尝试再次访问数据库而返回SQLITE_BUSY或者SQLITE_IOERR_BLOCKED。如果回调函数返回非０,将会不断尝试操作数据库。</span><br><span class="line">     也就是说，程序运行过程中，如果有其他进程或者线程在读写数据库，那么sqlite3_busy_handler会不断调用回调函数，直到其他进程或者线程释放锁。获得锁之后，不会再调用回调函数，从而向下执行，进行数据库操作。该函数是在获取不到锁的时候，以执行回调函数的次数来进行延迟，等待其他进程或者线程操作数据库结束，从而获得锁操作数据库。</span><br><span class="line">     */</span><br><span class="line">    if (timeout &gt; 0) &#123;</span><br><span class="line">        // busy handler设置为FMDBDatabaseBusyHandler函数</span><br><span class="line">        sqlite3_busy_handler(_db, &amp;FMDBDatabaseBusyHandler, (__bridge void *)(self));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // turn it off otherwise</span><br><span class="line">        // 关闭busy handler</span><br><span class="line">        sqlite3_busy_handler(_db, nil, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这就是回调函数</span><br><span class="line">static int FMDBDatabaseBusyHandler(void *f, int count) &#123;</span><br><span class="line">    FMDatabase *self = (__bridge FMDatabase*)f;</span><br><span class="line">    </span><br><span class="line">    // 如果是第一次调用，调用[+ timeIntervalSinceReferenceDate]方法，获取当前时间与2001年1月1日00:00:00 UTC的时间间隔，并赋值给startBusyRetryTime</span><br><span class="line">    if (count == 0) &#123;</span><br><span class="line">        self-&gt;_startBusyRetryTime = [NSDate timeIntervalSinceReferenceDate];</span><br><span class="line">        // 返回1，则将不断尝试操作数据库</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算当前时间与2001年1月1日00:00:00 UTC的时间间隔和startBusyRetryTime的间隔</span><br><span class="line">    NSTimeInterval delta = [NSDate timeIntervalSinceReferenceDate] - (self-&gt;_startBusyRetryTime);</span><br><span class="line">    // 如果间隔时间小于最大的重试间隔时间</span><br><span class="line">    if (delta &lt; [self maxBusyRetryTimeInterval]) &#123;</span><br><span class="line">        // 产生一个从50-99的随机整数作为需要挂起毫秒时间</span><br><span class="line">        int requestedSleepInMillseconds = (int) arc4random_uniform(50) + 50;</span><br><span class="line">        // 调用sqlite3_sleep返回实际挂起毫秒时间，如果不一致，可能是因为SQLite构建时没有将HAVE_USLEEP设置为1</span><br><span class="line">        int actualSleepInMilliseconds = sqlite3_sleep(requestedSleepInMillseconds);</span><br><span class="line">        if (actualSleepInMilliseconds != requestedSleepInMillseconds) &#123;</span><br><span class="line">            NSLog(@&quot;WARNING: Requested sleep of %i milliseconds, but SQLite returned %i. Maybe SQLite wasn&apos;t built with HAVE_USLEEP=1?&quot;, requestedSleepInMillseconds, actualSleepInMilliseconds);</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![db open]) &#123;</span><br><span class="line">	// do somthing        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行单个查询SQL语句"><a href="#执行单个查询SQL语句" class="headerlink" title="执行单个查询SQL语句"></a>执行单个查询SQL语句</h4><p>主要执行的是<code>(FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code>方法，<code>sql</code>是执行SELECT语句，<code>dictionaryArgs</code>是对应于<code>sql</code>语句里<code>？</code>的<code>key</code>和<code>value</code>，在将<code>sql</code>语句转换成<code>prepared</code>语句时，这里先从缓存中获取，没有的话再去调用<code>sqlite3_prepare_v2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123;</span><br><span class="line">    // 检查数据库是否存在</span><br><span class="line">    if (![self databaseExists]) &#123;</span><br><span class="line">        return 0x00;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查是否正在执行操作</span><br><span class="line">    if (_isExecutingStatement) &#123;</span><br><span class="line">        [self warnInUse];</span><br><span class="line">        return 0x00;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = YES;</span><br><span class="line">    </span><br><span class="line">    int rc                  = 0x00;</span><br><span class="line">    sqlite3_stmt *pStmt     = 0x00;</span><br><span class="line">    FMStatement *statement  = 0x00;</span><br><span class="line">    FMResultSet *rs         = 0x00;</span><br><span class="line">    </span><br><span class="line">    if (_traceExecution &amp;&amp; sql) &#123;</span><br><span class="line">        NSLog(@&quot;%@ executeQuery: %@&quot;, self, sql);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将sql语句转换成prepared语句</span><br><span class="line">    // 由于使用sqlite3_prepare_v2来生成sql对应的prepared语句代价很大</span><br><span class="line">    // 所以使用缓存机制来减少sqlite3_prepare_v2的使用</span><br><span class="line">    if (_shouldCacheStatements) &#123;</span><br><span class="line">        // 根据sql获取到缓存中的prepared语句</span><br><span class="line">        statement = [self cachedStatementForQuery:sql];</span><br><span class="line">        pStmt = statement ? [statement statement] : 0x00;</span><br><span class="line">        // 重置prepared语句</span><br><span class="line">        [statement reset];</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果缓存中没有sql对应的prepared语句，那么需要用sqlite3_prepare_v2生成对应的prepared语句</span><br><span class="line">    if (!pStmt) &#123;</span><br><span class="line">        </span><br><span class="line">        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;pStmt, 0);</span><br><span class="line">        </span><br><span class="line">        // 如果生成失败，则打印错误日志</span><br><span class="line">        if (SQLITE_OK != rc) &#123;</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">                NSLog(@&quot;DB Path: %@&quot;, _databasePath);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (_crashOnErrors) &#123;</span><br><span class="line">                NSAssert(false, @&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</span><br><span class="line">                // 停止程序</span><br><span class="line">                abort();</span><br><span class="line">            &#125;</span><br><span class="line">            // 释放所有内部资源和FMStatement</span><br><span class="line">            sqlite3_finalize(pStmt);</span><br><span class="line">            _isExecutingStatement = NO;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id obj;</span><br><span class="line">    int idx = 0;</span><br><span class="line">    // sqlite3_bind_parameter_count 返回SQL语句参数的数量</span><br><span class="line">    int queryCount = sqlite3_bind_parameter_count(pStmt); // pointed out by Dominic Yu (thanks!)</span><br><span class="line">    </span><br><span class="line">    // If dictionaryArgs is passed in, that means we are using sqlite&apos;s named parameter support</span><br><span class="line">    if (dictionaryArgs) &#123;</span><br><span class="line">        </span><br><span class="line">        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &#123;</span><br><span class="line">            </span><br><span class="line">            // Prefix the key with a colon.</span><br><span class="line">            NSString *parameterName = [[NSString alloc] initWithFormat:@&quot;:%@&quot;, dictionaryKey];</span><br><span class="line">            </span><br><span class="line">            if (_traceExecution) &#123;</span><br><span class="line">                NSLog(@&quot;%@ = %@&quot;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Get the index for the parameter name.</span><br><span class="line">            // 通过传入参数名来获取该参数的索引</span><br><span class="line">            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);</span><br><span class="line">            </span><br><span class="line">            FMDBRelease(parameterName);</span><br><span class="line">            // 如果索引大于0</span><br><span class="line">            if (namedIdx &gt; 0) &#123;</span><br><span class="line">                // Standard binding from here.</span><br><span class="line">                // 在prepared语句里将值绑定到索引位置</span><br><span class="line">                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];</span><br><span class="line">                // increment the binding count, so our check below works out</span><br><span class="line">                // 绑定数量加一</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                NSLog(@&quot;Could not find index for %@&quot;, dictionaryKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        </span><br><span class="line">        while (idx &lt; queryCount) &#123;</span><br><span class="line">            // 当调用下面三个方法时</span><br><span class="line">            // - (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...</span><br><span class="line">            // - (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments</span><br><span class="line">            // - (FMResultSet *)executeQuery:(NSString *)sql values:(NSArray *)values error:(NSError * __autoreleasing *)error</span><br><span class="line">            // 值是放在NSArray里面，循环取出来绑定</span><br><span class="line">            if (arrayArgs &amp;&amp; idx &lt; (int)[arrayArgs count]) &#123;</span><br><span class="line">                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];</span><br><span class="line">            &#125;</span><br><span class="line">            // 当调用下面两个方法时</span><br><span class="line">            // - (FMResultSet *)executeQuery:(NSString*)sql, ...</span><br><span class="line">            // - (FMResultSet *)executeQuery:(NSString*)sql withVAList:(va_list)args</span><br><span class="line">            // 值是放在va_list里面，循环取出来绑定</span><br><span class="line">            else if (args) &#123;</span><br><span class="line">                obj = va_arg(args, id);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //We ran out of arguments</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (_traceExecution) &#123;</span><br><span class="line">                if ([obj isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">                    NSLog(@&quot;data: %ld bytes&quot;, (unsigned long)[(NSData*)obj length]);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    NSLog(@&quot;obj: %@&quot;, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            idx++;</span><br><span class="line">            // 绑定参数</span><br><span class="line">            [self bindObject:obj toColumn:idx inStatement:pStmt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果绑定数量和参数数量不一致，打印错误，并释放资源</span><br><span class="line">    if (idx != queryCount) &#123;</span><br><span class="line">        NSLog(@&quot;Error: the bind count is not correct for the # of variables (executeQuery)&quot;);</span><br><span class="line">        sqlite3_finalize(pStmt);</span><br><span class="line">        _isExecutingStatement = NO;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FMDBRetain(statement); // to balance the release below</span><br><span class="line">    </span><br><span class="line">    // 如果statement不为空，则缓存</span><br><span class="line">    if (!statement) &#123;</span><br><span class="line">        statement = [[FMStatement alloc] init];</span><br><span class="line">        [statement setStatement:pStmt];</span><br><span class="line">        </span><br><span class="line">        if (_shouldCacheStatements &amp;&amp; sql) &#123;</span><br><span class="line">            // 以sql作为key来缓存statement</span><br><span class="line">            [self setCachedStatement:statement forQuery:sql];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // the statement gets closed in rs&apos;s dealloc or [rs close];</span><br><span class="line">    // 根据statement和FMDataBase对象来初始化FMResultSet对象</span><br><span class="line">    rs = [FMResultSet resultSetWithStatement:statement usingParentDatabase:self];</span><br><span class="line">    [rs setQuery:sql];</span><br><span class="line">    </span><br><span class="line">    // 将FMResultSet对象加到_openResultSets里</span><br><span class="line">    NSValue *openResultSet = [NSValue valueWithNonretainedObject:rs];</span><br><span class="line">    [_openResultSets addObject:openResultSet];</span><br><span class="line">    // useCount+1</span><br><span class="line">    [statement setUseCount:[statement useCount] + 1];</span><br><span class="line">    </span><br><span class="line">    FMDBRelease(statement);</span><br><span class="line">    // 设置_isExecutingStatement操作结束</span><br><span class="line">    _isExecutingStatement = NO;</span><br><span class="line">    </span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rs = [newDb executeQuery:@&quot;select rowid,* from test where a = ?&quot;, @&quot;hi&apos;&quot;];</span><br><span class="line"></span><br><span class="line">rs = [db executeQueryWithFormat:@&quot;select * from t5 where a = %s and a = %@ and b = %d&quot;, &quot;text&quot;, @&quot;text&quot;, 42];</span><br><span class="line"></span><br><span class="line">rs = [db executeQuery:@&quot;select * from testOneHundredTwelvePointTwo where b &gt; ?&quot; withArgumentsInArray:[NSArray arrayWithObject:[NSNumber numberWithInteger:1]]];</span><br><span class="line"></span><br><span class="line">rs = [db executeQuery:@&quot;select * from namedparamcounttest where a = :a&quot; withParameterDictionary:dictionaryArgs];</span><br></pre></td></tr></table></figure>
<h4 id="执行单个更新SQL语句"><a href="#执行单个更新SQL语句" class="headerlink" title="执行单个更新SQL语句"></a>执行单个更新SQL语句</h4><p><code>- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code>是主要函数，但是里面大部分处理和<code>- executeQuery: withArgumentsInArray: orDictionary: orVAList:</code>处理类似，不同处我已经注释说明，可以直接看注释部分代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123;</span><br><span class="line">    </span><br><span class="line">    if (![self databaseExists]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_isExecutingStatement) &#123;</span><br><span class="line">        [self warnInUse];</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = YES;</span><br><span class="line">    </span><br><span class="line">    int rc                   = 0x00;</span><br><span class="line">    sqlite3_stmt *pStmt      = 0x00;</span><br><span class="line">    FMStatement *cachedStmt  = 0x00;</span><br><span class="line">    </span><br><span class="line">    if (_traceExecution &amp;&amp; sql) &#123;</span><br><span class="line">        NSLog(@&quot;%@ executeUpdate: %@&quot;, self, sql);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_shouldCacheStatements) &#123;</span><br><span class="line">        cachedStmt = [self cachedStatementForQuery:sql];</span><br><span class="line">        pStmt = cachedStmt ? [cachedStmt statement] : 0x00;</span><br><span class="line">        [cachedStmt reset];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!pStmt) &#123;</span><br><span class="line">        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;pStmt, 0);</span><br><span class="line">        </span><br><span class="line">        if (SQLITE_OK != rc) &#123;</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">                NSLog(@&quot;DB Path: %@&quot;, _databasePath);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (_crashOnErrors) &#123;</span><br><span class="line">                NSAssert(false, @&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</span><br><span class="line">                abort();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (outErr) &#123;</span><br><span class="line">                *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sqlite3_finalize(pStmt);</span><br><span class="line">            </span><br><span class="line">            _isExecutingStatement = NO;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id obj;</span><br><span class="line">    int idx = 0;</span><br><span class="line">    int queryCount = sqlite3_bind_parameter_count(pStmt);</span><br><span class="line">    </span><br><span class="line">    // If dictionaryArgs is passed in, that means we are using sqlite&apos;s named parameter support</span><br><span class="line">    if (dictionaryArgs) &#123;</span><br><span class="line">        </span><br><span class="line">        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &#123;</span><br><span class="line">            </span><br><span class="line">            // Prefix the key with a colon.</span><br><span class="line">            NSString *parameterName = [[NSString alloc] initWithFormat:@&quot;:%@&quot;, dictionaryKey];</span><br><span class="line">            </span><br><span class="line">            if (_traceExecution) &#123;</span><br><span class="line">                NSLog(@&quot;%@ = %@&quot;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);</span><br><span class="line">            &#125;</span><br><span class="line">            // Get the index for the parameter name.</span><br><span class="line">            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);</span><br><span class="line">            </span><br><span class="line">            FMDBRelease(parameterName);</span><br><span class="line">            </span><br><span class="line">            if (namedIdx &gt; 0) &#123;</span><br><span class="line">                // Standard binding from here.</span><br><span class="line">                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];</span><br><span class="line">                </span><br><span class="line">                // increment the binding count, so our check below works out</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // 由于多了outErr，所以绑定时出错需要将error抛出</span><br><span class="line">                NSString *message = [NSString stringWithFormat:@&quot;Could not find index for %@&quot;, dictionaryKey];</span><br><span class="line">                </span><br><span class="line">                if (_logsErrors) &#123;</span><br><span class="line">                    NSLog(@&quot;%@&quot;, message);</span><br><span class="line">                &#125;</span><br><span class="line">                if (outErr) &#123;</span><br><span class="line">                    *outErr = [self errorWithMessage:message];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        </span><br><span class="line">        while (idx &lt; queryCount) &#123;</span><br><span class="line">            </span><br><span class="line">            if (arrayArgs &amp;&amp; idx &lt; (int)[arrayArgs count]) &#123;</span><br><span class="line">                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (args) &#123;</span><br><span class="line">                obj = va_arg(args, id);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //We ran out of arguments</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (_traceExecution) &#123;</span><br><span class="line">                if ([obj isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">                    NSLog(@&quot;data: %ld bytes&quot;, (unsigned long)[(NSData*)obj length]);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    NSLog(@&quot;obj: %@&quot;, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            idx++;</span><br><span class="line">            </span><br><span class="line">            [self bindObject:obj toColumn:idx inStatement:pStmt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (idx != queryCount) &#123;</span><br><span class="line">        // 同样也是组装error抛出</span><br><span class="line">        NSString *message = [NSString stringWithFormat:@&quot;Error: the bind count (%d) is not correct for the # of variables in the query (%d) (%@) (executeUpdate)&quot;, idx, queryCount, sql];</span><br><span class="line">        if (_logsErrors) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;, message);</span><br><span class="line">        &#125;</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [self errorWithMessage:message];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sqlite3_finalize(pStmt);</span><br><span class="line">        _isExecutingStatement = NO;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Call sqlite3_step() to run the virtual machine. Since the SQL being</span><br><span class="line">     ** executed is not a SELECT statement, we assume no data will be returned.</span><br><span class="line">     */</span><br><span class="line">    // sqlite3_prepare函数将SQL命令字符串解析并转换为一系列的命令字节码，这些字节码最终被传送到SQlite3的虚拟数据库引擎（VDBE: Virtual Database Engine）中执行，完成这项工作的是sqlite3_step函数。比如一个SELECT查询操作，sqlite3_step函数的每次调用都会返回结果集中的其中一行，直到再没有有效数据行了。每次调用sqlite3_step函数如果返回SQLITE_ROW，代表获得了有效数据行，可以通过sqlite3_column函数提取某列的值。如果调用sqlite3_step函数返回SQLITE_DONE，则代表prepared语句已经执行到终点了，没有有效数据了。很多命令第一次调用sqlite3_step函数就会返回SQLITE_DONE，因为这些SQL命令不会返回数据。对于INSERT，UPDATE，DELETE命令，会返回它们所修改的行号——一个单行单列的值。</span><br><span class="line">    /**</span><br><span class="line">     SQLITE_BUSY 数据库文件有锁</span><br><span class="line">     SQLITE_LOCKED 数据库中的某张表有锁</span><br><span class="line">     SQLITE_DONE sqlite3_step()执行完毕</span><br><span class="line">     SQLITE_ROW sqlite3_step()获取到下一行数据</span><br><span class="line">     SQLITE_ERROR 一般用于没有特别指定错误码的错误，就是说函数在执行过程中发生了错误，但无法知道错误发生的原因。</span><br><span class="line">     SQLITE_MISUSE 没有正确使用SQLite接口，比如一条语句在sqlite3_step函数执行之后，没有被重置之前，再次给其绑定参数，这时bind函数就会返回SQLITE_MISUSE。</span><br><span class="line">     **/</span><br><span class="line">    rc      = sqlite3_step(pStmt);</span><br><span class="line">    </span><br><span class="line">    if (SQLITE_DONE == rc) &#123;</span><br><span class="line">        // all is well, let&apos;s return.</span><br><span class="line">    &#125;</span><br><span class="line">    // sql操作被sqlite3_interrupt()函数终止</span><br><span class="line">    else if (SQLITE_INTERRUPT == rc) &#123;</span><br><span class="line">        if (_logsErrors) &#123;</span><br><span class="line">            NSLog(@&quot;Error calling sqlite3_step. Query was interrupted (%d: %s) SQLITE_INTERRUPT&quot;, rc, sqlite3_errmsg(_db));</span><br><span class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (rc == SQLITE_ROW) &#123;</span><br><span class="line">        NSString *message = [NSString stringWithFormat:@&quot;A executeUpdate is being called with a query string &apos;%@&apos;&quot;, sql];</span><br><span class="line">        if (_logsErrors) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;, message);</span><br><span class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">        &#125;</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [self errorWithMessage:message];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (SQLITE_ERROR == rc) &#123;</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;Error calling sqlite3_step (%d: %s) SQLITE_ERROR&quot;, rc, sqlite3_errmsg(_db));</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (SQLITE_MISUSE == rc) &#123;</span><br><span class="line">            // uh oh.</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;Error calling sqlite3_step (%d: %s) SQLITE_MISUSE&quot;, rc, sqlite3_errmsg(_db));</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // wtf?</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;Unknown error calling sqlite3_step (%d: %s) eu&quot;, rc, sqlite3_errmsg(_db));</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_shouldCacheStatements &amp;&amp; !cachedStmt) &#123;</span><br><span class="line">        cachedStmt = [[FMStatement alloc] init];</span><br><span class="line">        </span><br><span class="line">        [cachedStmt setStatement:pStmt];</span><br><span class="line">        </span><br><span class="line">        [self setCachedStatement:cachedStmt forQuery:sql];</span><br><span class="line">        </span><br><span class="line">        FMDBRelease(cachedStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int closeErrorCode;</span><br><span class="line">    </span><br><span class="line">    if (cachedStmt) &#123;</span><br><span class="line">        [cachedStmt setUseCount:[cachedStmt useCount] + 1];</span><br><span class="line">        closeErrorCode = sqlite3_reset(pStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        /* Finalize the virtual machine. This releases all memory and other</span><br><span class="line">         ** resources allocated by the sqlite3_prepare() call above.</span><br><span class="line">         */</span><br><span class="line">        closeErrorCode = sqlite3_finalize(pStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (closeErrorCode != SQLITE_OK) &#123;</span><br><span class="line">        if (_logsErrors) &#123;</span><br><span class="line">            NSLog(@&quot;Unknown error finalizing or resetting statement (%d: %s)&quot;, closeErrorCode, sqlite3_errmsg(_db));</span><br><span class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = NO;</span><br><span class="line">    return (rc == SQLITE_DONE || rc == SQLITE_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[db executeUpdate:@&quot;insert into t5 values (?, ?, ?, ?, ?)&quot; withErrorAndBindings:&amp;err, @&quot;text&quot;, [NSNumber numberWithInt:42], @&quot;BLOB&quot;, @&quot;d&quot;, [NSNumber numberWithInt:0]];</span><br><span class="line"></span><br><span class="line">[dbB executeUpdate:@&quot;create table attached (a text)&quot;];</span><br><span class="line"></span><br><span class="line">[dbB executeUpdate:@&quot;insert into attached values (?)&quot;, @&quot;test&quot;];</span><br><span class="line"></span><br><span class="line">[db executeUpdateWithFormat:@&quot;insert into t55 values (%c, %hi, %g)&quot;, &apos;a&apos;, testShort, testFloat];</span><br><span class="line"></span><br><span class="line">[db executeUpdate:@&quot;insert into testOneHundredTwelvePointTwo values (?, ?)&quot; withArgumentsInArray:[NSArray arrayWithObjects:@&quot;one&quot;, [NSNumber numberWithInteger:2], nil]];</span><br><span class="line"></span><br><span class="line">[db executeUpdate:@&quot;insert into namedparamtest values (:a, :b, :c, :d)&quot; withParameterDictionary:dictionaryArgs];</span><br></pre></td></tr></table></figure>
<h4 id="执行多个SQL语句"><a href="#执行多个SQL语句" class="headerlink" title="执行多个SQL语句"></a>执行多个SQL语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 使用executeStatements:函数可以将多个SQL执行语句写在一个字符串中，并执行</span><br><span class="line">- (BOOL)executeStatements:(NSString *)sql &#123;</span><br><span class="line">    return [self executeStatements:sql withResultBlock:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)executeStatements:(NSString *)sql withResultBlock:(FMDBExecuteStatementsCallbackBlock)block &#123;</span><br><span class="line">    </span><br><span class="line">    int rc;</span><br><span class="line">    char *errmsg = nil;</span><br><span class="line">    /*</span><br><span class="line">     sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg)</span><br><span class="line">     </span><br><span class="line">     该例程提供了一个执行 SQL 命令的快捷方式，SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。</span><br><span class="line">     </span><br><span class="line">     在这里，第一个参数 sqlite3 是打开的数据库对象，sqlite_callback 是一个回调，data 作为其第一个参数，errmsg 将被返回用来获取程序生成的任何错误。</span><br><span class="line">     </span><br><span class="line">     sqlite3_exec() 程序解析并执行由 sql 参数所给的每个命令，直到字符串结束或者遇到错误为止。</span><br><span class="line">     */</span><br><span class="line">    rc = sqlite3_exec([self sqliteHandle], [sql UTF8String], block ? FMDBExecuteBulkSQLCallback : nil, (__bridge void *)(block), &amp;errmsg);</span><br><span class="line">    </span><br><span class="line">    if (errmsg &amp;&amp; [self logsErrors]) &#123;</span><br><span class="line">        NSLog(@&quot;Error inserting batch: %s&quot;, errmsg);</span><br><span class="line">        sqlite3_free(errmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (rc == SQLITE_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSString *sql = @&quot;create table messages1 (id integer primary key messageId, x text);&quot;</span><br><span class="line">                 &quot;create table messages2 (id integer primary key messageId, y text);&quot;</span><br><span class="line">				 &quot;insert into messages1 (x) values (&apos;X&apos;);&quot;</span><br><span class="line">                 &quot;insert into messages2 (y) values (&apos;Y&apos;);&quot;;</span><br><span class="line"></span><br><span class="line">success = [db executeStatements:sql];</span><br><span class="line"></span><br><span class="line">sql = @&quot;select count(*) as count from messages1;&quot;</span><br><span class="line">       &quot;select count(*) as count from messages2;&quot;;</span><br><span class="line"></span><br><span class="line">success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="获取最后一条插入数据的RowId"><a href="#获取最后一条插入数据的RowId" class="headerlink" title="获取最后一条插入数据的RowId"></a>获取最后一条插入数据的RowId</h4><p>可以根据这个<code>id</code>拿到该数据，并且向上取数据库数据等操作都可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (sqlite_int64)lastInsertRowId &#123;</span><br><span class="line">    // 如果有正在执行语句，返回</span><br><span class="line">    if (_isExecutingStatement) &#123;</span><br><span class="line">        [self warnInUse];</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = YES;</span><br><span class="line">    // sqlite3_last_insert_rowid 获取指定数据库最后一个插入的rowid</span><br><span class="line">    sqlite_int64 ret = sqlite3_last_insert_rowid(_db);</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = NO;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统计上一次SQL语句受影响的行数"><a href="#统计上一次SQL语句受影响的行数" class="headerlink" title="统计上一次SQL语句受影响的行数"></a>统计上一次SQL语句受影响的行数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (int)changes &#123;</span><br><span class="line">    if (_isExecutingStatement) &#123;</span><br><span class="line">        [self warnInUse];</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = YES;</span><br><span class="line">    </span><br><span class="line">    int ret = sqlite3_changes(_db);</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = NO;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exclusive事务和deferred事务"><a href="#exclusive事务和deferred事务" class="headerlink" title="exclusive事务和deferred事务"></a>exclusive事务和deferred事务</h4><p>事务可以从<code>DEFERRED</code>，<code>IMMEDIATE</code>或者<code>EXCLUSIVE</code>，一个事务的类型在<code>BEGIN</code>命令中指定：<code>BEGIN [ DEFERRED | IMMEDIATE | EXCLUSIVE ] TRANSACTION</code></p>
<p>一个<code>deferred</code>事务不获取任何锁，直到它需要锁的时候，而且<code>BEGIN</code>语句本身也不会做什么事情——它开始于<code>UNLOCK</code>状态；默认情况下是这样的。如果仅仅用<code>BEGIN</code>开始一个事务，那么事务就是<code>DEFERRED</code>的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取<code>SHARED LOCK</code>；同样，当进行第一次写操作时，它会获取<code>RESERVED LOCK</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 开始延迟事务</span><br><span class="line">- (BOOL)beginDeferredTransaction &#123;</span><br><span class="line">    </span><br><span class="line">    BOOL b = [self executeUpdate:@&quot;begin deferred transaction&quot;];</span><br><span class="line">    if (b) &#123;</span><br><span class="line">        _inTransaction = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。</span><br><span class="line"></span><br><span class="line">// 开始事务</span><br><span class="line">- (BOOL)beginTransaction &#123;</span><br><span class="line">    </span><br><span class="line">    BOOL b = [self executeUpdate:@&quot;begin exclusive transaction&quot;];</span><br><span class="line">    if (b) &#123;</span><br><span class="line">        _inTransaction = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回滚事务</span><br><span class="line">- (BOOL)rollback &#123;</span><br><span class="line">    BOOL b = [self executeUpdate:@&quot;rollback transaction&quot;];</span><br><span class="line">    </span><br><span class="line">    if (b) &#123;</span><br><span class="line">        _inTransaction = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">// 提交事务</span><br><span class="line">- (BOOL)commit &#123;</span><br><span class="line">    BOOL b =  [self executeUpdate:@&quot;commit transaction&quot;];</span><br><span class="line">    </span><br><span class="line">    if (b) &#123;</span><br><span class="line">        _inTransaction = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据库加密及重置"><a href="#数据库加密及重置" class="headerlink" title="数据库加密及重置"></a>数据库加密及重置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)setKeyWithData:(NSData *)keyData &#123;</span><br><span class="line">// SQLITE_HAS_CODEC 用来确定是否支持加密</span><br><span class="line">#ifdef SQLITE_HAS_CODEC</span><br><span class="line">    if (!keyData) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // int sqlite3_key( sqlite3 *db, const void *pKey, int nKey)</span><br><span class="line">    // db是指定的数据库，pKey是密钥，nKey是密钥的长度</span><br><span class="line">    // 例如：sqlite3_key(_db, &quot;gongcheng&quot;, 9);</span><br><span class="line">    int rc = sqlite3_key(_db, [keyData bytes], (int)[keyData length]);</span><br><span class="line">    </span><br><span class="line">    return (rc == SQLITE_OK);</span><br><span class="line">#else</span><br><span class="line">#pragma unused(keyData)</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)rekeyWithData:(NSData *)keyData &#123;</span><br><span class="line">#ifdef SQLITE_HAS_CODEC</span><br><span class="line">    if (!keyData) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // int sqlite3_rekey( sqlite3 *db, const void *pKey, int nKey)</span><br><span class="line">    // db是指定的数据库，pKey是密钥，nKey是密钥的长度</span><br><span class="line">    // 例如：sqlite3_rekey(_db, &quot;yzy&quot;, 3);</span><br><span class="line">    int rc = sqlite3_rekey(_db, [keyData bytes], (int)[keyData length]);</span><br><span class="line">    </span><br><span class="line">    if (rc != SQLITE_OK) &#123;</span><br><span class="line">        NSLog(@&quot;error on rekey: %d&quot;, rc);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [self lastErrorMessage]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (rc == SQLITE_OK);</span><br><span class="line">#else</span><br><span class="line">#pragma unused(keyData)</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据库回滚时设置回滚节点"><a href="#数据库回滚时设置回滚节点" class="headerlink" title="数据库回滚时设置回滚节点"></a>数据库回滚时设置回滚节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (NSError*)inSavePoint:(void (^)(BOOL *rollback))block &#123;</span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3007000</span><br><span class="line">    static unsigned long savePointIdx = 0;</span><br><span class="line">    // 设置节点名称</span><br><span class="line">    NSString *name = [NSString stringWithFormat:@&quot;dbSavePoint%ld&quot;, savePointIdx++];</span><br><span class="line">    // 默认不回滚</span><br><span class="line">    BOOL shouldRollback = NO;</span><br><span class="line">    </span><br><span class="line">    NSError *err = 0x00;</span><br><span class="line">    // 先对当前状态进行保存</span><br><span class="line">    if (![self startSavePointWithName:name error:&amp;err]) &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(&amp;shouldRollback);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果需要回滚，则回滚当上一个节点</span><br><span class="line">    if (shouldRollback) &#123;</span><br><span class="line">        // We need to rollback and release this savepoint to remove it</span><br><span class="line">        [self rollbackToSavePointWithName:name error:&amp;err];</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放节点</span><br><span class="line">    [self releaseSavePointWithName:name error:&amp;err];</span><br><span class="line">    </span><br><span class="line">    return err;</span><br><span class="line">#else</span><br><span class="line">    NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil);</span><br><span class="line">    if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage);</span><br><span class="line">    return [NSError errorWithDomain:@&quot;FMDatabase&quot; code:0 userInfo:@&#123;NSLocalizedDescriptionKey : errorMessage&#125;];</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)close &#123;</span><br><span class="line">    // 清除缓存的prepared语句</span><br><span class="line">    [self clearCachedStatements];</span><br><span class="line">    // 关闭所有打开的FMResultSet对象</span><br><span class="line">    [self closeOpenResultSets];</span><br><span class="line">    </span><br><span class="line">    if (!_db) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int  rc;</span><br><span class="line">    BOOL retry;</span><br><span class="line">    BOOL triedFinalizingOpenStatements = NO;</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        retry   = NO;</span><br><span class="line">        // 调用sqlite3_close尝试关闭数据库</span><br><span class="line">        rc      = sqlite3_close(_db);</span><br><span class="line">        // 当返回结果是数据库繁忙或者被锁住了</span><br><span class="line">        if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &#123;</span><br><span class="line">            if (!triedFinalizingOpenStatements) &#123;</span><br><span class="line">                triedFinalizingOpenStatements = YES;</span><br><span class="line">                sqlite3_stmt *pStmt;</span><br><span class="line">                // 从关联的pDb数据里面对应的prepared语句开始往下找相应的prepared语句，</span><br><span class="line">                // 如果pStmt是NULL，则从pDb的第一个prepared语句开始找，</span><br><span class="line">                // 如果没有找到，则返回NULL</span><br><span class="line">                while ((pStmt = sqlite3_next_stmt(_db, nil)) !=0) &#123;</span><br><span class="line">                    // 找到之后，释放资源</span><br><span class="line">                    NSLog(@&quot;Closing leaked statement&quot;);</span><br><span class="line">                    sqlite3_finalize(pStmt);</span><br><span class="line">                    retry = YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (SQLITE_OK != rc) &#123;</span><br><span class="line">            NSLog(@&quot;error closing!: %d&quot;, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (retry);</span><br><span class="line">    </span><br><span class="line">    _db = nil;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[newDb close];</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/23/FMDB-two/" class="prev">PREV</a><a href="/2016/07/05/IM-UI-optimize/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/07/23/FMDB-one/';
var disqus_title = 'FMDB初探（一）';
var disqus_url = 'http://yuzeyang.github.io/2016/07/23/FMDB-one/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code. <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>