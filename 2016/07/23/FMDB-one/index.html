<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> FMDB初探（一） · 宫城</title><meta name="description" content="FMDB初探（一） - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">FMDB初探（一）</h1><div class="post-info">2016年7月23日</div><div class="post-content"><p>在之前的<a href="http://zeeyang.com/2016/06/22/GCDAsyncSocket-socket-optimize/" target="_blank" rel="external">iOS Socket重构设计</a>里面我有提到我们使用了FMDB做消息缓存，在数据库选型方面，我们<a href="http://broccoliii.me/" target="_blank" rel="external">西兰花</a>也对目前比较流行和成熟的<code>Realm</code>、<code>FMDB</code>和<code>Core Data</code>做了调查，里面包括了安装、使用和性能比较，是个不错的参考例子</p>
<p>在选型时，我们应该多选取几个作为对比，从使用方面评估学习成本，通过测试不同数据库操作来比较性能差异，了解有哪些大型的App使用了该数据库以及评价来侧面说明该数据库的成熟度和在使用过程中出现的问题，最后根据自己实际的业务需求来选型</p>
<p>在选定使用<code>FMDB</code>之后，我也只是简单的了解下<code>FMDB</code>的使用，并未对内部的实现和设计思路做深入了解，但是在阅读了代码之后，<code>FMDB</code>确实像其他博客里面提到的那样，是对原生的SQLite API进行了包装，暴露出相对友好的对外接口，只需传入SQL语句即可(但是对于习惯于使用Model操作的我们来说，直接写SQL语句还是比较麻烦的，所以GitHub上也就库对<code>FMDB</code>进行了封装，省去写SQL语句，直接对Model进行操作)，并且<code>FMDB</code>内部对SQL语句进行了缓存，再配合上多线程并发执行，在提高效率方面做了不少的优化，另外还扩展了内存/文件的IO操作和虚表的操作</p>
<p>下面我会将API使用和源码结合起来讲，方便了解<code>FMDB</code>以及对复习下原生的SQLite API</p>
<a id="more"></a>
<h2 id="FMDatabase"><a href="#FMDatabase" class="headerlink" title="FMDatabase"></a>FMDatabase</h2><h4 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h4><p>数据库的初始化对外有两种方法<code>+ databaseWithPath:</code>和<code>- initWithPath:</code>，内部实际上<code>+ databaseWithPath:</code>只是对<code>- initWithPath:</code>包装，代码里很多类似<code>FMDBReturnAutoreleased</code>等等这一类宏定义是为了兼容ARC和MRC</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)databaseWithPath:(NSString*)aPath &#123;&#10;    return FMDBReturnAutoreleased([[self alloc] initWithPath:aPath]);&#10;&#125;&#10;&#10;- (instancetype)init &#123;&#10;    return [self initWithPath:nil];&#10;&#125;&#10;&#10;- (instancetype)initWithPath:(NSString*)aPath &#123;&#10;    // SQLite&#25903;&#25345;&#19977;&#31181;&#32447;&#31243;&#27169;&#24335;&#65292;&#20998;&#21035;&#20026;&#21333;&#32447;&#31243;&#27169;&#24335;&#12289;&#22810;&#32447;&#31243;&#27169;&#24335;&#21644;&#20018;&#34892;&#27169;&#24335;&#10;    // sqlite3_threadsafe()&#30340;&#36820;&#22238;&#20540;&#21487;&#20197;&#30830;&#23450;&#32534;&#35793;&#26102;&#25351;&#23450;&#30340;&#32447;&#31243;&#27169;&#24335;&#65292;&#20854;&#20013;&#23545;&#20110;&#21333;&#32447;&#31243;&#27169;&#24335;&#65292;sqlite3_threadsafe()&#36820;&#22238;false&#65292;&#23545;&#20110;&#21478;&#22806;&#20004;&#20010;&#27169;&#24335;&#65292;&#21017;&#36820;&#22238;true&#12290;&#36825;&#26159;&#22240;&#20026;&#21333;&#32447;&#31243;&#27169;&#24335;&#19979;&#27809;&#26377;&#36827;&#34892;&#20114;&#26021;&#65292;&#25152;&#20197;&#22810;&#32447;&#31243;&#19979;&#26159;&#19981;&#23433;&#20840;&#30340;&#10;    assert(sqlite3_threadsafe()); // whoa there big boy- gotta make sure sqlite it happy with what we&#39;re going to do.&#10;    &#10;    self = [super init];&#10;    &#10;    if (self) &#123;&#10;        _databasePath               = [aPath copy];&#10;        _openResultSets             = [[NSMutableSet alloc] init];&#10;        // &#27492;&#26102;&#24182;&#19981;&#21019;&#24314;&#25968;&#25454;&#24211;&#65292;&#30495;&#27491;&#21019;&#24314;&#26159;&#22312;open&#30340;&#26102;&#20505;&#10;      &#9;_db                         = nil;&#10;        _logsErrors                 = YES;&#10;        _crashOnErrors              = NO;&#10;        _maxBusyRetryTimeInterval   = 2;&#10;    &#125;&#10;    &#10;    return self;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#32473;&#23450;database&#36335;&#24452;&#10;NSString *dbPath = @&#34;/tmp/tmp.db&#34;;&#10;// &#35843;&#29992;[+ databaseWithPath:]&#26041;&#27861;&#10;FMDatabase *db = [FMDatabase databaseWithPath:dbPath];</span><br></pre></td></tr></table></figure>
<h4 id="u6253_u5F00_u6570_u636E_u8FDE_u63A5"><a href="#u6253_u5F00_u6570_u636E_u8FDE_u63A5" class="headerlink" title="打开数据连接"></a>打开数据连接</h4><p>打开连接提供了三种方法，这时候才开始创建数据库</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)open &#123;&#10;    if (_db) &#123;&#10;        return YES;&#10;    &#125;&#10;    // &#26681;&#25454;&#25968;&#25454;&#24211;&#36335;&#24452;&#25171;&#24320;&#25968;&#25454;&#24211;&#65292;&#22914;&#26524;&#25968;&#25454;&#24211;&#19981;&#23384;&#22312;&#23601;&#26032;&#24314;&#19968;&#20010;&#10;    int err = sqlite3_open([self sqlitePath], (sqlite3**)&#38;_db );&#10;    if(err != SQLITE_OK) &#123;&#10;        NSLog(@&#34;error opening!: %d&#34;, err);&#10;        return NO;&#10;    &#125;&#10;    // &#35774;&#32622;&#26368;&#22823;&#32321;&#24537;&#37325;&#35797;&#26102;&#38388;&#38388;&#38548;&#65292;&#40664;&#35748;&#20026;2&#31186;&#10;    if (_maxBusyRetryTimeInterval &#62; 0.0) &#123;&#10;        // set the handler&#10;        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];&#10;    &#125;&#10;    &#10;  &#9;return YES;&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#26681;&#25454;&#26631;&#35760;&#25171;&#24320;&#19968;&#20010;&#26032;&#30340;&#25968;&#25454;&#24211;&#36830;&#25509;&#10;// flag&#21487;&#20197;&#26159;&#20197;&#19979;&#19977;&#31181;&#20540;&#20043;&#19968;&#65306;&#10;// SQLITE_OPEN_READONLY&#65292;&#21482;&#35835;&#27169;&#24335;&#65292;&#22914;&#26524;&#25968;&#25454;&#24211;&#19981;&#23384;&#22312;&#20250;&#25253;&#38169;&#10;// SQLITE_OPEN_READWRITE&#65292;&#35835;&#20889;&#27169;&#24335;&#65292;&#22914;&#26524;&#35813;&#25991;&#20214;&#22312;&#25805;&#20316;&#31995;&#32479;&#20013;&#26159;&#20889;&#20445;&#25252;&#30340;&#65292;&#37027;&#23601;&#26159;&#20197;&#21482;&#35835;&#26041;&#24335;&#25171;&#24320;&#65292;&#22914;&#26524;&#25968;&#25454;&#24211;&#19981;&#23384;&#22312;&#20250;&#25253;&#38169;&#10;// SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE&#65292;&#20197;&#35835;&#20889;&#26041;&#24335;&#25171;&#24320;&#65292;&#22914;&#26524;&#25968;&#25454;&#19981;&#23384;&#22312;&#21017;&#26032;&#24314;&#19968;&#20010;&#65292;&#36825;&#20010;&#29992;&#20110;open&#26041;&#27861;&#37324;&#38754;&#10;// &#20197;&#19978;&#36824;&#21487;&#20197;&#21487;&#36873;&#32452;&#21512;`SQLITE_OPEN_NOMUTEX`, `SQLITE_OPEN_FULLMUTEX`, `SQLITE_OPEN_SHAREDCACHE`, `SQLITE_OPEN_PRIVATECACHE`, and/or `SQLITE_OPEN_URI`&#10;- (BOOL)openWithFlags:(int)flags &#123;&#10;    return [self openWithFlags:flags vfs:nil];&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName &#123;&#10;#if SQLITE_VERSION_NUMBER &#62;= 3005000&#10;    if (_db) &#123;&#10;        return YES;&#10;    &#125;&#10;    // &#27604;sqlite3_open&#22810;&#20256;&#20837;&#20102;flags&#21644;vfsName&#65292;vfsName&#20026;&#20351;&#29992;&#30340;VFS&#27169;&#22359;&#30340;&#21517;&#31216;&#10;    // sqlite3_open_v2&#37324;zVfs&#21442;&#25968;&#20801;&#35768;&#23458;&#25143;&#24212;&#29992;&#31243;&#24207;&#21629;&#21517;&#19968;&#20010;&#34394;&#25311;&#25991;&#20214;&#31995;&#32479;&#65288;Virtual File System&#65289;&#27169;&#22359;&#65292;&#29992;&#26469;&#19982;&#25968;&#25454;&#24211;&#36830;&#25509;&#12290;VFS&#20316;&#20026;SQlite library&#21644;&#24213;&#23618;&#23384;&#20648;&#31995;&#32479;&#65288;&#22914;&#26576;&#20010;&#25991;&#20214;&#31995;&#32479;&#65289;&#20043;&#38388;&#30340;&#19968;&#20010;&#25277;&#35937;&#23618;&#65292;&#36890;&#24120;&#23458;&#25143;&#24212;&#29992;&#31243;&#24207;&#21487;&#20197;&#31616;&#21333;&#30340;&#32473;&#35813;&#21442;&#25968;&#20256;&#36882;&#19968;&#20010;NULL&#25351;&#38024;&#65292;&#20197;&#20351;&#29992;&#40664;&#35748;&#30340;VFS&#27169;&#22359;&#12290;&#10;    // sqlite3_open_v2&#27604;sqlite3_open&#21644;sqlite3_open16&#24378;&#22823;&#22312;&#23427;&#21487;&#20197;&#25351;&#23450;&#36830;&#25509;&#26041;&#24335;&#10;    int err = sqlite3_open_v2([self sqlitePath], (sqlite3**)&#38;_db, flags, [vfsName UTF8String]);&#10;    if(err != SQLITE_OK) &#123;&#10;        NSLog(@&#34;error opening!: %d&#34;, err);&#10;        return NO;&#10;    &#125;&#10;    &#10;    if (_maxBusyRetryTimeInterval &#62; 0.0) &#123;&#10;        // set the handler&#10;        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];&#10;    &#125;&#10;    &#10;    return YES;&#10;#else&#10;    NSLog(@&#34;openWithFlags requires SQLite 3.5&#34;);&#10;    return NO;&#10;#endif&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>open时会根据<code>_maxBusyRetryTimeInterval</code>来设置繁忙处理<code>busy handler</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout &#123;&#10;    &#10;    _maxBusyRetryTimeInterval = timeout;&#10;    &#10;    if (!_db) &#123;&#10;        return;&#10;    &#125;&#10;    /*&#10;     int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);&#10;     &#31532;&#20108;&#20010;&#21442;&#25968;&#26159;&#22238;&#35843;&#20989;&#25968;&#65288;busy handler&#65289;&#65292;&#22914;&#26524;&#35774;&#32622;&#20102;&#22238;&#35843;&#20989;&#25968;&#65292;&#37027;&#23601;&#38656;&#35201;&#35774;&#32622;sqlite3_busy_handler&#30340;&#31532;&#19977;&#20010;&#21442;&#25968;&#65292;&#36825;&#37324;&#20256;&#36882;&#32473;&#23427;&#30340;&#26159;&#19968;&#20010;void*&#30340;&#21442;&#25968;&#30340;&#25335;&#36125;&#65307;&#22914;&#26524;&#22238;&#35843;&#20989;&#25968;&#36820;&#22238;&#65296;&#26102;&#65292;&#23558;&#19981;&#20877;&#23581;&#35797;&#20877;&#27425;&#35775;&#38382;&#25968;&#25454;&#24211;&#32780;&#36820;&#22238;SQLITE_BUSY&#25110;&#32773;SQLITE_IOERR_BLOCKED&#12290;&#22914;&#26524;&#22238;&#35843;&#20989;&#25968;&#36820;&#22238;&#38750;&#65296;,&#23558;&#20250;&#19981;&#26029;&#23581;&#35797;&#25805;&#20316;&#25968;&#25454;&#24211;&#12290;&#10;     &#20063;&#23601;&#26159;&#35828;&#65292;&#31243;&#24207;&#36816;&#34892;&#36807;&#31243;&#20013;&#65292;&#22914;&#26524;&#26377;&#20854;&#20182;&#36827;&#31243;&#25110;&#32773;&#32447;&#31243;&#22312;&#35835;&#20889;&#25968;&#25454;&#24211;&#65292;&#37027;&#20040;sqlite3_busy_handler&#20250;&#19981;&#26029;&#35843;&#29992;&#22238;&#35843;&#20989;&#25968;&#65292;&#30452;&#21040;&#20854;&#20182;&#36827;&#31243;&#25110;&#32773;&#32447;&#31243;&#37322;&#25918;&#38145;&#12290;&#33719;&#24471;&#38145;&#20043;&#21518;&#65292;&#19981;&#20250;&#20877;&#35843;&#29992;&#22238;&#35843;&#20989;&#25968;&#65292;&#20174;&#32780;&#21521;&#19979;&#25191;&#34892;&#65292;&#36827;&#34892;&#25968;&#25454;&#24211;&#25805;&#20316;&#12290;&#35813;&#20989;&#25968;&#26159;&#22312;&#33719;&#21462;&#19981;&#21040;&#38145;&#30340;&#26102;&#20505;&#65292;&#20197;&#25191;&#34892;&#22238;&#35843;&#20989;&#25968;&#30340;&#27425;&#25968;&#26469;&#36827;&#34892;&#24310;&#36831;&#65292;&#31561;&#24453;&#20854;&#20182;&#36827;&#31243;&#25110;&#32773;&#32447;&#31243;&#25805;&#20316;&#25968;&#25454;&#24211;&#32467;&#26463;&#65292;&#20174;&#32780;&#33719;&#24471;&#38145;&#25805;&#20316;&#25968;&#25454;&#24211;&#12290;&#10;     */&#10;    if (timeout &#62; 0) &#123;&#10;        // busy handler&#35774;&#32622;&#20026;FMDBDatabaseBusyHandler&#20989;&#25968;&#10;        sqlite3_busy_handler(_db, &#38;FMDBDatabaseBusyHandler, (__bridge void *)(self));&#10;    &#125;&#10;    else &#123;&#10;        // turn it off otherwise&#10;        // &#20851;&#38381;busy handler&#10;        sqlite3_busy_handler(_db, nil, nil);&#10;    &#125;&#10;&#125;&#10;&#10;// &#36825;&#23601;&#26159;&#22238;&#35843;&#20989;&#25968;&#10;static int FMDBDatabaseBusyHandler(void *f, int count) &#123;&#10;    FMDatabase *self = (__bridge FMDatabase*)f;&#10;    &#10;    // &#22914;&#26524;&#26159;&#31532;&#19968;&#27425;&#35843;&#29992;&#65292;&#35843;&#29992;[+ timeIntervalSinceReferenceDate]&#26041;&#27861;&#65292;&#33719;&#21462;&#24403;&#21069;&#26102;&#38388;&#19982;2001&#24180;1&#26376;1&#26085;00:00:00 UTC&#30340;&#26102;&#38388;&#38388;&#38548;&#65292;&#24182;&#36171;&#20540;&#32473;startBusyRetryTime&#10;    if (count == 0) &#123;&#10;        self-&#62;_startBusyRetryTime = [NSDate timeIntervalSinceReferenceDate];&#10;        // &#36820;&#22238;1&#65292;&#21017;&#23558;&#19981;&#26029;&#23581;&#35797;&#25805;&#20316;&#25968;&#25454;&#24211;&#10;        return 1;&#10;    &#125;&#10;    // &#35745;&#31639;&#24403;&#21069;&#26102;&#38388;&#19982;2001&#24180;1&#26376;1&#26085;00:00:00 UTC&#30340;&#26102;&#38388;&#38388;&#38548;&#21644;startBusyRetryTime&#30340;&#38388;&#38548;&#10;    NSTimeInterval delta = [NSDate timeIntervalSinceReferenceDate] - (self-&#62;_startBusyRetryTime);&#10;    // &#22914;&#26524;&#38388;&#38548;&#26102;&#38388;&#23567;&#20110;&#26368;&#22823;&#30340;&#37325;&#35797;&#38388;&#38548;&#26102;&#38388;&#10;    if (delta &#60; [self maxBusyRetryTimeInterval]) &#123;&#10;        // &#20135;&#29983;&#19968;&#20010;&#20174;50-99&#30340;&#38543;&#26426;&#25972;&#25968;&#20316;&#20026;&#38656;&#35201;&#25346;&#36215;&#27627;&#31186;&#26102;&#38388;&#10;        int requestedSleepInMillseconds = (int) arc4random_uniform(50) + 50;&#10;        // &#35843;&#29992;sqlite3_sleep&#36820;&#22238;&#23454;&#38469;&#25346;&#36215;&#27627;&#31186;&#26102;&#38388;&#65292;&#22914;&#26524;&#19981;&#19968;&#33268;&#65292;&#21487;&#33021;&#26159;&#22240;&#20026;SQLite&#26500;&#24314;&#26102;&#27809;&#26377;&#23558;HAVE_USLEEP&#35774;&#32622;&#20026;1&#10;        int actualSleepInMilliseconds = sqlite3_sleep(requestedSleepInMillseconds);&#10;        if (actualSleepInMilliseconds != requestedSleepInMillseconds) &#123;&#10;            NSLog(@&#34;WARNING: Requested sleep of %i milliseconds, but SQLite returned %i. Maybe SQLite wasn&#39;t built with HAVE_USLEEP=1?&#34;, requestedSleepInMillseconds, actualSleepInMilliseconds);&#10;        &#125;&#10;        return 1;&#10;    &#125;&#10;    &#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (![db open]) &#123;&#10;&#9;// do somthing        &#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u5355_u4E2A_u67E5_u8BE2SQL_u8BED_u53E5"><a href="#u6267_u884C_u5355_u4E2A_u67E5_u8BE2SQL_u8BED_u53E5" class="headerlink" title="执行单个查询SQL语句"></a>执行单个查询SQL语句</h4><p>主要执行的是<code>(FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code>方法，<code>sql</code>是执行SELECT语句，<code>dictionaryArgs</code>是对应于<code>sql</code>语句里<code>？</code>的<code>key</code>和<code>value</code>，在将<code>sql</code>语句转换成<code>prepared</code>语句时，这里先从缓存中获取，没有的话再去调用<code>sqlite3_prepare_v2</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123;&#10;    // &#26816;&#26597;&#25968;&#25454;&#24211;&#26159;&#21542;&#23384;&#22312;&#10;    if (![self databaseExists]) &#123;&#10;        return 0x00;&#10;    &#125;&#10;    // &#26816;&#26597;&#26159;&#21542;&#27491;&#22312;&#25191;&#34892;&#25805;&#20316;&#10;    if (_isExecutingStatement) &#123;&#10;        [self warnInUse];&#10;        return 0x00;&#10;    &#125;&#10;    &#10;    _isExecutingStatement = YES;&#10;    &#10;    int rc                  = 0x00;&#10;    sqlite3_stmt *pStmt     = 0x00;&#10;    FMStatement *statement  = 0x00;&#10;    FMResultSet *rs         = 0x00;&#10;    &#10;    if (_traceExecution &#38;&#38; sql) &#123;&#10;        NSLog(@&#34;%@ executeQuery: %@&#34;, self, sql);&#10;    &#125;&#10;    // &#23558;sql&#35821;&#21477;&#36716;&#25442;&#25104;prepared&#35821;&#21477;&#10;    // &#30001;&#20110;&#20351;&#29992;sqlite3_prepare_v2&#26469;&#29983;&#25104;sql&#23545;&#24212;&#30340;prepared&#35821;&#21477;&#20195;&#20215;&#24456;&#22823;&#10;    // &#25152;&#20197;&#20351;&#29992;&#32531;&#23384;&#26426;&#21046;&#26469;&#20943;&#23569;sqlite3_prepare_v2&#30340;&#20351;&#29992;&#10;    if (_shouldCacheStatements) &#123;&#10;        // &#26681;&#25454;sql&#33719;&#21462;&#21040;&#32531;&#23384;&#20013;&#30340;prepared&#35821;&#21477;&#10;        statement = [self cachedStatementForQuery:sql];&#10;        pStmt = statement ? [statement statement] : 0x00;&#10;        // &#37325;&#32622;prepared&#35821;&#21477;&#10;        [statement reset];&#10;    &#125;&#10;    // &#22914;&#26524;&#32531;&#23384;&#20013;&#27809;&#26377;sql&#23545;&#24212;&#30340;prepared&#35821;&#21477;&#65292;&#37027;&#20040;&#38656;&#35201;&#29992;sqlite3_prepare_v2&#29983;&#25104;&#23545;&#24212;&#30340;prepared&#35821;&#21477;&#10;    if (!pStmt) &#123;&#10;        &#10;        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &#38;pStmt, 0);&#10;        &#10;        // &#22914;&#26524;&#29983;&#25104;&#22833;&#36133;&#65292;&#21017;&#25171;&#21360;&#38169;&#35823;&#26085;&#24535;&#10;        if (SQLITE_OK != rc) &#123;&#10;            if (_logsErrors) &#123;&#10;                NSLog(@&#34;DB Error: %d \&#34;%@\&#34;&#34;, [self lastErrorCode], [self lastErrorMessage]);&#10;                NSLog(@&#34;DB Query: %@&#34;, sql);&#10;                NSLog(@&#34;DB Path: %@&#34;, _databasePath);&#10;            &#125;&#10;            &#10;            if (_crashOnErrors) &#123;&#10;                NSAssert(false, @&#34;DB Error: %d \&#34;%@\&#34;&#34;, [self lastErrorCode], [self lastErrorMessage]);&#10;                // &#20572;&#27490;&#31243;&#24207;&#10;                abort();&#10;            &#125;&#10;            // &#37322;&#25918;&#25152;&#26377;&#20869;&#37096;&#36164;&#28304;&#21644;FMStatement&#10;            sqlite3_finalize(pStmt);&#10;            _isExecutingStatement = NO;&#10;            return nil;&#10;        &#125;&#10;    &#125;&#10;    &#10;    id obj;&#10;    int idx = 0;&#10;    // sqlite3_bind_parameter_count &#36820;&#22238;SQL&#35821;&#21477;&#21442;&#25968;&#30340;&#25968;&#37327;&#10;    int queryCount = sqlite3_bind_parameter_count(pStmt); // pointed out by Dominic Yu (thanks!)&#10;    &#10;    // If dictionaryArgs is passed in, that means we are using sqlite&#39;s named parameter support&#10;    if (dictionaryArgs) &#123;&#10;        &#10;        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &#123;&#10;            &#10;            // Prefix the key with a colon.&#10;            NSString *parameterName = [[NSString alloc] initWithFormat:@&#34;:%@&#34;, dictionaryKey];&#10;            &#10;            if (_traceExecution) &#123;&#10;                NSLog(@&#34;%@ = %@&#34;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);&#10;            &#125;&#10;            &#10;            // Get the index for the parameter name.&#10;            // &#36890;&#36807;&#20256;&#20837;&#21442;&#25968;&#21517;&#26469;&#33719;&#21462;&#35813;&#21442;&#25968;&#30340;&#32034;&#24341;&#10;            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);&#10;            &#10;            FMDBRelease(parameterName);&#10;            // &#22914;&#26524;&#32034;&#24341;&#22823;&#20110;0&#10;            if (namedIdx &#62; 0) &#123;&#10;                // Standard binding from here.&#10;                // &#22312;prepared&#35821;&#21477;&#37324;&#23558;&#20540;&#32465;&#23450;&#21040;&#32034;&#24341;&#20301;&#32622;&#10;                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];&#10;                // increment the binding count, so our check below works out&#10;                // &#32465;&#23450;&#25968;&#37327;&#21152;&#19968;&#10;                idx++;&#10;            &#125;&#10;            else &#123;&#10;                NSLog(@&#34;Could not find index for %@&#34;, dictionaryKey);&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    else &#123;&#10;        &#10;        while (idx &#60; queryCount) &#123;&#10;            // &#24403;&#35843;&#29992;&#19979;&#38754;&#19977;&#20010;&#26041;&#27861;&#26102;&#10;            // - (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...&#10;            // - (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments&#10;            // - (FMResultSet *)executeQuery:(NSString *)sql values:(NSArray *)values error:(NSError * __autoreleasing *)error&#10;            // &#20540;&#26159;&#25918;&#22312;NSArray&#37324;&#38754;&#65292;&#24490;&#29615;&#21462;&#20986;&#26469;&#32465;&#23450;&#10;            if (arrayArgs &#38;&#38; idx &#60; (int)[arrayArgs count]) &#123;&#10;                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];&#10;            &#125;&#10;            // &#24403;&#35843;&#29992;&#19979;&#38754;&#20004;&#20010;&#26041;&#27861;&#26102;&#10;            // - (FMResultSet *)executeQuery:(NSString*)sql, ...&#10;            // - (FMResultSet *)executeQuery:(NSString*)sql withVAList:(va_list)args&#10;            // &#20540;&#26159;&#25918;&#22312;va_list&#37324;&#38754;&#65292;&#24490;&#29615;&#21462;&#20986;&#26469;&#32465;&#23450;&#10;            else if (args) &#123;&#10;                obj = va_arg(args, id);&#10;            &#125;&#10;            else &#123;&#10;                //We ran out of arguments&#10;                break;&#10;            &#125;&#10;            &#10;            if (_traceExecution) &#123;&#10;                if ([obj isKindOfClass:[NSData class]]) &#123;&#10;                    NSLog(@&#34;data: %ld bytes&#34;, (unsigned long)[(NSData*)obj length]);&#10;                &#125;&#10;                else &#123;&#10;                    NSLog(@&#34;obj: %@&#34;, obj);&#10;                &#125;&#10;            &#125;&#10;            &#10;            idx++;&#10;            // &#32465;&#23450;&#21442;&#25968;&#10;            [self bindObject:obj toColumn:idx inStatement:pStmt];&#10;        &#125;&#10;    &#125;&#10;    // &#22914;&#26524;&#32465;&#23450;&#25968;&#37327;&#21644;&#21442;&#25968;&#25968;&#37327;&#19981;&#19968;&#33268;&#65292;&#25171;&#21360;&#38169;&#35823;&#65292;&#24182;&#37322;&#25918;&#36164;&#28304;&#10;    if (idx != queryCount) &#123;&#10;        NSLog(@&#34;Error: the bind count is not correct for the # of variables (executeQuery)&#34;);&#10;        sqlite3_finalize(pStmt);&#10;        _isExecutingStatement = NO;&#10;        return nil;&#10;    &#125;&#10;    &#10;    FMDBRetain(statement); // to balance the release below&#10;    &#10;    // &#22914;&#26524;statement&#19981;&#20026;&#31354;&#65292;&#21017;&#32531;&#23384;&#10;    if (!statement) &#123;&#10;        statement = [[FMStatement alloc] init];&#10;        [statement setStatement:pStmt];&#10;        &#10;        if (_shouldCacheStatements &#38;&#38; sql) &#123;&#10;            // &#20197;sql&#20316;&#20026;key&#26469;&#32531;&#23384;statement&#10;            [self setCachedStatement:statement forQuery:sql];&#10;        &#125;&#10;    &#125;&#10;    &#10;    // the statement gets closed in rs&#39;s dealloc or [rs close];&#10;    // &#26681;&#25454;statement&#21644;FMDataBase&#23545;&#35937;&#26469;&#21021;&#22987;&#21270;FMResultSet&#23545;&#35937;&#10;    rs = [FMResultSet resultSetWithStatement:statement usingParentDatabase:self];&#10;    [rs setQuery:sql];&#10;    &#10;    // &#23558;FMResultSet&#23545;&#35937;&#21152;&#21040;_openResultSets&#37324;&#10;    NSValue *openResultSet = [NSValue valueWithNonretainedObject:rs];&#10;    [_openResultSets addObject:openResultSet];&#10;    // useCount+1&#10;    [statement setUseCount:[statement useCount] + 1];&#10;    &#10;    FMDBRelease(statement);&#10;    // &#35774;&#32622;_isExecutingStatement&#25805;&#20316;&#32467;&#26463;&#10;    _isExecutingStatement = NO;&#10;    &#10;    return rs;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs = [newDb executeQuery:@&#34;select rowid,* from test where a = ?&#34;, @&#34;hi&#39;&#34;];&#10;&#10;rs = [db executeQueryWithFormat:@&#34;select * from t5 where a = %s and a = %@ and b = %d&#34;, &#34;text&#34;, @&#34;text&#34;, 42];&#10;&#10;rs = [db executeQuery:@&#34;select * from testOneHundredTwelvePointTwo where b &#62; ?&#34; withArgumentsInArray:[NSArray arrayWithObject:[NSNumber numberWithInteger:1]]];&#10;&#10;rs = [db executeQuery:@&#34;select * from namedparamcounttest where a = :a&#34; withParameterDictionary:dictionaryArgs];</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u5355_u4E2A_u66F4_u65B0SQL_u8BED_u53E5"><a href="#u6267_u884C_u5355_u4E2A_u66F4_u65B0SQL_u8BED_u53E5" class="headerlink" title="执行单个更新SQL语句"></a>执行单个更新SQL语句</h4><p><code>- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code>是主要函数，但是里面大部分处理和<code>- executeQuery: withArgumentsInArray: orDictionary: orVAList:</code>处理类似，不同处我已经注释说明，可以直接看注释部分代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123;&#10;    &#10;    if (![self databaseExists]) &#123;&#10;        return NO;&#10;    &#125;&#10;    &#10;    if (_isExecutingStatement) &#123;&#10;        [self warnInUse];&#10;        return NO;&#10;    &#125;&#10;    &#10;    _isExecutingStatement = YES;&#10;    &#10;    int rc                   = 0x00;&#10;    sqlite3_stmt *pStmt      = 0x00;&#10;    FMStatement *cachedStmt  = 0x00;&#10;    &#10;    if (_traceExecution &#38;&#38; sql) &#123;&#10;        NSLog(@&#34;%@ executeUpdate: %@&#34;, self, sql);&#10;    &#125;&#10;    &#10;    if (_shouldCacheStatements) &#123;&#10;        cachedStmt = [self cachedStatementForQuery:sql];&#10;        pStmt = cachedStmt ? [cachedStmt statement] : 0x00;&#10;        [cachedStmt reset];&#10;    &#125;&#10;    &#10;    if (!pStmt) &#123;&#10;        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &#38;pStmt, 0);&#10;        &#10;        if (SQLITE_OK != rc) &#123;&#10;            if (_logsErrors) &#123;&#10;                NSLog(@&#34;DB Error: %d \&#34;%@\&#34;&#34;, [self lastErrorCode], [self lastErrorMessage]);&#10;                NSLog(@&#34;DB Query: %@&#34;, sql);&#10;                NSLog(@&#34;DB Path: %@&#34;, _databasePath);&#10;            &#125;&#10;            &#10;            if (_crashOnErrors) &#123;&#10;                NSAssert(false, @&#34;DB Error: %d \&#34;%@\&#34;&#34;, [self lastErrorCode], [self lastErrorMessage]);&#10;                abort();&#10;            &#125;&#10;            &#10;            if (outErr) &#123;&#10;                *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];&#10;            &#125;&#10;            &#10;            sqlite3_finalize(pStmt);&#10;            &#10;            _isExecutingStatement = NO;&#10;            return NO;&#10;        &#125;&#10;    &#125;&#10;    &#10;    id obj;&#10;    int idx = 0;&#10;    int queryCount = sqlite3_bind_parameter_count(pStmt);&#10;    &#10;    // If dictionaryArgs is passed in, that means we are using sqlite&#39;s named parameter support&#10;    if (dictionaryArgs) &#123;&#10;        &#10;        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &#123;&#10;            &#10;            // Prefix the key with a colon.&#10;            NSString *parameterName = [[NSString alloc] initWithFormat:@&#34;:%@&#34;, dictionaryKey];&#10;            &#10;            if (_traceExecution) &#123;&#10;                NSLog(@&#34;%@ = %@&#34;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);&#10;            &#125;&#10;            // Get the index for the parameter name.&#10;            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);&#10;            &#10;            FMDBRelease(parameterName);&#10;            &#10;            if (namedIdx &#62; 0) &#123;&#10;                // Standard binding from here.&#10;                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];&#10;                &#10;                // increment the binding count, so our check below works out&#10;                idx++;&#10;            &#125;&#10;            else &#123;&#10;                // &#30001;&#20110;&#22810;&#20102;outErr&#65292;&#25152;&#20197;&#32465;&#23450;&#26102;&#20986;&#38169;&#38656;&#35201;&#23558;error&#25243;&#20986;&#10;                NSString *message = [NSString stringWithFormat:@&#34;Could not find index for %@&#34;, dictionaryKey];&#10;                &#10;                if (_logsErrors) &#123;&#10;                    NSLog(@&#34;%@&#34;, message);&#10;                &#125;&#10;                if (outErr) &#123;&#10;                    *outErr = [self errorWithMessage:message];&#10;                &#125;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    else &#123;&#10;        &#10;        while (idx &#60; queryCount) &#123;&#10;            &#10;            if (arrayArgs &#38;&#38; idx &#60; (int)[arrayArgs count]) &#123;&#10;                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];&#10;            &#125;&#10;            else if (args) &#123;&#10;                obj = va_arg(args, id);&#10;            &#125;&#10;            else &#123;&#10;                //We ran out of arguments&#10;                break;&#10;            &#125;&#10;            &#10;            if (_traceExecution) &#123;&#10;                if ([obj isKindOfClass:[NSData class]]) &#123;&#10;                    NSLog(@&#34;data: %ld bytes&#34;, (unsigned long)[(NSData*)obj length]);&#10;                &#125;&#10;                else &#123;&#10;                    NSLog(@&#34;obj: %@&#34;, obj);&#10;                &#125;&#10;            &#125;&#10;            &#10;            idx++;&#10;            &#10;            [self bindObject:obj toColumn:idx inStatement:pStmt];&#10;        &#125;&#10;    &#125;&#10;    &#10;    &#10;    if (idx != queryCount) &#123;&#10;        // &#21516;&#26679;&#20063;&#26159;&#32452;&#35013;error&#25243;&#20986;&#10;        NSString *message = [NSString stringWithFormat:@&#34;Error: the bind count (%d) is not correct for the # of variables in the query (%d) (%@) (executeUpdate)&#34;, idx, queryCount, sql];&#10;        if (_logsErrors) &#123;&#10;            NSLog(@&#34;%@&#34;, message);&#10;        &#125;&#10;        if (outErr) &#123;&#10;            *outErr = [self errorWithMessage:message];&#10;        &#125;&#10;        &#10;        sqlite3_finalize(pStmt);&#10;        _isExecutingStatement = NO;&#10;        return NO;&#10;    &#125;&#10;    &#10;    /* Call sqlite3_step() to run the virtual machine. Since the SQL being&#10;     ** executed is not a SELECT statement, we assume no data will be returned.&#10;     */&#10;    // sqlite3_prepare&#20989;&#25968;&#23558;SQL&#21629;&#20196;&#23383;&#31526;&#20018;&#35299;&#26512;&#24182;&#36716;&#25442;&#20026;&#19968;&#31995;&#21015;&#30340;&#21629;&#20196;&#23383;&#33410;&#30721;&#65292;&#36825;&#20123;&#23383;&#33410;&#30721;&#26368;&#32456;&#34987;&#20256;&#36865;&#21040;SQlite3&#30340;&#34394;&#25311;&#25968;&#25454;&#24211;&#24341;&#25806;&#65288;VDBE: Virtual Database Engine&#65289;&#20013;&#25191;&#34892;&#65292;&#23436;&#25104;&#36825;&#39033;&#24037;&#20316;&#30340;&#26159;sqlite3_step&#20989;&#25968;&#12290;&#27604;&#22914;&#19968;&#20010;SELECT&#26597;&#35810;&#25805;&#20316;&#65292;sqlite3_step&#20989;&#25968;&#30340;&#27599;&#27425;&#35843;&#29992;&#37117;&#20250;&#36820;&#22238;&#32467;&#26524;&#38598;&#20013;&#30340;&#20854;&#20013;&#19968;&#34892;&#65292;&#30452;&#21040;&#20877;&#27809;&#26377;&#26377;&#25928;&#25968;&#25454;&#34892;&#20102;&#12290;&#27599;&#27425;&#35843;&#29992;sqlite3_step&#20989;&#25968;&#22914;&#26524;&#36820;&#22238;SQLITE_ROW&#65292;&#20195;&#34920;&#33719;&#24471;&#20102;&#26377;&#25928;&#25968;&#25454;&#34892;&#65292;&#21487;&#20197;&#36890;&#36807;sqlite3_column&#20989;&#25968;&#25552;&#21462;&#26576;&#21015;&#30340;&#20540;&#12290;&#22914;&#26524;&#35843;&#29992;sqlite3_step&#20989;&#25968;&#36820;&#22238;SQLITE_DONE&#65292;&#21017;&#20195;&#34920;prepared&#35821;&#21477;&#24050;&#32463;&#25191;&#34892;&#21040;&#32456;&#28857;&#20102;&#65292;&#27809;&#26377;&#26377;&#25928;&#25968;&#25454;&#20102;&#12290;&#24456;&#22810;&#21629;&#20196;&#31532;&#19968;&#27425;&#35843;&#29992;sqlite3_step&#20989;&#25968;&#23601;&#20250;&#36820;&#22238;SQLITE_DONE&#65292;&#22240;&#20026;&#36825;&#20123;SQL&#21629;&#20196;&#19981;&#20250;&#36820;&#22238;&#25968;&#25454;&#12290;&#23545;&#20110;INSERT&#65292;UPDATE&#65292;DELETE&#21629;&#20196;&#65292;&#20250;&#36820;&#22238;&#23427;&#20204;&#25152;&#20462;&#25913;&#30340;&#34892;&#21495;&#8212;&#8212;&#19968;&#20010;&#21333;&#34892;&#21333;&#21015;&#30340;&#20540;&#12290;&#10;    /**&#10;     SQLITE_BUSY &#25968;&#25454;&#24211;&#25991;&#20214;&#26377;&#38145;&#10;     SQLITE_LOCKED &#25968;&#25454;&#24211;&#20013;&#30340;&#26576;&#24352;&#34920;&#26377;&#38145;&#10;     SQLITE_DONE sqlite3_step()&#25191;&#34892;&#23436;&#27605;&#10;     SQLITE_ROW sqlite3_step()&#33719;&#21462;&#21040;&#19979;&#19968;&#34892;&#25968;&#25454;&#10;     SQLITE_ERROR &#19968;&#33324;&#29992;&#20110;&#27809;&#26377;&#29305;&#21035;&#25351;&#23450;&#38169;&#35823;&#30721;&#30340;&#38169;&#35823;&#65292;&#23601;&#26159;&#35828;&#20989;&#25968;&#22312;&#25191;&#34892;&#36807;&#31243;&#20013;&#21457;&#29983;&#20102;&#38169;&#35823;&#65292;&#20294;&#26080;&#27861;&#30693;&#36947;&#38169;&#35823;&#21457;&#29983;&#30340;&#21407;&#22240;&#12290;&#10;     SQLITE_MISUSE &#27809;&#26377;&#27491;&#30830;&#20351;&#29992;SQLite&#25509;&#21475;&#65292;&#27604;&#22914;&#19968;&#26465;&#35821;&#21477;&#22312;sqlite3_step&#20989;&#25968;&#25191;&#34892;&#20043;&#21518;&#65292;&#27809;&#26377;&#34987;&#37325;&#32622;&#20043;&#21069;&#65292;&#20877;&#27425;&#32473;&#20854;&#32465;&#23450;&#21442;&#25968;&#65292;&#36825;&#26102;bind&#20989;&#25968;&#23601;&#20250;&#36820;&#22238;SQLITE_MISUSE&#12290;&#10;     **/&#10;    rc      = sqlite3_step(pStmt);&#10;    &#10;    if (SQLITE_DONE == rc) &#123;&#10;        // all is well, let&#39;s return.&#10;    &#125;&#10;    // sql&#25805;&#20316;&#34987;sqlite3_interrupt()&#20989;&#25968;&#32456;&#27490;&#10;    else if (SQLITE_INTERRUPT == rc) &#123;&#10;        if (_logsErrors) &#123;&#10;            NSLog(@&#34;Error calling sqlite3_step. Query was interrupted (%d: %s) SQLITE_INTERRUPT&#34;, rc, sqlite3_errmsg(_db));&#10;            NSLog(@&#34;DB Query: %@&#34;, sql);&#10;        &#125;&#10;    &#125;&#10;    else if (rc == SQLITE_ROW) &#123;&#10;        NSString *message = [NSString stringWithFormat:@&#34;A executeUpdate is being called with a query string &#39;%@&#39;&#34;, sql];&#10;        if (_logsErrors) &#123;&#10;            NSLog(@&#34;%@&#34;, message);&#10;            NSLog(@&#34;DB Query: %@&#34;, sql);&#10;        &#125;&#10;        if (outErr) &#123;&#10;            *outErr = [self errorWithMessage:message];&#10;        &#125;&#10;    &#125;&#10;    else &#123;&#10;        if (outErr) &#123;&#10;            *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];&#10;        &#125;&#10;        &#10;        if (SQLITE_ERROR == rc) &#123;&#10;            if (_logsErrors) &#123;&#10;                NSLog(@&#34;Error calling sqlite3_step (%d: %s) SQLITE_ERROR&#34;, rc, sqlite3_errmsg(_db));&#10;                NSLog(@&#34;DB Query: %@&#34;, sql);&#10;            &#125;&#10;        &#125;&#10;        else if (SQLITE_MISUSE == rc) &#123;&#10;            // uh oh.&#10;            if (_logsErrors) &#123;&#10;                NSLog(@&#34;Error calling sqlite3_step (%d: %s) SQLITE_MISUSE&#34;, rc, sqlite3_errmsg(_db));&#10;                NSLog(@&#34;DB Query: %@&#34;, sql);&#10;            &#125;&#10;        &#125;&#10;        else &#123;&#10;            // wtf?&#10;            if (_logsErrors) &#123;&#10;                NSLog(@&#34;Unknown error calling sqlite3_step (%d: %s) eu&#34;, rc, sqlite3_errmsg(_db));&#10;                NSLog(@&#34;DB Query: %@&#34;, sql);&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    &#10;    if (_shouldCacheStatements &#38;&#38; !cachedStmt) &#123;&#10;        cachedStmt = [[FMStatement alloc] init];&#10;        &#10;        [cachedStmt setStatement:pStmt];&#10;        &#10;        [self setCachedStatement:cachedStmt forQuery:sql];&#10;        &#10;        FMDBRelease(cachedStmt);&#10;    &#125;&#10;    &#10;    int closeErrorCode;&#10;    &#10;    if (cachedStmt) &#123;&#10;        [cachedStmt setUseCount:[cachedStmt useCount] + 1];&#10;        closeErrorCode = sqlite3_reset(pStmt);&#10;    &#125;&#10;    else &#123;&#10;        /* Finalize the virtual machine. This releases all memory and other&#10;         ** resources allocated by the sqlite3_prepare() call above.&#10;         */&#10;        closeErrorCode = sqlite3_finalize(pStmt);&#10;    &#125;&#10;    &#10;    if (closeErrorCode != SQLITE_OK) &#123;&#10;        if (_logsErrors) &#123;&#10;            NSLog(@&#34;Unknown error finalizing or resetting statement (%d: %s)&#34;, closeErrorCode, sqlite3_errmsg(_db));&#10;            NSLog(@&#34;DB Query: %@&#34;, sql);&#10;        &#125;&#10;    &#125;&#10;    &#10;    _isExecutingStatement = NO;&#10;    return (rc == SQLITE_DONE || rc == SQLITE_OK);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[db executeUpdate:@&#34;insert into t5 values (?, ?, ?, ?, ?)&#34; withErrorAndBindings:&#38;err, @&#34;text&#34;, [NSNumber numberWithInt:42], @&#34;BLOB&#34;, @&#34;d&#34;, [NSNumber numberWithInt:0]];&#10;&#10;[dbB executeUpdate:@&#34;create table attached (a text)&#34;];&#10;&#10;[dbB executeUpdate:@&#34;insert into attached values (?)&#34;, @&#34;test&#34;];&#10;&#10;[db executeUpdateWithFormat:@&#34;insert into t55 values (%c, %hi, %g)&#34;, &#39;a&#39;, testShort, testFloat];&#10;&#10;[db executeUpdate:@&#34;insert into testOneHundredTwelvePointTwo values (?, ?)&#34; withArgumentsInArray:[NSArray arrayWithObjects:@&#34;one&#34;, [NSNumber numberWithInteger:2], nil]];&#10;&#10;[db executeUpdate:@&#34;insert into namedparamtest values (:a, :b, :c, :d)&#34; withParameterDictionary:dictionaryArgs];</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u591A_u4E2ASQL_u8BED_u53E5"><a href="#u6267_u884C_u591A_u4E2ASQL_u8BED_u53E5" class="headerlink" title="执行多个SQL语句"></a>执行多个SQL语句</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20351;&#29992;executeStatements:&#20989;&#25968;&#21487;&#20197;&#23558;&#22810;&#20010;SQL&#25191;&#34892;&#35821;&#21477;&#20889;&#22312;&#19968;&#20010;&#23383;&#31526;&#20018;&#20013;&#65292;&#24182;&#25191;&#34892;&#10;- (BOOL)executeStatements:(NSString *)sql &#123;&#10;    return [self executeStatements:sql withResultBlock:nil];&#10;&#125;&#10;&#10;- (BOOL)executeStatements:(NSString *)sql withResultBlock:(FMDBExecuteStatementsCallbackBlock)block &#123;&#10;    &#10;    int rc;&#10;    char *errmsg = nil;&#10;    /*&#10;     sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg)&#10;     &#10;     &#35813;&#20363;&#31243;&#25552;&#20379;&#20102;&#19968;&#20010;&#25191;&#34892; SQL &#21629;&#20196;&#30340;&#24555;&#25463;&#26041;&#24335;&#65292;SQL &#21629;&#20196;&#30001; sql &#21442;&#25968;&#25552;&#20379;&#65292;&#21487;&#20197;&#30001;&#22810;&#20010; SQL &#21629;&#20196;&#32452;&#25104;&#12290;&#10;     &#10;     &#22312;&#36825;&#37324;&#65292;&#31532;&#19968;&#20010;&#21442;&#25968; sqlite3 &#26159;&#25171;&#24320;&#30340;&#25968;&#25454;&#24211;&#23545;&#35937;&#65292;sqlite_callback &#26159;&#19968;&#20010;&#22238;&#35843;&#65292;data &#20316;&#20026;&#20854;&#31532;&#19968;&#20010;&#21442;&#25968;&#65292;errmsg &#23558;&#34987;&#36820;&#22238;&#29992;&#26469;&#33719;&#21462;&#31243;&#24207;&#29983;&#25104;&#30340;&#20219;&#20309;&#38169;&#35823;&#12290;&#10;     &#10;     sqlite3_exec() &#31243;&#24207;&#35299;&#26512;&#24182;&#25191;&#34892;&#30001; sql &#21442;&#25968;&#25152;&#32473;&#30340;&#27599;&#20010;&#21629;&#20196;&#65292;&#30452;&#21040;&#23383;&#31526;&#20018;&#32467;&#26463;&#25110;&#32773;&#36935;&#21040;&#38169;&#35823;&#20026;&#27490;&#12290;&#10;     */&#10;    rc = sqlite3_exec([self sqliteHandle], [sql UTF8String], block ? FMDBExecuteBulkSQLCallback : nil, (__bridge void *)(block), &#38;errmsg);&#10;    &#10;    if (errmsg &#38;&#38; [self logsErrors]) &#123;&#10;        NSLog(@&#34;Error inserting batch: %s&#34;, errmsg);&#10;        sqlite3_free(errmsg);&#10;    &#125;&#10;    &#10;    return (rc == SQLITE_OK);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *sql = @&#34;create table messages1 (id integer primary key messageId, x text);&#34;&#10;                 &#34;create table messages2 (id integer primary key messageId, y text);&#34;&#10;&#9;&#9;&#9;&#9; &#34;insert into messages1 (x) values (&#39;X&#39;);&#34;&#10;                 &#34;insert into messages2 (y) values (&#39;Y&#39;);&#34;;&#10;&#10;success = [db executeStatements:sql];&#10;&#10;sql = @&#34;select count(*) as count from messages1;&#34;&#10;       &#34;select count(*) as count from messages2;&#34;;&#10;&#10;success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) &#123;&#10;    // do something&#10;&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="u83B7_u53D6_u6700_u540E_u4E00_u6761_u63D2_u5165_u6570_u636E_u7684RowId"><a href="#u83B7_u53D6_u6700_u540E_u4E00_u6761_u63D2_u5165_u6570_u636E_u7684RowId" class="headerlink" title="获取最后一条插入数据的RowId"></a>获取最后一条插入数据的RowId</h4><p>可以根据这个<code>id</code>拿到该数据，并且向上取数据库数据等操作都可以</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (sqlite_int64)lastInsertRowId &#123;&#10;    // &#22914;&#26524;&#26377;&#27491;&#22312;&#25191;&#34892;&#35821;&#21477;&#65292;&#36820;&#22238;&#10;    if (_isExecutingStatement) &#123;&#10;        [self warnInUse];&#10;        return NO;&#10;    &#125;&#10;    &#10;    _isExecutingStatement = YES;&#10;    // sqlite3_last_insert_rowid &#33719;&#21462;&#25351;&#23450;&#25968;&#25454;&#24211;&#26368;&#21518;&#19968;&#20010;&#25554;&#20837;&#30340;rowid&#10;    sqlite_int64 ret = sqlite3_last_insert_rowid(_db);&#10;    &#10;    _isExecutingStatement = NO;&#10;    &#10;    return ret;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u7EDF_u8BA1_u4E0A_u4E00_u6B21SQL_u8BED_u53E5_u53D7_u5F71_u54CD_u7684_u884C_u6570"><a href="#u7EDF_u8BA1_u4E0A_u4E00_u6B21SQL_u8BED_u53E5_u53D7_u5F71_u54CD_u7684_u884C_u6570" class="headerlink" title="统计上一次SQL语句受影响的行数"></a>统计上一次SQL语句受影响的行数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (int)changes &#123;&#10;    if (_isExecutingStatement) &#123;&#10;        [self warnInUse];&#10;        return 0;&#10;    &#125;&#10;    &#10;    _isExecutingStatement = YES;&#10;    &#10;    int ret = sqlite3_changes(_db);&#10;    &#10;    _isExecutingStatement = NO;&#10;    &#10;    return ret;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exclusive_u4E8B_u52A1_u548Cdeferred_u4E8B_u52A1"><a href="#exclusive_u4E8B_u52A1_u548Cdeferred_u4E8B_u52A1" class="headerlink" title="exclusive事务和deferred事务"></a>exclusive事务和deferred事务</h4><p>事务可以从<code>DEFERRED</code>，<code>IMMEDIATE</code>或者<code>EXCLUSIVE</code>，一个事务的类型在<code>BEGIN</code>命令中指定：<code>BEGIN [ DEFERRED | IMMEDIATE | EXCLUSIVE ] TRANSACTION</code></p>
<p>一个<code>deferred</code>事务不获取任何锁，直到它需要锁的时候，而且<code>BEGIN</code>语句本身也不会做什么事情——它开始于<code>UNLOCK</code>状态；默认情况下是这样的。如果仅仅用<code>BEGIN</code>开始一个事务，那么事务就是<code>DEFERRED</code>的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取<code>SHARED LOCK</code>；同样，当进行第一次写操作时，它会获取<code>RESERVED LOCK</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#24320;&#22987;&#24310;&#36831;&#20107;&#21153;&#10;- (BOOL)beginDeferredTransaction &#123;&#10;    &#10;    BOOL b = [self executeUpdate:@&#34;begin deferred transaction&#34;];&#10;    if (b) &#123;&#10;        _inTransaction = YES;&#10;    &#125;&#10;    &#10;    return b;&#10;&#125;&#10;&#10;//Exclusive&#20107;&#21153;&#20250;&#35797;&#30528;&#33719;&#21462;&#23545;&#25968;&#25454;&#24211;&#30340;EXCLUSIVE&#38145;&#12290;&#36825;&#19982;IMMEDIATE&#31867;&#20284;&#65292;&#20294;&#26159;&#19968;&#26086;&#25104;&#21151;&#65292;EXCLUSIVE&#20107;&#21153;&#20445;&#35777;&#27809;&#26377;&#20854;&#23427;&#30340;&#36830;&#25509;&#65292;&#25152;&#20197;&#23601;&#21487;&#23545;&#25968;&#25454;&#24211;&#36827;&#34892;&#35835;&#20889;&#25805;&#20316;&#20102;&#12290;&#10;&#10;// &#24320;&#22987;&#20107;&#21153;&#10;- (BOOL)beginTransaction &#123;&#10;    &#10;    BOOL b = [self executeUpdate:@&#34;begin exclusive transaction&#34;];&#10;    if (b) &#123;&#10;        _inTransaction = YES;&#10;    &#125;&#10;    &#10;    return b;&#10;&#125;&#10;&#10;// &#22238;&#28378;&#20107;&#21153;&#10;- (BOOL)rollback &#123;&#10;    BOOL b = [self executeUpdate:@&#34;rollback transaction&#34;];&#10;    &#10;    if (b) &#123;&#10;        _inTransaction = NO;&#10;    &#125;&#10;    &#10;    return b;&#10;&#125;&#10;// &#25552;&#20132;&#20107;&#21153;&#10;- (BOOL)commit &#123;&#10;    BOOL b =  [self executeUpdate:@&#34;commit transaction&#34;];&#10;    &#10;    if (b) &#123;&#10;        _inTransaction = NO;&#10;    &#125;&#10;    &#10;    return b;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6570_u636E_u5E93_u52A0_u5BC6_u53CA_u91CD_u7F6E"><a href="#u6570_u636E_u5E93_u52A0_u5BC6_u53CA_u91CD_u7F6E" class="headerlink" title="数据库加密及重置"></a>数据库加密及重置</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)setKeyWithData:(NSData *)keyData &#123;&#10;// SQLITE_HAS_CODEC &#29992;&#26469;&#30830;&#23450;&#26159;&#21542;&#25903;&#25345;&#21152;&#23494;&#10;#ifdef SQLITE_HAS_CODEC&#10;    if (!keyData) &#123;&#10;        return NO;&#10;    &#125;&#10;    &#10;    // int sqlite3_key( sqlite3 *db, const void *pKey, int nKey)&#10;    // db&#26159;&#25351;&#23450;&#30340;&#25968;&#25454;&#24211;&#65292;pKey&#26159;&#23494;&#38053;&#65292;nKey&#26159;&#23494;&#38053;&#30340;&#38271;&#24230;&#10;    // &#20363;&#22914;&#65306;sqlite3_key(_db, &#34;gongcheng&#34;, 9);&#10;    int rc = sqlite3_key(_db, [keyData bytes], (int)[keyData length]);&#10;    &#10;    return (rc == SQLITE_OK);&#10;#else&#10;#pragma unused(keyData)&#10;    return NO;&#10;#endif&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)rekeyWithData:(NSData *)keyData &#123;&#10;#ifdef SQLITE_HAS_CODEC&#10;    if (!keyData) &#123;&#10;        return NO;&#10;    &#125;&#10;    &#10;    // int sqlite3_rekey( sqlite3 *db, const void *pKey, int nKey)&#10;    // db&#26159;&#25351;&#23450;&#30340;&#25968;&#25454;&#24211;&#65292;pKey&#26159;&#23494;&#38053;&#65292;nKey&#26159;&#23494;&#38053;&#30340;&#38271;&#24230;&#10;    // &#20363;&#22914;&#65306;sqlite3_rekey(_db, &#34;yzy&#34;, 3);&#10;    int rc = sqlite3_rekey(_db, [keyData bytes], (int)[keyData length]);&#10;    &#10;    if (rc != SQLITE_OK) &#123;&#10;        NSLog(@&#34;error on rekey: %d&#34;, rc);&#10;        NSLog(@&#34;%@&#34;, [self lastErrorMessage]);&#10;    &#125;&#10;    &#10;    return (rc == SQLITE_OK);&#10;#else&#10;#pragma unused(keyData)&#10;    return NO;&#10;#endif&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6570_u636E_u5E93_u56DE_u6EDA_u65F6_u8BBE_u7F6E_u56DE_u6EDA_u8282_u70B9"><a href="#u6570_u636E_u5E93_u56DE_u6EDA_u65F6_u8BBE_u7F6E_u56DE_u6EDA_u8282_u70B9" class="headerlink" title="数据库回滚时设置回滚节点"></a>数据库回滚时设置回滚节点</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSError*)inSavePoint:(void (^)(BOOL *rollback))block &#123;&#10;#if SQLITE_VERSION_NUMBER &#62;= 3007000&#10;    static unsigned long savePointIdx = 0;&#10;    // &#35774;&#32622;&#33410;&#28857;&#21517;&#31216;&#10;    NSString *name = [NSString stringWithFormat:@&#34;dbSavePoint%ld&#34;, savePointIdx++];&#10;    // &#40664;&#35748;&#19981;&#22238;&#28378;&#10;    BOOL shouldRollback = NO;&#10;    &#10;    NSError *err = 0x00;&#10;    // &#20808;&#23545;&#24403;&#21069;&#29366;&#24577;&#36827;&#34892;&#20445;&#23384;&#10;    if (![self startSavePointWithName:name error:&#38;err]) &#123;&#10;        return err;&#10;    &#125;&#10;    &#10;    if (block) &#123;&#10;        block(&#38;shouldRollback);&#10;    &#125;&#10;    // &#22914;&#26524;&#38656;&#35201;&#22238;&#28378;&#65292;&#21017;&#22238;&#28378;&#24403;&#19978;&#19968;&#20010;&#33410;&#28857;&#10;    if (shouldRollback) &#123;&#10;        // We need to rollback and release this savepoint to remove it&#10;        [self rollbackToSavePointWithName:name error:&#38;err];&#10;    &#125;&#10;    // &#37322;&#25918;&#33410;&#28857;&#10;    [self releaseSavePointWithName:name error:&#38;err];&#10;    &#10;    return err;&#10;#else&#10;    NSString *errorMessage = NSLocalizedString(@&#34;Save point functions require SQLite 3.7&#34;, nil);&#10;    if (self.logsErrors) NSLog(@&#34;%@&#34;, errorMessage);&#10;    return [NSError errorWithDomain:@&#34;FMDatabase&#34; code:0 userInfo:@&#123;NSLocalizedDescriptionKey : errorMessage&#125;];&#10;#endif&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5173_u95ED_u6570_u636E_u5E93_u8FDE_u63A5"><a href="#u5173_u95ED_u6570_u636E_u5E93_u8FDE_u63A5" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)close &#123;&#10;    // &#28165;&#38500;&#32531;&#23384;&#30340;prepared&#35821;&#21477;&#10;    [self clearCachedStatements];&#10;    // &#20851;&#38381;&#25152;&#26377;&#25171;&#24320;&#30340;FMResultSet&#23545;&#35937;&#10;    [self closeOpenResultSets];&#10;    &#10;    if (!_db) &#123;&#10;        return YES;&#10;    &#125;&#10;    &#10;    int  rc;&#10;    BOOL retry;&#10;    BOOL triedFinalizingOpenStatements = NO;&#10;    &#10;    do &#123;&#10;        retry   = NO;&#10;        // &#35843;&#29992;sqlite3_close&#23581;&#35797;&#20851;&#38381;&#25968;&#25454;&#24211;&#10;        rc      = sqlite3_close(_db);&#10;        // &#24403;&#36820;&#22238;&#32467;&#26524;&#26159;&#25968;&#25454;&#24211;&#32321;&#24537;&#25110;&#32773;&#34987;&#38145;&#20303;&#20102;&#10;        if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &#123;&#10;            if (!triedFinalizingOpenStatements) &#123;&#10;                triedFinalizingOpenStatements = YES;&#10;                sqlite3_stmt *pStmt;&#10;                // &#20174;&#20851;&#32852;&#30340;pDb&#25968;&#25454;&#37324;&#38754;&#23545;&#24212;&#30340;prepared&#35821;&#21477;&#24320;&#22987;&#24448;&#19979;&#25214;&#30456;&#24212;&#30340;prepared&#35821;&#21477;&#65292;&#10;                // &#22914;&#26524;pStmt&#26159;NULL&#65292;&#21017;&#20174;pDb&#30340;&#31532;&#19968;&#20010;prepared&#35821;&#21477;&#24320;&#22987;&#25214;&#65292;&#10;                // &#22914;&#26524;&#27809;&#26377;&#25214;&#21040;&#65292;&#21017;&#36820;&#22238;NULL&#10;                while ((pStmt = sqlite3_next_stmt(_db, nil)) !=0) &#123;&#10;                    // &#25214;&#21040;&#20043;&#21518;&#65292;&#37322;&#25918;&#36164;&#28304;&#10;                    NSLog(@&#34;Closing leaked statement&#34;);&#10;                    sqlite3_finalize(pStmt);&#10;                    retry = YES;&#10;                &#125;&#10;            &#125;&#10;        &#125;&#10;        else if (SQLITE_OK != rc) &#123;&#10;            NSLog(@&#34;error closing!: %d&#34;, rc);&#10;        &#125;&#10;    &#125;&#10;    while (retry);&#10;    &#10;    _db = nil;&#10;    return YES;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[newDb close];</span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/23/FMDB-two/" class="prev">PREV</a><a href="/2016/07/05/IM-UI-optimize/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/07/23/FMDB-one/';
var disqus_title = 'FMDB初探（一）';
var disqus_url = 'http://yuzeyang.github.io/2016/07/23/FMDB-one/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>