<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> IM UI性能优化之异步绘制 · 宫城</title><meta name="description" content="IM UI性能优化之异步绘制 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">IM UI性能优化之异步绘制</h1><div class="post-info">2016年7月5日</div><div class="post-content"><p>重构完Socket之后，最近我们也开始针对IM的UI做了优化，这次的优化我们主要是参考了<a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a>对于性能方面的优化，前期我的另一个小伙伴<a href="http://broccoliii.me/" target="_blank" rel="external">西兰花</a>也对<a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a>做了调研，不过这个库理解起来确实要费一番功夫，由于YYkit的核心思路基本上都是学习AsyncDisplayKit的，相信YYkit这个库大家都已经很熟悉了，不过可能还没有看过这个库，那下面我做一个简单的介绍</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/yykit.png" alt=""></p>
<p>YYKit的作者是<a href="http://blog.ibireme.com/" target="_blank" rel="external">郭曜源</a>，YYKit实际上是将它那些单独的iOS组件整合在了一起，类似于集合一样组成功能比较全面的组件，你也可以根据自己业务的需要单独使用其中的某些部分</p>
<h2 id="0x00__u524D_u671F_u51C6_u5907"><a href="#0x00__u524D_u671F_u51C6_u5907" class="headerlink" title="0x00 前期准备"></a>0x00 前期准备</h2><p>我们首先阅读了郭曜源在<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">对界面流畅性方面的见解</a>，里面提到了<code>异步绘制</code>，但是文字表述毕竟是抽象的，然后我们简单看了下他的YYText和YYAsyncLayer组件，看完之后实际上对如何使用他的YYAsyncLayer这个组件来实现异步绘制还是有点模糊的，后来我们直接看他的微博demo，我们逐渐理清了他是如何实现异步绘制以及几个性能优化方面的点</p>
<p>因为YYLabel Async Display里面加了是否异步绘制开关，所以我们直接用这个例子作为对比，首先我们来看下异步绘制的效果，开始的时候我们关闭异步绘制的开关，你会发现FPS瞬间掉到6了，屏幕滚动开始非常卡，但是打开开关之后，滚动时虽然FPS还是会掉到30-40，但是滑动的流畅度比之前要好很多，感觉这异步绘制的效果杠杠的好啊，那我们一定要看看他是怎么做的了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/YYAsyncLayer.gif!500x500" alt=""></p>
<h2 id="0x01__u5206_u6790"><a href="#0x01__u5206_u6790" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><p>其实整一个性能优化关键的点及流程有三个：</p>
<h5 id="1-_u6570_u636E_u6E90_u7684_u5F02_u6B65_u5904_u7406"><a href="#1-_u6570_u636E_u6E90_u7684_u5F02_u6B65_u5904_u7406" class="headerlink" title="1.数据源的异步处理"></a>1.数据源的异步处理</h5><p>当我们获取到数据源的时候，我们需要对数据源进行计算处理，计算出UI绘制所需要的属性比如宽高、颜色等等，而且这些计算要异步去做，否则会卡住主线程，等这些数据源计算完成之后，再去处理绘制，但是如果数据源过大，计算的耗时还是在的，所以会有较长时间的等待时间，此时我们需要考虑加上等待的友好处理</p>
<h5 id="2-_u91C7_u7528_u66F4_u8F7B_u91CF_u7EA7_u7684_u7ED8_u5236"><a href="#2-_u91C7_u7528_u66F4_u8F7B_u91CF_u7EA7_u7684_u7ED8_u5236" class="headerlink" title="2.采用更轻量级的绘制"></a>2.采用更轻量级的绘制</h5><p>在绘制时，对于不需要响应触摸事件的控件，我们应该尽量避免创建UIView对象，取而代之的是使用更为轻量的CALayer，并且对于一个layer包含多个subLayer的情况时，我们可以通过图层预合成的方法，将多个subLayer合成渲染成一张图片，通过上述的处理，不仅能减少CPU在创建UIKit对象的消耗，还能减少GPU在合成和渲染上的消耗，内存的占用也会少很多</p>
<h5 id="3-_u5F02_u6B65_u7ED8_u5236"><a href="#3-_u5F02_u6B65_u7ED8_u5236" class="headerlink" title="3.异步绘制"></a>3.异步绘制</h5><p>我们将使用<code>YYAsyncLayer</code>组件实现异步绘制</p>
<h2 id="0x02_YYAsyncLayer_u4ECB_u7ECD"><a href="#0x02_YYAsyncLayer_u4ECB_u7ECD" class="headerlink" title="0x02 YYAsyncLayer介绍"></a>0x02 YYAsyncLayer介绍</h2><p>前面两个优化点，平时在做的时候可能也都会去做，但是异步绘制这个该怎么去实现呢？我们直接来看下<code>YYAsyncLayer</code>的代码</p>
<p><code>YYAsyncLayer</code>组件里面一共包含了三个类：<code>YYAsyncLayer</code>、<code>YYSentinel</code>、<code>YYTransaction</code></p>
<p><code>YYAsyncLayer</code>类是我们主要用的类，它是CALayer的子类，是用来异步渲染layer内容</p>
<p><code>YYSentinel</code>类是用来给线程安全计数的，用于在多线程处理的场景</p>
<p><code>YYTransaction</code>类是利用runloop在休眠前的空闲时间来触发你预设的方法</p>
<p>因为我们没有用到<code>YYTransaction</code>类，所以我们直接将<code>YYAsyncLayer</code>、<code>YYSentinel</code>合成一个类，并做了混淆，这样可以少引用一个库</p>
<p>我们首先来看<code>YYAsyncLayer</code>的头文件</p>
<p><code>YYAsyncLayer</code>类只有一个<code>displaysAsynchronously</code>属性，就是设置渲染是否是异步执行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property BOOL displaysAsynchronously;</div></pre></td></tr></table></figure>
<p>然后还有个代理方法，这个代理方法的触发时机是在layer的内容需要更新的时候，此时你有个新的绘制任务，然后返回的是个<code>YYAsyncLayerDisplayTask</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;</div></pre></td></tr></table></figure>
<p><code>YYAsyncLayerDisplayTask</code>类只有三个block，即将绘制、绘制中、绘制完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);</div><div class="line">@property (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));</div><div class="line">@property (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);</div></pre></td></tr></table></figure>
<p>看到实现文件里面，触发这个代理的方法是<code>- setNeedsDisplay</code>方法，就是当layer需要更新内容的时候，它会向代理发起一个异步绘制的请求，将内容的渲染放到后台队列去做，所以我们在使用<code>YYAsyncLayer</code>类时，我们需要重写<code>+ layerClass</code>方法，返回<code>YYAsyncLayer</code>类，否则会直接调用<code>CALayer</code>的方法，不会触发代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)setNeedsDisplay &#123;</div><div class="line">    [self _cancelAsyncDisplay];</div><div class="line">    [super setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)display &#123;</div><div class="line">    super.contents = super.contents;</div><div class="line">    [self _displayAsync:_displaysAsynchronously];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Private</div><div class="line"></div><div class="line">- (void)_displayAsync:(BOOL)async &#123;</div><div class="line">    __strong id&lt;YYAsyncLayerDelegate&gt; delegate = self.delegate;</div><div class="line">    YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>- _displayAsync</code>方法里面主要分成三部分：</p>
<p>如果没有设置display回调，layer的内容会被清空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!task.display) &#123;</div><div class="line">    if (task.willDisplay) task.willDisplay(self);</div><div class="line">    self.contents = nil;</div><div class="line">    if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据之前<code>displaysAsynchronously</code>属性设置判断，如果是同步绘制的话，实际上的操作就是在调用完<code>display</code>block之后，将sublayer合成一张图作为layer的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[self increase];</div><div class="line">if (task.willDisplay) task.willDisplay(self);</div><div class="line">UIGraphicsBeginImageContextWithOptions(self.bounds.size,self.opaque,self.contentsScale);</div><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">task.display(context, self.bounds.size, ^&#123;return NO;&#125;);</div><div class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">UIGraphicsEndImageContext();</div><div class="line">self.contents = (__bridge id)(image.CGImage);</div><div class="line">if (task.didDisplay) task.didDisplay(self, YES);</div></pre></td></tr></table></figure>
<p>而异步渲染的处理和同步渲染大同小异，第一，多了一个<code>BOOL (^isCancelled)()</code>block，这个block的好处是，在<code>display</code>block调用绘制前，可以通过判断<code>isCancelled</code>布尔值的值来停止绘制，减少性能上的消耗，以及避免出现线程阻塞的情况，比如TableView快速滑动的时候，就可以通过这样的判断，来避免不必要的绘制，提升滑动的流畅性，第二，将上面同步的绘制处理放到了异步去做，绘制方式是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">if (task.willDisplay) task.willDisplay(self);</div><div class="line">int32_t value = self.value;</div><div class="line">BOOL (^isCancelled)() = ^BOOL() &#123;</div><div class="line">    return value != self.value;</div><div class="line">&#125;;</div><div class="line">CGSize size = self.bounds.size;</div><div class="line">BOOL opaque = self.opaque;</div><div class="line">CGFloat scale = self.contentsScale;</div><div class="line">if (size.width &lt; 1 || size.height &lt; 1) &#123;</div><div class="line">    CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</div><div class="line">    self.contents = nil;</div><div class="line">    if (image) &#123;</div><div class="line">        dispatch_async(FIMAsyncLayerGetReleaseQueue(), ^&#123;</div><div class="line">            CFRelease(image);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dispatch_async(FIMAsyncLayerGetDisplayQueue(), ^&#123;</div><div class="line">    if (isCancelled()) return;</div><div class="line">    UIGraphicsBeginImageContextWithOptions(size, opaque, scale);</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    task.display(context, size, isCancelled);</div><div class="line">    if (isCancelled()) &#123;</div><div class="line">        UIGraphicsEndImageContext();</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">        &#125;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    if (isCancelled()) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">        &#125;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        if (isCancelled()) &#123;</div><div class="line">            if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">        &#125; else &#123;</div><div class="line">            self.contents = (__bridge id)(image.CGImage);</div><div class="line">            if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个异步的队列也是自己创建的，在预设了一个队列最大值之后，通过获取运行该进程的系统处于激活状态的处理器数量来创建队列，使得绘制的效率达到最高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static dispatch_queue_t FIMAsyncLayerGetDisplayQueue() &#123;</div><div class="line">#define MAX_QUEUE_COUNT 16</div><div class="line">    static int queueCount;</div><div class="line">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    static int32_t counter = 0;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</div><div class="line">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</div><div class="line">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</div><div class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</div><div class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</div><div class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.FIMkit.render&quot;, attr);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</div><div class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.FIMkit.render&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    int32_t cur = OSAtomicIncrement32(&amp;counter);</div><div class="line">    if (cur &lt; 0) cur = -cur;</div><div class="line">    return queues[(cur) % queueCount];</div><div class="line">#undef MAX_QUEUE_COUNT</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x03__u8865_u5145"><a href="#0x03__u8865_u5145" class="headerlink" title="0x03 补充"></a>0x03 补充</h2><p>在<code>文本</code>的实现上，我们更加推荐使用CoreText，CoreText对象占用的内存少，而且适用于文本排版复杂的情况，虽然在实现上较为复杂，但是所带来的好处远远要多</p>
<p>在渲染<code>图片</code>时，我们应该在后台把图片绘制到<code>CGBitmapContext</code>中，然后从<code>Bitmap</code>直接创建图片，因为如果使用原来ImageView读取Image的方式是，在创建Image或者CGImageSource对象时，图片数据并不会立即解码，而是等到设置到ImageView或者layer.contents，layer被提交到GPU之前，才解码，并且这些操作都是在主线程进行，是相当耗性能的，所以我们应该用推荐的方式去绘制，而且AFNetworking在对图片处理的时候也是这么做的</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFURLResponseSerializationImage.png" alt=""></p>
<h2 id="0x04__u7B80_u5355_u5B9E_u73B0demo"><a href="#0x04__u7B80_u5355_u5B9E_u73B0demo" class="headerlink" title="0x04 简单实现demo"></a>0x04 简单实现demo</h2><p>对于上述优化点，我实现了一个简单的<a href="https://github.com/Yuzeyang/GCAsyncDisplayDemo" target="_blank" rel="external">CoreText demo</a>，可以看一下这个demo做进一步了解~</p>
<h2 id="0x05__u76F8_u5173_u63A8_u8350_u9605_u8BFB"><a href="#0x05__u76F8_u5173_u63A8_u8350_u9605_u8BFB" class="headerlink" title="0x05 相关推荐阅读"></a>0x05 相关推荐阅读</h2><p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=27&amp;uin=MjI5NjY4NTU%3D&amp;key=7b81aac53bd2393d5c4f70d3d589ce1750179035ed3e4fc89454779d85881a9acd97a28bef1484ddbcfcd3250861abc7&amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.11.6+build(15G31" target="_blank" rel="external">iOS 事件处理机制与图像渲染过程</a>&amp;version=12000110&amp;lang=zh_CN&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=JE1V0DIEopWtscTKwaYEiHN6qmvNRu9O60t4vUkn3Ek%3D)</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/06/22/GCDAsyncSocket-socket-optimize/" class="prev">PREV</a><a href="/2016/07/23/FMDB-one/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/07/05/IM-UI-optimize/';
var disqus_title = 'IM UI性能优化之异步绘制';
var disqus_url = 'http://yuzeyang.github.io/2016/07/05/IM-UI-optimize/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>