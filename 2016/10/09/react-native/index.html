<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React Native接入现有项目 · 宫城</title><meta name="description" content="React Native接入现有项目 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">React Native接入现有项目</h1><div class="post-info">2016年10月9日</div><div class="post-content"><p>有一段时间没有写东西了，因为最近项目开始尝试使用React Native（以下简称RN）来开发，所以这段时间一直在研究，目前为止开发的内容不多，所以使用过的东西也不算多，这里也只是做个简单的记录</p>
<p>这里我打算从以下几个方面来讲：</p>
<p>1.背景介绍<br>2.环境的配置<br>3.项目的结构与设计<br>4.RN与原生的交互<br>5.本地调试与本地打包调试<br>6.远程热更新<br>7.踩坑记录<br>8.相关资料</p>
<a id="more"></a>
<h2 id="0x00__u80CC_u666F_u4ECB_u7ECD"><a href="#0x00__u80CC_u666F_u4ECB_u7ECD" class="headerlink" title="0x00 背景介绍"></a>0x00 背景介绍</h2><p>RN是Facebook在React.js 2015大会上公布开源的，它是基于开源框架React.js来实现的，它支持了iOS和Android两大平台，解决开发者们编写重复代码的痛点，实现了所谓的跨平台开发，Write Once , Run Anywhere，这是目前很多开发者所追求的，特别是一些独立开发者或者项目快速迭代的团队，可以尝试使用RN来开发，另外包括方便的npm管理，快速的调试等等</p>
<p>那么既然优点这么明显，为什么大部分的团队还是采用传统的iOS、Android开发呢，踩过坑的同学都知道，首先在支持上还做得不够完善，在使用组件时，RN原有提供的组件往往不能很好的支持，与原生组件多少存在着差异，而且在使用第三方组件时，又会因为长期不更新的原因，存在很多坑，对于新手来说，根本不知道坑在哪，完全无从下手。另外RN的性能也不能和原生的相提并论，特别是列表组件在渲染大量数据时，流畅性方面还是原生更加优越，而且并非所以代码iOS和Android都能公用，如果某个组件只支持某一个平台，那你必须分开编写代码，实际上还是存在重复代码，除此之外学习的成本以及团队RN推广等等原因都需要考量，但是我相信，跨平台开发始终是一个趋势，RN整个社区也在不断的发展，相信未来我们会实现真正意义上的跨平台开发~</p>
<h2 id="0x01__u73AF_u5883_u914D_u7F6E"><a href="#0x01__u73AF_u5883_u914D_u7F6E" class="headerlink" title="0x01 环境配置"></a>0x01 环境配置</h2><p>相对于Android的环境配置过程来说，iOS可以说是简单轻松…出现的问题要少很多</p>
<p>首先我们需要安装<strong>Homebrew</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>然后安装<strong>node</strong>和<strong>watchman</strong>(用于监测文件系统的变更)</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install <span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">brew</span> install watchman</span><br></pre></td></tr></table></figure>
<p>RN的命令行工具<strong>react-native-cli</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> react-<span class="keyword">native</span>-cli</span></span><br></pre></td></tr></table></figure>
<p>如果遇到权限问题，只要前面加个<strong>sudo</strong>即可</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> react-<span class="keyword">native</span>-cli</span></span><br></pre></td></tr></table></figure>
<p>yeah~that’s all~我在配置的过程中，基本没有报错，如果有出现配置问题的话，请自行Google一下，看看大家的解决方法</p>
<h2 id="0x02_RN_u7684_u8FD0_u884C_u6D41_u7A0B"><a href="#0x02_RN_u7684_u8FD0_u884C_u6D41_u7A0B" class="headerlink" title="0x02 RN的运行流程"></a>0x02 RN的运行流程</h2><h3 id="RN_u7684_u8FD0_u884C_u673A_u5236"><a href="#RN_u7684_u8FD0_u884C_u673A_u5236" class="headerlink" title="RN的运行机制"></a>RN的运行机制</h3><p>在开始写代码之前，我们需要了解RN的运行机制是怎么样的，这样写起来思路会更加清晰</p>
<p>首先，程序需要有个入口，我们可以创建很多的组件，但是有且只有一个组件用来做为程序的入口，RN的入口则类似于iOS的main.m，在iOS里我们会在main函数里设置应用程序类的代理类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return UIApplicationMain(argc, argv, nil, NSStringFromClass([KDAppDelegate class]));</span><br></pre></td></tr></table></figure>
<p>同样，RN里我们需要注册入口的名称，并且这个名称要和原生的初始化RN界面时的入口名称保持一致</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用navigation使用的组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建navigation类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">navigation</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// set compnent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册navigation为程序的入口</span></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'navigation'</span>, () =&gt; navigation);</span><br></pre></td></tr></table></figure>
<p>在iOS原生这边需要用到RN的地方，我们需要初始化它</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURL *jsCodeLocation =&#10;[[NSBundle mainBundle] URLForResource:@&#34;bundle/index.ios&#34; withExtension:@&#34;jsbundle&#34;];&#10;//        [NSURL URLWithString:@&#34;http://172.17.9.188:8081/index.ios.bundle?platform=ios&#34;];&#10;RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation&#10;                                                    moduleName:@&#34;navigation&#34;&#10;                                            initialProperties:nil&#10;                                                 launchOptions:nil];&#10;self.view = rootView;</span><br></pre></td></tr></table></figure>
<p>Tip：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">jsCodeLocation</span> 是RN资源加载的路径，我们有两种方式去加载，一种是加载本地的js文件及其他资源文件，一种是我们将其打包成bundle文件，前者的优势在于方便调试，后者是用来打包发布上线用</span><br></pre></td></tr></table></figure>
<p><code>moduleName</code>是对应于RN的入口名字，且这个是唯一的，那我们如果原生有多个入口需要初始化不同的RN界面，那该怎么办呢？这就用到了<code>initialProperties</code>，它是字典类型，我们可以将入口作为路由，在<code>initialProperties</code>里传入我们需要初始化的界面名称，入口获取到名称之后，渲染对应的界面即可</p>
<h3 id="RN_u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F"><a href="#RN_u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="RN组件的生命周期"></a>RN组件的生命周期</h3><p>在RN里面，所谓的界面应该称作类或者组件更为合适</p>
<p>并且组件也有它的生命周期，和iOS里的<code>viewWillAppear</code>、<code>viewDidDisappear</code>等等很像，下面生命周期内容取自于<a href="http://www.race604.com/react-native-component-lifecycle/" target="_blank" rel="external">http://www.race604.com/react-native-component-lifecycle/</a></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/RNCycleLife.jpg!700x700" alt=""></p>
<p>我们可以把组件生命周期大致分为三个阶段：</p>
<ul>
<li>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；</li>
<li>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；</li>
<li>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</li>
</ul>
<p>下面来详细介绍生命周期中的各回调函数。</p>
<h4 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h4><p>在组件创建之前，会先调用 <code>getDefaultProps()</code>，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 <code>getInitialState()</code>，来初始化组件的状态。</p>
<h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h4><p>然后，准备加载组件，会调用 <code>componentWillMount()</code>，其原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentWillMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 <code>render()</code> 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。</p>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h4><p>在组件第一次绘制之后，会调用 <code>componentDidMount()</code>，通知组件已经加载完成。函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 <code>componentDidMount()</code>，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 <code>setTimeout</code> 或者 <code>setInterval</code>，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发。</p>
<h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>如果组件收到新的属性（props），就会调用 <code>componentWillReceiveProps()</code>，其原型如下：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> componentWillReceiveProps(  </span><br><span class="line">  <span class="keyword">object</span> nextProps</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 是即将被设置的属性，旧的属性还是可以通过 <code>this.props</code> 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 <code>this.setState()</code> 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 <code>render()</code> 调用。如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">componentWillReceiveProps</span>: <span class="tag">function</span>(nextProps) &#123;  </span><br><span class="line">  <span class="tag">this</span><span class="class">.setState</span>(&#123;</span><br><span class="line">    <span class="attribute">likesIncreasing</span>: nextProps.likeCount &gt; this.props.likeCount</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>当组件接收到新的属性和状态改变的话，都会触发调用 <code>shouldComponentUpdate(...)</code>，函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean shouldComponentUpdate(  </span><br><span class="line">  <span class="tag">object</span> nextProps, <span class="tag">object</span> nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 和上面的 <code>componentWillReceiveProps</code> 函数一样，<code>nextState</code> 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 <code>true</code> 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。</p>
<p>默认情况下，这个函数永远返回 <code>true</code> 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。</p>
<h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>如果组件状态或者属性改变，并且上面的 <code>shouldComponentUpdate(...)</code> 返回为 <code>true</code>，就会开始准更新组件，并调用 <code>componentWillUpdate()</code>，其函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentWillUpdate(  </span><br><span class="line">  <span class="tag">object</span> nextProps, <span class="tag">object</span> nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数与 <code>shouldComponentUpdate</code> 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 <code>this.setState</code> 来修改状态。这个函数调用之后，就会把 <code>nextProps</code> 和 <code>nextState</code> 分别设置到 <code>this.props</code>和 <code>this.state</code> 中。紧接着这个函数，就会调用 <code>render()</code> 来更新界面了。</p>
<h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><p>调用了 <code>render()</code> 更新完成界面之后，会调用 <code>componentDidUpdate()</code> 来得到通知，其函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentDidUpdate(  </span><br><span class="line">  <span class="tag">object</span> prevProps, <span class="tag">object</span> prevState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 <code>prevProps</code> 和 <code>prevState</code>。</p>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h4><p>当组件要被从界面上移除的时候，就会调用 <code>componentWillUnmount()</code>，其函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等。</p>
<p>下表是生命周期函数的调用次数，以及能否使用 setSate()：</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>调用次数</th>
<th>能否使用 setSate()</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDefaultProps</td>
<td>1(全局调用一次)</td>
<td>否</td>
</tr>
<tr>
<td>getInitialState</td>
<td>1</td>
<td>否</td>
</tr>
<tr>
<td>componentWillMount</td>
<td>1</td>
<td>是</td>
</tr>
<tr>
<td>render</td>
<td>&gt;=1</td>
<td>否</td>
</tr>
<tr>
<td>componentDidMount</td>
<td>1</td>
<td>是</td>
</tr>
<tr>
<td>componentWillReceiveProps</td>
<td>&gt;=0</td>
<td>是</td>
</tr>
<tr>
<td>shouldComponentUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentWillUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentDidUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentWillUnmount</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="RN_u7684_u8BBE_u8BA1_u6A21_u5F0F"><a href="#RN_u7684_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="RN的设计模式"></a>RN的设计模式</h3><p>目前设计模式也非常多，如Flux，Reflux，Redux，Relay，Marty，不过以上都不是很了解，可以参考<a href="https://segmentfault.com/a/1190000004161358" target="_blank" rel="external">ReactNative的组件架构设计</a>学习了解一下，由于做客户端的同学接触的最多的是MVC，MVVM、MVCS等等，所以我觉得选用类似MVCS的模式可能更加适合新手的学习，比如写组件时，通常我们会创建一个组件，里面会包含数据的处理，页面的渲染，样式的设置，网络请求，当这些内容过多时，组件就会显得特别臃肿，所以我们需要将其拆分开为数据模型（Model），页面渲染，样式设置，网路请求（Service），这里的页面渲染和样式设置，不能算是称作为iOS里的Controller和View，应该跟前端一样，在html文件里面写布局，css文件里面写样式，感觉像是MVCS和前端的融合</p>
<h2 id="0x03_RN_u4E0E_u539F_u751F_u7684_u4EA4_u4E92"><a href="#0x03_RN_u4E0E_u539F_u751F_u7684_u4EA4_u4E92" class="headerlink" title="0x03 RN与原生的交互"></a>0x03 RN与原生的交互</h2><p>在写RN时不免会遇到与原生交互，下面我分JS调用原生、原生调用JS来讲</p>
<h3 id="JS_u8C03_u7528_u539F_u751F"><a href="#JS_u8C03_u7528_u539F_u751F" class="headerlink" title="JS调用原生"></a>JS调用原生</h3><p>在调用原生时，我们需要实现<code>RCTBridgeModule</code>和<code>RCT_EXPORT_MODULE();</code></p>
<p><code>RCT_EXPORT_MODULE();</code>则是一个宏定义，返回moduleName，并且调用<code>+ load</code>方法注册</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RCT_EXPORT_MODULE(js_name) \&#10;RCT_EXTERN void RCTRegisterModule(Class); \&#10;+ (NSString *)moduleName &#123; return @#js_name; &#125; \&#10;+ (void)load &#123; RCTRegisterModule(self); &#125;</span><br></pre></td></tr></table></figure>
<p>例如我们增加一个bridge方法，获取版本号，<code>getVersion</code>为方法名，<code>callback</code>是原生回调给JS的内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(getVersion : (RCTResponseSenderBlock)callback) &#123;&#10;    NSString *version =&#10;    [[NSBundle mainBundle] objectForInfoDictionaryKey:@&#34;CFBundleShortVersionString&#34;];&#10;    callback(@[[NSNull null], @[version]]);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后返回方法的队列为主队列</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_queue_t)methodQueue &#123;&#10;    return dispatch_get_main_queue();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在JS文件里，我们可以定义一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ZanIntentModule = NativeModules.ZanIntentModule;</span><br></pre></td></tr></table></figure>
<p>然后在使用的时候调用我们在原生时定义方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZanIntentModule.getVersion(</span><br><span class="line">(callback) =&gt; &#123;</span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="u539F_u751F_u8C03_u7528JS"><a href="#u539F_u751F_u8C03_u7528JS" class="headerlink" title="原生调用JS"></a>原生调用JS</h3><p>老版本的调用方式为，但是接口被标记为deprecated：<code>__deprecated_msg(&quot;Subclass RCTEventEmitter instead&quot;);</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.bridge.eventDispatcher sendAppEventWithName:kGiftReloadData body:nil];</span><br></pre></td></tr></table></figure>
<p>新版本的调用方式为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZanEventEmitter *emitter = [[ZanEventEmitter alloc] init];&#10;emitter.bridge = self.bridge;&#10;[emitter sendEventWithName:kGiftReloadData body:nil];</span><br></pre></td></tr></table></figure>
<p>但是新版本坑的是，直接这样调用时bridge居然是nil，网上说用单例，但是也不行…所以我还是用老版本的调用方法，有哪个大神知道怎么用新版本接口调用的正确姿势，请留言交流哈</p>
<p>然后在实现<code>RCTBridgeDelegate</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge &#123;&#10;    return [[NSBundle mainBundle] URLForResource:@&#34;bundle/index.ios&#34; withExtension:@&#34;jsbundle&#34;];&#10;//    return [NSURL URLWithString:@&#34;http://172.17.9.94:8081/index.ios.bundle?platform=ios&#34;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在对应的组件里，需要在<code>componentWillMount</code>增加监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.eventEmitter = NativeAppEventEmitter.addListener(</span><br><span class="line">    <span class="string">'GiftReloadData'</span>,</span><br><span class="line">    () =&gt; <span class="keyword">this</span>._reloadData()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的也需要移除掉监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  subscription.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后原生发送action之后，会触发我们设定好的<code>reloadData()</code>方法</p>
<h2 id="0x04__u672C_u5730_u8C03_u8BD5_u4E0E_u6253_u5305_u8C03_u8BD5"><a href="#0x04__u672C_u5730_u8C03_u8BD5_u4E0E_u6253_u5305_u8C03_u8BD5" class="headerlink" title="0x04 本地调试与打包调试"></a>0x04 本地调试与打包调试</h2><p>在编写的过程中，也需要进行调试，调试有两种方法：一种是本地调试，一种是打包调试</p>
<h3 id="u672C_u5730_u8C03_u8BD5"><a href="#u672C_u5730_u8C03_u8BD5" class="headerlink" title="本地调试"></a>本地调试</h3><p>我们在加载bundle时，需要替换成你的ip地址，端口号不要变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSURL URLWithString:@&#34;http://172.17.9.94:8081/index.ios.bundle?platform=ios&#34;]</span><br></pre></td></tr></table></figure>
<p>如果你是在真机上调试，你需要开启HTTP代理，填写你的ip地址和端口号</p>
<p>在终端上，先进入到你的项目目录（与node_modules目录同级），然后开启服务</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yzydeMacBook-Pro:shangjiaban-ios yzy$ npm start</span><br></pre></td></tr></table></figure>
<p>你修改了某处之后，在模拟器上点击<code>Shake Gesture</code>或者快捷键，在真机上只要摇一摇就可以</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Shake.png!400x400" alt=""></p>
<p>在模拟器弹出框里选择<code>Roload</code>，这样就会重新加载你本地的JS文件</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/simulation.png!400x400" alt=""></p>
<p>如果你想查看JS里面的log日志，你可以选择<code>Start Remote JS Debugging</code>，在chrome浏览器里就能看到输出的日志了</p>
<h3 id="u6253_u5305_u8C03_u8BD5"><a href="#u6253_u5305_u8C03_u8BD5" class="headerlink" title="<img src=" http:="" 7xtit4.com1.z0.glb.clouddn.com="" chromedebug.png"="" alt="">打包调试"></a><img src="http://7xtit4.com1.z0.glb.clouddn.com/chromeDebug.png" alt="">打包调试</h3><p>另外一种就是打包调试，但是比较麻烦，首先我们要讲bundle加载方式改为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSBundle mainBundle] URLForResource:@&#34;bundle/index.ios&#34; withExtension:@&#34;jsbundle&#34;];</span><br></pre></td></tr></table></figure>
<p>然后在终端里面，输入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yzydeMacBook-Pro:shangjiaban-ios yzy$ react-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output ./xxx/bundle/index.ios.jsbundle --assets-dest ./xxx/bundle</span><br></pre></td></tr></table></figure>
<p><code>--bundle-output ./xxx/bundle/index.ios.jsbundle</code>指的是输出的bundle文件路径</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[20:54:43] &#60;START&#62; Building Dependency Graph&#10;[20:54:43] &#60;START&#62; Crawling File System&#10;[20:54:43] &#60;START&#62; find dependencies&#10;[20:54:48] &#60;END&#62;   Crawling File System (4712ms)&#10;[20:54:48] &#60;START&#62; Building in-memory fs for JavaScript&#10;[20:54:48] &#60;END&#62;   Building in-memory fs for JavaScript (230ms)&#10;[20:54:48] &#60;START&#62; Building in-memory fs for Assets&#10;[20:54:48] &#60;END&#62;   Building in-memory fs for Assets (154ms)&#10;[20:54:48] &#60;START&#62; Building Haste Map&#10;[20:54:48] &#60;START&#62; Building (deprecated) Asset Map&#10;[20:54:48] &#60;END&#62;   Building (deprecated) Asset Map (66ms)&#10;[20:54:48] &#60;END&#62;   Building Haste Map (154ms)&#10;[20:54:48] &#60;END&#62;   Building Dependency Graph (5261ms)&#10;transformed 372/372 (100%)&#10;[20:54:49] &#60;END&#62;   find dependencies (6402ms)&#10;bundle: start&#10;bundle: finish&#10;bundle: Writing bundle output to: ./Koudaitong/bundle/index.ios.jsbundle&#10;bundle: Copying 5 asset files&#10;bundle: Done writing bundle output&#10;bundle: Done copying assets</span><br></pre></td></tr></table></figure>
<p>当看到这样的信息的时候，说明已经打包成功了，再将生成的bundle文件夹以<code>Create folder references</code>形式加到工程里，然后就可以run了</p>
<p>Tip:</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在真机调试时，需要在Edit Scheme里在<span class="keyword">Run</span>模式里，将Build Configuration改为<span class="keyword">Release</span>模式</span><br></pre></td></tr></table></figure>
<h2 id="0x05__u8FDC_u7A0B_u70ED_u66F4_u65B0"><a href="#0x05__u8FDC_u7A0B_u70ED_u66F4_u65B0" class="headerlink" title="0x05 远程热更新"></a>0x05 远程热更新</h2><p>这块网上的方案大同小异，因为目前我们还是采取本地打包加载的方式，还未上热更新，所以在这不好多做说明，等上了热更新之后，我再来补充~</p>
<h2 id="0x06__u8E29_u5751_u8BB0_u5F55"><a href="#0x06__u8E29_u5751_u8BB0_u5F55" class="headerlink" title="0x06 踩坑记录"></a>0x06 踩坑记录</h2><p>踩坑最多是应该是使用上的</p>
<p>1.RN系统的组件并不是所有都是共用的，比如segment支持iOS，不支持Android，Alert分为iOS和Android等等，所以还是要写重复的代码</p>
<p>2.ListView不支持iOS原生的滑动操作，需要使用第三方库，但是第三方库不能控制只编辑一个Cell</p>
<p>3.由于原先iOS和Android的代码仓库是分开的，所以接入RN时，JS文件也是跟着仓库走的，这样iOS和Android会存在重复代码，并且目前两个人分别接iOS和Android，写JS时，有时并不共享，容易代码写着写着就有差异了，偏离了Write Once , Run Anywhere的初衷</p>
<h2 id="0x07__u76F8_u5173_u8D44_u6599"><a href="#0x07__u76F8_u5173_u8D44_u6599" class="headerlink" title="0x07 相关资料"></a>0x07 相关资料</h2><p><a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a></p>
<p><a href="http://reactnative.cn/" target="_blank" rel="external">React Native 中文网</a></p>
<p><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="external">汇集了各类react-native学习资源、开源App和组件</a></p>
<p><a href="http://blog.talisk.cn/blog/2016/08/13/RN-Learning-path-for-iOS-developer/" target="_blank" rel="external">写给 iOS 开发者的 React Native 学习路线</a></p>
<p><a href="http://www.lcode.org/" target="_blank" rel="external">江清清的技术专栏</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/09/08/iOS-Drawer-Table-View/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/10/09/react-native/';
var disqus_title = 'React Native接入现有项目';
var disqus_url = 'http://yuzeyang.github.io/2016/10/09/react-native/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>