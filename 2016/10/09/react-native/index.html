<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 项目接入使用React Native · 宫城</title><meta name="description" content="项目接入使用React Native - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">项目接入使用React Native</h1><div class="post-info">2016年10月9日</div><div class="post-content"><p>有一段时间没有写东西了，因为最近项目开始尝试使用React Native（以下简称RN）来开发，所以这段时间一直在研究，目前为止开发的内容不多，所以使用过的东西也不算多，这里也只是做个简单的记录</p>
<p>这里我打算从以下几个方面来讲：</p>
<p>1.背景介绍</p>
<p>2.环境的配置</p>
<p>3.RN所需要知道的知识</p>
<p>4.RN与原生的交互</p>
<p>5.本地调试与本地打包调试</p>
<p>6.远程热更新</p>
<p>7.iOS和Android不同样式处理</p>
<p>8.踩坑记录</p>
<p>9.相关资料</p>
<a id="more"></a>
<h2 id="0x00__u80CC_u666F_u4ECB_u7ECD"><a href="#0x00__u80CC_u666F_u4ECB_u7ECD" class="headerlink" title="0x00 背景介绍"></a>0x00 背景介绍</h2><p>RN是Facebook在React.js 2015大会上公布开源的，它是基于开源框架React.js来实现的，它支持了iOS和Android两大平台，解决开发者们编写重复代码的痛点，实现了所谓的跨平台开发，Write Once , Run Anywhere，这是目前很多开发者所追求的，特别是一些独立开发者或者项目快速迭代的团队，可以尝试使用RN来开发，另外包括方便的npm管理，快速的调试等等</p>
<p>那么既然优点这么明显，为什么大部分的团队还是采用传统的iOS、Android开发呢，踩过坑的同学都知道，首先在支持上还做得不够完善，在使用组件时，RN原有提供的组件往往不能很好的支持，与原生组件多少存在着差异，而且在使用第三方组件时，又会因为长期不更新的原因，存在很多坑，对于新手来说，根本不知道坑在哪，完全无从下手。另外RN的性能也不能和原生的相提并论，特别是列表组件在渲染大量数据时，流畅性方面还是原生更加优越，而且并非所以代码iOS和Android都能公用，如果某个组件只支持某一个平台，那你必须分开编写代码，实际上还是存在重复代码，除此之外学习的成本以及团队RN推广等等原因都需要考量，但是我相信，跨平台开发始终是一个趋势，RN整个社区也在不断的发展，相信未来我们会实现真正意义上的跨平台开发~</p>
<h2 id="0x01__u73AF_u5883_u914D_u7F6E"><a href="#0x01__u73AF_u5883_u914D_u7F6E" class="headerlink" title="0x01 环境配置"></a>0x01 环境配置</h2><p>相对于Android的环境配置过程来说，iOS可以说是简单轻松…出现的问题要少很多</p>
<p>首先我们需要安装<strong>Homebrew</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>然后安装<strong>node</strong>和<strong>watchman</strong>(用于监测文件系统的变更)</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install <span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">brew</span> install watchman</span><br></pre></td></tr></table></figure>
<p>RN的命令行工具<strong>react-native-cli</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> react-<span class="keyword">native</span>-cli</span></span><br></pre></td></tr></table></figure>
<p>如果遇到权限问题，只要前面加个<strong>sudo</strong>即可</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> react-<span class="keyword">native</span>-cli</span></span><br></pre></td></tr></table></figure>
<p>yeah~that’s all~我在配置的过程中，基本没有报错，如果有出现配置问题的话，请自行Google一下，看看大家的解决方法</p>
<p>如果在原有iOS项目中集成的话，我们需要在package.json文件配置一下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"your project name"</span></span>,</span><br><span class="line">  "<span class="attribute">version</span>": <span class="value"><span class="string">"0.0.1"</span></span>,</span><br><span class="line">  "<span class="attribute">private</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">  "<span class="attribute">scripts</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">start</span>": <span class="value"><span class="string">"node node_modules/react-native/local-cli/cli.js start"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">dependencies</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">react</span>": <span class="value"><span class="string">"15.3.1"</span></span>,</span><br><span class="line">    "<span class="attribute">react-native</span>": <span class="value"><span class="string">"0.33.0"</span></span>,</span><br><span class="line">    "<span class="attribute">react-native-swipeout</span>": <span class="value"><span class="string">"^2.0.12"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>并且Podfile里，导入需要的RN模块</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'React'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../node_modules/react-native'</span>, <span class="symbol">:subspecs</span> =&gt; [</span><br><span class="line">    <span class="string">'Core'</span>,</span><br><span class="line">    <span class="string">'RCTText'</span>,</span><br><span class="line">    <span class="string">'RCTImage'</span>,</span><br><span class="line">    <span class="string">'RCTNetwork'</span>,</span><br><span class="line">    <span class="string">'RCTWebSocket'</span>, <span class="comment"># needed for debugging</span></span><br><span class="line">    <span class="comment"># Add any other subspecs you want to use in your project</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="0x02_RN_u6240_u9700_u8981_u77E5_u9053_u7684_u77E5_u8BC6"><a href="#0x02_RN_u6240_u9700_u8981_u77E5_u9053_u7684_u77E5_u8BC6" class="headerlink" title="0x02 RN所需要知道的知识"></a>0x02 RN所需要知道的知识</h2><h3 id="RN_u7684_u8FD0_u884C_u673A_u5236"><a href="#RN_u7684_u8FD0_u884C_u673A_u5236" class="headerlink" title="RN的运行机制"></a>RN的运行机制</h3><p>在开始写代码之前，我们需要了解RN的运行机制是怎么样的，这样写起来思路会更加清晰</p>
<p>首先，程序需要有个入口，我们可以创建很多的组件，但是有且只有一个组件用来做为程序的入口，RN的入口则类似于iOS的main.m，在iOS里我们会在main函数里设置应用程序类的代理类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return UIApplicationMain(argc, argv, nil, NSStringFromClass([KDAppDelegate class]));</span><br></pre></td></tr></table></figure>
<p>同样，RN里我们需要注册入口的名称，并且这个名称要和原生的初始化RN界面时的入口名称保持一致</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用navigation使用的组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建navigation类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">navigation</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// set compnent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册navigation为程序的入口</span></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'navigation'</span>, () =&gt; navigation);</span><br></pre></td></tr></table></figure>
<p>在iOS原生这边需要用到RN的地方，我们需要初始化它</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURL *jsCodeLocation =&#10;[[NSBundle mainBundle] URLForResource:@&#34;bundle/index.ios&#34; withExtension:@&#34;jsbundle&#34;];&#10;//        [NSURL URLWithString:@&#34;http://172.17.9.188:8081/index.ios.bundle?platform=ios&#34;];&#10;RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation&#10;                                                    moduleName:@&#34;navigation&#34;&#10;                                            initialProperties:nil&#10;                                                 launchOptions:nil];&#10;self.view = rootView;</span><br></pre></td></tr></table></figure>
<p>Tip：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">jsCodeLocation</span> 是RN资源加载的路径，我们有两种方式去加载，一种是加载本地的js文件及其他资源文件，一种是我们将其打包成bundle文件，前者的优势在于方便调试，后者是用来打包发布上线用</span><br></pre></td></tr></table></figure>
<p><code>moduleName</code>是对应于RN的入口名字，且这个是唯一的，那我们如果原生有多个入口需要初始化不同的RN界面，那该怎么办呢？这就用到了<code>initialProperties</code>，它是字典类型，我们可以将入口作为路由，在<code>initialProperties</code>里传入我们需要初始化的界面名称，入口获取到名称之后，渲染对应的界面即可</p>
<h3 id="RN_u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F"><a href="#RN_u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="RN组件的生命周期"></a>RN组件的生命周期</h3><p>在RN里面，所谓的界面应该称作类或者组件更为合适</p>
<p>并且组件也有它的生命周期，和iOS里的<code>viewWillAppear</code>、<code>viewDidDisappear</code>等等很像，下面生命周期内容取自于<a href="http://www.race604.com/react-native-component-lifecycle/" target="_blank" rel="external">http://www.race604.com/react-native-component-lifecycle/</a></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/RNCycleLife.jpg!700x700" alt=""></p>
<p>我们可以把组件生命周期大致分为三个阶段：</p>
<ul>
<li>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；</li>
<li>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；</li>
<li>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</li>
</ul>
<p>下面来详细介绍生命周期中的各回调函数。</p>
<h4 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h4><p>在组件创建之前，会先调用 <code>getDefaultProps()</code>，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 <code>getInitialState()</code>，来初始化组件的状态。</p>
<h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h4><p>然后，准备加载组件，会调用 <code>componentWillMount()</code>，其原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentWillMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 <code>render()</code> 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。</p>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h4><p>在组件第一次绘制之后，会调用 <code>componentDidMount()</code>，通知组件已经加载完成。函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 <code>componentDidMount()</code>，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 <code>setTimeout</code> 或者 <code>setInterval</code>，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发。</p>
<h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>如果组件收到新的属性（props），就会调用 <code>componentWillReceiveProps()</code>，其原型如下：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> componentWillReceiveProps(  </span><br><span class="line">  <span class="keyword">object</span> nextProps</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 是即将被设置的属性，旧的属性还是可以通过 <code>this.props</code> 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 <code>this.setState()</code> 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 <code>render()</code> 调用。如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">componentWillReceiveProps</span>: <span class="tag">function</span>(nextProps) &#123;  </span><br><span class="line">  <span class="tag">this</span><span class="class">.setState</span>(&#123;</span><br><span class="line">    <span class="attribute">likesIncreasing</span>: nextProps.likeCount &gt; this.props.likeCount</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>当组件接收到新的属性和状态改变的话，都会触发调用 <code>shouldComponentUpdate(...)</code>，函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean shouldComponentUpdate(  </span><br><span class="line">  <span class="tag">object</span> nextProps, <span class="tag">object</span> nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 和上面的 <code>componentWillReceiveProps</code> 函数一样，<code>nextState</code> 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 <code>true</code> 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。</p>
<p>默认情况下，这个函数永远返回 <code>true</code> 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。</p>
<h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>如果组件状态或者属性改变，并且上面的 <code>shouldComponentUpdate(...)</code> 返回为 <code>true</code>，就会开始准更新组件，并调用 <code>componentWillUpdate()</code>，其函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentWillUpdate(  </span><br><span class="line">  <span class="tag">object</span> nextProps, <span class="tag">object</span> nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数与 <code>shouldComponentUpdate</code> 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 <code>this.setState</code> 来修改状态。这个函数调用之后，就会把 <code>nextProps</code> 和 <code>nextState</code> 分别设置到 <code>this.props</code>和 <code>this.state</code> 中。紧接着这个函数，就会调用 <code>render()</code> 来更新界面了。</p>
<h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><p>调用了 <code>render()</code> 更新完成界面之后，会调用 <code>componentDidUpdate()</code> 来得到通知，其函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentDidUpdate(  </span><br><span class="line">  <span class="tag">object</span> prevProps, <span class="tag">object</span> prevState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 <code>prevProps</code> 和 <code>prevState</code>。</p>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h4><p>当组件要被从界面上移除的时候，就会调用 <code>componentWillUnmount()</code>，其函数原型如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等。</p>
<p>下表是生命周期函数的调用次数，以及能否使用 setSate()：</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>调用次数</th>
<th>能否使用 setSate()</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDefaultProps</td>
<td>1(全局调用一次)</td>
<td>否</td>
</tr>
<tr>
<td>getInitialState</td>
<td>1</td>
<td>否</td>
</tr>
<tr>
<td>componentWillMount</td>
<td>1</td>
<td>是</td>
</tr>
<tr>
<td>render</td>
<td>&gt;=1</td>
<td>否</td>
</tr>
<tr>
<td>componentDidMount</td>
<td>1</td>
<td>是</td>
</tr>
<tr>
<td>componentWillReceiveProps</td>
<td>&gt;=0</td>
<td>是</td>
</tr>
<tr>
<td>shouldComponentUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentWillUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentDidUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentWillUnmount</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="RN_u7684_u8BBE_u8BA1_u6A21_u5F0F"><a href="#RN_u7684_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="RN的设计模式"></a>RN的设计模式</h3><p>目前设计模式也非常多，如Flux，Reflux，Redux，Relay，Marty，不过以上都不是很了解，可以参考<a href="https://segmentfault.com/a/1190000004161358" target="_blank" rel="external">ReactNative的组件架构设计</a>学习了解一下，由于做客户端的同学接触的最多的是MVC，MVVM、MVCS等等，所以我觉得选用类似MVCS的模式可能更加适合新手的学习，比如写组件时，通常我们会创建一个组件，里面会包含数据的处理，页面的渲染，样式的设置，网络请求，当这些内容过多时，组件就会显得特别臃肿，所以我们需要将其拆分开为数据模型（Model），页面渲染，样式设置，网路请求（Service），这里的页面渲染和样式设置，不能算是称作为iOS里的Controller和View，应该跟前端一样，在html文件里面写布局，css文件里面写样式，感觉像是MVCS和前端的融合</p>
<h2 id="0x03_RN_u4E0E_u539F_u751F_u7684_u4EA4_u4E92"><a href="#0x03_RN_u4E0E_u539F_u751F_u7684_u4EA4_u4E92" class="headerlink" title="0x03 RN与原生的交互"></a>0x03 RN与原生的交互</h2><p>在写RN时不免会遇到与原生交互，下面我分JS调用原生、原生调用JS来讲</p>
<h3 id="JS_u8C03_u7528_u539F_u751F"><a href="#JS_u8C03_u7528_u539F_u751F" class="headerlink" title="JS调用原生"></a>JS调用原生</h3><p>在调用原生时，我们需要实现<code>RCTBridgeModule</code>和<code>RCT_EXPORT_MODULE();</code></p>
<p><code>RCT_EXPORT_MODULE();</code>则是一个宏定义，返回moduleName，并且调用<code>+ load</code>方法注册</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RCT_EXPORT_MODULE(js_name) \&#10;RCT_EXTERN void RCTRegisterModule(Class); \&#10;+ (NSString *)moduleName &#123; return @#js_name; &#125; \&#10;+ (void)load &#123; RCTRegisterModule(self); &#125;</span><br></pre></td></tr></table></figure>
<p>例如我们增加一个bridge方法，获取版本号，<code>getVersion</code>为方法名，<code>callback</code>是原生回调给JS的内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(getVersion : (RCTResponseSenderBlock)callback) &#123;&#10;    NSString *version =&#10;    [[NSBundle mainBundle] objectForInfoDictionaryKey:@&#34;CFBundleShortVersionString&#34;];&#10;    callback(@[[NSNull null], @[version]]);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后返回方法的队列为主队列</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_queue_t)methodQueue &#123;&#10;    return dispatch_get_main_queue();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在JS文件里，我们可以定义一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ZanIntentModule = NativeModules.ZanIntentModule;</span><br></pre></td></tr></table></figure>
<p>然后在使用的时候调用我们在原生时定义方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZanIntentModule.getVersion(</span><br><span class="line">(callback) =&gt; &#123;</span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="u539F_u751F_u8C03_u7528JS"><a href="#u539F_u751F_u8C03_u7528JS" class="headerlink" title="原生调用JS"></a>原生调用JS</h3><p>老版本的调用方式为，但是接口被标记为deprecated：<code>__deprecated_msg(&quot;Subclass RCTEventEmitter instead&quot;);</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.bridge.eventDispatcher sendAppEventWithName:kGiftReloadData body:nil];</span><br></pre></td></tr></table></figure>
<p>新版本的调用方式为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZanEventEmitter *emitter = [[ZanEventEmitter alloc] init];&#10;emitter.bridge = self.bridge;&#10;[emitter sendEventWithName:kGiftReloadData body:nil];</span><br></pre></td></tr></table></figure>
<p>但是新版本坑的是，直接这样调用时bridge居然是nil，网上说用单例，但是也不行…所以我还是用老版本的调用方法，有哪个大神知道怎么用新版本接口调用的正确姿势，请留言交流哈</p>
<p>然后在实现<code>RCTBridgeDelegate</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge &#123;&#10;    return [[NSBundle mainBundle] URLForResource:@&#34;bundle/index.ios&#34; withExtension:@&#34;jsbundle&#34;];&#10;//    return [NSURL URLWithString:@&#34;http://172.17.9.94:8081/index.ios.bundle?platform=ios&#34;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在对应的组件里，需要在<code>componentWillMount</code>增加监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.eventEmitter = NativeAppEventEmitter.addListener(</span><br><span class="line">    <span class="string">'GiftReloadData'</span>,</span><br><span class="line">    () =&gt; <span class="keyword">this</span>._reloadData()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的也需要移除掉监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  subscription.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后原生发送action之后，会触发我们设定好的<code>reloadData()</code>方法</p>
<h2 id="0x04__u672C_u5730_u8C03_u8BD5_u4E0E_u6253_u5305_u8C03_u8BD5"><a href="#0x04__u672C_u5730_u8C03_u8BD5_u4E0E_u6253_u5305_u8C03_u8BD5" class="headerlink" title="0x04 本地调试与打包调试"></a>0x04 本地调试与打包调试</h2><p>在编写的过程中，也需要进行调试，调试有两种方法：一种是本地调试，一种是打包调试</p>
<h3 id="u672C_u5730_u8C03_u8BD5"><a href="#u672C_u5730_u8C03_u8BD5" class="headerlink" title="本地调试"></a>本地调试</h3><p>我们在加载bundle时，需要替换成你的ip地址，端口号不要变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSURL URLWithString:@&#34;http://172.17.9.94:8081/index.ios.bundle?platform=ios&#34;]</span><br></pre></td></tr></table></figure>
<p>如果你是在真机上调试，你需要开启HTTP代理，填写你的ip地址和端口号</p>
<p>在终端上，先进入到你的项目目录（与node_modules目录同级），然后开启服务</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yzydeMacBook-Pro:shangjiaban-ios yzy$ npm start</span><br></pre></td></tr></table></figure>
<p>你修改了某处之后，在模拟器上点击<code>Shake Gesture</code>或者快捷键，在真机上只要摇一摇就可以</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Shake.png!400x400" alt=""></p>
<p>在模拟器弹出框里选择<code>Roload</code>，这样就会重新加载你本地的JS文件</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/simulation.png!400x400" alt=""></p>
<p>如果你想查看JS里面的log日志，你可以选择<code>Start Remote JS Debugging</code>，在chrome浏览器里就能看到输出的日志了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/chromeDebug.png" alt=""></p>
<h3 id="u6253_u5305_u8C03_u8BD5"><a href="#u6253_u5305_u8C03_u8BD5" class="headerlink" title="打包调试"></a>打包调试</h3><p>另外一种就是打包调试，但是比较麻烦，首先我们要讲bundle加载方式改为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSBundle mainBundle] URLForResource:@&#34;bundle/index.ios&#34; withExtension:@&#34;jsbundle&#34;];</span><br></pre></td></tr></table></figure>
<p>然后在终端里面，输入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yzydeMacBook-Pro:shangjiaban-ios yzy$ react-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output ./xxx/bundle/index.ios.jsbundle --assets-dest ./xxx/bundle</span><br></pre></td></tr></table></figure>
<p><code>--bundle-output ./xxx/bundle/index.ios.jsbundle</code>指的是输出的bundle文件路径</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[20:54:43] &#60;START&#62; Building Dependency Graph&#10;[20:54:43] &#60;START&#62; Crawling File System&#10;[20:54:43] &#60;START&#62; find dependencies&#10;[20:54:48] &#60;END&#62;   Crawling File System (4712ms)&#10;[20:54:48] &#60;START&#62; Building in-memory fs for JavaScript&#10;[20:54:48] &#60;END&#62;   Building in-memory fs for JavaScript (230ms)&#10;[20:54:48] &#60;START&#62; Building in-memory fs for Assets&#10;[20:54:48] &#60;END&#62;   Building in-memory fs for Assets (154ms)&#10;[20:54:48] &#60;START&#62; Building Haste Map&#10;[20:54:48] &#60;START&#62; Building (deprecated) Asset Map&#10;[20:54:48] &#60;END&#62;   Building (deprecated) Asset Map (66ms)&#10;[20:54:48] &#60;END&#62;   Building Haste Map (154ms)&#10;[20:54:48] &#60;END&#62;   Building Dependency Graph (5261ms)&#10;transformed 372/372 (100%)&#10;[20:54:49] &#60;END&#62;   find dependencies (6402ms)&#10;bundle: start&#10;bundle: finish&#10;bundle: Writing bundle output to: ./Koudaitong/bundle/index.ios.jsbundle&#10;bundle: Copying 5 asset files&#10;bundle: Done writing bundle output&#10;bundle: Done copying assets</span><br></pre></td></tr></table></figure>
<p>当看到这样的信息的时候，说明已经打包成功了，再将生成的bundle文件夹以<code>Create folder references</code>形式加到工程里，然后就可以run了</p>
<p>Tip:</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在真机调试时，需要在Edit Scheme里在<span class="keyword">Run</span>模式里，将Build Configuration改为<span class="keyword">Release</span>模式</span><br></pre></td></tr></table></figure>
<h2 id="0x05__u8FDC_u7A0B_u70ED_u66F4_u65B0"><a href="#0x05__u8FDC_u7A0B_u70ED_u66F4_u65B0" class="headerlink" title="0x05 远程热更新"></a>0x05 远程热更新</h2><p>这块网上的方案大同小异，因为目前我们还是采取本地打包加载的方式，还未上热更新，所以在这不好多做说明，等上了热更新之后，我再来补充~</p>
<p>2016年11月23日更新：</p>
<p>Tips：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该热更新方法取自于有赞技术团队官方博客里《React <span class="keyword">Native</span>有赞初探》，欢迎关注我们技术团队的博客~</span><br></pre></td></tr></table></figure>
<h3 id="u9009_u578B"><a href="#u9009_u578B" class="headerlink" title="选型"></a>选型</h3><p>经过调研和选型，最终选择了微软出品的 <code>CodePush</code> 作为 <code>React Native</code> 热部署方案。</p>
<p><code>CodePush</code> 是提供给 <code>React Native</code> 开发者直接部署移动应用更新给用户设备的云服务。<code>CodePush</code> 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 <code>SDK</code> 里面查询更新。<code>CodePush</code> 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。</p>
<p><code>CodePush</code> 可以进行实时的推送代码更新：</p>
<ul>
<li>直接对用户部署代码更新</li>
<li>管理 <code>Alpha</code> ， <code>Beta</code> 和生产环境应用</li>
<li>支持 <code>JavaScript</code> 文件与图片资源的更新</li>
<li>暂不支持增量更新</li>
</ul>
<p><code>CodePush</code> 开源了 <code>react-native</code> 版本，<a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="external">react-native-code-push</a>托管在GitHub上。</p>
<p>具体的教程和用法微软都在 <code>Github上</code> 做了详细说明，接下来简单地梳理一下从配置、编码、部署等具体流程。</p>
<p>(1) 安装 <code>CodePush CLI</code></p>
<p>管理 <code>CodePush</code> 账号需要通过 <code>NodeJS-based CLI</code>。 只需要在终端输入 <code>npm install -g code-push-cli</code> ，就可以安装了。 安装完毕后，输入 <code>code-push -v</code> 查看版本，如看到版本代表成功。</p>
<p>(2) 创建一个 <code>CodePush</code> 账号 在终端输入 <code>code-push register</code> ，会打开如下注册页面让你选择授权账号。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/codepush.png" alt=""></p>
<p>授权通过之后，<code>CodePush</code> 会告诉你“access key”，复制此key到终端即可完成注册。</p>
<p>然后终端输入 <code>code-push login</code> 进行登陆，登陆成功后，你的session文件将会写在 /Users/你的用户名 <code>/.code-push.config</code>。</p>
<p>(3) 在CodePush服务器注册app 为了让 <code>CodePush</code> 服务器知道你的app，我们需要向它注册app： 在终端输入 <code>code-push app add</code> 即可完成注册。</p>
<p>例如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">code</span>-<span class="keyword">push </span>app <span class="keyword">add </span>shangjiaban-<span class="keyword">android</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是iOS平台，命令为 <code>code-push app add shangjiaban-ios</code> ， <code>Android</code> 和 <code>iOS</code> 必须要区分</p>
</blockquote>
<p>还有很多 <code>code-push app</code> 相关的命令，参考如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$: code-push app <span class="operator"><span class="keyword">help</span></span><br><span class="line"><span class="keyword">Usage</span>: code-push app &lt;command&gt;</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  <span class="keyword">add</span>       <span class="keyword">Add</span> a <span class="keyword">new</span> app <span class="keyword">to</span> your <span class="keyword">account</span></span><br><span class="line">  remove    Remove an app <span class="keyword">from</span> your <span class="keyword">account</span></span><br><span class="line">  rm        Remove an app <span class="keyword">from</span> your <span class="keyword">account</span></span><br><span class="line">  <span class="keyword">rename</span>    <span class="keyword">Rename</span> an existing app</span><br><span class="line">  <span class="keyword">list</span>      Lists the apps associated <span class="keyword">with</span> your <span class="keyword">account</span></span><br><span class="line">  ls        Lists the apps associated <span class="keyword">with</span> your <span class="keyword">account</span></span><br><span class="line">  transfer  Transfer the ownership <span class="keyword">of</span> an app <span class="keyword">to</span> another <span class="keyword">account</span></span></span><br></pre></td></tr></table></figure>
<h3 id="iOS_u914D_u7F6E"><a href="#iOS_u914D_u7F6E" class="headerlink" title="iOS配置"></a>iOS配置</h3><p>iOS平台上关于 <code>CodePush</code> 的配置和 <code>Android</code> 平台是类似的，可以参考上文的(1)(2)(3)，iOS平台集成 <code>CodePush</code> 比较简单，官网提供了3种集成方式，这里重点介绍如何通过 <code>cocoapods</code> 来集成。</p>
<p>(1) 引入 <code>CodePush</code></p>
<p>首先在Podfile文件中添加 <code>CodePush</code>，配置如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'CodePush'</span>, :path =&gt; <span class="string">'./node_modules/react-native-code-push'</span></span><br></pre></td></tr></table></figure>
<p>然后执行 <code>pod install</code> 就可以了。</p>
<p>(2) 声明 <code>bundle</code> 文件来源</p>
<p>引入 <code>CodePush</code> 后还需要在代码中声明 <code>bundle</code> 的加载来源，之前是加载本地的<code>bundle</code>文件，现在需要调用 <code>CodePush</code> 提供的方法指定加载 <code>Bundle</code> 文件，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"CodePush.h"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 原来的bundle加载方法</span></span><br><span class="line">jsCodeLocation = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"main"</span> withExtension:<span class="string">@"jsbundle"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// CodePush的bundle加载方法，这里的bundleURL默认加载的是main.jsbundle，</span></span><br><span class="line"><span class="comment">// 如果你的名称不一样，需要调用CodePush提供的其他方法来自定义。</span></span><br><span class="line">jsCodeLocation = [CodePush bundleURL];</span><br></pre></td></tr></table></figure>
<p>最后还需要在 <code>Info.plist</code> 中添加一个 <code>key</code> 为 <code>CodePushDeploymentKey</code> ,其<code>value</code> 就是 <code>CodePush</code> 提供的唯一 <code>token</code> 值。具体获取方法，可以通过如下命令获得</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">code</span>-<span class="keyword">push </span>deployment ls &lt;appName&gt; -k</span><br></pre></td></tr></table></figure>
<h3 id="RN_u914D_u7F6E"><a href="#RN_u914D_u7F6E" class="headerlink" title="RN配置"></a>RN配置</h3><p>为了达到更好的体验效果，我们决定采用静默升级的策略，让用户无感知地体验热更新，也可以是具体的升级流程图如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/updateStrategy.png!500x500" alt=""></p>
<p>如果要达成上述热部署效果，那么还需要在 <code>JavaScript</code> 文件中完成更新时机和更新策略的设置。</p>
<p>(1)在js中导入 <code>CodePush</code> 模块：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codePush <span class="keyword">from</span> <span class="string">'react-native-code-push'</span></span><br></pre></td></tr></table></figure>
<p>(2)在 <code>componentDidMount</code> 中调用 <code>sync</code> 方法，后台请求更新</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codePush.<span class="function"><span class="title">sync</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果是非强制并允许更新， <code>CodePush</code> 会在后台静默地将更新下载到本地，等待APP再一次启动或者加载 <code>React Native</code> 页面的时候更新应用。</p>
<p>如果更新是强制性的，更新文件下载好之后会立即进行更新。关于如何配置是否强制更新，会在下文发布更新处重点说明。</p>
<p>如果你期望更及时的获得更新，可以在每次APP从后台进入前台的时候去主动的检查更新：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AppState.addEventListener(<span class="string">"change"</span>, <span class="function"><span class="params">(newState)</span> =&gt;</span> &#123;  </span><br><span class="line">        newState === <span class="string">"active"</span> &amp;&amp; codePush.sync(&#123;</span><br><span class="line">            <span class="attribute">installMode</span>:codePush.InstallMode.ON_NEXT_RESUME,</span><br><span class="line">            <span class="attribute">deploymentKey</span>: DEPLOYMENT_KEY,</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上述流程图提及的三种更新方式，就是通过 <code>installMode</code> 参数控制的，取值方式分别为：</p>
<ol>
<li><code>codePush.InstallMode.ON_NEXT_RESTART</code>即下一次启动的时候安装更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESUME</code>即下一次切后台切换的时候安装更新</li>
<li><code>codePush.InstallMode. IMMEDIATE</code>立即下载安装更新</li>
</ol>
<blockquote>
<p>如果发布更新时 <code>mandatory</code> 参数为true，即强制更新，则上述设置都会无效，只有<code>mandatory</code> 参数为fasle时，设置才会有效。</p>
</blockquote>
<h3 id="u6253_u5305_u5E76_u53D1_u5E03"><a href="#u6253_u5305_u5E76_u53D1_u5E03" class="headerlink" title="打包并发布"></a>打包并发布</h3><p>(1) 打包js 发布更新之前，需要先把js打包成 <code>bundle</code> ，以下是Android的做法：</p>
<p>第一步： 在 <code>Android</code> 工程目录里面新增 <code>release</code> 文件： <code>mkdir release</code> ，对于iOS来说，目前 <code>bundle</code> 文件直接放在工程根目录下，所以无需这一步。 第二步： 运行命令打包</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">react</span><span class="literal">-</span><span class="comment">native</span> <span class="comment">bundle</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">platform</span> <span class="comment">平台</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">entry</span><span class="literal">-</span><span class="comment">file</span> <span class="comment">启动文件</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bundle</span><span class="literal">-</span><span class="comment">output</span> <span class="comment">打包js输出文件</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">assets</span><span class="literal">-</span><span class="comment">dest</span> <span class="comment">资源输出目录</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">dev</span> <span class="comment">是否调试。</span></span><br></pre></td></tr></table></figure>
<p>例如:</p>
<p>Android</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">react</span>-native <span class="keyword">bundle </span>--platform <span class="keyword">android </span>--<span class="preprocessor">entry</span>-file index.<span class="keyword">android.js </span>--<span class="keyword">bundle-output </span>./release/index.<span class="keyword">android.bundle </span>--assets-dest ./release --dev false</span><br></pre></td></tr></table></figure>
<p>iOS</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">react</span><span class="literal">-</span><span class="comment">native</span> <span class="comment">bundle</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">platform</span> <span class="comment">ios</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">entry</span><span class="literal">-</span><span class="comment">file</span> <span class="comment">index</span><span class="string">.</span><span class="comment">ios</span><span class="string">.</span><span class="comment">js</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bundle</span><span class="literal">-</span><span class="comment">output</span> <span class="string">.</span><span class="comment">/Koudaitong/main</span><span class="string">.</span><span class="comment">jsbundle</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">assets</span><span class="literal">-</span><span class="comment">dest</span> <span class="string">.</span><span class="comment">/Koudaitong</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">dev</span> <span class="comment">false</span></span><br></pre></td></tr></table></figure>
<p>(2) 发布更新</p>
<p>打包 <code>bundle</code> 结束后，就可以通过 <code>CodePush</code> 发布更新了。在终端输入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code-push release <span class="tag">&lt;<span class="title">应用名称</span>&gt;</span> <span class="tag">&lt;<span class="title">Bundles所在目录</span>&gt;</span> <span class="tag">&lt;<span class="title">对应的应用版本</span>&gt;</span> --deploymentName： 更新环境  </span><br><span class="line">--description： 更新描述 --mandatory： 是否强制更新</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p>Android</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push release shangjiaban-android ./release <span class="number">3.12</span><span class="number">.1</span> --description <span class="string">"update React Native"</span> --mandatory <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>iOS</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-<span class="keyword">push</span> release shangjiaban-ios .<span class="regexp">/Koudaitong/m</span>ain.jsbundle <span class="number">3.12</span>.<span class="number">0</span> --<span class="keyword">description</span> <span class="string">"update React Native"</span> --mandatory <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
</blockquote>
<ol>
<li><code>CodePush</code> 默认是更新 <code>Staging</code> 环境的，如果是 <code>Staging</code> ，则不需要填写<code>deploymentName</code>。</li>
<li>如果有 <code>mandatory</code> 则 <code>Code Push</code> 会根据 <code>mandatory</code> 是 <code>true</code> 或<code>false</code> 来控制应用是否强制更新。默认情况下 <code>mandatory</code> 为 <code>false</code> 即不强制更新。</li>
<li>对应的应用版本 <code>targetBinaryVersion</code> 是指当前app的版本(对应 <code>build.gradle</code> 中设置的versionName “3.12.1”)，也就是说此次更新的 <code>js/images</code> 对应的是app的那个版本。不要将其理解为这次js更新的版本。 如客户端版本是3.12.1，那么我们对3.12.1的客户端更新 <code>js/images</code> ， <code>targetBinaryVersion</code> 填的就是3.12.1。</li>
<li>对于对某个应用版本进行多次更新的情况， <code>CodePush</code> 会检查每次上传的 <code>bundle</code> ，如果在该版本下如3.12.1已经存在与这次上传完全一样的 <code>bundle</code> (对应一个版本有两个 <code>bundle</code> 的 <code>md5</code> 完全一样)，那么 <code>CodePush</code> 会拒绝此次更新。</li>
</ol>
<h2 id="0x06_iOS_u548CAndroid_u4E0D_u540C_u6837_u5F0F_u5904_u7406"><a href="#0x06_iOS_u548CAndroid_u4E0D_u540C_u6837_u5F0F_u5904_u7406" class="headerlink" title="0x06 iOS和Android不同样式处理"></a>0x06 iOS和Android不同样式处理</h2><p>最近看到FB的F8代码里面对于iOS和Android不同平台上样式的处理觉得挺不错的，由于系统原生控件样式设计风格的不一样，导致在写style的时候会根据不同的platform来写，之前做法是定义不同的style，然后判断platform去用，这样style里面的代码会存在冗余，而且对style的定义也不好</p>
<p>FB的做法是定义一个style的基类，然后基类里解析平台信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">styles: Object</span>): </span>&#123;[name: string]: number&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> platformStyles = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.keys(styles).forEach((name) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;ios, android, ...style&#125; = &#123;...styles[name]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ios &amp;&amp; Platform.OS === <span class="string">'ios'</span>) &#123;</span><br><span class="line">      style = &#123;...style, ...ios&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (android &amp;&amp; Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">      style = &#123;...style, ...android&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    platformStyles[name] = style;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> StyleSheet.create(platformStyles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在style里面，写iOS和Android的样式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">button: &#123;</span><br><span class="line">    borderColor: <span class="string">'transparent'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    justifyContent: <span class="string">'center'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'transparent'</span>,</span><br><span class="line">    ios: &#123;</span><br><span class="line">      height: HEIGHT,</span><br><span class="line">      paddingHorizontal: <span class="number">20</span>,</span><br><span class="line">      borderRadius: HEIGHT / <span class="number">2</span>,</span><br><span class="line">      borderWidth: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    android: &#123;</span><br><span class="line">      paddingBottom: <span class="number">6</span>,</span><br><span class="line">      paddingHorizontal: <span class="number">10</span>,</span><br><span class="line">      borderBottomWidth: <span class="number">3</span>,</span><br><span class="line">      marginRight: <span class="number">10</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="0x07__u8E29_u5751_u8BB0_u5F55"><a href="#0x07__u8E29_u5751_u8BB0_u5F55" class="headerlink" title="0x07 踩坑记录"></a>0x07 踩坑记录</h2><p>踩坑最多是应该是使用上的</p>
<p>1.RN系统的组件并不是所有都是共用的，比如segment支持iOS，不支持Android，Alert分为iOS和Android等等，所以还是要写重复的代码</p>
<p>2.ListView不支持iOS原生的滑动操作，需要使用第三方库，但是第三方库不能控制只编辑一个Cell</p>
<p>3.由于原先iOS和Android的代码仓库是分开的，所以接入RN时，JS文件也是跟着仓库走的，这样iOS和Android会存在重复代码，并且目前两个人分别接iOS和Android，写JS时，有时并不共享，容易代码写着写着就有差异了，偏离了Write Once , Run Anywhere的初衷</p>
<h2 id="0x08__u76F8_u5173_u8D44_u6599"><a href="#0x08__u76F8_u5173_u8D44_u6599" class="headerlink" title="0x08 相关资料"></a>0x08 相关资料</h2><p><a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a></p>
<p><a href="http://reactnative.cn/" target="_blank" rel="external">React Native 中文网</a></p>
<p><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="external">汇集了各类react-native学习资源、开源App和组件</a></p>
<p><a href="http://blog.talisk.cn/blog/2016/08/13/RN-Learning-path-for-iOS-developer/" target="_blank" rel="external">写给 iOS 开发者的 React Native 学习路线</a></p>
<p><a href="http://www.lcode.org/" target="_blank" rel="external">江清清的技术专栏</a></p>
<p><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8" target="_blank" rel="external">React/React Native 的ES5 ES6写法对照表</a></p>
<p><a href="http://tech.youzan.com/react-native-zan/" target="_blank" rel="external">React Native有赞初探</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/09/08/iOS-Drawer-Table-View/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/10/09/react-native/';
var disqus_title = '项目接入使用React Native';
var disqus_url = 'http://yuzeyang.github.io/2016/10/09/react-native/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>