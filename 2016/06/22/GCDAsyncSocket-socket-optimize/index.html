<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS Socket重构设计 · 宫城</title><meta name="description" content="iOS Socket重构设计 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS Socket重构设计</h1><div class="post-info">2016年6月22日</div><div class="post-content"><p>之前基于GCDAsyncSocket封装了一个Socket Manager类，但是由于业务复杂度的上升，之前设计的业务接口的数量逐渐增加，代理回调也随之增加，代理的使用也越来越麻烦，所以我们针对socket通信这块，进行了一次重构</p>
<p>这里有我们的新童鞋<a href="http://broccoliii.me/" target="_blank" rel="external">西兰花</a>很大的功劳哈~</p>
<p>代码地址：<a href="https://github.com/Yuzeyang/GCDAsyncSocketManager" target="_blank" rel="external">GCDAsyncSocketManager</a></p>
<a id="more"></a>
<p>之前的设计方案可以看这里：<a href="http://zeeyang.com/2016/01/17/GCDAsyncSocket-socket/" target="_blank" rel="external">socket重构前方案</a></p>
<p>针对老的设计，我们做出了以下几点修改方向：</p>
<h2 id="0x00__u62C6_u5206SocketManager"><a href="#0x00__u62C6_u5206SocketManager" class="headerlink" title="0x00 拆分SocketManager"></a>0x00 拆分SocketManager</h2><p>首先我们对SocketManager进行开刀，我们将socket相关的操作和业务相关的操作进行拆分，将业务相关的单独放到一个类里面完成，我们命名它为CommunicationManager</p>
<p>现在在SocketManager里面，我们只保留了<code>服务器读写数据</code>、<code>断开连接</code>、<code>心跳</code>、<code>重连</code>、<code>GCDAsyncSocket回调设置</code></p>
<p>在CommunicationManager里面，我们做所有业务的操作</p>
<h2 id="0x01__u4E1A_u52A1_u63A5_u53E3_u6539_u4E3A_u901A_u7528_u63A5_u53E3"><a href="#0x01__u4E1A_u52A1_u63A5_u53E3_u6539_u4E3A_u901A_u7528_u63A5_u53E3" class="headerlink" title="0x01 业务接口改为通用接口"></a>0x01 业务接口改为通用接口</h2><p>由于业务请求类型的不断增加，业务接口的数量也在不断增加，这样使得头文件一眼望不到底…自己看起来都很头疼，更别说是使用方了…</p>
<p>首先我们将不同的业务请求以枚举的方式列出来，方便外部调用的时候查看，并且最好在枚举后面加上注释，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; *  &#19994;&#21153;&#31867;&#22411;&#10; */&#10;typedef NS_ENUM(NSInteger, FIMRequestType) &#123;&#10;    FIMRequestType_Beat = 1,                       //&#24515;&#36339;&#10;    FIMRequestType_ConnectionAuthAppraisal,        //&#36830;&#25509;&#37492;&#26435;&#10;  &#9;FIMRequestType_GetConversationsList,           //&#33719;&#21462;&#20250;&#35805;&#21015;&#34920;&#10;    ...&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以将业务接口用下面这一个通用的接口替换掉，只需要传<code>type</code>业务请求类型，<code>body</code>请求体和<code>callback</code>回调</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; *  &#21521;&#26381;&#21153;&#22120;&#21457;&#36865;&#25968;&#25454;&#10; *&#10; *  @param type    &#35831;&#27714;&#31867;&#22411;&#10; *  @param body    &#35831;&#27714;&#20307;&#10; */&#10;- (void)socketWriteDataWithRequestType:(FIMRequestType)type&#10;                           requestBody:(nonnull NSDictionary *)body&#10;                            completion:(nullable SocketDidReadBlock)callback;</span><br></pre></td></tr></table></figure>
<p>比如业务方可以如下使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *requestBody = @&#123; @&#34;limit&#34;: @(10), @&#34;offset&#34;: @(0) &#125;;&#10;[[FIMCommunicationManager sharedInstance]&#10;socketWriteDataWithRequestType:FIMRequestType_GetConversationsList&#10;                   requestBody:requestBody&#10;                    completion:^(NSError *error, id data) &#123;&#10;                        // do something&#10;                    &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="0x02__u544A_u522BDelegate_uFF0C_u4F7F_u7528Blcok"><a href="#0x02__u544A_u522BDelegate_uFF0C_u4F7F_u7528Blcok" class="headerlink" title="0x02 告别Delegate，使用Blcok"></a>0x02 告别Delegate，使用Blcok</h2><p>前面也提到，之前会对不同的业务请求，设定相应的delegate回调，但是数量一多，使用起来那真的是槽糕，所以我们参考<code>AFNetworking</code>的做法，发起请求时将block与一个唯一标识进行绑定，同时将这个唯一标识放到请求里面发给服务器（服务器对该标识不做任何处理），在等到GCDAsyncSocket回调回来的时候，我们通过服务器返回的这个标识，找到对应的block回调出去，这样对业务方来说，这个socket接口用起来其实和HTTP请求接口是一模一样的，将请求的上下文也关联起来了</p>
<p>如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/replaceDelegate.png" alt=""></p>
<p>具体实现：</p>
<p>发起请求时</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)socketWriteDataWithRequestType:(FIMRequestType)type&#10;                           requestBody:(nonnull NSDictionary *)body&#10;                            completion:(nullable SocketDidReadBlock)callback &#123;&#10;  // ...                            &#10;   &#10;  // &#29983;&#25104;&#21807;&#19968;&#26631;&#35782;&#10;  NSString *blockRequestID = [self createRequestID];&#10;  if (callback) &#123;&#10;      // &#23558;block&#21644;&#26631;&#35782;&#36827;&#34892;&#32465;&#23450;&#65292;&#23384;&#21040;&#19968;&#20010;&#20840;&#23616;&#21464;&#37327;&#37324;&#38754;&#10;      [self.requestsMap setObject:callback forKey:blockRequestID];&#10;  &#125;&#10;                              &#10;  // ...&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接收到GCDAsyncSocket回调时</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &#123;&#10;  // ...&#10;  &#10;  // &#26681;&#25454;&#26381;&#21153;&#22120;&#36820;&#22238;&#30340;&#26631;&#35782;&#24471;&#21040;&#30456;&#24212;&#30340;block&#10;  SocketDidReadBlock didReadBlock = self.requestsMap[requestID];&#10;  &#10;  switch (requestType) &#123;&#10;        case FIMRequestType_ConnectionAuthAppraisal: &#123;&#10;            if (didReadBlock) &#123;&#10;                didReadBlock(nil, nil);&#10;            &#125;&#10;        &#125; break;&#10;    &#9;// ...&#10;    &#9;default: &#123;&#10;            // do something&#10;        &#125; break;&#10;  &#125;&#10;  &#10;  // ...&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03__u4F7F_u7528_u6A21_u62DF_u670D_u52A1_u5668_u65F6_u95F4_uFF0C_u6765_u89E3_u51B3_u7F13_u5B58_u6D88_u606F_u4FDD_u5E8F_u95EE_u9898"><a href="#0x03__u4F7F_u7528_u6A21_u62DF_u670D_u52A1_u5668_u65F6_u95F4_uFF0C_u6765_u89E3_u51B3_u7F13_u5B58_u6D88_u606F_u4FDD_u5E8F_u95EE_u9898" class="headerlink" title="0x03 使用模拟服务器时间，来解决缓存消息保序问题"></a>0x03 使用模拟服务器时间，来解决缓存消息保序问题</h2><p>在socket模块里面，我们基于FMDB实现了一套缓存机制，但是聊天页面对数据库读写操作的场景非常复杂，而且我们对发送失败的消息也进行了缓存，如果使用msgID对消息进行保序，你要考虑发送成功和失败消息的排序，以及重发消息之后的排序，等等场景，这样实现起来也会很让人头大</p>
<p>所以我们采用<code>消息的创建时间</code>来进行保序，这样不管消息是怎么操作的，从数据库里面读出来的数据，我们只需要根据创建时间来排下序返回给业务层，如果业务层对数据进行修改的时候，我们更新消息的创建时间，这样下次取出来的顺序和UI展示的顺序也还是一样的</p>
<p>那这个创建时间是由服务器生成的，而且消息发送成功之后，服务器也不会返回给我们这条消息的创建时间，而且失败的消息服务器那边是不会存的，所以就需要我们本地模拟服务器来生成这个时间</p>
<p>因为考虑到本地时间和服务器时间存在偏差，所以我们在socket建立连接成功之后，返回给我们服务器时间，我们拿到服务器时间之后和手机的本地时间做个比较，记录下这个偏差值，然后业务层在调用发送消息的接口时，socket内部模拟出服务器创建时间赋值给该消息，然后存到数据库里面，这样就可以基本保证数据库存储消息的顺序和服务器的顺序是一致的</p>
<p>如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/serverCreateTime.png" alt=""></p>
<h2 id="0x04__u76D1_u542C_u7F51_u7EDC_u72B6_u6001_u6765_u6539_u53D8socket_u8FDE_u63A5_u72B6_u6001"><a href="#0x04__u76D1_u542C_u7F51_u7EDC_u72B6_u6001_u6765_u6539_u53D8socket_u8FDE_u63A5_u72B6_u6001" class="headerlink" title="0x04 监听网络状态来改变socket连接状态"></a>0x04 监听网络状态来改变socket连接状态</h2><p>我们对socket连接状态也做了微调，我们通过测试微信的连接，发现以下两点：</p>
<p>1、网络断开后，socket直接断开，显示“未连接”</p>
<p>2、有网但是socket连接不上时，socket会一直重连，重连n次后，休眠几秒后，再重连，如此循环</p>
<p>所以我们也对socket连接做了调整，用<code>AFNetWorking</code>库里面监测网络状态类<code>AFNetworkReachabilityManager</code>（<a href="http://zeeyang.com/2016/05/23/AFNetWorking-four/" target="_blank" rel="external">AFNetworkReachabilityManager原理</a>），在无网时，判断如果socket正在连接或者已连接时，我们主动调用<code>disconnect</code>断开连接，如果有网，判断如果socket未连接，我们主动建立连接，建立连接不成功的情况时，我们走重连的流程，只是我们依旧保持了重连n次后，n次失败后不再重连了，这个是与微信不同的地方</p>
<h2 id="0x05__u4F7F_u7528FIMSocketModel"><a href="#0x05__u4F7F_u7528FIMSocketModel" class="headerlink" title="0x05 使用FIMSocketModel"></a>0x05 使用FIMSocketModel</h2><p>因为请求的数据结构基本一样，所以我们定义了FIMSocketModel类来方便对数据的转化，我们定义了几个必传的字段，以及可能请求不同所需的一些非必传字段，由于之前我们body体里面的内容是做了2次JSON转化处理的，所以业务层传入body内容时叫苦连天，FIMSocketModel也增加了<code>- socketModelToJSONString</code>方法，方便Socket内部转化成JSON处理，这样业务层只需要传一个字典进来，Socket内部就会处理好一切，使用起来一下就方便了~</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/05/IM-UI-optimize/" class="prev">PREV</a><a href="/2016/06/13/Qiniu-token/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/06/22/GCDAsyncSocket-socket-optimize/';
var disqus_title = 'iOS Socket重构设计';
var disqus_url = 'http://yuzeyang.github.io/2016/06/22/GCDAsyncSocket-socket-optimize/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>