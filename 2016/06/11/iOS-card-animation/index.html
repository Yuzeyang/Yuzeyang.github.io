<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 模仿iOS7 task switcher的卡片动画 · 宫城</title><meta name="description" content="模仿iOS7 task switcher的卡片动画 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">模仿iOS7 task switcher的卡片动画</h1><div class="post-info">2016年6月11日</div><div class="post-content"><p>最近看到一个iOS9的task switcher开源实现，但是没有删除功能，就想着干脆做一个模仿iOS7系统的效果，加上删除和重用卡片功能，效果图如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCCardViewController.gif!500x500" alt=""></p>
<p>这是代码地址：<a href="https://github.com/Yuzeyang/GCCardViewController" target="_blank" rel="external">https://github.com/Yuzeyang/GCCardViewController</a></p>
<a id="more"></a>
<p>实现上可以使用scrollView或者collectionView去做，这个我是用scrollView去做</p>
<p>功能点上分为三点：</p>
<p>1.卡片滑动的效果</p>
<p>2.卡片重用</p>
<p>3.卡片删除</p>
<h2 id="u5361_u7247_u6ED1_u52A8_u6548_u679C"><a href="#u5361_u7247_u6ED1_u52A8_u6548_u679C" class="headerlink" title="卡片滑动效果"></a>卡片滑动效果</h2><p>通过- [scrollViewDidScroll:]代理获取scrollView滑动时的contentOffset值，计算当前contentOffset和原先contentOffset之间的差值diff，再算出进度值progress，以及根据差值diff是否大于0来获取卡片的滑动方向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</div><div class="line">    CGFloat orginContentOffset = self.currentCardIndex*kGCScrollViewWidth;</div><div class="line">    CGFloat diff = scrollView.contentOffset.x - orginContentOffset;</div><div class="line">    CGFloat progress = fabs(diff)/(kGCViewWidth*0.8);</div><div class="line">    CardMoveDirection direction = diff &gt; 0 ? CardMoveDirectionLeft : CardMoveDirectionRight;</div><div class="line">    for (UIView *card in self.cards) &#123;</div><div class="line">        [self.cardDelegate updateCard:card withProgress:progress direction:direction];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 卡片重用</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用自己的cardDelegate方法更新卡片的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)updateCard:(UIView *)card withProgress:(CGFloat)progress direction:(CardMoveDirection)direction;</div></pre></td></tr></table></figure>
<p>当前卡片不管是左移还是右移，只需要根据progress来更新状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">card.layer.transform = CATransform3DMakeScale(1 - 0.1 * progress, 1 - 0.1 * progress, 1.0);</div><div class="line">card.layer.opacity = 1 - 0.2*progress;</div></pre></td></tr></table></figure>
<p>根据左移还是右移，来决定改变当前卡片下一张还是上一张卡片的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSInteger transCardTag = direction == CardMoveDirectionLeft ? [self.cardScrollView currentCard] + 1 : [self.cardScrollView currentCard] - 1;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">card.layer.transform = CATransform3DMakeScale(0.9 + 0.1*progress, 0.9 + 0.1*progress, 1.0);</div><div class="line">card.layer.opacity = 0.8 + 0.2*progress;</div></pre></td></tr></table></figure>
<h2 id="u5361_u7247_u91CD_u7528"><a href="#u5361_u7247_u91CD_u7528" class="headerlink" title="卡片重用"></a>卡片重用</h2><p>由于页面上只显示三张卡片，所以要重用卡片的话，我们需要初始化四张卡片，类似于tableViewCell的重用处理一样，当第一张卡片离开屏幕显示之后，将第一张卡片移到最后一张卡片的后面，反之，同理</p>
<p>在- [scrollViewDidScroll:]里面，根据contentOffset变化的绝对值大于scrollView宽度的80%时，对卡片进行重用，以及改变当前的index</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (fabs(diff) &gt;= kGCScrollViewWidth*0.8) &#123;</div><div class="line">        self.currentCardIndex = direction == CardMoveDirectionLeft ? self.currentCardIndex + 1 : self.currentCardIndex - 1;</div><div class="line">        [self reuseCardWithMoveDirection:direction];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在重用之前，并不是所有位置都需要重用，在index（index从0开始计算）小于2或者index大于总卡片数量-3的时候，才需要重用，左移时，取出cards数组里面第一个card，将card移到最后一个card后面，改变它的center就可以，右移时，取出最后一个card，移到第一个card前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)reuseCardWithMoveDirection:(CardMoveDirection)moveDirection &#123;</div><div class="line">    BOOL isLeft = moveDirection == CardMoveDirectionLeft;</div><div class="line">    UIView *card = nil;</div><div class="line">    if (isLeft) &#123;</div><div class="line">        if (self.currentCardIndex &gt; self.totalNumberOfCards - 3 || self.currentCardIndex &lt; 2) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        card = [self.cards objectAtIndex:0];</div><div class="line">        card.tag+=4;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (self.currentCardIndex &gt; self.totalNumberOfCards - 4 ||</div><div class="line">            self.currentCardIndex &lt; 1) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        card = [self.cards objectAtIndex:3];</div><div class="line">        card.tag-=4;</div><div class="line">    &#125;</div><div class="line">    card.center = [self centerForCardWithIndex:card.tag];</div><div class="line">    [self.cardDataSource cardReuseView:card atIndex:card.tag];</div><div class="line">    [self ascendingSortCards];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且调用- [cardReuseView:atIndex:]对重用的卡片改变数据源，最后按tag值升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (UIView *)cardReuseView:(UIView *)reuseView atIndex:(NSInteger)index &#123;</div><div class="line">    if (reuseView) &#123;</div><div class="line">        // you can set new style</div><div class="line">        return reuseView;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIView *card = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kGCCardWidth * 0.9, kGCCardHeight)];</div><div class="line">    card.layer.backgroundColor = [UIColor whiteColor].CGColor;</div><div class="line">    card.layer.cornerRadius = 4;</div><div class="line">    card.layer.masksToBounds = YES;</div><div class="line">    </div><div class="line">    return card;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="u5361_u7247_u5220_u9664"><a href="#u5361_u7247_u5220_u9664" class="headerlink" title="卡片删除"></a>卡片删除</h2><p>卡片删除是一个可选功能，通过设置canDeleteCard来添加手势</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, assign) BOOL canDeleteCard;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (self.canDeleteCard) &#123;</div><div class="line">    UIPanGestureRecognizer *deleteGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(deleteCard:)];</div><div class="line">    deleteGesture.minimumNumberOfTouches = 1;</div><div class="line">    deleteGesture.maximumNumberOfTouches = 1;</div><div class="line">    deleteGesture.delegate = self;</div><div class="line">    [card addGestureRecognizer:deleteGesture];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于卡片有拖动手势和scrollView也有拖动手势，这两个手势会出现冲突，所以我们需要根据手势的方向来判断到底应该是作用于卡片上还是scrollView上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123;</div><div class="line">    if ([gestureRecognizer isKindOfClass:[UIPanGestureRecognizer class]]) &#123;</div><div class="line">        CGPoint translatedPoint = [(UIPanGestureRecognizer *)gestureRecognizer translationInView:gestureRecognizer.view];</div><div class="line">        if (fabs(translatedPoint.y) &gt; fabs(translatedPoint.x)) &#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用卡片删除手势时，向下拖动时不做删除，向上拖动屏幕高度的一半后，删除卡片，并且重用删除后的卡片，这部分重用相对比较复杂</p>
<h5 id="u5F53_u5361_u7247_u5C0F_u4E8E_u7B49_u4E8E_u56DB_u5F20_u65F6_uFF0C_u6211_u4EEC_u76F4_u63A5_u79FB_u9664_u5F53_u524D_u7684_u5361_u7247"><a href="#u5F53_u5361_u7247_u5C0F_u4E8E_u7B49_u4E8E_u56DB_u5F20_u65F6_uFF0C_u6211_u4EEC_u76F4_u63A5_u79FB_u9664_u5F53_u524D_u7684_u5361_u7247" class="headerlink" title="当卡片小于等于四张时，我们直接移除当前的卡片"></a>当卡片小于等于四张时，我们直接移除当前的卡片</h5><p>-&gt; 如果当前卡片index为0时 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>-&gt; 如果当前卡片index为最后一张时 -&gt; 左边的卡片右移 -&gt; 左边卡片的tag不变</p>
<p>-&gt; 如果当前卡片index为中间时 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>最后按升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (self.totalNumberOfCards &lt;= 4) &#123;</div><div class="line">    [(UIView *)[self.cards objectAtIndex:index] removeFromSuperview];</div><div class="line">    [self resetTagFromIndex:index];</div><div class="line">    [self.cards removeObjectAtIndex:index];</div><div class="line">    [self ascendingSortCards];</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)resetTagFromIndex:(NSInteger)index &#123;</div><div class="line">    [self.cards enumerateObjectsUsingBlock:^(UIView *card, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        if ((NSInteger)idx &gt; index) &#123;</div><div class="line">            card.tag-=1;</div><div class="line">            [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">                card.center = [self centerForCardWithIndex:card.tag];</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当卡片超过四张时，我们需要重用删除的卡片</p>
<p>-&gt; 如果当前卡片index为0时 -&gt; 卡片的tag值加4 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>-&gt; 如果当前卡片index为最后一张时 -&gt; 卡片的tag值减4 -&gt; 左边的卡片右移 -&gt; 左边卡片的tag不变</p>
<p>-&gt; 如果当前卡片index为中间时 -&gt; 以四个卡片为一组，获取第一个卡片和最后一个卡片的tag值 -&gt; 判读最后一个卡片是否是最后一张卡片 -&gt; 如果是，则将卡片移到第一张卡片的左边，如果不是，则将卡片移到最后一张卡片的右边 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>最后按升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">UIView *card = [self.cards objectAtIndex:index];</div><div class="line">NSInteger fromIndex = index;</div><div class="line">if (index == 0) &#123;</div><div class="line">    card.tag+=4;</div><div class="line">    fromIndex = index - 1;</div><div class="line">&#125; else if (index == 3) &#123;</div><div class="line">    card.tag-=4;</div><div class="line">&#125; else &#123;</div><div class="line">    NSInteger lastTag = ((UIView *)[self.cards lastObject]).tag;</div><div class="line">    NSInteger firstTag = ((UIView *)[self.cards firstObject]).tag;</div><div class="line">    if (lastTag == self.totalNumberOfCards - 1) &#123;</div><div class="line">        card.tag = firstTag - 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        card.tag = lastTag + 1;</div><div class="line">        fromIndex = index - 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">card.center = [self centerForCardWithIndex:card.tag];</div><div class="line">[self ascendingSortCards];</div><div class="line">[self resetTagFromIndex:fromIndex];</div><div class="line">[self.cardDataSource cardReuseView:card atIndex:card.tag];</div></pre></td></tr></table></figure>
<p>最后只要改变scrollView的contentSize和卡片状态即可~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">    [self.scrollView setContentSize:CGSizeMake(kGCScrollViewWidth*self.totalNumberOfCards, kGCViewHeight)];</div><div class="line">    for (UIView *card in self.cards) &#123;</div><div class="line">        [self.cardDelegate updateCard:card withProgress:1 direction:CardMoveDirectionNone];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2016/05/27/AFNetWorking-six/" class="prev">上一篇</a><a href="/2016/06/13/Qiniu-token/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2016/06/11/iOS-card-animation/';
var disqus_title = '模仿iOS7 task switcher的卡片动画';
var disqus_url = 'http://yuzeyang.github.io/2016/06/11/iOS-card-animation/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>