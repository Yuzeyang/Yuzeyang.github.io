<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宫城</title>
  <subtitle>Talk is cheap,show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuzeyang.github.io/"/>
  <updated>2017-07-02T07:49:21.000Z</updated>
  <id>http://yuzeyang.github.io/</id>
  
  <author>
    <name>宫城</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket 实现原理</title>
    <link href="http://yuzeyang.github.io/2017/07/02/websocket/"/>
    <id>http://yuzeyang.github.io/2017/07/02/websocket/</id>
    <published>2017-07-02T02:28:06.000Z</published>
    <updated>2017-07-02T07:49:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u80CC_u666F"><a href="#u80CC_u666F" class="headerlink" title="背景"></a>背景</h2><p>之前我们将 <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">CocoaAsyncSocket</a> 作为底层实现，在其上面封装了一套 Socket 通信机制以及业务接口，最近我们开始研究 WebSocket ，并用来替换掉原先的 CocoaAsyncSocket ，简单来说一下两者的关系，WebSocket 和 Socket 虽然名称上很像，但两者是完全不同的东西， WebSocket 是建立在 TCP/IP 协议之上，属于应用层的协议，而 Socket 是在应用层和传输层中的一个抽象层，它是将 TCP/IP 层的复杂操作抽象成几个简单的接口来提供给应用层调用。为什么要做这次替换呢？原因是我们服务端在做改造，同时网页版IM已经使用了 WebSocket ，客户端也采用的话对于服务端来说维护一套代码会更好更方便，而且 WebSocket 在体积、实时性和扩展上都具有一定的优势。</p>
<p>WebSocket 最新的协议是<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external">13 RFC 6455</a> ，要理解 WebSocket 的实现，一定要去理解它的协议！~</p>
<a id="more"></a>
<p>WebSocket 的实现分为握手，数据发送/读取</p>
<h2 id="u63E1_u624B"><a href="#u63E1_u624B" class="headerlink" title="握手"></a>握手</h2><p>握手要从请求头去理解。</p>
<p>WebSocket 首先发起一个 HTTP 请求，在请求头加上  <code>Upgrade</code> 字段，该字段用改变 HTTP 协议版本或者是换用其他协议，这里我们把 <code>Upgrade</code> 的值设为 <code>websocket</code> ，将它升级为 WebSocket 协议。</p>
<p>同时要注意 <code>Sec-WebSocket-Key</code> 字段，它由客户端生成并发给服务端，用于证明服务端接收到的是一个可受信的连接握手，可以帮助服务端排除自身接收到的由非 WebSocket 客户端发起的连接，该值是一串随机经过 <code>base64</code> 编码的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</div><div class="line">Origin: http://example.com</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div></pre></td></tr></table></figure>
<p>我们可以简化请求头，将请求以字符串方式发送出去，当然别忘了最后的两个空行作为包结束：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fmt = <span class="string">"GET %s HTTP/1.1\r\n"</span></div><div class="line">                   <span class="string">"Upgrade: websocket\r\n"</span></div><div class="line">                   <span class="string">"Connection: Upgrade\r\n"</span></div><div class="line">                   <span class="string">"Host: %s\r\n"</span></div><div class="line">                   <span class="string">"Sec-WebSocket-Key: %s\r\n"</span></div><div class="line">                   <span class="string">"Sec-WebSocket-Version: 13\r\n"</span></div><div class="line">                   <span class="string">"\r\n"</span>;</div><div class="line">size = <span class="built_in">strlen</span>(fmt) + <span class="built_in">strlen</span>(path) + <span class="built_in">strlen</span>(host) + <span class="built_in">strlen</span>(ws-&gt;key);</div><div class="line">buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size);</div><div class="line"><span class="built_in">sprintf</span>(buf, fmt, path, host, ws-&gt;key);</div><div class="line">size = <span class="built_in">strlen</span>(buf);</div><div class="line">nbytes = ws-&gt;io_send(ws, ws-&gt;context, buf, size);</div></pre></td></tr></table></figure>
<p>收到请求后，服务端也会做一次响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div></pre></td></tr></table></figure>
<p>里面重要的是 <code>Sec-WebSocket-Accept</code> ，服务端通过从请求头中读取 <code>Sec-WebSocket-Key</code> 与 一串全局唯一的标识字符串（俗称魔串）“258EAFA5-E914-47DA-   95CA-C5AB0DC85B11”做拼接，生成长度为160字节的SHA-1字符串，然后进行base64编码，作为 <code>Sec-WebSocket-Accept</code> 的值回传给客户端。</p>
<p>处理握手 HTTP 响应解析的时候，可以用 nodejs 的 <a href="https://github.com/nodejs/http-parser" target="_blank" rel="external">http-paser</a> ，解析方式也比较简单，就是对头信息的逐字读取再处理，具体处理你可以看一下它的状态机实现。解析完成你需要对其内容进行解析，看返回是否正确，同时去管理你的握手状态。</p>
<h2 id="u6570_u636E_u53D1_u9001/_u8BFB_u53D6"><a href="#u6570_u636E_u53D1_u9001/_u8BFB_u53D6" class="headerlink" title="数据发送/读取"></a>数据发送/读取</h2><p>数据的处理就要拿这个帧协议图来说明了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0                   1                   2                   3</div><div class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</div><div class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</div><div class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</div><div class="line">| |1|2|3|       |K|             |                               |</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|     Extended payload length continued, if payload len == 127  |</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|                               |Masking-key, if MASK set to 1  |</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">| Masking-key (continued)       |          Payload Data         |</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|                     Payload Data continued ...                |</div><div class="line">+---------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>首先我们来看看数字的含义，数字表示位，0-7表示有8位，等于1个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div></pre></td></tr></table></figure>
<p>所以如果要组装一个帧数据可以这样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *rev = (rev *)<span class="built_in">malloc</span>(<span class="number">4</span>);</div><div class="line">rev[<span class="number">0</span>] = (<span class="keyword">char</span>)(<span class="number">0x81</span> &amp; <span class="number">0xff</span>);</div><div class="line">rev[<span class="number">1</span>] = <span class="number">126</span> &amp; <span class="number">0x7f</span>;</div><div class="line">rev[<span class="number">2</span>] = <span class="number">1</span>;</div><div class="line">rev[<span class="number">3</span>] = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>ok，了解了帧数据的样子，我们反过来去理解值对应的帧字段。</p>
<p>首先<code>0x81</code>是什么，这个是十六进制数据，转换成二进制就是<code>1000 0001</code>， 是一个字节的长度，也就是这一段里面每一位的值：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0 1 2 3 4 5 6 7 8 </div><div class="line">+-+-+-+-+-------+</div><div class="line">|F|R|R|R| opcode|</div><div class="line">|I|S|S|S|  (4)  |</div><div class="line">|N|V|V|V|       |</div><div class="line">| |1|2|3|		|</div><div class="line">+-+-+-+-+-------+</div></pre></td></tr></table></figure>
<ul>
<li><code>FIN</code> 表示该帧是不是消息的最后一帧，1表示结束，0表示还有下一帧。</li>
<li><code>RSV1, RSV2, RSV3</code> 必须为0，除非扩展协商定义了一个非0的值，如果没有定义非0值，且收到了非0的  <code>RSV</code> ，那么 WebSocket 的连接会失效。</li>
<li><code>opcode</code> 用来描述 <code>Payload data</code> 的定义，如果收到了一个位置的 <code>opcode</code> ，同样会使 WebSocket 连接失效，协议定义了以下值：<ul>
<li>%x0 表示连续的帧</li>
<li>%x1 表示text帧</li>
<li>%x2 表示二进制帧</li>
<li>%x3-7 预留给非控制帧</li>
<li>%x8 表示关闭连接帧</li>
<li>%x9 表示ping</li>
<li>%xA 表示pong</li>
<li>%xB-F 预留给控制帧</li>
</ul>
</li>
</ul>
<p><code>0xff</code> 作用就是取出需要的二进制值。</p>
<p>下面再来看<code>126</code>，126则表示的是 <code>Payload len</code> ，也就是 Payload 的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">                8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">                +-+-------------+-------------------------------+</div><div class="line">                |M| Payload len |    Extended payload length    |</div><div class="line">                |A|     (7)     |             (16/64)           |</div><div class="line">                |S|             |   (if payload len==126/127)   |</div><div class="line">                |K|             |                               |</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|     Extended payload length continued, if payload len == 127  |</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|                               |Masking-key, if MASK set to 1  |</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">| Masking-key (continued)       |           Payload Data         |</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|                     Payload Data continued ...                |</div><div class="line">+---------------------------------------------------------------+</div></pre></td></tr></table></figure>
<ul>
<li><code>MASK</code>  表示<code>Playload data</code> 是否要加掩码，如果设成1，则需要赋值 <code>Masking-key</code> 。所有从客户端发到服务端的帧都要加掩码</li>
<li><code>Playload len</code> 表示 Payload 的长度，这里分为三种情况<ul>
<li>长度小于126，则是需要7位</li>
<li>长度是126，则需要额外2个字节的大小，也就是 <code>Extended payload length</code> </li>
<li>长度是127，则需要额外8个字节的大小，也就是 <code>Extended payload length</code> + <code>Extended payload length continued</code> ，<code>Extended payload length</code> 是2个字节，<code>Extended payload length continued</code> 是6个字节</li>
</ul>
</li>
<li><code>Playload len</code> 则表示 <code>Extension data</code> 与 <code>Application data</code> 的和</li>
</ul>
<p>而数据的发送和读取就是对帧的封装和解析。</p>
<p>数据发送:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ws_recv</span><span class="params">(<span class="keyword">websocket_t</span> *ws)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ws-&gt;state != WS_STATE_HANDSHAKE_COMPLETED) &#123;</div><div class="line">        <span class="keyword">return</span> ws_do_handshake(ws);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">while</span>(TRUE) &#123;</div><div class="line">        ret = ws__recv(ws);</div><div class="line">        <span class="keyword">if</span> (ret != OK) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ws__recv</span><span class="params">(<span class="keyword">websocket_t</span> *ws)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> nbytes;</div><div class="line">    <span class="keyword">int</span> ret = OK, i;</div><div class="line">    <span class="keyword">int</span> state = ws-&gt;rd_state;</div><div class="line">    <span class="keyword">char</span> *rd_buf;</div><div class="line">    <span class="keyword">uint64_t</span> rd_buf_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span>(state) &#123;</div><div class="line">        <span class="keyword">case</span> WS_READ_IDLE: &#123;</div><div class="line">            <span class="keyword">if</span> (ws-&gt;buf_pos &lt; <span class="number">2</span>) &#123;</div><div class="line">                rd_buf_len = <span class="number">2</span> - ws-&gt;buf_pos;</div><div class="line">                rd_buf = <span class="built_in">malloc</span>(rd_buf_len);</div><div class="line">                nbytes = ws-&gt;io_recv(ws, ws-&gt;context, rd_buf, (<span class="keyword">size_t</span>) (rd_buf_len));</div><div class="line">                <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="built_in">free</span>(rd_buf);</div><div class="line">                    <span class="comment">//TODO errono fix</span></div><div class="line">                    ret = nbytes;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ws__enqueue_buf(ws, rd_buf, (<span class="keyword">size_t</span>)nbytes) ;</div><div class="line">                <span class="built_in">free</span>(rd_buf);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ws-&gt;buf_pos &lt; <span class="number">2</span>) &#123;</div><div class="line">                ret = WS_WANT_READ;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">ws_frame_t</span> * frame;</div><div class="line">            <span class="keyword">if</span> (ws-&gt;frame == <span class="literal">NULL</span>) &#123;</div><div class="line">                frame__alloc(&amp;ws-&gt;frame);</div><div class="line">                frame = ws-&gt;frame;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                frame = ws-&gt;frame;</div><div class="line">            &#125;</div><div class="line">            rd_buf = ws-&gt;buf;</div><div class="line">            frame-&gt;fin = (*(rd_buf) &amp; <span class="number">0x80</span>) == <span class="number">0x80</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            frame-&gt;op_code = *(rd_buf) &amp; <span class="number">0x0f</span>;</div><div class="line">            frame-&gt;payload_len = *(rd_buf + <span class="number">1</span>) &amp; <span class="number">0x7f</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (frame-&gt;payload_len &lt; <span class="number">126</span>) &#123;</div><div class="line">                frame-&gt;payload_bit_offset = <span class="number">2</span>;</div><div class="line">                ws-&gt;rd_state = WS_READ_PAYLOAD;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame -&gt; payload_len == <span class="number">126</span>) &#123;</div><div class="line">                frame-&gt;payload_bit_offset = <span class="number">4</span>;</div><div class="line">                ws-&gt;rd_state = WS_READ_EXTEND_PAYLOAD_2_WORDS;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                frame-&gt;payload_bit_offset = <span class="number">8</span>;</div><div class="line">                ws-&gt;rd_state = WS_READ_EXTEND_PAYLOAD_8_WORDS;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ws__reset_buf(ws, <span class="number">2</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> WS_READ_EXTEND_PAYLOAD_2_WORDS: &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PAYLOAD_LEN_BITS 2</span></div><div class="line">            <span class="keyword">if</span> (ws-&gt;buf_pos &lt; PAYLOAD_LEN_BITS) &#123;</div><div class="line">                rd_buf_len = PAYLOAD_LEN_BITS - ws-&gt;buf_pos;</div><div class="line">                rd_buf = <span class="built_in">malloc</span>(rd_buf_len);</div><div class="line">                nbytes = ws-&gt;io_recv(ws, ws-&gt;context, rd_buf, (<span class="keyword">size_t</span>) (rd_buf_len));</div><div class="line">                <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="built_in">free</span>(rd_buf);</div><div class="line">                    ret = nbytes;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ws__enqueue_buf(ws, rd_buf, (<span class="keyword">size_t</span>)nbytes) ;</div><div class="line">                <span class="built_in">free</span>(rd_buf);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ws-&gt;buf_pos &lt; PAYLOAD_LEN_BITS) &#123;</div><div class="line">                ret = WS_WANT_READ;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            rd_buf = ws-&gt;buf;</div><div class="line">            <span class="keyword">ws_frame_t</span> * frame = ws-&gt;frame;</div><div class="line">            <span class="comment">//rd_buf[0] = 0; rd_buf[1] = 255</span></div><div class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PAYLOAD_LEN_BITS; i++) &#123;</div><div class="line">                *(((<span class="keyword">char</span> *)&amp;frame-&gt;payload_len) + i) = rd_buf[PAYLOAD_LEN_BITS - <span class="number">1</span> - i];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ws__reset_buf(ws, PAYLOAD_LEN_BITS);</div><div class="line">            ws-&gt;rd_state = WS_READ_PAYLOAD;</div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span> PAYLOAD_LEN_BITS</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> WS_READ_EXTEND_PAYLOAD_8_WORDS: &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PAYLOAD_LEN_BITS 8</span></div><div class="line">            <span class="keyword">if</span> (ws-&gt;buf_pos &lt; PAYLOAD_LEN_BITS) &#123;</div><div class="line">                rd_buf_len = PAYLOAD_LEN_BITS - ws-&gt;buf_pos;</div><div class="line">                rd_buf = <span class="built_in">malloc</span>(rd_buf_len);</div><div class="line">                nbytes = ws-&gt;io_recv(ws, ws-&gt;context, rd_buf, (<span class="keyword">size_t</span>) (rd_buf_len));</div><div class="line">                <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="built_in">free</span>(rd_buf);</div><div class="line">                    ret = nbytes;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ws__enqueue_buf(ws, rd_buf, (<span class="keyword">size_t</span>)nbytes) ;</div><div class="line">                <span class="built_in">free</span>(rd_buf);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ws-&gt;buf_pos &lt; PAYLOAD_LEN_BITS) &#123;</div><div class="line">                ret = WS_WANT_READ;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            rd_buf = ws-&gt;buf;</div><div class="line">            <span class="keyword">ws_frame_t</span> * frame = ws-&gt;frame;</div><div class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PAYLOAD_LEN_BITS; i++) &#123;</div><div class="line">                *(((<span class="keyword">char</span> *)&amp;frame-&gt;payload_len) + i) = rd_buf[PAYLOAD_LEN_BITS - <span class="number">1</span> - i];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ws__reset_buf(ws, PAYLOAD_LEN_BITS);</div><div class="line">            ws-&gt;rd_state = WS_READ_PAYLOAD;</div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span> PAYLOAD_LEN_BITS</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> WS_READ_PAYLOAD: &#123;</div><div class="line">            <span class="keyword">ws_frame_t</span> * frame = ws-&gt;frame;</div><div class="line">            <span class="keyword">uint64_t</span> payload_len = frame-&gt;payload_len;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ws-&gt;buf_pos &lt; payload_len) &#123;</div><div class="line">                rd_buf_len = payload_len - ws-&gt;buf_pos;</div><div class="line">                rd_buf = <span class="built_in">malloc</span>(rd_buf_len);</div><div class="line">                nbytes = ws-&gt;io_recv(ws, ws-&gt;context, rd_buf, (<span class="keyword">size_t</span>) (rd_buf_len));</div><div class="line">                <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="built_in">free</span>(rd_buf);</div><div class="line">                    ret = nbytes;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ws__enqueue_buf(ws, rd_buf, (<span class="keyword">size_t</span>)nbytes) ;</div><div class="line">                <span class="built_in">free</span>(rd_buf);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ws-&gt;buf_pos &lt; payload_len) &#123;</div><div class="line">                ret = WS_WANT_READ;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            rd_buf = ws-&gt;buf;</div><div class="line">            frame-&gt;payload = <span class="built_in">malloc</span>(payload_len);</div><div class="line">            <span class="built_in">memcpy</span>(frame-&gt;payload, rd_buf, payload_len);</div><div class="line"></div><div class="line">            ws__reset_buf(ws, payload_len);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (frame-&gt;fin == <span class="number">1</span>) &#123;</div><div class="line">                <span class="comment">// is control frame</span></div><div class="line">                <span class="keyword">if</span> (frame-&gt;op_code == OP_CLOSE) &#123;</div><div class="line">                    <span class="comment">// TODO if should response a close frame</span></div><div class="line">                    <span class="comment">// close connection</span></div><div class="line">                    <span class="keyword">if</span> (ws-&gt;close_cb) &#123;</div><div class="line">                        ws-&gt;close_cb(ws);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    ws__dispatch_msg(ws, frame);</div><div class="line">                    ws-&gt;frame = <span class="literal">NULL</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">ws_frame_t</span> *new_frame;</div><div class="line">                frame__alloc(&amp;new_frame);</div><div class="line">                frame-&gt;next = new_frame;</div><div class="line">                new_frame-&gt;prev = frame;</div><div class="line">                ws-&gt;frame = new_frame;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ws-&gt;rd_state = WS_READ_IDLE;</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数据解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ws__wrap_packet</span><span class="params">(_WS_IN <span class="keyword">websocket_t</span> *ws,</span></span></div><div class="line">                     _WS_IN <span class="keyword">const</span> <span class="keyword">char</span> *payload,</div><div class="line">                     _WS_IN <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size,</div><div class="line">                     _WS_IN <span class="keyword">int</span> flags,</div><div class="line">                     _WS_OUT <span class="keyword">char</span>** out,</div><div class="line">                     _WS_OUT <span class="keyword">uint64_t</span> *out_size) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> timeval tv;</div><div class="line">    <span class="keyword">char</span> mask[<span class="number">4</span>];</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mask_int;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> payload_len_bits;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> payload_bit_offset = <span class="number">6</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extend_payload_len_bits, i;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> frame_size;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MASK_BIT_LEN = <span class="number">4</span>;</div><div class="line"></div><div class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</div><div class="line">	srand(tv.tv_usec * tv.tv_sec);</div><div class="line">	mask_int = rand();</div><div class="line">	<span class="built_in">memcpy</span>(mask, &amp;mask_int, <span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * payload_len bits</div><div class="line">     * ref to https://tools.ietf.org/html/rfc6455#section-5.2</div><div class="line">     * If 0-125, that is the payload length</div><div class="line">     *</div><div class="line">     * If payload length is equals 126, the following 2 bytes interpreted as a</div><div class="line">     * 16-bit unsigned integer are the payload length</div><div class="line">     * </div><div class="line">     * If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the</div><div class="line">     * most significant bit MUST be 0) are the payload length.</div><div class="line">     */</div><div class="line">	<span class="keyword">if</span> (payload_size &lt;= <span class="number">125</span>) &#123;</div><div class="line">        <span class="comment">// consts of ((fin + rsv1/2/3 + opcode) + payload-len bits + mask bit len + payload len)</span></div><div class="line">        extend_payload_len_bits = <span class="number">0</span>;</div><div class="line">		frame_size = <span class="number">1</span> + <span class="number">1</span> + MASK_BIT_LEN + payload_size;</div><div class="line"></div><div class="line">        payload_len_bits = payload_size;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (payload_size &gt; <span class="number">125</span> &amp;&amp; payload_size &lt;= <span class="number">0xffff</span>) &#123;</div><div class="line">        extend_payload_len_bits = <span class="number">2</span>;</div><div class="line">        <span class="comment">// consts of ((fin + rsv1/2/3 + opcode) + payload-len bits + extend-payload-len bites + mask bit len + payload len)</span></div><div class="line">		frame_size = <span class="number">1</span> + <span class="number">1</span> + extend_payload_len_bits + MASK_BIT_LEN + payload_size;</div><div class="line">		payload_len_bits = <span class="number">126</span>;</div><div class="line"></div><div class="line">		payload_bit_offset += extend_payload_len_bits;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (payload_size &gt; <span class="number">0xffff</span> &amp;&amp; payload_size &lt;= <span class="number">0xffffffffffffffff</span>LL) &#123;</div><div class="line">        extend_payload_len_bits = <span class="number">8</span>;</div><div class="line">        <span class="comment">// consts of ((fin + rsv1/2/3 + opcode) + payload-len bits + extend-payload-len bites + mask bit len + payload len)</span></div><div class="line">		frame_size = <span class="number">1</span> + <span class="number">1</span> + extend_payload_len_bits + MASK_BIT_LEN + payload_size;</div><div class="line">		payload_len_bits = <span class="number">127</span>;</div><div class="line">		payload_bit_offset += extend_payload_len_bits;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ws-&gt;error_cb) &#123;</div><div class="line">            <span class="keyword">ws_error_t</span> *err = ws_new_error(WS_SEND_DATA_TOO_LARGE_ERR);</div><div class="line">            ws-&gt;error_cb(ws, err);</div><div class="line">            <span class="built_in">free</span>(err);</div><div class="line">        &#125;</div><div class="line">		<span class="keyword">return</span> ;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    *out_size = frame_size;</div><div class="line">	<span class="keyword">char</span> *data = (*out) = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(frame_size);</div><div class="line">    <span class="keyword">char</span> *buf_offset = data;</div><div class="line"></div><div class="line">    bzero(data, frame_size);</div><div class="line">	*data = flags &amp; <span class="number">0xff</span>;</div><div class="line"></div><div class="line">    buf_offset = data + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// set mask bit = 1</span></div><div class="line">	*(buf_offset) = payload_len_bits | <span class="number">0x80</span>; <span class="comment">//payload length with mask bit on</span></div><div class="line"></div><div class="line">    buf_offset = data + <span class="number">2</span>;</div><div class="line">	<span class="keyword">if</span> (payload_len_bits == <span class="number">126</span>) &#123;</div><div class="line">		payload_size &amp;= <span class="number">0xffff</span>;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (payload_len_bits == <span class="number">127</span>) &#123;</div><div class="line">		payload_size &amp;= <span class="number">0xffffffffffffffff</span>LL;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; extend_payload_len_bits; i++) &#123;</div><div class="line">        *(buf_offset + i) = *((<span class="keyword">char</span> *)&amp;payload_size + (extend_payload_len_bits - i - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * according to https://tools.ietf.org/html/rfc6455#section-5.3</div><div class="line">     * </div><div class="line">     * buf_offset is set to mask bit</div><div class="line">     */</div><div class="line">    buf_offset = data + payload_bit_offset - <span class="number">4</span>;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">		*(buf_offset + i) = mask[i] &amp; <span class="number">0xff</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * mask the payload data </div><div class="line">     */</div><div class="line">    buf_offset = data + payload_bit_offset;</div><div class="line">	<span class="built_in">memcpy</span>(buf_offset, payload, payload_size);</div><div class="line">	mask_payload(mask, buf_offset, payload_size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>对WebSocket的学习主要是对协议的理解，理解了协议，对数据的操作就会自然而然的明白~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u80CC_u666F&quot;&gt;&lt;a href=&quot;#u80CC_u666F&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前我们将 &lt;a href=&quot;https://github.com/robbiehanson/CocoaAsyncSocket&quot;&gt;CocoaAsyncSocket&lt;/a&gt; 作为底层实现，在其上面封装了一套 Socket 通信机制以及业务接口，最近我们开始研究 WebSocket ，并用来替换掉原先的 CocoaAsyncSocket ，简单来说一下两者的关系，WebSocket 和 Socket 虽然名称上很像，但两者是完全不同的东西， WebSocket 是建立在 TCP/IP 协议之上，属于应用层的协议，而 Socket 是在应用层和传输层中的一个抽象层，它是将 TCP/IP 层的复杂操作抽象成几个简单的接口来提供给应用层调用。为什么要做这次替换呢？原因是我们服务端在做改造，同时网页版IM已经使用了 WebSocket ，客户端也采用的话对于服务端来说维护一套代码会更好更方便，而且 WebSocket 在体积、实时性和扩展上都具有一定的优势。&lt;/p&gt;
&lt;p&gt;WebSocket 最新的协议是&lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot;&gt;13 RFC 6455&lt;/a&gt; ，要理解 WebSocket 的实现，一定要去理解它的协议！~&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebSocket" scheme="http://yuzeyang.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Mantle 解析</title>
    <link href="http://yuzeyang.github.io/2017/06/18/Mantle/"/>
    <id>http://yuzeyang.github.io/2017/06/18/Mantle/</id>
    <published>2017-06-18T06:56:57.000Z</published>
    <updated>2017-07-02T02:32:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>对 JSON 解析库目前流行的也是非常的多，<a href="https://github.com/jsonmodel/jsonmodel" target="_blank" rel="external">jsonmodel</a> 、<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a> 、<a href="https://github.com/ibireme/YYModel" target="_blank" rel="external">YYModel</a> 等都是大家常用的，使用这些库的好处就是你无需关心数据解析转换和复杂的类型判断处理，你只需要确定好客户端的数据结构能够与后端数据结构相对应即可，而这些库里面对于解析的处理也都是大同小异，无非是在使用、性能和异常处理上有些差别，这里推荐一下郭曜源大神（ YYModel 的作者）的文章，内容是对<a href="http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/" target="_blank" rel="external">各大解析库进行了比较</a>，对于开发者来说，了解其解析过程是最为基础的，这次看完 Mantle 的解析处理，我也做个简单的总结，大家可以互相学习交流。</p>
<a id="more"></a>
<p>首先 Mantle 对于 JSON 解析的过程分为三步：</p>
<p>第一步是对 Model 字段的转换处理</p>
<p>第二步是对 JSON Dictionary 值的转换处理</p>
<p>第三步是对 Model 的赋值</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>对于解析 JSON 数据，我们比较常用是以下这个方法，<code>modelClass</code> 指的是继承于 <code>MTLModel</code> 的子类，也是我们需要解析成的目标 Model 类， <code>JSONDictionary</code> 则是需要解析的 JSON 数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</div><div class="line">	MTLJSONAdapter *adapter = [[self alloc] initWithModelClass:modelClass];</div><div class="line"></div><div class="line">	return [adapter modelFromJSONDictionary:JSONDictionary error:error];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现上看就两步，先根据 modelClass 初始化一个适配器，再根据 JSON 数据返回 model 对象。</p>
<p>初始化适配器的内容比较多，我们分段来说几个关键的地方。</p>
<p>首先检查的就是 Model 是否实现了 <code>MTLJSONSerializing</code> 协议，未实现的话会触发断言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (id)initWithModelClass:(Class)modelClass &#123;</div><div class="line">	NSParameterAssert(modelClass != nil);</div><div class="line">	NSParameterAssert([modelClass conformsToProtocol:@protocol(MTLJSONSerializing)]);</div><div class="line">  </div><div class="line">  	self = [super init];</div><div class="line">	if (self == nil) return nil;</div><div class="line"></div><div class="line">	_modelClass = modelClass;</div><div class="line"></div><div class="line">	_JSONKeyPathsByPropertyKey = [modelClass JSONKeyPathsByPropertyKey];</div><div class="line">  	</div><div class="line">  	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么先来看下  <code>MTLJSONSerializing</code> 协议，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@protocol MTLJSONSerializing &lt;MTLModel&gt;</div><div class="line">@required</div><div class="line">+ (NSDictionary *)JSONKeyPathsByPropertyKey;</div><div class="line"></div><div class="line">@optional</div><div class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;</div><div class="line">+ (Class)classForParsingJSONDictionary:(NSDictionary *)JSONDictionary;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p> <code>JSONKeyPathsByPropertyKey</code> 方法是里面唯一一个必须要实现的，它是用于将属性和 JSON 的解析路径做关联，它不仅仅可以用于给属性起“别名”，还可以用于多级解析和多层嵌套，用官方例子来举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (NSDictionary *)JSONKeyPathsByPropertyKey &#123;</div><div class="line">   return @&#123;</div><div class="line">       @&quot;name&quot;: @&quot;POI.name&quot;,</div><div class="line">       @&quot;point&quot;: @[ @&quot;latitude&quot;, @&quot;longitude&quot; ],</div><div class="line">       @&quot;starred&quot;: @&quot;starred&quot;</div><div class="line">   &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">在映射过程中 starred 与 JSONDictionary[@&quot;starred&quot;] 做映射，</div><div class="line">name 与 JSONDictionary[@&quot;POI&quot;][@&quot;name&quot;] 做映射，</div><div class="line">point 则等同于以下这个 dictionary</div><div class="line">@&#123;</div><div class="line">   @&quot;latitude&quot;: JSONDictionary[@&quot;latitude&quot;],</div><div class="line">   @&quot;longitude&quot;: JSONDictionary[@&quot;longitude&quot;]</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这样的设计很是方便，可以自由定义映射解析之间的关系，但是在实现的时候会发现，我们在处理对于像 starred 这样普通的解析关系时，仍旧需要一个一个重新在定义一遍，如果我们的数据结构内容非常的多，那就是个体力活了，而且不定义就无法解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (id)initWithModelClass:(Class)modelClass &#123;</div><div class="line">	...</div><div class="line">  	</div><div class="line">    NSSet *propertyKeys = [self.modelClass propertyKeys];</div><div class="line">      </div><div class="line">  	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)propertyKeys &#123;</div><div class="line">	NSSet *cachedKeys = objc_getAssociatedObject(self, MTLModelCachedPropertyKeysKey);</div><div class="line">	if (cachedKeys != nil) return cachedKeys;</div><div class="line"></div><div class="line">	NSMutableSet *keys = [NSMutableSet set];</div><div class="line"></div><div class="line">	[self enumeratePropertiesUsingBlock:^(objc_property_t property, BOOL *stop) &#123;</div><div class="line">		NSString *key = @(property_getName(property));</div><div class="line"></div><div class="line">		if ([self storageBehaviorForPropertyWithKey:key] != MTLPropertyStorageNone) &#123;</div><div class="line">			 [keys addObject:key];</div><div class="line">		&#125;</div><div class="line">	&#125;];</div><div class="line"></div><div class="line">	objc_setAssociatedObject(self, MTLModelCachedPropertyKeysKey, keys, OBJC_ASSOCIATION_COPY);</div><div class="line"></div><div class="line">	return keys;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>propertyKeys</code> 是遍历 MTLModel 子类的属性，判断其拷贝行为，过滤掉不做存储的属性，注意它同时会对 hash 、 superclass 、 description 、 debugDescription 这四个属性进行判断，在 NSObject 内这四个都是 readonly 的，如果你不去将它设为 readwrite 的话，它们是不做存储的。</p>
<p>说到存储行为，MTLModel用了一个枚举 <code>MTLPropertyStorage</code> 来标记一个属性的拷贝行为，分为三类，</p>
<p>第一类 <code>MTLPropertyStorageNone</code> ：属性不做任何存储，在 MTLModel里判断不存储的条件是1.没有该属性，自然不用存储 2.该属性没有使用 @dynamic 指令，但是没有成员变量，并且没有对应的setter和getter方法 3. MTLModel 类中属性是只读，且没有成员变量。</p>
<p>第二类 <code>MTLPropertyStorageTransitory</code> ：属性只做暂时性的存储，在官方解释里看到一句话 <code>It may disappear at any time</code> ，感觉指的是弱引用的属性，但是在 MTLModel 里并没有看到返回  MTLPropertyStorageTransitory 的处理，但在 MTLTestModel 中可以找到， MTLTestModel 对 <code>storageBehaviorForPropertyWithKey:</code> 进行了重写，其中它对属性名进行了判断，在对应的头文件里我们也可以找到这个属性的说明：<code>Should not be stored in JSON, has MTLPropertyStorageTransitory.</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (MTLPropertyStorage)storageBehaviorForPropertyWithKey:(NSString *)propertyKey &#123;</div><div class="line">  if ([propertyKey isEqual:@&quot;weakModel&quot;]) &#123;</div><div class="line">  	return MTLPropertyStorageTransitory;</div><div class="line">  &#125; else &#123;</div><div class="line">  	return [super storageBehaviorForPropertyWithKey:propertyKey];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三类 <code>MTLPropertyStoragePermanen</code> ，属性做永久存储， MTLModel 里判断只要不是 MTLPropertyStorageNone 就是 MTLPropertyStoragePermanen，需要做暂时存储的，就需要在子类里重写了。</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)initWithModelClass:(Class)modelClass &#123;</div><div class="line">	...</div><div class="line">  	</div><div class="line">    _valueTransformersByPropertyKey = [self.class valueTransformersForModelClass:modelClass];</div><div class="line">	_JSONAdaptersByModelClass = [NSMapTable strongToStrongObjectsMapTable];</div><div class="line"></div><div class="line">	return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在遍历完之后开始对属性的值进行转换操作，对于转换操作也提供了三种方式，</p>
<p>第一种是自定义方式，在子类里定义实现方法名为 <code>key（属性名）</code> + <code>JSONTransformer</code>  的方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSValueTransformer *)URLJSONTransformer &#123;</div><div class="line">    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种是重写 MTLJSONSerializing 的 optional 协议，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key &#123;</div><div class="line">	return @&#123;</div><div class="line">		// Not provided transformer for self.URL</div><div class="line">		@&quot;otherURL&quot;: [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName],</div><div class="line">	&#125;[key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三种则是根据属性的类型做相应的转换。</p>
<p>在以上两部转换完成之后剩下的就是赋值了，因为实现了 JSONKeyPathsByPropertyKey 方法，所以从 JSONDictionary 取值时如果碰到以数组形式定义的 key 时，会以<code>.</code>进行拆分，例如 <code>@&quot;name&quot;: @&quot;POI.name&quot;</code> ，则对应的取值处理是 <code>JSONDictionary[@&quot;POI&quot;][@&quot;name”]</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</div><div class="line">	...</div><div class="line">      </div><div class="line">      for (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;</div><div class="line">		id JSONKeyPaths = self.JSONKeyPathsByPropertyKey[propertyKey];</div><div class="line"></div><div class="line">		if (JSONKeyPaths == nil) continue;</div><div class="line"></div><div class="line">		id value;</div><div class="line"></div><div class="line">		if ([JSONKeyPaths isKindOfClass:NSArray.class]) &#123;</div><div class="line">			NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];</div><div class="line"></div><div class="line">			for (NSString *keyPath in JSONKeyPaths) &#123;</div><div class="line">				BOOL success = NO;</div><div class="line">				id value = [JSONDictionary mtl_valueForJSONKeyPath:keyPath success:&amp;success error:error];</div><div class="line"></div><div class="line">				if (!success) return nil;</div><div class="line"></div><div class="line">				if (value != nil) dictionary[keyPath] = value;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			value = dictionary;</div><div class="line">		&#125; else &#123;</div><div class="line">			BOOL success = NO;</div><div class="line">			value = [JSONDictionary mtl_valueForJSONKeyPath:JSONKeyPaths success:&amp;success error:error];</div><div class="line"></div><div class="line">			if (!success) return nil;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">  </div><div class="line">  	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还记得我们在子类里定义的 keyTransform 方法么，在取值之后这些值都会做相应的转换，注意一点就是NSNull对象会先转换成nil，然后将nil转换成NSNull对象插入到新的 dictionaryValue 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</div><div class="line">	...</div><div class="line">      </div><div class="line">      for (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;</div><div class="line">		...</div><div class="line">          </div><div class="line">         @try &#123;</div><div class="line">            NSValueTransformer *transformer = self.valueTransformersByPropertyKey[propertyKey];</div><div class="line">            if (transformer != nil) &#123;</div><div class="line">                // Map NSNull -&gt; nil for the transformer, and then back for the</div><div class="line">                // dictionary we&apos;re going to insert into.</div><div class="line">                if ([value isEqual:NSNull.null]) value = nil;</div><div class="line"></div><div class="line">                if ([transformer respondsToSelector:@selector(transformedValue:success:error:)]) &#123;</div><div class="line">                    id&lt;MTLTransformerErrorHandling&gt; errorHandlingTransformer = (id)transformer;</div><div class="line"></div><div class="line">                    BOOL success = YES;</div><div class="line">                    value = [errorHandlingTransformer transformedValue:value success:&amp;success error:error];</div><div class="line"></div><div class="line">                    if (!success) return nil;</div><div class="line">                &#125; else &#123;</div><div class="line">                    value = [transformer transformedValue:value];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (value == nil) value = NSNull.null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dictionaryValue[propertyKey] = value;</div><div class="line">        &#125; @catch (NSException *ex) &#123;</div><div class="line">            NSLog(@&quot;*** Caught exception %@ parsing JSON key path \&quot;%@\&quot; from: %@&quot;, ex, JSONKeyPaths, JSONDictionary);</div><div class="line"></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">  </div><div class="line">  	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>在生成 dictionaryValue 之后，开始调用 <code>- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error</code> 来对子类进行初始化，并调用 <code>MTLValidateAndSetValue</code> 来赋值，至此从 JSONDictionary 到 model 的解析算是完成了~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;</div><div class="line">	self = [self init];</div><div class="line">	if (self == nil) return nil;</div><div class="line"></div><div class="line">	for (NSString *key in dictionary) &#123;</div><div class="line">		// Mark this as being autoreleased, because validateValue may return</div><div class="line">		// a new object to be stored in this variable (and we don&apos;t want ARC to</div><div class="line">		// double-free or leak the old or new values).</div><div class="line">		__autoreleasing id value = [dictionary objectForKey:key];</div><div class="line"></div><div class="line">		if ([value isEqual:NSNull.null]) value = nil;</div><div class="line"></div><div class="line">		BOOL success = MTLValidateAndSetValue(self, key, value, YES, error);</div><div class="line">		if (!success) return nil;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 JSON 解析库目前流行的也是非常的多，&lt;a href=&quot;https://github.com/jsonmodel/jsonmodel&quot;&gt;jsonmodel&lt;/a&gt; 、&lt;a href=&quot;https://github.com/Mantle/Mantle&quot;&gt;Mantle&lt;/a&gt; 、&lt;a href=&quot;https://github.com/ibireme/YYModel&quot;&gt;YYModel&lt;/a&gt; 等都是大家常用的，使用这些库的好处就是你无需关心数据解析转换和复杂的类型判断处理，你只需要确定好客户端的数据结构能够与后端数据结构相对应即可，而这些库里面对于解析的处理也都是大同小异，无非是在使用、性能和异常处理上有些差别，这里推荐一下郭曜源大神（ YYModel 的作者）的文章，内容是对&lt;a href=&quot;http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/&quot;&gt;各大解析库进行了比较&lt;/a&gt;，对于开发者来说，了解其解析过程是最为基础的，这次看完 Mantle 的解析处理，我也做个简单的总结，大家可以互相学习交流。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mantle" scheme="http://yuzeyang.github.io/tags/Mantle/"/>
    
  </entry>
  
  <entry>
    <title>有赞 App 动态化配置中心实践</title>
    <link href="http://yuzeyang.github.io/2017/04/06/Youzan-App-Config-Center/"/>
    <id>http://yuzeyang.github.io/2017/04/06/Youzan-App-Config-Center/</id>
    <published>2017-04-06T12:16:19.000Z</published>
    <updated>2017-04-11T12:06:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u80CC_u666F"><a href="#u80CC_u666F" class="headerlink" title="背景"></a>背景</h2><p>客户端大量的硬编码导致其灵活性大大降低，一些细小的改动只能通过发布版本解决，用户升级更新迭代速度慢，时效性差等原因，催生出了有赞 App 的动态化配置中心，它可以将配置，功能，界面，数据等各种配置数据统一进行管理下发，实时生效，极大地提升了客户端的灵活性。</p>
<p>同时配置中心不仅仅是简单的对配置数据进行修改、读取而已，更需要在容错性、流量优化、带宽节省等各方面的优化上下功夫。本文主要提供了有赞 App 的动态化配置中心解决方案，也总结了版本迭代中所做的优化。</p>
<a id="more"></a>
<h2 id="u914D_u7F6E_u4E2D_u5FC3_u8BBE_u8BA1"><a href="#u914D_u7F6E_u4E2D_u5FC3_u8BBE_u8BA1" class="headerlink" title="配置中心设计"></a>配置中心设计</h2><p>起初有赞各 App 内都散落着一些写死的链接，但随着 WWDC 16 中，Apple 表示将继续在 iOS 10 和 macOS 10.12 里收紧对普通 HTTP 的访问限制，并且无法使用 <code>NSAllowsArbitraryLoads</code> 来绕过 ATS 限制。我们只能很费时费力的把各 App 内所有访问 HTTP 的链接都修改成 HTTPS，这一个小小的改动就如此麻烦，那后续大的改动更难以想象，所以我们开始思考能否将这些重复且动态的工作抽象成一个配置中心，用它来支撑各个业务。</p>
<h4 id="u7B2C_u4E00_u7248"><a href="#u7B2C_u4E00_u7248" class="headerlink" title="第一版"></a>第一版</h4><p>第一版设计的相对简单，我们只是专门设计了一个 API，通过 API 请求配置数据，并且每个业务单独维护一份配置文件。</p>
<p>具体流程：客户端进入到前台，也就是应用程序被激活的时候，通过配置中心的接口向服务端请求最新的配置数据，如果配置文件有更新，则下发最新的配置给客户端，并且客户端本地存储这份最新的配置，用于应用运行时使用。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AppConfigCenter1.png" alt=""></p>
<p>但随着模块化的推进和应用数量的增加，配置文件的体积和数量会逐渐增大，每一次修改都会全量下发到客户端，这部分的流量累积起来是一个非常庞大的数字。并且使用配置文件去管理配置，只能维护到最新的配置，无法做到下发指定版本的配置。</p>
<p>所以针对这些弊端问题，我们衍生出了第二版配置中心。</p>
<h4 id="u7B2C_u4E8C_u7248"><a href="#u7B2C_u4E8C_u7248" class="headerlink" title="第二版"></a>第二版</h4><p>为了解决第一版产生的流量浪费和配置管理弱的问题，我们优化了配置下发和管理流程，我们采取的策略是 <code>增量更新</code> 和 <code>数据库存储配置</code> 。</p>
<p>具体流程改动：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AppConfigCenter2.png" alt=""></p>
<h4 id="u589E_u91CF_u66F4_u65B0"><a href="#u589E_u91CF_u66F4_u65B0" class="headerlink" title="增量更新"></a>增量更新</h4><p>增量更新的优势主要体现在业务增长的过程中。我们的配置文件可能会从几十 KB 增长到几百 KB 甚至更大，如果还继续使用全量更新，这部分流量对用户来说是非常浪费的。而使用增量更新之后，服务端只需要下发不同配置之间的差异补丁包，补丁包的大小相比于原始配置的大小是非常小的，可以节省下90%左右的流量，这是非常可观的。</p>
<p>增量更新我们目前使用的是 Google 出的 <a href="https://code.google.com/p/google-diff-match-patch/" target="_blank" rel="external">google-diff-match-patch</a> ，支持 Java,  JavaScript, Dart, C++, C#,  Objective-C, Lua 和 Python，但是官网已经下掉了该 SDK（不明白为什么），需要到 GitHub 上搜索类似于 <code>diff patch language:java</code> 这样的关键词，就能找到对应平台下的 SDK 了，有人已经 fork 出来了，因为只是字符串的比较处理，所以可以放心使用。</p>
<p>该增量更新的原理是先通过比较首部和尾部的相同部分，目的是提升一定的效率，再比较中间差异的部分，差异的部分通过一些字符去表示该改动是  <code>DEL</code>  还是  <code>ADD</code>  还是  <code>EQUAL</code>  ，这样最终形成的补丁包比改动部分要大一点，但是相比于全量更新已经减少很多了。</p>
<p>并且生成补丁包基本是毫秒级的，也不必担心接口请求的耗时问题。</p>
<p>服务端把前后配置的字符串进行比较即可得到一组补丁数据：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$dmp = <span class="keyword">new</span> DiffMatchPatch();</div><div class="line">$patches = $dmp-&gt;patch_make($oldConfigString, $latestConfigString);</div><div class="line">$patchStrings = [];</div><div class="line"><span class="keyword">foreach</span> ($patches <span class="keyword">as</span> $patchObject) &#123;</div><div class="line">    array_push($patchStrings, $patchObject-&gt;__toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成的补丁以官方为例，补丁内包含两个字符串之间变动部分的 location 和 length，并最终下发给客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@@ -16,21 +16,29 @@</div><div class="line"> see </div><div class="line">-yonder</div><div class="line">+the</div><div class="line">  cloud </div><div class="line">+over there </div><div class="line"> that</div><div class="line">@@ -47,18 +47,19 @@</div><div class="line">  almost </div><div class="line">-in</div><div class="line">+the</div><div class="line">  shape o</div><div class="line">@@ -86,24 +86,18 @@</div><div class="line">  By </div><div class="line">-the mass, and &apos;t</div><div class="line">+golly, it </div><div class="line"> is l</div><div class="line">@@ -129,21 +129,23 @@</div><div class="line"> et: </div><div class="line">-Me</div><div class="line">+I </div><div class="line"> think</div><div class="line">-s</div><div class="line">  it </div><div class="line">-i</div><div class="line">+look</div><div class="line"> s li</div><div class="line">@@ -177,12 +177,12 @@</div><div class="line">  is </div><div class="line">-back</div><div class="line">+shap</div><div class="line"> ed l</div><div class="line">@@ -234,11 +234,19 @@</div><div class="line"> us: </div><div class="line">-Ver</div><div class="line">+It&apos;s totall</div><div class="line"> y li</div></pre></td></tr></table></figure>
<p>以 iOS 为例，客户端获取补丁包后，根据补丁包内变动符号以及变动内容对本地配置文件内容进行字符串拼接或删除操作，形成最终的配置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">DiffMatchPatch *dmp = [[DiffMatchPatch alloc] init];</div><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *patchStrings = configDic[<span class="string">@"patches"</span>];</div><div class="line"><span class="built_in">NSMutableArray</span>&lt;Patch *&gt; *patches = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *patchString <span class="keyword">in</span> patchStrings) &#123;</div><div class="line">    <span class="built_in">NSArray</span>&lt;Patch *&gt; *patch = [dmp patch_fromText:patchString error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (!error) &#123;</div><div class="line">        [patches addObjectsFromArray:patch];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSString</span> *newCacheConfig = [[dmp patch_apply:patches toString:cacheConfig] objectAtIndex:<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p>为了确保客户端最终生成的配置与服务端保持一致，客户端在打好补丁之后，用该配置生成 MD5 值，与我们在服务端下发补丁包时携带的最新配置的 MD5 值进行比较，在一致的情况下才去缓存配置，避免因为补丁造成 App 无法使用的问题。</p>
<h4 id="u6570_u636E_u5E93_u7BA1_u7406_u914D_u7F6E"><a href="#u6570_u636E_u5E93_u7BA1_u7406_u914D_u7F6E" class="headerlink" title="数据库管理配置"></a>数据库管理配置</h4><p>实现增量更新的前提是我们需要有不同版本的配置记录，而用文件去管理是非常不可控的，取而代之的是我们可以通过数据库来管理，同时利于后期的横向扩展，可以针对不同平台，不同渠道，不同版本等规则下发。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/dbConfig.png" alt=""></p>
<p>目前我们是根据版本和应用来关联到配置，所以表结构设计的很简单，把应用、版本和配置放在一张表里面，后面针对多渠道和多平台等规则之后，表结构上会做一定调整。</p>
<p>由于需要 App 能及时获取到最新配置，我们选择在 App 激活的时机去获取配置，通过数据统计中心我们可以看到 App 当日启动次数的时段分析，再结合配置文件大小，我们可以预估所占带宽的大小，运维是非常担心你把他的带宽跑满，影响到其他业务，所以我们需要做两个优化，一个是压缩配置，一个是本地缓存。</p>
<h5 id="u538B_u7F29_u914D_u7F6E"><a href="#u538B_u7F29_u914D_u7F6E" class="headerlink" title="压缩配置"></a>压缩配置</h5><p>为了不占用过多的带宽，我们需要在写入之前把配置压缩，读取之后解压配置。</p>
<p>这里我们通过 <code>gzip</code> 来压缩配置：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$data[<span class="string">'config'</span>] = base64_encode(gzcompress(json_encode($config)));</div></pre></td></tr></table></figure>
<p>需要注意的是 <code>gzip</code> 可以设置压缩等级，范围是0 - 9，默认是6，但是提升压缩等级会占用较多 CPU 时间和内存，我们使用默认等级压缩之后，配置文件体积减少了75%，看来是配置内相同的部分比较多，所以压缩效果还是比较明显的。</p>
<p>这里有人会问，为什么 <code>gzip</code> 之后还要 <code>base64</code> 编码一下，因为二进制数据不能直接写到text字段里面，写进去之后读出来也是解压不了的。进行 <code>base64</code>  编码之后，我们的压缩配置内容会比原来多1/3的长度。</p>
<h5 id="u672C_u5730_u7F13_u5B58"><a href="#u672C_u5730_u7F13_u5B58" class="headerlink" title="本地缓存"></a>本地缓存</h5><p>对于相同的配置，我们可以不用频繁地去请求数据库，而将其缓存到本地，这样后续的请求可以直接从缓存中读取配置，当然请记得设置缓存的过期时间。</p>
<p>我们目前用的是 <code>Redis</code> 缓存，它对于复杂的数据结构和操作支持的相当不错，而且操作简单，对于前期只是key-value存储的话，可以考虑使用 <code>Redis</code> 。</p>
<h4 id="u53EF_u64CD_u4F5C_u754C_u9762"><a href="#u53EF_u64CD_u4F5C_u754C_u9762" class="headerlink" title="可操作界面"></a>可操作界面</h4><p>为了方便业务方修改配置，我们在内部平台上提供了一个简单的可操作界面，通过顶部的Tab栏切换查看不同应用下的配置记录。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/cpAppConfigCenter.png" alt=""></p>
<p>点击 <code>查看详情</code> 可以看到当前版本的配置内容，目前展示的效果并不友好，后面会进行优化。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/cpAppConfigCenterDetail.png" alt=""></p>
<p>在需要修改配置的时候，我们可以通过 <code>新增配置</code> 给指定应用修改配置，新增时会自动在版本上 +1。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/cpAppConfigCenterAdd.png" alt=""></p>
<h2 id="u540E_u7EED_u4F18_u5316"><a href="#u540E_u7EED_u4F18_u5316" class="headerlink" title="后续优化"></a>后续优化</h2><p>目前有赞 App 已经实现了动态化配置中心整一套流程，但是在一些细节方面还需要不断的改进优化，比如：</p>
<ul>
<li>更加丰富的配置下发规则</li>
<li>可操作界面配置的有效性的校验</li>
<li>可操作界面的视觉优化</li>
<li>等等</li>
</ul>
<p>也欢迎大家提出自己的意见和建议，我们一起探讨学习！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u80CC_u666F&quot;&gt;&lt;a href=&quot;#u80CC_u666F&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;客户端大量的硬编码导致其灵活性大大降低，一些细小的改动只能通过发布版本解决，用户升级更新迭代速度慢，时效性差等原因，催生出了有赞 App 的动态化配置中心，它可以将配置，功能，界面，数据等各种配置数据统一进行管理下发，实时生效，极大地提升了客户端的灵活性。&lt;/p&gt;
&lt;p&gt;同时配置中心不仅仅是简单的对配置数据进行修改、读取而已，更需要在容错性、流量优化、带宽节省等各方面的优化上下功夫。本文主要提供了有赞 App 的动态化配置中心解决方案，也总结了版本迭代中所做的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="App 配置中心" scheme="http://yuzeyang.github.io/tags/App-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>查看MySQL连接的root密码</title>
    <link href="http://yuzeyang.github.io/2017/01/04/Check-MySQL-Password/"/>
    <id>http://yuzeyang.github.io/2017/01/04/Check-MySQL-Password/</id>
    <published>2017-01-03T16:03:02.000Z</published>
    <updated>2017-01-03T16:26:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>晚上在用<code>Navicat</code>去连本地的MySQL的时候发现我已经忘了密码了，试了网上很多方式都不行…后来发现其实可以自己直接去看当初设置的密码..</p>
<p>来看正文：</p>
<a id="more"></a>
<h5 id="1-_u9996_u5148_u6211_u4EEC_u8FDB_u5230MySQL_u7684bin_u76EE_u5F55_u4E0B"><a href="#1-_u9996_u5148_u6211_u4EEC_u8FDB_u5230MySQL_u7684bin_u76EE_u5F55_u4E0B" class="headerlink" title="1.首先我们进到MySQL的bin目录下"></a>1.首先我们进到MySQL的bin目录下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  cd /usr/local/mysql/bin</div></pre></td></tr></table></figure>
<h5 id="2-_u5207_u6362_u6210root_u8EAB_u4EFD"><a href="#2-_u5207_u6362_u6210root_u8EAB_u4EFD" class="headerlink" title="2.切换成root身份"></a>2.切换成root身份</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  bin sudo su</div></pre></td></tr></table></figure>
<h5 id="3-_u8DE8_u8FC7_u6743_u9650_u7684_u9A8C_u8BC1"><a href="#3-_u8DE8_u8FC7_u6743_u9650_u7684_u9A8C_u8BC1" class="headerlink" title="3.跨过权限的验证"></a>3.跨过权限的验证</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sh-3.2# ./mysqld_safe --skip-grant-tables &amp;</div><div class="line">[1] 9451</div><div class="line">sh-3.2# 2017-01-03T15:40:10.6NZ mysqld_safe Logging to &apos;/usr/local/mysql/data/yzydeMacBook-Pro.local.err&apos;.</div><div class="line">2017-01-03T15:40:10.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data</div></pre></td></tr></table></figure>
<h5 id="4-_u4EE5root_u8EAB_u4EFD_u767B_u5F55MySQL"><a href="#4-_u4EE5root_u8EAB_u4EFD_u767B_u5F55MySQL" class="headerlink" title="4.以root身份登录MySQL"></a>4.以root身份登录MySQL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">./mysql -uroot</div><div class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</div><div class="line">Your MySQL connection id is 2</div><div class="line">Server version: 5.7.12 MySQL Community Server (GPL)</div><div class="line"></div><div class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</div><div class="line"></div><div class="line">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class="line">affiliates. Other names may be trademarks of their respective</div><div class="line">owners.</div><div class="line"></div><div class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</div></pre></td></tr></table></figure>
<h5 id="5-_u9009_u62E9mysql_u6570_u636E_u5E93"><a href="#5-_u9009_u62E9mysql_u6570_u636E_u5E93" class="headerlink" title="5.选择mysql数据库"></a>5.选择mysql数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; use mysql</div><div class="line">Reading table information for completion of table and column names</div><div class="line">You can turn off this feature to get a quicker startup with -A</div><div class="line"></div><div class="line">Database changed</div></pre></td></tr></table></figure>
<h5 id="6-_u663E_u793Amysql_u6570_u636E_u5E93_u4E0B_u7684_u8868"><a href="#6-_u663E_u793Amysql_u6570_u636E_u5E93_u4E0B_u7684_u8868" class="headerlink" title="6.显示mysql数据库下的表"></a>6.显示mysql数据库下的表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show tables;</div><div class="line">+---------------------------+</div><div class="line">| Tables_in_mysql           |</div><div class="line">+---------------------------+</div><div class="line">| columns_priv              |</div><div class="line">| db                        |</div><div class="line">| engine_cost               |</div><div class="line">| event                     |</div><div class="line">| func                      |</div><div class="line">| general_log               |</div><div class="line">| gtid_executed             |</div><div class="line">| help_category             |</div><div class="line">| help_keyword              |</div><div class="line">| help_relation             |</div><div class="line">| help_topic                |</div><div class="line">| innodb_index_stats        |</div><div class="line">| innodb_table_stats        |</div><div class="line">| ndb_binlog_index          |</div><div class="line">| plugin                    |</div><div class="line">| proc                      |</div><div class="line">| procs_priv                |</div><div class="line">| proxies_priv              |</div><div class="line">| server_cost               |</div><div class="line">| servers                   |</div><div class="line">| slave_master_info         |</div><div class="line">| slave_relay_log_info      |</div><div class="line">| slave_worker_info         |</div><div class="line">| slow_log                  |</div><div class="line">| tables_priv               |</div><div class="line">| time_zone                 |</div><div class="line">| time_zone_leap_second     |</div><div class="line">| time_zone_name            |</div><div class="line">| time_zone_transition      |</div><div class="line">| time_zone_transition_type |</div><div class="line">| user                      |</div><div class="line">+---------------------------+</div><div class="line">31 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h5 id="7-_u5F88_u660E_u663E_u6211_u4EEC_u9700_u8981_u7684_u5BC6_u7801_u662F_u5B58_u5728user_u8FD9_u4E2A_u8868_u4E0B_u7684_uFF0C_u6240_u4EE5_u6211_u4EEC_u76F4_u63A5_u770Buser_u7684_u8868_u7ED3_u6784_u662F_u600E_u4E48_u6837_u7684"><a href="#7-_u5F88_u660E_u663E_u6211_u4EEC_u9700_u8981_u7684_u5BC6_u7801_u662F_u5B58_u5728user_u8FD9_u4E2A_u8868_u4E0B_u7684_uFF0C_u6240_u4EE5_u6211_u4EEC_u76F4_u63A5_u770Buser_u7684_u8868_u7ED3_u6784_u662F_u600E_u4E48_u6837_u7684" class="headerlink" title="7.很明显我们需要的密码是存在user这个表下的，所以我们直接看user的表结构是怎么样的"></a>7.很明显我们需要的密码是存在user这个表下的，所以我们直接看user的表结构是怎么样的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show columns from user;</div><div class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</div><div class="line">| Field                  | Type                              | Null | Key | Default               | Extra |</div><div class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</div><div class="line">| Host                   | char(60)                          | NO   | PRI |                       |       |</div><div class="line">| User                   | char(32)                          | NO   | PRI |                       |       |</div><div class="line">| Select_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Insert_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Update_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Delete_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Create_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Drop_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Reload_priv            | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Shutdown_priv          | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Process_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| File_priv              | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Grant_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| References_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Index_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Alter_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Show_db_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Super_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Create_tmp_table_priv  | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Lock_tables_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Execute_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Repl_slave_priv        | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Repl_client_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Create_view_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Show_view_priv         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Create_routine_priv    | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Alter_routine_priv     | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Create_user_priv       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Event_priv             | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Trigger_priv           | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| Create_tablespace_priv | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| ssl_type               | enum(&apos;&apos;,&apos;ANY&apos;,&apos;X509&apos;,&apos;SPECIFIED&apos;) | NO   |     |                       |       |</div><div class="line">| ssl_cipher             | blob                              | NO   |     | NULL                  |       |</div><div class="line">| x509_issuer            | blob                              | NO   |     | NULL                  |       |</div><div class="line">| x509_subject           | blob                              | NO   |     | NULL                  |       |</div><div class="line">| max_questions          | int(11) unsigned                  | NO   |     | 0                     |       |</div><div class="line">| max_updates            | int(11) unsigned                  | NO   |     | 0                     |       |</div><div class="line">| max_connections        | int(11) unsigned                  | NO   |     | 0                     |       |</div><div class="line">| max_user_connections   | int(11) unsigned                  | NO   |     | 0                     |       |</div><div class="line">| plugin                 | char(64)                          | NO   |     | mysql_native_password |       |</div><div class="line">| authentication_string  | text                              | YES  |     | NULL                  |       |</div><div class="line">| password_expired       | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">| password_last_changed  | timestamp                         | YES  |     | NULL                  |       |</div><div class="line">| password_lifetime      | smallint(5) unsigned              | YES  |     | NULL                  |       |</div><div class="line">| account_locked         | enum(&apos;N&apos;,&apos;Y&apos;)                     | NO   |     | N                     |       |</div><div class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</div><div class="line">45 rows in set (0.02 sec)</div></pre></td></tr></table></figure>
<h5 id="8-_u8868_u7684_u5185_u5BB9_u6BD4_u8F83_u591A_uFF0C_u4F46_u662F_u6211_u4EEC_u5F88_u5BB9_u6613_u5C31_u53D1_u73B0_uFF0C_u5BC6_u7801_u5176_u5B9E_u662F_u5B58_u5728authentication_string_u5B57_u6BB5_u4E0B_u7684_uFF0C_u90A3_u6211_u4EEC_u5C31_u53EF_u4EE5_u76F4_u63A5_u8BFBUser_u5185_u5BB9_u4E3Aroot_u7684_u5BC6_u7801_u4E86"><a href="#8-_u8868_u7684_u5185_u5BB9_u6BD4_u8F83_u591A_uFF0C_u4F46_u662F_u6211_u4EEC_u5F88_u5BB9_u6613_u5C31_u53D1_u73B0_uFF0C_u5BC6_u7801_u5176_u5B9E_u662F_u5B58_u5728authentication_string_u5B57_u6BB5_u4E0B_u7684_uFF0C_u90A3_u6211_u4EEC_u5C31_u53EF_u4EE5_u76F4_u63A5_u8BFBUser_u5185_u5BB9_u4E3Aroot_u7684_u5BC6_u7801_u4E86" class="headerlink" title="8.表的内容比较多，但是我们很容易就发现，密码其实是存在authentication_string字段下的，那我们就可以直接读User内容为root的密码了"></a>8.表的内容比较多，但是我们很容易就发现，密码其实是存在authentication_string字段下的，那我们就可以直接读User内容为root的密码了</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select authentication_string from user where User=&apos;root&apos;;</div><div class="line">+-------------------------------------------+</div><div class="line">| authentication_string                     |</div><div class="line">+-------------------------------------------+</div><div class="line">| *781D25322166DB7FF99BA4A1FA5ED30439A60DDE |</div><div class="line">+-------------------------------------------+</div><div class="line">1 row in set (0.01 sec)</div></pre></td></tr></table></figure>
<p>OK，那我们拿着这个密码到<code>Navicat</code>试试看</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/EditConnection.png!400x400" alt=""></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/connectionSuccessful.png!400x400" alt=""></p>
<p>Wonderful~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;晚上在用&lt;code&gt;Navicat&lt;/code&gt;去连本地的MySQL的时候发现我已经忘了密码了，试了网上很多方式都不行…后来发现其实可以自己直接去看当初设置的密码..&lt;/p&gt;
&lt;p&gt;来看正文：&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yuzeyang.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>项目接入使用React Native</title>
    <link href="http://yuzeyang.github.io/2016/10/09/react-native/"/>
    <id>http://yuzeyang.github.io/2016/10/09/react-native/</id>
    <published>2016-10-09T13:53:32.000Z</published>
    <updated>2016-12-02T08:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一段时间没有写东西了，因为最近项目开始尝试使用React Native（以下简称RN）来开发，所以这段时间一直在研究，目前为止开发的内容不多，所以使用过的东西也不算多，这里也只是做个简单的记录</p>
<p>这里我打算从以下几个方面来讲：</p>
<p>1.背景介绍</p>
<p>2.环境的配置</p>
<p>3.RN所需要知道的知识</p>
<p>4.RN与原生的交互</p>
<p>5.本地调试与本地打包调试</p>
<p>6.远程热更新</p>
<p>7.iOS和Android不同样式处理</p>
<p>8.踩坑记录</p>
<p>9.相关资料</p>
<a id="more"></a>
<h2 id="0x00__u80CC_u666F_u4ECB_u7ECD"><a href="#0x00__u80CC_u666F_u4ECB_u7ECD" class="headerlink" title="0x00 背景介绍"></a>0x00 背景介绍</h2><p>RN是Facebook在React.js 2015大会上公布开源的，它是基于开源框架React.js来实现的，它支持了iOS和Android两大平台，解决开发者们编写重复代码的痛点，实现了所谓的跨平台开发，Write Once , Run Anywhere，这是目前很多开发者所追求的，特别是一些独立开发者或者项目快速迭代的团队，可以尝试使用RN来开发，另外包括方便的npm管理，快速的调试等等</p>
<p>那么既然优点这么明显，为什么大部分的团队还是采用传统的iOS、Android开发呢，踩过坑的同学都知道，首先在支持上还做得不够完善，在使用组件时，RN原有提供的组件往往不能很好的支持，与原生组件多少存在着差异，而且在使用第三方组件时，又会因为长期不更新的原因，存在很多坑，对于新手来说，根本不知道坑在哪，完全无从下手。另外RN的性能也不能和原生的相提并论，特别是列表组件在渲染大量数据时，流畅性方面还是原生更加优越，而且并非所以代码iOS和Android都能公用，如果某个组件只支持某一个平台，那你必须分开编写代码，实际上还是存在重复代码，除此之外学习的成本以及团队RN推广等等原因都需要考量，但是我相信，跨平台开发始终是一个趋势，RN整个社区也在不断的发展，相信未来我们会实现真正意义上的跨平台开发~</p>
<h2 id="0x01__u73AF_u5883_u914D_u7F6E"><a href="#0x01__u73AF_u5883_u914D_u7F6E" class="headerlink" title="0x01 环境配置"></a>0x01 环境配置</h2><p>相对于Android的环境配置过程来说，iOS可以说是简单轻松…出现的问题要少很多</p>
<p>首先我们需要安装<strong>Homebrew</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<p>然后安装<strong>node</strong>和<strong>watchman</strong>(用于监测文件系统的变更)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install node</div><div class="line">brew install watchman</div></pre></td></tr></table></figure>
<p>RN的命令行工具<strong>react-native-cli</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g react-native-cli</div></pre></td></tr></table></figure>
<p>如果遇到权限问题，只要前面加个<strong>sudo</strong>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g react-native-cli</div></pre></td></tr></table></figure>
<p>yeah~that’s all~我在配置的过程中，基本没有报错，如果有出现配置问题的话，请自行Google一下，看看大家的解决方法</p>
<p>如果在原有iOS项目中集成的话，我们需要在package.json文件配置一下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"your project name"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"start"</span>: <span class="string">"node node_modules/react-native/local-cli/cli.js start"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"react"</span>: <span class="string">"15.3.1"</span>,</div><div class="line">    <span class="attr">"react-native"</span>: <span class="string">"0.33.0"</span>,</div><div class="line">    <span class="attr">"react-native-swipeout"</span>: <span class="string">"^2.0.12"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且Podfile里，导入需要的RN模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [</div><div class="line">    &apos;Core&apos;,</div><div class="line">    &apos;RCTText&apos;,</div><div class="line">    &apos;RCTImage&apos;,</div><div class="line">    &apos;RCTNetwork&apos;,</div><div class="line">    &apos;RCTWebSocket&apos;, # needed for debugging</div><div class="line">    # Add any other subspecs you want to use in your project</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="0x02_RN_u6240_u9700_u8981_u77E5_u9053_u7684_u77E5_u8BC6"><a href="#0x02_RN_u6240_u9700_u8981_u77E5_u9053_u7684_u77E5_u8BC6" class="headerlink" title="0x02 RN所需要知道的知识"></a>0x02 RN所需要知道的知识</h2><h3 id="RN_u7684_u8FD0_u884C_u673A_u5236"><a href="#RN_u7684_u8FD0_u884C_u673A_u5236" class="headerlink" title="RN的运行机制"></a>RN的运行机制</h3><p>在开始写代码之前，我们需要了解RN的运行机制是怎么样的，这样写起来思路会更加清晰</p>
<p>首先，程序需要有个入口，我们可以创建很多的组件，但是有且只有一个组件用来做为程序的入口，RN的入口则类似于iOS的main.m，在iOS里我们会在main函数里设置应用程序类的代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return UIApplicationMain(argc, argv, nil, NSStringFromClass([KDAppDelegate class]));</div></pre></td></tr></table></figure>
<p>同样，RN里我们需要注册入口的名称，并且这个名称要和原生的初始化RN界面时的入口名称保持一致</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 引用navigation使用的组件</span></div><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  AppRegistry,</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 创建navigation类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">navigation</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">// set compnent</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 注册navigation为程序的入口</span></div><div class="line">AppRegistry.registerComponent(<span class="string">'navigation'</span>, () =&gt; navigation);</div></pre></td></tr></table></figure>
<p>在iOS原生这边需要用到RN的地方，我们需要初始化它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSURL *jsCodeLocation =</div><div class="line">[[NSBundle mainBundle] URLForResource:@&quot;bundle/index.ios&quot; withExtension:@&quot;jsbundle&quot;];</div><div class="line">//        [NSURL URLWithString:@&quot;http://172.17.9.188:8081/index.ios.bundle?platform=ios&quot;];</div><div class="line">RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</div><div class="line">                                                    moduleName:@&quot;navigation&quot;</div><div class="line">                                            initialProperties:nil</div><div class="line">                                                 launchOptions:nil];</div><div class="line">self.view = rootView;</div></pre></td></tr></table></figure>
<p>Tip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jsCodeLocation 是RN资源加载的路径，我们有两种方式去加载，一种是加载本地的js文件及其他资源文件，一种是我们将其打包成bundle文件，前者的优势在于方便调试，后者是用来打包发布上线用</div></pre></td></tr></table></figure>
<p><code>moduleName</code>是对应于RN的入口名字，且这个是唯一的，那我们如果原生有多个入口需要初始化不同的RN界面，那该怎么办呢？这就用到了<code>initialProperties</code>，它是字典类型，我们可以将入口作为路由，在<code>initialProperties</code>里传入我们需要初始化的界面名称，入口获取到名称之后，渲染对应的界面即可</p>
<h3 id="RN_u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F"><a href="#RN_u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="RN组件的生命周期"></a>RN组件的生命周期</h3><p>在RN里面，所谓的界面应该称作类或者组件更为合适</p>
<p>并且组件也有它的生命周期，和iOS里的<code>viewWillAppear</code>、<code>viewDidDisappear</code>等等很像，下面生命周期内容取自于<a href="http://www.race604.com/react-native-component-lifecycle/" target="_blank" rel="external">http://www.race604.com/react-native-component-lifecycle/</a></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/RNCycleLife.jpg!700x700" alt=""></p>
<p>我们可以把组件生命周期大致分为三个阶段：</p>
<ul>
<li>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；</li>
<li>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；</li>
<li>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</li>
</ul>
<p>下面来详细介绍生命周期中的各回调函数。</p>
<h4 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h4><p>在组件创建之前，会先调用 <code>getDefaultProps()</code>，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 <code>getInitialState()</code>，来初始化组件的状态。</p>
<h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h4><p>然后，准备加载组件，会调用 <code>componentWillMount()</code>，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentWillMount()</div></pre></td></tr></table></figure>
<p>这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 <code>render()</code> 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。</p>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h4><p>在组件第一次绘制之后，会调用 <code>componentDidMount()</code>，通知组件已经加载完成。函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentDidMount()</div></pre></td></tr></table></figure>
<p>这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 <code>componentDidMount()</code>，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 <code>setTimeout</code> 或者 <code>setInterval</code>，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发。</p>
<h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>如果组件收到新的属性（props），就会调用 <code>componentWillReceiveProps()</code>，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentWillReceiveProps(  </div><div class="line">  object nextProps</div><div class="line">)</div></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 是即将被设置的属性，旧的属性还是可以通过 <code>this.props</code> 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 <code>this.setState()</code> 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 <code>render()</code> 调用。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps: function(nextProps) &#123;  </div><div class="line">  this.setState(&#123;</div><div class="line">    likesIncreasing: nextProps.likeCount &gt; this.props.likeCount</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>当组件接收到新的属性和状态改变的话，都会触发调用 <code>shouldComponentUpdate(...)</code>，函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boolean shouldComponentUpdate(  </div><div class="line">  object nextProps, object nextState</div><div class="line">)</div></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 和上面的 <code>componentWillReceiveProps</code> 函数一样，<code>nextState</code> 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 <code>true</code> 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。</p>
<p>默认情况下，这个函数永远返回 <code>true</code> 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。</p>
<h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>如果组件状态或者属性改变，并且上面的 <code>shouldComponentUpdate(...)</code> 返回为 <code>true</code>，就会开始准更新组件，并调用 <code>componentWillUpdate()</code>，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentWillUpdate(  </div><div class="line">  object nextProps, object nextState</div><div class="line">)</div></pre></td></tr></table></figure>
<p>输入参数与 <code>shouldComponentUpdate</code> 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 <code>this.setState</code> 来修改状态。这个函数调用之后，就会把 <code>nextProps</code> 和 <code>nextState</code> 分别设置到 <code>this.props</code>和 <code>this.state</code> 中。紧接着这个函数，就会调用 <code>render()</code> 来更新界面了。</p>
<h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><p>调用了 <code>render()</code> 更新完成界面之后，会调用 <code>componentDidUpdate()</code> 来得到通知，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentDidUpdate(  </div><div class="line">  object prevProps, object prevState</div><div class="line">)</div></pre></td></tr></table></figure>
<p>因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 <code>prevProps</code> 和 <code>prevState</code>。</p>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h4><p>当组件要被从界面上移除的时候，就会调用 <code>componentWillUnmount()</code>，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentWillUnmount()</div></pre></td></tr></table></figure>
<p>在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等。</p>
<p>下表是生命周期函数的调用次数，以及能否使用 setSate()：</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>调用次数</th>
<th>能否使用 setSate()</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDefaultProps</td>
<td>1(全局调用一次)</td>
<td>否</td>
</tr>
<tr>
<td>getInitialState</td>
<td>1</td>
<td>否</td>
</tr>
<tr>
<td>componentWillMount</td>
<td>1</td>
<td>是</td>
</tr>
<tr>
<td>render</td>
<td>&gt;=1</td>
<td>否</td>
</tr>
<tr>
<td>componentDidMount</td>
<td>1</td>
<td>是</td>
</tr>
<tr>
<td>componentWillReceiveProps</td>
<td>&gt;=0</td>
<td>是</td>
</tr>
<tr>
<td>shouldComponentUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentWillUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentDidUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentWillUnmount</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="RN_u7684_u8BBE_u8BA1_u6A21_u5F0F"><a href="#RN_u7684_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="RN的设计模式"></a>RN的设计模式</h3><p>目前设计模式也非常多，如Flux，Reflux，Redux，Relay，Marty，不过以上都不是很了解，可以参考<a href="https://segmentfault.com/a/1190000004161358" target="_blank" rel="external">ReactNative的组件架构设计</a>学习了解一下，由于做客户端的同学接触的最多的是MVC，MVVM、MVCS等等，所以我觉得选用类似MVCS的模式可能更加适合新手的学习，比如写组件时，通常我们会创建一个组件，里面会包含数据的处理，页面的渲染，样式的设置，网络请求，当这些内容过多时，组件就会显得特别臃肿，所以我们需要将其拆分开为数据模型（Model），页面渲染，样式设置，网路请求（Service），这里的页面渲染和样式设置，不能算是称作为iOS里的Controller和View，应该跟前端一样，在html文件里面写布局，css文件里面写样式，感觉像是MVCS和前端的融合</p>
<h2 id="0x03_RN_u4E0E_u539F_u751F_u7684_u4EA4_u4E92"><a href="#0x03_RN_u4E0E_u539F_u751F_u7684_u4EA4_u4E92" class="headerlink" title="0x03 RN与原生的交互"></a>0x03 RN与原生的交互</h2><p>在写RN时不免会遇到与原生交互，下面我分JS调用原生、原生调用JS来讲</p>
<h3 id="JS_u8C03_u7528_u539F_u751F"><a href="#JS_u8C03_u7528_u539F_u751F" class="headerlink" title="JS调用原生"></a>JS调用原生</h3><p>在调用原生时，我们需要实现<code>RCTBridgeModule</code>和<code>RCT_EXPORT_MODULE();</code></p>
<p><code>RCT_EXPORT_MODULE();</code>则是一个宏定义，返回moduleName，并且调用<code>+ load</code>方法注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define RCT_EXPORT_MODULE(js_name) \</div><div class="line">RCT_EXTERN void RCTRegisterModule(Class); \</div><div class="line">+ (NSString *)moduleName &#123; return @#js_name; &#125; \</div><div class="line">+ (void)load &#123; RCTRegisterModule(self); &#125;</div></pre></td></tr></table></figure>
<p>例如我们增加一个bridge方法，获取版本号，<code>getVersion</code>为方法名，<code>callback</code>是原生回调给JS的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RCT_EXPORT_METHOD(getVersion : (RCTResponseSenderBlock)callback) &#123;</div><div class="line">    NSString *version =</div><div class="line">    [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];</div><div class="line">    callback(@[[NSNull null], @[version]]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后返回方法的队列为主队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (dispatch_queue_t)methodQueue &#123;</div><div class="line">    return dispatch_get_main_queue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在JS文件里，我们可以定义一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ZanIntentModule = NativeModules.ZanIntentModule;</div></pre></td></tr></table></figure>
<p>然后在使用的时候调用我们在原生时定义方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ZanIntentModule.getVersion(</div><div class="line"><span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// do some thing</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="u539F_u751F_u8C03_u7528JS"><a href="#u539F_u751F_u8C03_u7528JS" class="headerlink" title="原生调用JS"></a>原生调用JS</h3><p>老版本的调用方式为，但是接口被标记为deprecated：<code>__deprecated_msg(&quot;Subclass RCTEventEmitter instead&quot;);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.bridge.eventDispatcher sendAppEventWithName:kGiftReloadData body:nil];</div></pre></td></tr></table></figure>
<p>新版本的调用方式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ZanEventEmitter *emitter = [[ZanEventEmitter alloc] init];</div><div class="line">emitter.bridge = self.bridge;</div><div class="line">[emitter sendEventWithName:kGiftReloadData body:nil];</div></pre></td></tr></table></figure>
<p>但是新版本坑的是，直接这样调用时bridge居然是nil，网上说用单例，但是也不行…所以我还是用老版本的调用方法，有哪个大神知道怎么用新版本接口调用的正确姿势，请留言交流哈</p>
<p>然后在实现<code>RCTBridgeDelegate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge &#123;</div><div class="line">    return [[NSBundle mainBundle] URLForResource:@&quot;bundle/index.ios&quot; withExtension:@&quot;jsbundle&quot;];</div><div class="line">//    return [NSURL URLWithString:@&quot;http://172.17.9.94:8081/index.ios.bundle?platform=ios&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在对应的组件里，需要在<code>componentWillMount</code>增加监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentWillMount() &#123;</div><div class="line">  <span class="keyword">this</span>.eventEmitter = NativeAppEventEmitter.addListener(</div><div class="line">    <span class="string">'GiftReloadData'</span>,</div><div class="line">    () =&gt; <span class="keyword">this</span>._reloadData()</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的也需要移除掉监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">componentWillUnmount() &#123;</div><div class="line">  subscription.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后原生发送action之后，会触发我们设定好的<code>reloadData()</code>方法</p>
<h2 id="0x04__u672C_u5730_u8C03_u8BD5_u4E0E_u6253_u5305_u8C03_u8BD5"><a href="#0x04__u672C_u5730_u8C03_u8BD5_u4E0E_u6253_u5305_u8C03_u8BD5" class="headerlink" title="0x04 本地调试与打包调试"></a>0x04 本地调试与打包调试</h2><p>在编写的过程中，也需要进行调试，调试有两种方法：一种是本地调试，一种是打包调试</p>
<h3 id="u672C_u5730_u8C03_u8BD5"><a href="#u672C_u5730_u8C03_u8BD5" class="headerlink" title="本地调试"></a>本地调试</h3><p>我们在加载bundle时，需要替换成你的ip地址，端口号不要变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[NSURL URLWithString:@&quot;http://172.17.9.94:8081/index.ios.bundle?platform=ios&quot;]</div></pre></td></tr></table></figure>
<p>如果你是在真机上调试，你需要开启HTTP代理，填写你的ip地址和端口号</p>
<p>在终端上，先进入到你的项目目录（与node_modules目录同级），然后开启服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yzydeMacBook-Pro:shangjiaban-ios yzy$ npm start</div></pre></td></tr></table></figure>
<p>你修改了某处之后，在模拟器上点击<code>Shake Gesture</code>或者快捷键，在真机上只要摇一摇就可以</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Shake.png!400x400" alt=""></p>
<p>在模拟器弹出框里选择<code>Roload</code>，这样就会重新加载你本地的JS文件</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/simulation.png!400x400" alt=""></p>
<p>如果你想查看JS里面的log日志，你可以选择<code>Start Remote JS Debugging</code>，在chrome浏览器里就能看到输出的日志了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/chromeDebug.png" alt=""></p>
<h3 id="u6253_u5305_u8C03_u8BD5"><a href="#u6253_u5305_u8C03_u8BD5" class="headerlink" title="打包调试"></a>打包调试</h3><p>另外一种就是打包调试，但是比较麻烦，首先我们要讲bundle加载方式改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSBundle mainBundle] URLForResource:@&quot;bundle/index.ios&quot; withExtension:@&quot;jsbundle&quot;];</div></pre></td></tr></table></figure>
<p>然后在终端里面，输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yzydeMacBook-Pro:shangjiaban-ios yzy$ react-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output ./xxx/bundle/index.ios.jsbundle --assets-dest ./xxx/bundle</div></pre></td></tr></table></figure>
<p><code>--bundle-output ./xxx/bundle/index.ios.jsbundle</code>指的是输出的bundle文件路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[20:54:43] &lt;START&gt; Building Dependency Graph</div><div class="line">[20:54:43] &lt;START&gt; Crawling File System</div><div class="line">[20:54:43] &lt;START&gt; find dependencies</div><div class="line">[20:54:48] &lt;END&gt;   Crawling File System (4712ms)</div><div class="line">[20:54:48] &lt;START&gt; Building in-memory fs for JavaScript</div><div class="line">[20:54:48] &lt;END&gt;   Building in-memory fs for JavaScript (230ms)</div><div class="line">[20:54:48] &lt;START&gt; Building in-memory fs for Assets</div><div class="line">[20:54:48] &lt;END&gt;   Building in-memory fs for Assets (154ms)</div><div class="line">[20:54:48] &lt;START&gt; Building Haste Map</div><div class="line">[20:54:48] &lt;START&gt; Building (deprecated) Asset Map</div><div class="line">[20:54:48] &lt;END&gt;   Building (deprecated) Asset Map (66ms)</div><div class="line">[20:54:48] &lt;END&gt;   Building Haste Map (154ms)</div><div class="line">[20:54:48] &lt;END&gt;   Building Dependency Graph (5261ms)</div><div class="line">transformed 372/372 (100%)</div><div class="line">[20:54:49] &lt;END&gt;   find dependencies (6402ms)</div><div class="line">bundle: start</div><div class="line">bundle: finish</div><div class="line">bundle: Writing bundle output to: ./Koudaitong/bundle/index.ios.jsbundle</div><div class="line">bundle: Copying 5 asset files</div><div class="line">bundle: Done writing bundle output</div><div class="line">bundle: Done copying assets</div></pre></td></tr></table></figure>
<p>当看到这样的信息的时候，说明已经打包成功了，再将生成的bundle文件夹以<code>Create folder references</code>形式加到工程里，然后就可以run了</p>
<p>Tip:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在真机调试时，需要在Edit Scheme里在Run模式里，将Build Configuration改为Release模式</div></pre></td></tr></table></figure>
<h2 id="0x05__u8FDC_u7A0B_u70ED_u66F4_u65B0"><a href="#0x05__u8FDC_u7A0B_u70ED_u66F4_u65B0" class="headerlink" title="0x05 远程热更新"></a>0x05 远程热更新</h2><p>这块网上的方案大同小异，因为目前我们还是采取本地打包加载的方式，还未上热更新，所以在这不好多做说明，等上了热更新之后，我再来补充~</p>
<p>2016年11月23日更新：</p>
<p>Tips：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">该热更新方法取自于有赞技术团队官方博客里《React Native有赞初探》，欢迎关注我们技术团队的博客~</div></pre></td></tr></table></figure>
<h3 id="u9009_u578B"><a href="#u9009_u578B" class="headerlink" title="选型"></a>选型</h3><p>经过调研和选型，最终选择了微软出品的 <code>CodePush</code> 作为 <code>React Native</code> 热部署方案。</p>
<p><code>CodePush</code> 是提供给 <code>React Native</code> 开发者直接部署移动应用更新给用户设备的云服务。<code>CodePush</code> 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 <code>SDK</code> 里面查询更新。<code>CodePush</code> 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。</p>
<p><code>CodePush</code> 可以进行实时的推送代码更新：</p>
<ul>
<li>直接对用户部署代码更新</li>
<li>管理 <code>Alpha</code> ， <code>Beta</code> 和生产环境应用</li>
<li>支持 <code>JavaScript</code> 文件与图片资源的更新</li>
<li>暂不支持增量更新</li>
</ul>
<p><code>CodePush</code> 开源了 <code>react-native</code> 版本，<a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="external">react-native-code-push</a>托管在GitHub上。</p>
<p>具体的教程和用法微软都在 <code>Github上</code> 做了详细说明，接下来简单地梳理一下从配置、编码、部署等具体流程。</p>
<p>(1) 安装 <code>CodePush CLI</code></p>
<p>管理 <code>CodePush</code> 账号需要通过 <code>NodeJS-based CLI</code>。 只需要在终端输入 <code>npm install -g code-push-cli</code> ，就可以安装了。 安装完毕后，输入 <code>code-push -v</code> 查看版本，如看到版本代表成功。</p>
<p>(2) 创建一个 <code>CodePush</code> 账号 在终端输入 <code>code-push register</code> ，会打开如下注册页面让你选择授权账号。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/codepush.png" alt=""></p>
<p>授权通过之后，<code>CodePush</code> 会告诉你“access key”，复制此key到终端即可完成注册。</p>
<p>然后终端输入 <code>code-push login</code> 进行登陆，登陆成功后，你的session文件将会写在 /Users/你的用户名 <code>/.code-push.config</code>。</p>
<p>(3) 在CodePush服务器注册app 为了让 <code>CodePush</code> 服务器知道你的app，我们需要向它注册app： 在终端输入 <code>code-push app add</code> 即可完成注册。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code-push app add shangjiaban-android</div></pre></td></tr></table></figure>
<blockquote>
<p>如果是iOS平台，命令为 <code>code-push app add shangjiaban-ios</code> ， <code>Android</code> 和 <code>iOS</code> 必须要区分</p>
</blockquote>
<p>还有很多 <code>code-push app</code> 相关的命令，参考如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$: code-push app help</div><div class="line">Usage: code-push app &lt;command&gt;</div><div class="line"></div><div class="line">命令：</div><div class="line">  add       Add a new app to your account</div><div class="line">  remove    Remove an app from your account</div><div class="line">  rm        Remove an app from your account</div><div class="line">  rename    Rename an existing app</div><div class="line">  list      Lists the apps associated with your account</div><div class="line">  ls        Lists the apps associated with your account</div><div class="line">  transfer  Transfer the ownership of an app to another account</div></pre></td></tr></table></figure>
<h3 id="iOS_u914D_u7F6E"><a href="#iOS_u914D_u7F6E" class="headerlink" title="iOS配置"></a>iOS配置</h3><p>iOS平台上关于 <code>CodePush</code> 的配置和 <code>Android</code> 平台是类似的，可以参考上文的(1)(2)(3)，iOS平台集成 <code>CodePush</code> 比较简单，官网提供了3种集成方式，这里重点介绍如何通过 <code>cocoapods</code> 来集成。</p>
<p>(1) 引入 <code>CodePush</code></p>
<p>首先在Podfile文件中添加 <code>CodePush</code>，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;CodePush&apos;, :path =&gt; &apos;./node_modules/react-native-code-push&apos;</div></pre></td></tr></table></figure>
<p>然后执行 <code>pod install</code> 就可以了。</p>
<p>(2) 声明 <code>bundle</code> 文件来源</p>
<p>引入 <code>CodePush</code> 后还需要在代码中声明 <code>bundle</code> 的加载来源，之前是加载本地的<code>bundle</code>文件，现在需要调用 <code>CodePush</code> 提供的方法指定加载 <code>Bundle</code> 文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &quot;CodePush.h&quot;</div><div class="line">...</div><div class="line">// 原来的bundle加载方法</div><div class="line">jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</div><div class="line"></div><div class="line">// CodePush的bundle加载方法，这里的bundleURL默认加载的是main.jsbundle，</div><div class="line">// 如果你的名称不一样，需要调用CodePush提供的其他方法来自定义。</div><div class="line">jsCodeLocation = [CodePush bundleURL];</div></pre></td></tr></table></figure>
<p>最后还需要在 <code>Info.plist</code> 中添加一个 <code>key</code> 为 <code>CodePushDeploymentKey</code> ,其<code>value</code> 就是 <code>CodePush</code> 提供的唯一 <code>token</code> 值。具体获取方法，可以通过如下命令获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code-push deployment ls &lt;appName&gt; -k</div></pre></td></tr></table></figure>
<h3 id="RN_u914D_u7F6E"><a href="#RN_u914D_u7F6E" class="headerlink" title="RN配置"></a>RN配置</h3><p>为了达到更好的体验效果，我们决定采用静默升级的策略，让用户无感知地体验热更新，也可以是具体的升级流程图如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/updateStrategy.png!500x500" alt=""></p>
<p>如果要达成上述热部署效果，那么还需要在 <code>JavaScript</code> 文件中完成更新时机和更新策略的设置。</p>
<p>(1)在js中导入 <code>CodePush</code> 模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import codePush from &apos;react-native-code-push&apos;</div></pre></td></tr></table></figure>
<p>(2)在 <code>componentDidMount</code> 中调用 <code>sync</code> 方法，后台请求更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codePush.sync()</div></pre></td></tr></table></figure>
<p>如果是非强制并允许更新， <code>CodePush</code> 会在后台静默地将更新下载到本地，等待APP再一次启动或者加载 <code>React Native</code> 页面的时候更新应用。</p>
<p>如果更新是强制性的，更新文件下载好之后会立即进行更新。关于如何配置是否强制更新，会在下文发布更新处重点说明。</p>
<p>如果你期望更及时的获得更新，可以在每次APP从后台进入前台的时候去主动的检查更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AppState.addEventListener(&quot;change&quot;, (newState) =&gt; &#123;  </div><div class="line">        newState === &quot;active&quot; &amp;&amp; codePush.sync(&#123;</div><div class="line">            installMode:codePush.InstallMode.ON_NEXT_RESUME,</div><div class="line">            deploymentKey: DEPLOYMENT_KEY,</div><div class="line">          &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>上述流程图提及的三种更新方式，就是通过 <code>installMode</code> 参数控制的，取值方式分别为：</p>
<ol>
<li><code>codePush.InstallMode.ON_NEXT_RESTART</code>即下一次启动的时候安装更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESUME</code>即下一次切后台切换的时候安装更新</li>
<li><code>codePush.InstallMode. IMMEDIATE</code>立即下载安装更新</li>
</ol>
<blockquote>
<p>如果发布更新时 <code>mandatory</code> 参数为true，即强制更新，则上述设置都会无效，只有<code>mandatory</code> 参数为fasle时，设置才会有效。</p>
</blockquote>
<h3 id="u6253_u5305_u5E76_u53D1_u5E03"><a href="#u6253_u5305_u5E76_u53D1_u5E03" class="headerlink" title="打包并发布"></a>打包并发布</h3><p>(1) 打包js 发布更新之前，需要先把js打包成 <code>bundle</code> ，以下是Android的做法：</p>
<p>第一步： 在 <code>Android</code> 工程目录里面新增 <code>release</code> 文件： <code>mkdir release</code> ，对于iOS来说，目前 <code>bundle</code> 文件直接放在工程根目录下，所以无需这一步。 第二步： 运行命令打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试。</div></pre></td></tr></table></figure>
<p>例如:</p>
<p>Android</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native bundle --platform android --entry-file index.android.js --bundle-output ./release/index.android.bundle --assets-dest ./release --dev false</div></pre></td></tr></table></figure>
<p>iOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native bundle --platform ios --entry-file index.ios.js --bundle-output ./Koudaitong/main.jsbundle --assets-dest ./Koudaitong --dev false</div></pre></td></tr></table></figure>
<p>(2) 发布更新</p>
<p>打包 <code>bundle</code> 结束后，就可以通过 <code>CodePush</code> 发布更新了。在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">code-push release &lt;应用名称&gt; &lt;Bundles所在目录&gt; &lt;对应的应用版本&gt; --deploymentName： 更新环境  </div><div class="line">--description： 更新描述 --mandatory： 是否强制更新</div></pre></td></tr></table></figure>
<p>例如：</p>
<p>Android</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code-push release shangjiaban-android ./release 3.12.1 --description &quot;update React Native&quot; --mandatory true</div></pre></td></tr></table></figure>
<p>iOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code-push release shangjiaban-ios ./Koudaitong/main.jsbundle 3.12.0 --description &quot;update React Native&quot; --mandatory false</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
</blockquote>
<ol>
<li><code>CodePush</code> 默认是更新 <code>Staging</code> 环境的，如果是 <code>Staging</code> ，则不需要填写<code>deploymentName</code>。</li>
<li>如果有 <code>mandatory</code> 则 <code>Code Push</code> 会根据 <code>mandatory</code> 是 <code>true</code> 或<code>false</code> 来控制应用是否强制更新。默认情况下 <code>mandatory</code> 为 <code>false</code> 即不强制更新。</li>
<li>对应的应用版本 <code>targetBinaryVersion</code> 是指当前app的版本(对应 <code>build.gradle</code> 中设置的versionName “3.12.1”)，也就是说此次更新的 <code>js/images</code> 对应的是app的那个版本。不要将其理解为这次js更新的版本。 如客户端版本是3.12.1，那么我们对3.12.1的客户端更新 <code>js/images</code> ， <code>targetBinaryVersion</code> 填的就是3.12.1。</li>
<li>对于对某个应用版本进行多次更新的情况， <code>CodePush</code> 会检查每次上传的 <code>bundle</code> ，如果在该版本下如3.12.1已经存在与这次上传完全一样的 <code>bundle</code> (对应一个版本有两个 <code>bundle</code> 的 <code>md5</code> 完全一样)，那么 <code>CodePush</code> 会拒绝此次更新。</li>
</ol>
<h2 id="0x06_iOS_u548CAndroid_u4E0D_u540C_u6837_u5F0F_u5904_u7406"><a href="#0x06_iOS_u548CAndroid_u4E0D_u540C_u6837_u5F0F_u5904_u7406" class="headerlink" title="0x06 iOS和Android不同样式处理"></a>0x06 iOS和Android不同样式处理</h2><p>最近看到FB的F8代码里面对于iOS和Android不同平台上样式的处理觉得挺不错的，由于系统原生控件样式设计风格的不一样，导致在写styles的时候会根据不同的platform来写，之前做法是定义不同的styles，然后判断platform去用，这样styles里面的代码会存在冗余，而且对styles的定义也不好</p>
<p>FB的做法是定义一个styles的基类，然后基类里解析平台信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">styles: Object</span>): </span>&#123;[name: string]: number&#125; &#123;</div><div class="line">  <span class="keyword">const</span> platformStyles = &#123;&#125;;</div><div class="line">  <span class="built_in">Object</span>.keys(styles).forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> &#123;ios, android, ...style&#125; = &#123;...styles[name]&#125;;</div><div class="line">    <span class="keyword">if</span> (ios &amp;&amp; Platform.OS === <span class="string">'ios'</span>) &#123;</div><div class="line">      style = &#123;...style, ...ios&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (android &amp;&amp; Platform.OS === <span class="string">'android'</span>) &#123;</div><div class="line">      style = &#123;...style, ...android&#125;;</div><div class="line">    &#125;</div><div class="line">    platformStyles[name] = style;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> StyleSheet.create(platformStyles);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析完之后，在styles里面，会根据不同的platform取不同的样式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">button: &#123;</div><div class="line">    <span class="attr">borderColor</span>: <span class="string">'transparent'</span>,</div><div class="line">    <span class="attr">alignItems</span>: <span class="string">'center'</span>,</div><div class="line">    <span class="attr">justifyContent</span>: <span class="string">'center'</span>,</div><div class="line">    <span class="attr">backgroundColor</span>: <span class="string">'transparent'</span>,</div><div class="line">    <span class="attr">ios</span>: &#123;</div><div class="line">      <span class="attr">height</span>: HEIGHT,</div><div class="line">      <span class="attr">paddingHorizontal</span>: <span class="number">20</span>,</div><div class="line">      <span class="attr">borderRadius</span>: HEIGHT / <span class="number">2</span>,</div><div class="line">      <span class="attr">borderWidth</span>: <span class="number">1</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">android</span>: &#123;</div><div class="line">      <span class="attr">paddingBottom</span>: <span class="number">6</span>,</div><div class="line">      <span class="attr">paddingHorizontal</span>: <span class="number">10</span>,</div><div class="line">      <span class="attr">borderBottomWidth</span>: <span class="number">3</span>,</div><div class="line">      <span class="attr">marginRight</span>: <span class="number">10</span>,</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<h2 id="0x07__u8E29_u5751_u8BB0_u5F55"><a href="#0x07__u8E29_u5751_u8BB0_u5F55" class="headerlink" title="0x07 踩坑记录"></a>0x07 踩坑记录</h2><p>踩坑最多是应该是使用上的</p>
<p>1.RN系统的组件并不是所有都是共用的，比如segment支持iOS，不支持Android，Alert分为iOS和Android等等，所以还是要写重复的代码</p>
<p>2.ListView不支持iOS原生的滑动操作，需要使用第三方库，但是第三方库不能控制只编辑一个Cell</p>
<p>3.由于原先iOS和Android的代码仓库是分开的，所以接入RN时，JS文件也是跟着仓库走的，这样iOS和Android会存在重复代码，并且目前两个人分别接iOS和Android，写JS时，有时并不共享，容易代码写着写着就有差异了，偏离了Write Once , Run Anywhere的初衷</p>
<h2 id="0x08__u76F8_u5173_u8D44_u6599"><a href="#0x08__u76F8_u5173_u8D44_u6599" class="headerlink" title="0x08 相关资料"></a>0x08 相关资料</h2><p><a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a></p>
<p><a href="http://reactnative.cn/" target="_blank" rel="external">React Native 中文网</a></p>
<p><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="external">汇集了各类react-native学习资源、开源App和组件</a></p>
<p><a href="http://blog.talisk.cn/blog/2016/08/13/RN-Learning-path-for-iOS-developer/" target="_blank" rel="external">写给 iOS 开发者的 React Native 学习路线</a></p>
<p><a href="http://www.lcode.org/" target="_blank" rel="external">江清清的技术专栏</a></p>
<p><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8" target="_blank" rel="external">React/React Native 的ES5 ES6写法对照表</a></p>
<p><a href="http://tech.youzan.com/react-native-zan/" target="_blank" rel="external">React Native有赞初探</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一段时间没有写东西了，因为最近项目开始尝试使用React Native（以下简称RN）来开发，所以这段时间一直在研究，目前为止开发的内容不多，所以使用过的东西也不算多，这里也只是做个简单的记录&lt;/p&gt;
&lt;p&gt;这里我打算从以下几个方面来讲：&lt;/p&gt;
&lt;p&gt;1.背景介绍&lt;/p&gt;
&lt;p&gt;2.环境的配置&lt;/p&gt;
&lt;p&gt;3.RN所需要知道的知识&lt;/p&gt;
&lt;p&gt;4.RN与原生的交互&lt;/p&gt;
&lt;p&gt;5.本地调试与本地打包调试&lt;/p&gt;
&lt;p&gt;6.远程热更新&lt;/p&gt;
&lt;p&gt;7.iOS和Android不同样式处理&lt;/p&gt;
&lt;p&gt;8.踩坑记录&lt;/p&gt;
&lt;p&gt;9.相关资料&lt;/p&gt;
    
    </summary>
    
    
      <category term="React Native" scheme="http://yuzeyang.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>iOS 抽屉式效果列表</title>
    <link href="http://yuzeyang.github.io/2016/09/08/iOS-Drawer-Table-View/"/>
    <id>http://yuzeyang.github.io/2016/09/08/iOS-Drawer-Table-View/</id>
    <published>2016-09-08T14:16:43.000Z</published>
    <updated>2016-09-12T11:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前很喜欢收藏<a href="https://dribbble.com/shots" target="_blank" rel="external">dribbble</a>里面的一些动效gif，里面不仅是动效还是配色等等都非常的美，作为一个视觉动物，真的想把他们一个一个都实现出来，作为自己的一个作品，那真的是一件赏心悦目的事情，看着G20也快结束了，赶紧趁还闲着，先实现一个，我先挑选了一个比较简单的动效—–<strong>抽屉式效果列表</strong></p>
<p>我们先来看下效果:</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCDrawerTableView.gif!500x500" alt=""></p>
<a id="more"></a>
<p>原来的动效地址找不到了…有知道的请留言给我…</p>
<p>代码地址：<a href="https://github.com/Yuzeyang/GCDrawerTableView" target="_blank" rel="external">https://github.com/Yuzeyang/GCDrawerTableView</a></p>
<p>老样子，我们来分析下步骤</p>
<h2 id="0x00_cell_u7684_u5904_u7406"><a href="#0x00_cell_u7684_u5904_u7406" class="headerlink" title="0x00 cell的处理"></a>0x00 cell的处理</h2><p>我们将<code>cell</code>和<code>详情界面</code>分开来处理</p>
<p>我们可以看到，当我们选中其中一个<code>cell</code>的时候，该<code>cell</code>会移动到列表上方的某一个位置，其他<code>cell</code>则不显示，点击<code>x</code>的时候，<code>cell</code>返回为原位，其他<code>cell</code>又重新显示</p>
<p>选中处理：首先是先将其他<code>cell</code>隐藏，我们取出<code>tableview</code>的可见<code>cell</code>，然后将除了选中的<code>cell</code>之外的透明度都设置为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GCTableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];</div><div class="line">[self.tableView bringSubviewToFront:cell];</div><div class="line">for (UIView *subcell in tableView.visibleCells) &#123;</div><div class="line">    if (subcell != cell) &#123;</div><div class="line">        subcell.alpha = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后改变选中<code>cell</code>的原点值，并且给<code>cell</code>增加阴影，这里我偷懒没有做按钮的动画，只是用文字表示了按钮的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">    CGRect rect = self.frame;</div><div class="line">    self.originCellFrame = rect;</div><div class="line">    CGPoint origin = CGPointMake(0, contentOffsetY + 30);</div><div class="line">    rect.origin = origin;</div><div class="line">    self.frame = rect;</div><div class="line"></div><div class="line">    // 详情页处理</div><div class="line"></div><div class="line">    [self addShadowWithView:self];</div><div class="line">    [self addShadowWithView:self.detailView];</div><div class="line">    [self.detailButton setTitle:@&quot;×&quot; forState:UIControlStateNormal];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>由于cell的动画处理是放在自定义cell里面做的，所以在点击关闭的时候，需要在动画结束之后回调给视图控制器，所以这里就用了block来回调关闭的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)deselectCell &#123;</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        self.frame = self.originCellFrame;</div><div class="line">        </div><div class="line">        self.layer.shadowColor = [UIColor clearColor].CGColor;</div><div class="line">        self.layer.shadowRadius = 0;</div><div class="line">        self.layer.shadowOpacity = 0.0;</div><div class="line">        </div><div class="line">        // 详情页处理</div><div class="line">        [self.detailButton setTitle:@&quot;...&quot; forState:UIControlStateNormal];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [self.helperHideView removeFromSuperview];</div><div class="line">        [self.detailView removeFromSuperview];</div><div class="line">        if (_deselectBlock) &#123;</div><div class="line">            _deselectBlock();</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在试图控制器里面，将其他的cell透明度改成1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[cell addDeselectBlock:^() &#123;</div><div class="line">    for (UIView *subcell in tableView.visibleCells) &#123;</div><div class="line">        if (subcell != cell) &#123;</div><div class="line">            subcell.alpha = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    tableView.allowsSelection = YES;</div><div class="line">    tableView.scrollEnabled = YES;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="0x01__u8BE6_u60C5_u9875"><a href="#0x01__u8BE6_u60C5_u9875" class="headerlink" title="0x01 详情页"></a>0x01 详情页</h2><p>可以看到<code>详情页</code>是类似于从上掉落的感觉，可能会联想到电商的那些筛选栏，但是筛选栏点击的时候，是上部分开始出现一直到下面，展示的顺序是反过来的，后面想了很久，只能想到利用视觉错误的效果，将详情页添加到cell的下一层，然后<code>cell</code>动画时候，详情页也做相应的动画，但是由于详情页的<code>size</code>比<code>cell</code>肯定是要大的，所以如果加到<code>cell</code>下一层时，是遮挡不住的，所以就需要一个遮挡的view来遮住详情页</p>
<p>首先我们需要将<code>cell</code>移到最前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.tableView bringSubviewToFront:cell];</div></pre></td></tr></table></figure>
<p>然后在cell的下一层加上<code>遮挡视图</code>和<code>详情页</code>，并根据cell的origin做frame的变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">UIView *superview = self.superview;</div><div class="line">    </div><div class="line">CGFloat height = CGRectGetMinY(self.frame) - contentOffsetY + 30;</div><div class="line">[self.helperHideView setFrame:CGRectMake(0, contentOffsetY, CGRectGetWidth(self.frame), height)];</div><div class="line">[superview insertSubview:self.helperHideView belowSubview:self];</div><div class="line"></div><div class="line">[self.detailView setFrame:CGRectMake(0, CGRectGetMaxY(self.frame) - (GCDeviceHeight - 100 - 30*2),</div><div class="line">                                     CGRectGetWidth(self.frame), GCDeviceHeight - 100 - 30*2)];</div><div class="line">[superview insertSubview:self.detailView belowSubview:self.helperHideView];</div><div class="line"></div><div class="line">[UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">  	// cell处理  </div><div class="line">  </div><div class="line">  	CGRect rect2 = self.helperHideView.frame;</div><div class="line">    self.originHelperViewFrame = rect2;</div><div class="line">    CGPoint origin2 = CGPointMake(0, contentOffsetY + 30 - height);</div><div class="line">    rect2.origin = origin2;</div><div class="line">    self.helperHideView.frame = rect2;</div><div class="line"></div><div class="line">    CGRect rect1 = self.detailView.frame;</div><div class="line">    self.originDetailViewFrame = rect1;</div><div class="line">    CGPoint origin1 = CGPointMake(0, 100 + 30 + contentOffsetY);</div><div class="line">    rect1.origin = origin1;</div><div class="line">    self.detailView.frame = rect1;</div><div class="line"></div><div class="line">    [self addShadowWithView:self];</div><div class="line">    [self addShadowWithView:self.detailView];</div><div class="line">    [self.detailButton setTitle:@&quot;×&quot; forState:UIControlStateNormal];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>然后在关闭的时候，移除掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)deselectCell &#123;</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        // cell处理</div><div class="line">        </div><div class="line">        self.detailView.layer.shadowColor = [UIColor clearColor].CGColor;</div><div class="line">        self.detailView.layer.shadowRadius = 0;</div><div class="line">        self.detailView.layer.shadowOpacity = 0.0;</div><div class="line">        </div><div class="line">        self.detailView.frame = self.originDetailViewFrame;</div><div class="line">        self.helperHideView.frame = self.originHelperViewFrame;</div><div class="line">        </div><div class="line">        [self.detailButton setTitle:@&quot;...&quot; forState:UIControlStateNormal];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [self.helperHideView removeFromSuperview];</div><div class="line">        [self.detailView removeFromSuperview];</div><div class="line">        if (_deselectBlock) &#123;</div><div class="line">            _deselectBlock();</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就实现了抽屉式的效果，但是总感觉还有更好的办法实现，如果有思路的，欢迎交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前很喜欢收藏&lt;a href=&quot;https://dribbble.com/shots&quot;&gt;dribbble&lt;/a&gt;里面的一些动效gif，里面不仅是动效还是配色等等都非常的美，作为一个视觉动物，真的想把他们一个一个都实现出来，作为自己的一个作品，那真的是一件赏心悦目的事情，看着G20也快结束了，赶紧趁还闲着，先实现一个，我先挑选了一个比较简单的动效—–&lt;strong&gt;抽屉式效果列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来看下效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCDrawerTableView.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="抽屉式 列表" scheme="http://yuzeyang.github.io/tags/%E6%8A%BD%E5%B1%89%E5%BC%8F-%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>果冻效果下拉刷新控件</title>
    <link href="http://yuzeyang.github.io/2016/09/02/loadingAniamtion-0902/"/>
    <id>http://yuzeyang.github.io/2016/09/02/loadingAniamtion-0902/</id>
    <published>2016-09-02T05:23:04.000Z</published>
    <updated>2016-09-02T09:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个下拉控件是在<a href="http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/?sukey=3997c0719f151520e178bb5175f11bfb983f5560c51261103fafb276bac79e1371d16e07ede0cca9f23d826405507a3c" target="_blank" rel="external">Elastic view animation using UIBezierPath</a>这篇博客上看到的，觉得效果还不错，自己也就OC简单实现了一下（原作者是用Swift写的），控件效果如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationTwo.gif!700x700" alt=""></p>
<p>这是代码地址：<a href="https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo" target="_blank" rel="external">https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo</a></p>
<p>这个控件的动画效果分为两个部分：</p>
<p>1.下拉的果冻效果</p>
<p>2.下拉进度圆圈的显示及旋转</p>
<a id="more"></a>
<h2 id="0x00__u4E0B_u62C9_u679C_u51BB_u72B6_u6001_u5B9E_u73B0_u601D_u8DEF"><a href="#0x00__u4E0B_u62C9_u679C_u51BB_u72B6_u6001_u5B9E_u73B0_u601D_u8DEF" class="headerlink" title="0x00 下拉果冻状态实现思路"></a>0x00 下拉果冻状态实现思路</h2><p>对于下拉的状态，我将其分为三种，然后在初始化的时候，将状态设置为正常状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, GCLoadingState) &#123;</div><div class="line">    GCLoadingStateNormal,	// 正常状态</div><div class="line">    GCLoadingStateLoading,	// 加载中状态</div><div class="line">    GCLoadingStateCancelled	// 取消加载状态</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>并且在初始化的时候，绘制曲线的初始样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)drawOriginPath &#123;</div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:CGPointMake(0, 0)];</div><div class="line">    [path addLineToPoint:CGPointMake(0, kGCLoadingViewMinHeight)];</div><div class="line">    [path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), kGCLoadingViewMinHeight)];</div><div class="line">    [path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), 0)];</div><div class="line">    </div><div class="line">    self.loadLayer.path = path.CGPath;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那在手指拖动的过程中，我们该如果实现果冻拉伸的效果呢？</p>
<p>我们需要一个辅助视图<code>centerHelperView</code>，这个辅助视图是加在下面这条线的中间的，如图的小黑点：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/centerHelperView.png!500x500" alt=""></p>
<p>在下拉时我们就根据这个<code>centerHelperView</code>的变化来不断的绘制我们的曲线，所以我们用到了<code>CADisplayLink</code>，这个应该在写动画的时候用的也是比较多了，是根据屏幕的刷新频率将内容绘制到屏幕的定时器，当我们将定时器加到<code>runLoop</code>里时，我们需要注意在设置<code>mode</code>时，如果将<code>mode</code>设置为<code>NSDefaultRunLoopMode</code>，那么在滑动的时候，定时器会暂停，直到停止滑动才会继续工作，所以我们需要将<code>mode</code>设置为<code>NSRunLoopCommonModes</code>，这样能保证定时器在滑动的过程中也能正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (CADisplayLink *)displayLink &#123;</div><div class="line">    if (!_displayLink) &#123;</div><div class="line">        _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkAction:)];</div><div class="line">        [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line">        _displayLink.paused = YES;</div><div class="line">    &#125;</div><div class="line">    return _displayLink;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在取出<code>centerHelperView</code>的原点，来不断绘制果冻的曲线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)displayLinkAction:(CADisplayLink *)displayLink &#123;</div><div class="line">    CALayer *centerHelperViewLayer = (CALayer *)[self.centerHelperView.layer presentationLayer];</div><div class="line">    CGRect centerHelperViewRect = [[centerHelperViewLayer valueForKey:@&quot;frame&quot;] CGRectValue];</div><div class="line">    [self drawLoadLayerWithCenter:centerHelperViewRect.origin];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然我们能够获取到<code>centerHelperView</code>在不同时间里的位置，那么我们就可以根据它来绘制我们的曲线</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/loadingPoint.png!300x300" alt=""></p>
<p>我们可以看到左右两边都是直线，调用<code>- addLineToPoint</code>方法即可，重要的是底下这条线，我们获取到<code>centerHelperView</code>的位置后，暂且用<code>c</code>来表示，我们在绘制曲线时，需要用到<code>controlPoint1</code>和<code>controlPoint2</code>，那我们就把底下的线分为三段，并且以<code>c</code>为中心店，左边取出<code>l3</code>、<code>l2</code>、<code>l1</code>，右边取出<code>r3</code>、<code>r2</code>、<code>r1</code>，曲线分为三条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">[path moveToPoint:CGPointMake(0, 0)];</div><div class="line">[path addLineToPoint:l3];</div><div class="line">[path addCurveToPoint:l1 controlPoint1:l3 controlPoint2:l2];</div><div class="line">[path addCurveToPoint:r1 controlPoint1:l1 controlPoint2:c];</div><div class="line">[path addCurveToPoint:r3 controlPoint1:r1 controlPoint2:r2];</div><div class="line">[path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), 0)];</div></pre></td></tr></table></figure>
<p>果冻的曲线我们就完成了，然后我们就要开始对手势的状态来进行处理</p>
<p>在写控件调试的时候，你可以通过给目标视图添加<code>UIPanGestureRecognizer</code>，调用<code>- translationInView:</code>来获取到手指在屏幕上拖动时位置的变化，但是下拉刷新控件一般都是加在ScrollView上的，ScrollView自己是有一个只读的<code>UIPanGestureRecognizer</code>属性，所以我们不必自己再添加一个，我们只需要观察<code>UIPanGestureRecognizer</code>的<code>state</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.associatedScrollView addObserver:self forKeyPath:@&quot;panGestureRecognizer.state&quot; options:NSKeyValueObservingOptionNew context:nil];</div></pre></td></tr></table></figure>
<p>在取消拖动时，我们根据<code>ScrollView</code>的<code>contentOffset</code>来判断，是否是取消加载还是加载</p>
<h2 id="0x01__u4E0B_u62C9_u8FDB_u5EA6_u5706_u5708_u7684_u663E_u793A_u53CA_u65CB_u8F6C"><a href="#0x01__u4E0B_u62C9_u8FDB_u5EA6_u5706_u5708_u7684_u663E_u793A_u53CA_u65CB_u8F6C" class="headerlink" title="0x01 下拉进度圆圈的显示及旋转"></a>0x01 下拉进度圆圈的显示及旋转</h2><p>进度圆圈的显示主要是依赖于下拉的进度，然后改变<code>progress</code>，圆圈随之绘制就好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (contentOffset.y &lt; 0) &#123;</div><div class="line">    self.progress = MAX(0.0, MIN(fabs(contentOffset.y/kGCPullMaxDistance), 1.0));</div><div class="line">&#125; else &#123;</div><div class="line">    self.progress = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    UIBezierPath *circlePath = [UIBezierPath bezierPath];</div><div class="line">    [circlePath moveToPoint:CGPointMake(0, - kGCLoadingCircleRadius)];</div><div class="line">    [circlePath addArcWithCenter:CGPointMake(0, 0) radius:kGCLoadingCircleRadius startAngle:-M_PI/2 endAngle:((M_PI*17/9)*self.progess - M_PI/2) clockwise:YES];</div><div class="line">    </div><div class="line">    self.circleLayer.path = circlePath.CGPath;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>progress</code>达到1之后，就开始旋转动画了，这个我们使用<code>CABasicAnimation</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">rotationAnimation.toValue = @(M_PI*2);</div><div class="line">rotationAnimation.beginTime = CACurrentMediaTime();</div><div class="line">rotationAnimation.duration = 1.0;</div><div class="line">rotationAnimation.fillMode = kCAFillModeForwards;</div><div class="line">rotationAnimation.repeatCount = HUGE_VALF;</div><div class="line">[self.circleLayer addAnimation:rotationAnimation forKey:nil];</div></pre></td></tr></table></figure>
<p>ok，大功告成~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个下拉控件是在&lt;a href=&quot;http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/?sukey=3997c0719f151520e178bb5175f11bfb983f5560c51261103fafb276bac79e1371d16e07ede0cca9f23d826405507a3c&quot;&gt;Elastic view animation using UIBezierPath&lt;/a&gt;这篇博客上看到的，觉得效果还不错，自己也就OC简单实现了一下（原作者是用Swift写的），控件效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationTwo.gif!700x700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo&quot;&gt;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个控件的动画效果分为两个部分：&lt;/p&gt;
&lt;p&gt;1.下拉的果冻效果&lt;/p&gt;
&lt;p&gt;2.下拉进度圆圈的显示及旋转&lt;/p&gt;
    
    </summary>
    
    
      <category term="下拉刷新" scheme="http://yuzeyang.github.io/tags/%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>根据协议名获取所有代理方法</title>
    <link href="http://yuzeyang.github.io/2016/08/07/get-protocol-methods/"/>
    <id>http://yuzeyang.github.io/2016/08/07/get-protocol-methods/</id>
    <published>2016-08-07T00:34:59.000Z</published>
    <updated>2016-08-10T09:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为一直在用<a href="https://github.com/markohlebar/Peckham" target="_blank" rel="external">Peckham</a>这个插件，能够在编辑器的任意位置使用快捷键快速引用头文件，所以后来在想能不能也写一个类似的插件快速引入什么东西，细细一想平时自己在引用代理协议的时候，基本都是要跑到文件顶部添加好之后，再回到原来的位置继续写，如果有必须实现的代理方法没注意实现的话，可能又要回到implementation看warnings或者跳转到协议里面看哪些是必须实现，拷贝过来，粘贴到自己的实现里面，这样的操作实在是太麻烦了，所以我想可以写个插件，使用快捷键将必须实现的代理方法到implementation底部，这样对于开发者来说能避免很多不必要操作，也能快速明白哪些代理方法必须实现，好，接下来我来构思下怎么实现这个插件（但是后面这个实现出来的效果并不是很完美，所以还是放弃了…原因看更多）</p>
<a id="more"></a>
<p>1.在写完协议名之后，双击或者单击拖动选中协议名<br>2.使用快捷键，根据选中的协议名，查找协议里面的所有代理方法<br>3.再筛选出里面require标记的代理方法<br>4.将这些代理方法，添加到当前类的实现文件里面</p>
<p>我接下去讲的都是默认你已经了解了插件的配置以及调试</p>
<h2 id="u9009_u4E2D_u534F_u8BAE_u540D"><a href="#u9009_u4E2D_u534F_u8BAE_u540D" class="headerlink" title="选中协议名"></a>选中协议名</h2><p>首先我们在初始化bundle的时候，注册<code>NSTextViewDidChangeSelectionNotification</code>通知，<code>- selectString :</code>用来接收选中文本改变时通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(selectString:)</div><div class="line">name:NSTextViewDidChangeSelectionNotification object:nil];</div></pre></td></tr></table></figure>
<p>然后在接收方法里面，我们获取到当前操作的编辑页面<code>NSTextView</code>对象，然后获取到选中的<code>range</code>，取出选中的文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)selectString:(NSNotification *)notification &#123;</div><div class="line">    if ([notification.object isKindOfClass:[NSTextView class]]) &#123;</div><div class="line">        NSTextView* textView = (NSTextView *)notification.object;</div><div class="line">        NSArray* selectedRanges = [textView selectedRanges];</div><div class="line">        if (selectedRanges.count == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        NSRange selectedRange = [[selectedRanges objectAtIndex:0] rangeValue];</div><div class="line">        NSString* text = textView.textStorage.string;</div><div class="line">        self.selectedString = [text substringWithRange:selectedRange];</div><div class="line">        NSLog(@&quot;%s %@&quot;,__func__,self.selectedString);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528_u5FEB_u6377_u952E_uFF0C_u67E5_u627E_u534F_u8BAE_u91CC_u9762_u7684_u6240_u6709_u4EE3_u7406_u65B9_u6CD5"><a href="#u4F7F_u7528_u5FEB_u6377_u952E_uFF0C_u67E5_u627E_u534F_u8BAE_u91CC_u9762_u7684_u6240_u6709_u4EE3_u7406_u65B9_u6CD5" class="headerlink" title="使用快捷键，查找协议里面的所有代理方法"></a>使用快捷键，查找协议里面的所有代理方法</h2><p>快捷键的设置在增加<code>NSMenuItem</code>对象时就已经设置了，并且设置其快捷键为<code>^⎇G</code>，以及对应的<code>- searchProtocol:</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[menuItem submenu] addItem:[NSMenuItem separatorItem]];</div><div class="line">        </div><div class="line">NSMenuItem *protolMenuItem = [[NSMenuItem alloc] initWithTitle:@&quot;Protol Helper&quot; action:@selector(searchProtocol:) keyEquivalent:@&quot;g&quot;];</div><div class="line">[protolMenuItem setKeyEquivalentModifierMask:NSAlternateKeyMask|NSControlKeyMask];</div><div class="line">protolMenuItem.target = self;</div><div class="line">[[menuItem submenu] addItem:protolMenuItem];</div></pre></td></tr></table></figure>
<p>然后我们怎么查找到选中文本对应的协议和里面的代理方法呢？</p>
<p>我们先找怎么获取到代理方法，然后倒推回来，首先我们需要用到<code>runtime</code>，我们进到<code>runtime.h</code>里，通过搜索<code>protocol</code>关键字，我们找了<code>protocol_copyMethodDescriptionList</code>这个方法，<code>p</code>是一个<code>Protocol</code>对象，<code>isRequiredMethod</code>筛选是否是必须的方法，这样的话，我们就可以直接通过这个方法来获取必须实现的代理方法，<code>isInstanceMethod</code>筛选是否是实例方法，<code>outCount</code>这个表示返回方法的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount)</div><div class="line">     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);</div></pre></td></tr></table></figure>
<p><code>Protocol</code>对象我们可以通过<code>objc_getProtocol</code>方法，通过传入协议名来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const char *protocolName = self.selectedString.UTF8String;</div><div class="line">Protocol *protocol = objc_getProtocol(protocolName);</div></pre></td></tr></table></figure>
<p>然后我们开始调用<code>protocol_copyMethodDescriptionList</code>方法，打印出方法信息，这里我就先不管代码简洁性了，我拿<code>NSTextViewDelegate</code>来测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">unsigned int count = 999;</div><div class="line">struct objc_method_description *methods1;</div><div class="line">struct objc_method_description *methods2;</div><div class="line">struct objc_method_description *methods3;</div><div class="line">struct objc_method_description *methods4;</div><div class="line">methods1 = protocol_copyMethodDescriptionList(protocol, NO, YES, &amp;count);</div><div class="line">methods2 = protocol_copyMethodDescriptionList(protocol, NO, NO, &amp;count);</div><div class="line">methods3 = protocol_copyMethodDescriptionList(protocol, YES, YES, &amp;count);</div><div class="line">methods4 = protocol_copyMethodDescriptionList(protocol, YES, NO, &amp;count);</div><div class="line"></div><div class="line">if (methods1 != NULL) &#123;</div><div class="line">    NSLog(@&quot;---------------------methods1&quot;);</div><div class="line">    [self logMethods:methods1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (methods2 != NULL) &#123;</div><div class="line">    NSLog(@&quot;---------------------methods2&quot;);</div><div class="line">    [self logMethods:methods2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (methods3 != NULL) &#123;</div><div class="line">    NSLog(@&quot;---------------------methods3&quot;);</div><div class="line">    [self logMethods:methods3];</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (methods4 != NULL) &#123;</div><div class="line">    NSLog(@&quot;---------------------methods4&quot;);</div><div class="line">    [self logMethods:methods4];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看下打印的方法信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] ---------------------methods1</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:shouldChangeTextInRange:replacementString: c48@0:8@16&#123;_NSRange=QQ&#125;24@40</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:willChangeSelectionFromCharacterRange:toCharacterRange: &#123;_NSRange=QQ&#125;56@0:8@16&#123;_NSRange=QQ&#125;24&#123;_NSRange=QQ&#125;40</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textViewDidChangeSelection: v24@0:8@16</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:completions:forPartialWordRange:indexOfSelectedItem: @56@0:8@16@24&#123;_NSRange=QQ&#125;32^q48</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doCommandBySelector: c32@0:8@16:24</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnLink:atIndex: c40@0:8@16@24Q32</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnCell:inRect:atIndex: v72@0:8@16@24&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;32Q64</div><div class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doubleClickedOnCell:inRect:atIndex: v72@0:8@16@24&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;32Q64</div><div class="line">...</div></pre></td></tr></table></figure>
<p>what？方法名居然不是完整的，不是我们看到<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>这样的，但是想想也对，方法名应该是这样的，不包含参数名和参数类型，虽然参数类型可以通过<code>objc_method_description</code>结构体里面<code>types</code>拿到，但是参数名怎么办…我总不能用abc来代替吧，虽然做是可以做，但是用起来还是要改参数名，这不是很麻烦…感觉在这里遇到瓶颈了</p>
<p>然后我想看到<code>objc_class</code>结构体里面也有存放协议信息，那他里面是怎么样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_protocol_list &#123;</div><div class="line">    struct objc_protocol_list *next;</div><div class="line">    long count;</div><div class="line">    Protocol *list[1];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface Protocol : Object</div><div class="line">&#123;</div><div class="line">@private</div><div class="line">    char *protocol_name OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocol_list OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_description_list *instance_methods OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_description_list *class_methods OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct objc_method_description_list &#123;</div><div class="line">        int count;</div><div class="line">        struct objc_method_description list[1];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct objc_method_description &#123;</div><div class="line">	SEL name;               /**&lt; The name of the method */</div><div class="line">	char *types;            /**&lt; The types of the method arguments */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过一系列的查找，我们又回到了<code>objc_method_description</code>，what？这<code>objc_class</code>最终拿到的数据还是从<code>objc_method_description</code>来的，那就是说明我们没有办法直接获得<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>….这样就不能达到我们所预期的那样了</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我们可以通过<code>protocol_copyMethodDescriptionList</code>方法获取到协议里面所有的代理方法，分为方法名和类型，但是不能获取到<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>这样的，如果用a，b，c这样的来填充参数名，这样在使用起来，使用方还要自己再替换参数名，这样会比较麻烦，解决不了我们的需求，gg…..</p>
<p>2016年8月10日补充：</p>
<p>后来西兰花提出说根据协议名称去爬开发文档上相关的代理方法或者找本地开发包里面的相关头文件，不考虑是否可行，但是有个共同的问题是只能获取到官方的，自己创建的不行，而且前者没有require标记</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为一直在用&lt;a href=&quot;https://github.com/markohlebar/Peckham&quot;&gt;Peckham&lt;/a&gt;这个插件，能够在编辑器的任意位置使用快捷键快速引用头文件，所以后来在想能不能也写一个类似的插件快速引入什么东西，细细一想平时自己在引用代理协议的时候，基本都是要跑到文件顶部添加好之后，再回到原来的位置继续写，如果有必须实现的代理方法没注意实现的话，可能又要回到implementation看warnings或者跳转到协议里面看哪些是必须实现，拷贝过来，粘贴到自己的实现里面，这样的操作实在是太麻烦了，所以我想可以写个插件，使用快捷键将必须实现的代理方法到implementation底部，这样对于开发者来说能避免很多不必要操作，也能快速明白哪些代理方法必须实现，好，接下来我来构思下怎么实现这个插件（但是后面这个实现出来的效果并不是很完美，所以还是放弃了…原因看更多）&lt;/p&gt;
    
    </summary>
    
    
      <category term="协议方法" scheme="http://yuzeyang.github.io/tags/%E5%8D%8F%E8%AE%AE%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>加载动画分析</title>
    <link href="http://yuzeyang.github.io/2016/07/27/loadingAnimation-0727/"/>
    <id>http://yuzeyang.github.io/2016/07/27/loadingAnimation-0727/</id>
    <published>2016-07-27T14:49:19.000Z</published>
    <updated>2016-08-15T15:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写动画了…最近扒了下以前没有写的动画效果，想想从最老的开始写吧，之前看到的版本是用Swift写的，没仔细找有没有OC版的，所以干脆自己练习一下吧，我们先来看看效果：</p>
<p>(这里三角形是旋转动画，但是Gif录出来看上去是抖了两下…)</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationOne.gif!500x500" alt=""></p>
<p>可以直接run下代码，看下效果：<a href="https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne" target="_blank" rel="external">https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne</a></p>
<p>下面我来分析下过程</p>
<a id="more"></a>
<p>这个动画的实现只用到了<code>UIBezierPath</code>、<code>CABasicAnimation</code>和<code>CALayer</code></p>
<p>从Gif里面可以看到这个动画分为以下几个步骤：</p>
<p>1.从无到圆</p>
<p>2.圆x轴方向拉伸和y轴方向拉伸</p>
<p>3.“长出”三角形的三个角</p>
<p>4.三角形旋转</p>
<p>5.画两条边框</p>
<p>6.水面上涨动画</p>
<p>7.中间矩形放大至全屏</p>
<p>8.中间logo跟着出现</p>
<h2 id="0x00__u4ECE_u65E0_u5230_u5706"><a href="#0x00__u4ECE_u65E0_u5230_u5706" class="headerlink" title="0x00 从无到圆"></a>0x00 从无到圆</h2><p>这个比较简单，只要设定起始的size为0和设定默认圆半径大小，用<code>+ bezierPathWithOvalInRect:</code>方法画圆<code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *startPath = [self circleStartPath];</div><div class="line">UIBezierPath *endPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2, GCCircleRadius*2)];</div></pre></td></tr></table></figure>
<p>将最后圆的<code>path</code>设为<code>circleLayer</code>的<code>path</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.circleLayer = [CAShapeLayer layer];</div><div class="line">self.circleLayer.path = endPath.CGPath;</div><div class="line">self.circleLayer.fillColor = [UIColor orangeColor].CGColor;</div><div class="line">[self addSublayer:self.circleLayer];</div></pre></td></tr></table></figure>
<p>然后加上动画，因为我们修改的是<code>path</code>，所以我们<code>animation</code>的<code>keyPath</code>是<code>path</code>（后面也是），设定起始值为<code>startPath.CGPath</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *circleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">circleAnimation.fromValue = (__bridge id _Nullable)(startPath.CGPath);</div><div class="line">circleAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</div><div class="line">circleAnimation.duration = 0.2f;</div><div class="line">circleAnimation.fillMode = kCAFillModeForwards;</div><div class="line">circleAnimation.delegate = self;</div><div class="line">circleAnimation.removedOnCompletion = NO;</div><div class="line">[circleAnimation setValue:@&quot;circleAnimation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">[self.circleLayer addAnimation:circleAnimation forKey:nil];</div></pre></td></tr></table></figure>
<h2 id="0x01__u5706x_u8F74_u65B9_u5411_u62C9_u4F38_u548Cy_u8F74_u65B9_u5411_u62C9_u4F38"><a href="#0x01__u5706x_u8F74_u65B9_u5411_u62C9_u4F38_u548Cy_u8F74_u65B9_u5411_u62C9_u4F38" class="headerlink" title="0x01 圆x轴方向拉伸和y轴方向拉伸"></a>0x01 圆x轴方向拉伸和y轴方向拉伸</h2><p>这里我们的<code>keyPath</code>不用<code>transform.scale.x/y</code>，因为缩放之后，圆心会改变，看上去有偏移，这样动画写起来更复杂，所以我们干脆直接用拉伸后的<code>path</code>来做动画</p>
<p>创建x轴、y轴拉伸后的<code>path</code>，然后加到<code>animation</code>里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *scaleXPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius*1.1, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2.2, GCCircleRadius*2)];</div><div class="line">UIBezierPath *scaleYPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius*1.1, GCCircleRadius*2, GCCircleRadius*2.2)];</div><div class="line"></div><div class="line">CABasicAnimation *circleScaleXOneAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">circleScaleXOneAnimation.fromValue = (__bridge id _Nullable)(self.circleLayer.path);</div><div class="line">circleScaleXOneAnimation.toValue = (__bridge id _Nullable)(scaleXPath.CGPath);</div><div class="line">circleScaleXOneAnimation.duration = 0.2f;</div><div class="line">circleScaleXOneAnimation.beginTime = 0.0;</div></pre></td></tr></table></figure>
<p>一共四个<code>CABasicAnimation</code>对象，然后我们将这些动画加到<code>CAAnimationGroup</code>里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CAAnimationGroup *animationGroup = [CAAnimationGroup animation];</div><div class="line">animationGroup.animations = @[circleScaleXOneAnimation,circleScaleXTwoAnimation,circleScaleYOneAnimation,circleScaleYTwoAnimation];</div><div class="line">animationGroup.duration = circleScaleYTwoAnimation.beginTime + circleScaleYTwoAnimation.duration;</div><div class="line">animationGroup.delegate = self;</div><div class="line">[animationGroup setValue:@&quot;circleScaleAnimation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">[self.circleLayer addAnimation:animationGroup forKey:nil];</div></pre></td></tr></table></figure>
<h2 id="0x02__u201C_u957F_u51FA_u201D_u4E09_u89D2_u5F62_u7684_u4E09_u4E2A_u89D2"><a href="#0x02__u201C_u957F_u51FA_u201D_u4E09_u89D2_u5F62_u7684_u4E09_u4E2A_u89D2" class="headerlink" title="0x02 “长出”三角形的三个角"></a>0x02 “长出”三角形的三个角</h2><p>实际上三角形在等到圆形出现或者圆形拉伸完之后就已经在那了，“长出角”的感觉实际上只是改变了绘制的三个点的位置，首先我们根据圆的半径画出三角形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *originTrianglePath = [UIBezierPath bezierPath];</div><div class="line">[originTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.0]];</div><div class="line">[originTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];</div><div class="line">[originTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];</div><div class="line">[originTrianglePath closePath];</div><div class="line"></div><div class="line">self.triangleLayer = [CAShapeLayer layer];</div><div class="line">self.triangleLayer.path = originTrianglePath.CGPath;</div><div class="line">self.triangleLayer.fillColor = [UIColor orangeColor].CGColor;</div><div class="line">[self addSublayer:self.triangleLayer];</div></pre></td></tr></table></figure>
<p>然后改变左边点的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *blowUpLeftTrianglePath = [UIBezierPath bezierPath];</div><div class="line">[blowUpLeftTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.2]];</div><div class="line">[blowUpLeftTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];</div><div class="line">[blowUpLeftTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];</div><div class="line">[blowUpLeftTrianglePath closePath];</div></pre></td></tr></table></figure>
<p>也加上<code>path</code>的动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *blowUpLeftAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">blowUpLeftAnimation.fromValue = (__bridge id _Nullable)(self.triangleLayer.path);</div><div class="line">blowUpLeftAnimation.toValue = (__bridge id _Nullable)(blowUpLeftTrianglePath.CGPath);</div><div class="line">blowUpLeftAnimation.duration = 0.2f;</div><div class="line">blowUpLeftAnimation.beginTime = 0.0;</div></pre></td></tr></table></figure>
<p>右边和上边的点同理，然后也一起加到<code>CAAnimationGroup</code>里</p>
<h2 id="0x03__u4E09_u89D2_u5F62_u65CB_u8F6C"><a href="#0x03__u4E09_u89D2_u5F62_u65CB_u8F6C" class="headerlink" title="0x03 三角形旋转"></a>0x03 三角形旋转</h2><p>旋转就比较简单了，只要根据z轴旋转设定的角度即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *rotationAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">rotationAniamtion.toValue = @(M_PI*2);</div><div class="line">rotationAniamtion.duration = 0.4;</div><div class="line">rotationAniamtion.fillMode = kCAFillModeForwards;</div><div class="line">rotationAniamtion.delegate = self;</div><div class="line">rotationAniamtion.beginTime = CACurrentMediaTime();</div><div class="line">[rotationAniamtion setValue:@&quot;rotationAniamtion&quot; forKey:@&quot;animationName&quot;];</div><div class="line">[self.triangleLayer addAnimation:rotationAniamtion forKey:nil];</div></pre></td></tr></table></figure>
<h2 id="0x04__u753B_u4E24_u6761_u8FB9_u6846"><a href="#0x04__u753B_u4E24_u6761_u8FB9_u6846" class="headerlink" title="0x04 画两条边框"></a>0x04 画两条边框</h2><p>这两个边框绘制方法是一模一样的，只是中间有个时间间隔而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (CABasicAnimation *)drawRectWithLineColor:(CGColorRef)color animationValue:(NSString *)animationValue &#123;</div><div class="line">    CGPoint startPoint = [self triangleLeftPointWithScale:1.2];</div><div class="line">    UIBezierPath *rectPath = [UIBezierPath bezierPath];</div><div class="line">    [rectPath moveToPoint:startPoint];</div><div class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x, startPoint.y - GCCircleRadius*2.4)];</div><div class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - GCCircleRadius*2.4)];</div><div class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - 2)];</div><div class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x - 2.5, startPoint.y - 2)];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer = [CAShapeLayer layer];</div><div class="line">    layer.path = rectPath.CGPath;</div><div class="line">    layer.lineWidth = 5;</div><div class="line">    layer.strokeColor = color;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    [self addSublayer:layer];</div><div class="line">    </div><div class="line">    CABasicAnimation *rectAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</div><div class="line">    rectAniamtion.fromValue = @(0.0);</div><div class="line">    rectAniamtion.toValue = @(1.0);</div><div class="line">    rectAniamtion.duration = 0.8;</div><div class="line">    rectAniamtion.delegate = self;</div><div class="line">    if (animationValue.length) &#123;</div><div class="line">        [rectAniamtion setValue:@&quot;rectAniamtion&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    &#125;</div><div class="line">    [layer addAnimation:rectAniamtion forKey:nil];</div><div class="line">    </div><div class="line">    return rectAniamtion;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>间隔的话，我们直接调用<code>- performSelector: withObject: afterDelay:</code>来延迟执行第二条边框的绘制就好</p>
<h2 id="0x05__u6C34_u9762_u4E0A_u6DA8_u52A8_u753B"><a href="#0x05__u6C34_u9762_u4E0A_u6DA8_u52A8_u753B" class="headerlink" title="0x05 水面上涨动画"></a>0x05 水面上涨动画</h2><p>这个动画的关键就是用<code>- addCurveToPoint: controlPoint1: controlPoint2:</code>方法来画出水波的线，这个方法主要是利用<code>controlPoint1</code>和<code>controlPoint2</code>这两个点来控制弧度方向，如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/addCurveToPoint.png" alt=""></p>
<p>然后我们只需要交叉改变<code>controlPoint1</code>和<code>controlPoint2</code>这两个点在上下的位置和<code>startPoint</code>和<code>endPoint</code>的位置，就能感觉水面上涨的感觉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableArray &lt;UIBezierPath *&gt; *waterPathArray = [NSMutableArray array];</div><div class="line">for (NSInteger i = 0; i &lt; 11; i++) &#123;</div><div class="line">    UIBezierPath *water = [self water:i % 2 == 0 ? YES : NO withProgress:0.1*i];</div><div class="line">    [waterPathArray addObject:water];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建完毕<code>path</code>之后，将<code>anmations</code>放到<code>CAAnimationGroup</code>里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)addWaterAnimation:(NSMutableArray &lt;UIBezierPath *&gt; *)waterArray &#123;</div><div class="line">    NSMutableArray &lt;CABasicAnimation *&gt; *animationArray = [NSMutableArray array];</div><div class="line">    for (NSInteger i = 0; i &lt; waterArray.count - 1; i++) &#123;</div><div class="line">        CABasicAnimation *waterAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">        waterAniamtion.fromValue = (__bridge id _Nullable)(waterArray[i].CGPath);</div><div class="line">        waterAniamtion.toValue = (__bridge id _Nullable)(waterArray[i + 1].CGPath);</div><div class="line">        waterAniamtion.duration = 0.2;</div><div class="line">        waterAniamtion.beginTime = i == 0 ? 0.0 : animationArray[i - 1].beginTime + animationArray[i - 1].duration;</div><div class="line">        [animationArray addObject:waterAniamtion];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CAAnimationGroup *group = [CAAnimationGroup animation];</div><div class="line">    group.animations = animationArray;</div><div class="line">    group.duration = [animationArray lastObject].beginTime + [animationArray lastObject].duration;</div><div class="line">    group.fillMode = kCAFillModeForwards;</div><div class="line">    group.removedOnCompletion = NO;</div><div class="line">    group.delegate = self;</div><div class="line">    [group setValue:@&quot;waterAnimation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    [self.waterLayer addAnimation:group forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x06__u4E2D_u95F4_u77E9_u5F62_u653E_u5927_u81F3_u5168_u5C4F"><a href="#0x06__u4E2D_u95F4_u77E9_u5F62_u653E_u5927_u81F3_u5168_u5C4F" class="headerlink" title="0x06 中间矩形放大至全屏"></a>0x06 中间矩形放大至全屏</h2><p>和前面一样，创建好全屏大小的<code>path</code>之后，然后加上动画即可</p>
<h2 id="0x07__u4E2D_u95F4logo_u8DDF_u7740_u51FA_u73B0"><a href="#0x07__u4E2D_u95F4logo_u8DDF_u7740_u51FA_u73B0" class="headerlink" title="0x07 中间logo跟着出现"></a>0x07 中间logo跟着出现</h2><p>这个改变<code>bounds</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CALayer *logoLayer = [CALayer layer];</div><div class="line">logoLayer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;logo.jpg&quot;].CGImage);</div><div class="line"></div><div class="line">logoLayer.frame = CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 0, 0);</div><div class="line">[self addSublayer:logoLayer];</div><div class="line"></div><div class="line">CABasicAnimation *logoAnimation = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;];</div><div class="line">logoAnimation.toValue = [NSValue valueWithCGRect:CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 100, 120)];</div><div class="line">logoAnimation.duration = 0.2;</div><div class="line">logoAnimation.beginTime = 0.0;</div><div class="line">logoAnimation.removedOnCompletion = NO;</div><div class="line">logoAnimation.fillMode = kCAFillModeForwards;</div><div class="line">[logoLayer addAnimation:logoAnimation forKey:nil];</div></pre></td></tr></table></figure>
<p>这个加载动画的缺点就是在加载时没有可定制化的形状，只能修改圆形等的颜色，如果要改变形状，可能会涉及到动效的改动，所以这个动画只能作为学习分析参考</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写动画了…最近扒了下以前没有写的动画效果，想想从最老的开始写吧，之前看到的版本是用Swift写的，没仔细找有没有OC版的，所以干脆自己练习一下吧，我们先来看看效果：&lt;/p&gt;
&lt;p&gt;(这里三角形是旋转动画，但是Gif录出来看上去是抖了两下…)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationOne.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以直接run下代码，看下效果：&lt;a href=&quot;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne&quot;&gt;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我来分析下过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="加载动画" scheme="http://yuzeyang.github.io/tags/%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>FMDB初探（二）</title>
    <link href="http://yuzeyang.github.io/2016/07/23/FMDB-two/"/>
    <id>http://yuzeyang.github.io/2016/07/23/FMDB-two/</id>
    <published>2016-07-23T08:38:23.000Z</published>
    <updated>2016-07-23T10:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>FMResultSet</code>用来执行SQL语句结果的查询</p>
<p><code>FMDatabaseQueue</code>用不同的线程来执行若干个查询和更新操作</p>
<p><code>FMDatabasePool</code>和<code>FMDatabaseQueue</code>类似，但是只是用在数据库只读操作上</p>
<a id="more"></a>
<h2 id="FMResultSet"><a href="#FMResultSet" class="headerlink" title="FMResultSet"></a>FMResultSet</h2><p>主要是根据<code>columnName</code>列名/<code>columnIdx</code>列索引获取到相应数据格式的数据，以及使用<code>- next</code>方法，将查询结果逐行输入</p>
<h4 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)resultSetWithStatement:(FMStatement *)statement usingParentDatabase:(FMDatabase*)aDB &#123;</div><div class="line">    // 初始化FMResultSet对象</div><div class="line">    FMResultSet *rs = [[FMResultSet alloc] init];</div><div class="line">    // 设置prepared语句和db</div><div class="line">    [rs setStatement:statement];</div><div class="line">    [rs setParentDB:aDB];</div><div class="line">    // 设置prepared语句正在使用</div><div class="line">    NSParameterAssert(![statement inUse]);</div><div class="line">    [statement setInUse:YES]; // weak reference</div><div class="line">    </div><div class="line">    return FMDBReturnAutoreleased(rs);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="u83B7_u53D6_u7ED3_u679C"><a href="#u83B7_u53D6_u7ED3_u679C" class="headerlink" title="获取结果"></a>获取结果</h4><p>返回结果的数据类型有很多种：除了基本数据类型之外，还有<code>NSString</code>、<code>NSDate</code>、<code>NSData</code></p>
<p>比如以下两个接口<code>- intForColumn:</code>实际上调用的还是<code>- intForColumnIndex:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (int)intForColumn:(NSString*)columnName &#123;</div><div class="line">    return [self intForColumnIndex:[self columnIndexForName:columnName]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (int)intForColumnIndex:(int)columnIdx &#123;</div><div class="line">    return sqlite3_column_int([_statement statement], columnIdx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用<code>- columnIndexForName:</code>方法，用列名来获得列索引，这层映射关系都是存在<code>_columnNameToIndexMap</code>字典里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (int)columnIndexForName:(NSString*)columnName &#123;</div><div class="line">    columnName = [columnName lowercaseString];</div><div class="line">    </div><div class="line">    NSNumber *n = [[self columnNameToIndexMap] objectForKey:columnName];</div><div class="line">    </div><div class="line">    if (n) &#123;</div><div class="line">        return [n intValue];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSLog(@&quot;Warning: I could not find the column named &apos;%@&apos;.&quot;, columnName);</div><div class="line">    </div><div class="line">    return -1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMutableDictionary *)columnNameToIndexMap &#123;</div><div class="line">    if (!_columnNameToIndexMap) &#123;</div><div class="line">        int columnCount = sqlite3_column_count([_statement statement]);</div><div class="line">        _columnNameToIndexMap = [[NSMutableDictionary alloc] initWithCapacity:(NSUInteger)columnCount];</div><div class="line">        int columnIdx = 0;</div><div class="line">        for (columnIdx = 0; columnIdx &lt; columnCount; columnIdx++) &#123;</div><div class="line">            // 列名作为key，对应的列号作为value</div><div class="line">            [_columnNameToIndexMap setObject:[NSNumber numberWithInt:columnIdx]</div><div class="line">                                      forKey:[[NSString stringWithUTF8String:sqlite3_column_name([_statement statement], columnIdx)] lowercaseString]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return _columnNameToIndexMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="u9010_u884C_u8FD4_u56DE_u7ED3_u679C"><a href="#u9010_u884C_u8FD4_u56DE_u7ED3_u679C" class="headerlink" title="逐行返回结果"></a>逐行返回结果</h4><p><code>- next</code>方法本质是调用<code>- nextWithError</code>，<code>FMDB</code>里面有的注释写的还是挺逗的，连<code>wtf</code>都有…哈哈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (BOOL)nextWithError:(NSError **)outErr &#123;</div><div class="line">    /* Call sqlite3_step() to run the virtual machine. Since the SQL being</div><div class="line">     ** executed is not a SELECT statement, we assume no data will be returned.</div><div class="line">     */</div><div class="line">    // sqlite3_prepare函数将SQL命令字符串解析并转换为一系列的命令字节码，这些字节码最终被传送到SQlite3的虚拟数据库引擎（VDBE: Virtual Database Engine）中执行，完成这项工作的是sqlite3_step函数。比如一个SELECT查询操作，sqlite3_step函数的每次调用都会返回结果集中的其中一行，直到再没有有效数据行了。每次调用sqlite3_step函数如果返回SQLITE_ROW，代表获得了有效数据行，可以通过sqlite3_column函数提取某列的值。如果调用sqlite3_step函数返回SQLITE_DONE，则代表prepared语句已经执行到终点了，没有有效数据了。很多命令第一次调用sqlite3_step函数就会返回SQLITE_DONE，因为这些SQL命令不会返回数据。对于INSERT，UPDATE，DELETE命令，会返回它们所修改的行号——一个单行单列的值。</div><div class="line">    /**</div><div class="line">     SQLITE_BUSY 数据库文件有锁</div><div class="line">     SQLITE_LOCKED 数据库中的某张表有锁</div><div class="line">     SQLITE_DONE sqlite3_step()执行完毕</div><div class="line">     SQLITE_ROW sqlite3_step()获取到下一行数据</div><div class="line">     SQLITE_ERROR 一般用于没有特别指定错误码的错误，就是说函数在执行过程中发生了错误，但无法知道错误发生的原因。</div><div class="line">     SQLITE_MISUSE 没有正确使用SQLite接口，比如一条语句在sqlite3_step函数执行之后，没有被重置之前，再次给其绑定参数，这时bind函数就会返回SQLITE_MISUSE。</div><div class="line">     **/</div><div class="line">    int rc = sqlite3_step([_statement statement]);</div><div class="line">    </div><div class="line">    if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &#123;</div><div class="line">        NSLog(@&quot;%s:%d Database busy (%@)&quot;, __FUNCTION__, __LINE__, [_parentDB databasePath]);</div><div class="line">        NSLog(@&quot;Database busy&quot;);</div><div class="line">        if (outErr) &#123;</div><div class="line">            *outErr = [_parentDB lastError];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if (SQLITE_DONE == rc || SQLITE_ROW == rc) &#123;</div><div class="line">        // all is well, let&apos;s return.</div><div class="line">    &#125;</div><div class="line">    else if (SQLITE_ERROR == rc) &#123;</div><div class="line">        NSLog(@&quot;Error calling sqlite3_step (%d: %s) rs&quot;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));</div><div class="line">        if (outErr) &#123;</div><div class="line">            *outErr = [_parentDB lastError];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if (SQLITE_MISUSE == rc) &#123;</div><div class="line">        // uh oh.</div><div class="line">        NSLog(@&quot;Error calling sqlite3_step (%d: %s) rs&quot;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));</div><div class="line">        if (outErr) &#123;</div><div class="line">            if (_parentDB) &#123;</div><div class="line">                *outErr = [_parentDB lastError];</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                // If &apos;next&apos; or &apos;nextWithError&apos; is called after the result set is closed,</div><div class="line">                // we need to return the appropriate error.</div><div class="line">                NSDictionary* errorMessage = [NSDictionary dictionaryWithObject:@&quot;parentDB does not exist&quot; forKey:NSLocalizedDescriptionKey];</div><div class="line">                *outErr = [NSError errorWithDomain:@&quot;FMDatabase&quot; code:SQLITE_MISUSE userInfo:errorMessage];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // wtf?</div><div class="line">        NSLog(@&quot;Unknown error calling sqlite3_step (%d: %s) rs&quot;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));</div><div class="line">        if (outErr) &#123;</div><div class="line">            *outErr = [_parentDB lastError];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    if (rc != SQLITE_ROW) &#123;</div><div class="line">        [self close];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return (rc == SQLITE_ROW);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">while ([rs next]) &#123;</div><div class="line">    NSString *file = [rs stringForColumn:@&quot;file&quot;];</div><div class="line">    NSLog(@&quot;database_list: %@&quot;, file);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="FMDatabaseQueue"><a href="#FMDatabaseQueue" class="headerlink" title="FMDatabaseQueue"></a>FMDatabaseQueue</h2><p>是用来多线程并行执行SQL语句</p>
<h4 id="u521D_u59CB_u5316-1"><a href="#u521D_u59CB_u5316-1" class="headerlink" title="初始化"></a>初始化</h4><p>头文件里提供了很多种初始化方法，但是最终调用的还是<code>(instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags vfs:(NSString *)vfsName</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags vfs:(NSString *)vfsName &#123;</div><div class="line">    </div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    if (self != nil) &#123;</div><div class="line">        // 根据指定路径寻找数据库，如果已存在则返回db，不存在则创建</div><div class="line">        _db = [[[self class] databaseClass] databaseWithPath:aPath];</div><div class="line">        FMDBRetain(_db);</div><div class="line">        </div><div class="line">#if SQLITE_VERSION_NUMBER &gt;= 3005000</div><div class="line">        BOOL success = [_db openWithFlags:openFlags vfs:vfsName];</div><div class="line">#else</div><div class="line">        BOOL success = [_db open];</div><div class="line">#endif</div><div class="line">        if (!success) &#123;</div><div class="line">            NSLog(@&quot;Could not create database queue for path %@&quot;, aPath);</div><div class="line">            FMDBRelease(self);</div><div class="line">            return 0x00;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        _path = FMDBReturnRetained(aPath);</div><div class="line">        // 创建串行队列</div><div class="line">        _queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);</div><div class="line">        // 给_queue队列指定了kDispatchQueueSpecificKey字符串，并和self绑定，后面可以通过kDispatchQueueSpecificKey获取到self，但要保证正在执行的队列是这个_queue</div><div class="line">        dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);</div><div class="line">        _openFlags = openFlags;</div><div class="line">        _vfsName = [vfsName copy];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:dbPath];</div></pre></td></tr></table></figure>
<h4 id="u64CD_u4F5C_u6570_u636E_u5E93"><a href="#u64CD_u4F5C_u6570_u636E_u5E93" class="headerlink" title="操作数据库"></a>操作数据库</h4><p>想要多线程操作数据库时，不是直接使用<code>FMDatabase</code>对象，而是通过<code>FMDatabaseQueue</code>对象，调用<code>- inDatabas:</code>，通过<code>block</code>返回<code>FMDatabase</code>对象来操作，虽然<code>- inDatabas:</code>内是同步操作，但是线程之间是并行的，就相当于马路上有两条单行的路，虽然每条路上的车都是一辆接一辆的，但是两条路之间是互不影响的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)inDatabase:(void (^)(FMDatabase *db))block &#123;</div><div class="line">    // 通过kDispatchQueueSpecificKey来获取当前正在执行的队列，并且检查和self做比较，确保没有发生死锁，因为可以创建多个FMDatabaseQueue多个来执行不同的SQL语句</div><div class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);</div><div class="line">    assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);</div><div class="line">    </div><div class="line">    FMDBRetain(self);</div><div class="line">    // 在当前queue中，同步执行block</div><div class="line">    dispatch_sync(_queue, ^() &#123;</div><div class="line">        </div><div class="line">        FMDatabase *db = [self database];</div><div class="line">        block(db);</div><div class="line">        </div><div class="line">        if ([db hasOpenResultSets]) &#123;</div><div class="line">            NSLog(@&quot;Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]&quot;);</div><div class="line">            </div><div class="line">#if defined(DEBUG) &amp;&amp; DEBUG</div><div class="line">            NSSet *openSetCopy = FMDBReturnAutoreleased([[db valueForKey:@&quot;_openResultSets&quot;] copy]);</div><div class="line">            for (NSValue *rsInWrappedInATastyValueMeal in openSetCopy) &#123;</div><div class="line">                FMResultSet *rs = (FMResultSet *)[rsInWrappedInATastyValueMeal pointerValue];</div><div class="line">                NSLog(@&quot;query: &apos;%@&apos;&quot;, [rs query]);</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    FMDBRelease(self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[queue inDatabase:^(FMDatabase *adb) &#123;</div><div class="line">    [adb executeUpdate:@&quot;create table qfoo (foo text)&quot;];</div><div class="line">    [adb executeUpdate:@&quot;insert into qfoo values (&apos;hi&apos;)&quot;];</div><div class="line">    [adb executeUpdate:@&quot;insert into qfoo values (&apos;hello&apos;)&quot;];</div><div class="line">    [adb executeUpdate:@&quot;insert into qfoo values (&apos;not&apos;)&quot;];</div><div class="line"></div><div class="line">	int count = 0;</div><div class="line">    FMResultSet *rsl = [adb executeQuery:@&quot;select * from qfoo where foo like &apos;h%&apos;&quot;];</div><div class="line">    while ([rsl next]) &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    FMDBQuickCheck(count == 2);</div><div class="line"></div><div class="line">    count = 0;</div><div class="line">    rsl = [adb executeQuery:@&quot;select * from qfoo where foo like ?&quot;, @&quot;h%&quot;];</div><div class="line">    while ([rsl next]) &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    FMDBQuickCheck(count == 2);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="u4E8B_u52A1_u5904_u7406"><a href="#u4E8B_u52A1_u5904_u7406" class="headerlink" title="事务处理"></a>事务处理</h4><p>和<code>FMDatabase</code>一样，也有事务的处理，分为exclusive事务和deferred事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (void)inDeferredTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block &#123;</div><div class="line">    [self beginTransaction:YES withBlock:block];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)inTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block &#123;</div><div class="line">    [self beginTransaction:NO withBlock:block];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)beginTransaction:(BOOL)useDeferred withBlock:(void (^)(FMDatabase *db, BOOL *rollback))block &#123;</div><div class="line">    FMDBRetain(self);</div><div class="line">    dispatch_sync(_queue, ^() &#123; </div><div class="line">        </div><div class="line">        BOOL shouldRollback = NO;</div><div class="line">        // 是否使用延迟事务</div><div class="line">        if (useDeferred) &#123;</div><div class="line">            [[self database] beginDeferredTransaction];</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            [[self database] beginTransaction];</div><div class="line">        &#125;</div><div class="line">        // 如果数据库操作出错了，你可以设置是否需要回滚，回滚到操作之前的内容</div><div class="line">        block([self database], &amp;shouldRollback);</div><div class="line">        </div><div class="line">        if (shouldRollback) &#123;</div><div class="line">            [[self database] rollback];</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // 如果不需要回滚，则commit提交相应的sql操作</div><div class="line">            [[self database] commit];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    FMDBRelease(self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[queue inTransaction:^(FMDatabase *adb, BOOL *rollback) &#123;</div><div class="line">    NSLog(@&quot;Starting query  %ld&quot;, nby);</div><div class="line"></div><div class="line">    FMResultSet *rsl = [adb executeQuery:@&quot;select * from qfoo where foo like &apos;h%&apos;&quot;];</div><div class="line">    while ([rsl next]) &#123;</div><div class="line">        ;// whatever.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSLog(@&quot;Ending query    %ld&quot;, nby);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="FMDatabasePool"><a href="#FMDatabasePool" class="headerlink" title="FMDatabasePool"></a>FMDatabasePool</h2><blockquote>
<p>If you really really really know what you’re doing and <code>FMDatabasePool</code> is what  you really really need (ie, you’re using a read only database), OK you can use it.  But just be careful not to deadlock!</p>
</blockquote>
<p>对，这就是<code>FMDatabasePool</code>的描述，只能用于数据库只读操作，如果进行了写操作，很有可能会出现死锁，乱用搞不好就跪了…</p>
<p>里面的方法基本和<code>FMDatabaseQueue</code>差不多，里面有两个特别的属性：<code>_databaseInPool</code>和<code>_databaseOutPool</code>，按我的理解，这两个属性的作用就像是一个用来存放闲置的db，一个是用来存放正在执行操作的db，在<code>- inDatabase:</code>等这些方法最后都调用了<code>- pushDatabaseBackInPool:</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">// 将db放回InPool里面</div><div class="line">- (void)pushDatabaseBackInPool:(FMDatabase*)db &#123;</div><div class="line">    </div><div class="line">    if (!db) &#123; // db can be null if we set an upper bound on the # of databases to create.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 同步执行</div><div class="line">    [self executeLocked:^() &#123;</div><div class="line">        // 如果InPool数组里面包含db，说明db已经在InPool里面，不需要再放回InPool里，并且抛出异常，下面的操作就不进行了</div><div class="line">        if ([self-&gt;_databaseInPool containsObject:db]) &#123;</div><div class="line">            [[NSException exceptionWithName:@&quot;Database already in pool&quot; reason:@&quot;The FMDatabase being put back into the pool is already present in the pool&quot; userInfo:nil] raise];</div><div class="line">        &#125;</div><div class="line">        // 如果db不在InPool里面，把db加到InPool数组，并且从OutPool中移除</div><div class="line">        [self-&gt;_databaseInPool addObject:db];</div><div class="line">        [self-&gt;_databaseOutPool removeObject:db];</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (FMDatabase*)db &#123;</div><div class="line">    </div><div class="line">    __block FMDatabase *db;</div><div class="line">    </div><div class="line">    </div><div class="line">    [self executeLocked:^() &#123;</div><div class="line">        // 从_databaseInPool里面取出最后一个FMDatabase对象</div><div class="line">        db = [self-&gt;_databaseInPool lastObject];</div><div class="line">        </div><div class="line">        BOOL shouldNotifyDelegate = NO;</div><div class="line">        // 如果db存在，则加到_databaseOutPool里，_databaseInPool移除掉，我的理解是_databaseOutPool是用于存放正在执行操作的db池，_databaseInPool则存放闲置的db池</div><div class="line">        // 在需要使用的时候，从闲置的池里面取出来放到正在执行的池里面</div><div class="line">        if (db) &#123;</div><div class="line">            [self-&gt;_databaseOutPool addObject:db];</div><div class="line">            [self-&gt;_databaseInPool removeLastObject];</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // 检查最大创建的db数量，超过了则返回，否则就根据路径，找到db</div><div class="line">            if (self-&gt;_maximumNumberOfDatabasesToCreate) &#123;</div><div class="line">                NSUInteger currentCount = [self-&gt;_databaseOutPool count] + [self-&gt;_databaseInPool count];</div><div class="line">                </div><div class="line">                if (currentCount &gt;= self-&gt;_maximumNumberOfDatabasesToCreate) &#123;</div><div class="line">                    NSLog(@&quot;Maximum number of databases (%ld) has already been reached!&quot;, (long)currentCount);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            db = [[[self class] databaseClass] databaseWithPath:self-&gt;_path];</div><div class="line">            shouldNotifyDelegate = YES;</div><div class="line">        &#125;</div><div class="line">        // 根据_openFlags和_vfsName打开db</div><div class="line">        //This ensures that the db is opened before returning</div><div class="line">#if SQLITE_VERSION_NUMBER &gt;= 3005000</div><div class="line">        BOOL success = [db openWithFlags:self-&gt;_openFlags vfs:self-&gt;_vfsName];</div><div class="line">#else</div><div class="line">        BOOL success = [db open];</div><div class="line">#endif</div><div class="line">        if (success) &#123;</div><div class="line">            // 如果代理方法响应了，但是db不允许被加到pool里面，那么db关闭释放</div><div class="line">            if ([self-&gt;_delegate respondsToSelector:@selector(databasePool:shouldAddDatabaseToPool:)] &amp;&amp; ![self-&gt;_delegate databasePool:self shouldAddDatabaseToPool:db]) &#123;</div><div class="line">                [db close];</div><div class="line">                db = 0x00;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                //It should not get added in the pool twice if lastObject was found</div><div class="line">                // 对于新创建的db，需要加到_databaseOutPool里，而不需要加到_databaseInPool里</div><div class="line">                if (![self-&gt;_databaseOutPool containsObject:db]) &#123;</div><div class="line">                    [self-&gt;_databaseOutPool addObject:db];</div><div class="line">                    // 新创建的db需要响应delegate</div><div class="line">                    if (shouldNotifyDelegate &amp;&amp; [self-&gt;_delegate respondsToSelector:@selector(databasePool:didAddDatabase:)]) &#123;</div><div class="line">                        [self-&gt;_delegate databasePool:self didAddDatabase:db];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            NSLog(@&quot;Could not open up the database at path %@&quot;, self-&gt;_path);</div><div class="line">            db = 0x00;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    return db;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;FMResultSet&lt;/code&gt;用来执行SQL语句结果的查询&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FMDatabaseQueue&lt;/code&gt;用不同的线程来执行若干个查询和更新操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FMDatabasePool&lt;/code&gt;和&lt;code&gt;FMDatabaseQueue&lt;/code&gt;类似，但是只是用在数据库只读操作上&lt;/p&gt;
    
    </summary>
    
    
      <category term="FMDB" scheme="http://yuzeyang.github.io/tags/FMDB/"/>
    
  </entry>
  
  <entry>
    <title>FMDB初探（一）</title>
    <link href="http://yuzeyang.github.io/2016/07/23/FMDB-one/"/>
    <id>http://yuzeyang.github.io/2016/07/23/FMDB-one/</id>
    <published>2016-07-23T04:11:21.000Z</published>
    <updated>2016-07-24T10:49:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的<a href="http://zeeyang.com/2016/06/22/GCDAsyncSocket-socket-optimize/" target="_blank" rel="external">iOS Socket重构设计</a>里面我有提到我们使用了FMDB做消息缓存，在数据库选型方面，我们<a href="http://broccoliii.me/" target="_blank" rel="external">西兰花</a>也对目前比较流行和成熟的<code>Realm</code>、<code>FMDB</code>和<code>Core Data</code>做了调查，里面包括了安装、使用和性能比较，是个不错的参考例子</p>
<p>在选型时，我们应该多选取几个作为对比，从使用方面评估学习成本，通过测试不同数据库操作来比较性能差异，了解有哪些大型的App使用了该数据库以及评价来侧面说明该数据库的成熟度和在使用过程中出现的问题，最后根据自己实际的业务需求来选型</p>
<p>在选定使用<code>FMDB</code>之后，我也只是简单的了解下<code>FMDB</code>的使用，并未对内部的实现和设计思路做深入了解，但是在阅读了代码之后，<code>FMDB</code>确实像其他博客里面提到的那样，是对原生的SQLite API进行了包装，暴露出相对友好的对外接口，只需传入SQL语句即可(但是对于习惯于使用Model操作的我们来说，直接写SQL语句还是比较麻烦的，所以GitHub上也就库对<code>FMDB</code>进行了封装，省去写SQL语句，直接对Model进行操作)，并且<code>FMDB</code>内部对SQL语句进行了缓存，再配合上多线程并发执行，在提高效率方面做了不少的优化，另外还扩展了内存/文件的IO操作和虚表的操作</p>
<p>下面我会将API使用和源码结合起来讲，方便了解<code>FMDB</code>以及对复习下原生的SQLite API</p>
<a id="more"></a>
<h2 id="FMDatabase"><a href="#FMDatabase" class="headerlink" title="FMDatabase"></a>FMDatabase</h2><h4 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h4><p>数据库的初始化对外有两种方法<code>+ databaseWithPath:</code>和<code>- initWithPath:</code>，内部实际上<code>+ databaseWithPath:</code>只是对<code>- initWithPath:</code>包装，代码里很多类似<code>FMDBReturnAutoreleased</code>等等这一类宏定义是为了兼容ARC和MRC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)databaseWithPath:(NSString*)aPath &#123;</div><div class="line">    return FMDBReturnAutoreleased([[self alloc] initWithPath:aPath]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    return [self initWithPath:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithPath:(NSString*)aPath &#123;</div><div class="line">    // SQLite支持三种线程模式，分别为单线程模式、多线程模式和串行模式</div><div class="line">    // sqlite3_threadsafe()的返回值可以确定编译时指定的线程模式，其中对于单线程模式，sqlite3_threadsafe()返回false，对于另外两个模式，则返回true。这是因为单线程模式下没有进行互斥，所以多线程下是不安全的</div><div class="line">    assert(sqlite3_threadsafe()); // whoa there big boy- gotta make sure sqlite it happy with what we&apos;re going to do.</div><div class="line">    </div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    if (self) &#123;</div><div class="line">        _databasePath               = [aPath copy];</div><div class="line">        _openResultSets             = [[NSMutableSet alloc] init];</div><div class="line">        // 此时并不创建数据库，真正创建是在open的时候</div><div class="line">      	_db                         = nil;</div><div class="line">        _logsErrors                 = YES;</div><div class="line">        _crashOnErrors              = NO;</div><div class="line">        _maxBusyRetryTimeInterval   = 2;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 给定database路径</div><div class="line">NSString *dbPath = @&quot;/tmp/tmp.db&quot;;</div><div class="line">// 调用[+ databaseWithPath:]方法</div><div class="line">FMDatabase *db = [FMDatabase databaseWithPath:dbPath];</div></pre></td></tr></table></figure>
<h4 id="u6253_u5F00_u6570_u636E_u8FDE_u63A5"><a href="#u6253_u5F00_u6570_u636E_u8FDE_u63A5" class="headerlink" title="打开数据连接"></a>打开数据连接</h4><p>打开连接提供了三种方法，这时候才开始创建数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (BOOL)open &#123;</div><div class="line">    if (_db) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    // 根据数据库路径打开数据库，如果数据库不存在就新建一个</div><div class="line">    int err = sqlite3_open([self sqlitePath], (sqlite3**)&amp;_db );</div><div class="line">    if(err != SQLITE_OK) &#123;</div><div class="line">        NSLog(@&quot;error opening!: %d&quot;, err);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    // 设置最大繁忙重试时间间隔，默认为2秒</div><div class="line">    if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</div><div class="line">        // set the handler</div><div class="line">        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  	return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 根据标记打开一个新的数据库连接</div><div class="line">// flag可以是以下三种值之一：</div><div class="line">// SQLITE_OPEN_READONLY，只读模式，如果数据库不存在会报错</div><div class="line">// SQLITE_OPEN_READWRITE，读写模式，如果该文件在操作系统中是写保护的，那就是以只读方式打开，如果数据库不存在会报错</div><div class="line">// SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE，以读写方式打开，如果数据不存在则新建一个，这个用于open方法里面</div><div class="line">// 以上还可以可选组合`SQLITE_OPEN_NOMUTEX`, `SQLITE_OPEN_FULLMUTEX`, `SQLITE_OPEN_SHAREDCACHE`, `SQLITE_OPEN_PRIVATECACHE`, and/or `SQLITE_OPEN_URI`</div><div class="line">- (BOOL)openWithFlags:(int)flags &#123;</div><div class="line">    return [self openWithFlags:flags vfs:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName &#123;</div><div class="line">#if SQLITE_VERSION_NUMBER &gt;= 3005000</div><div class="line">    if (_db) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    // 比sqlite3_open多传入了flags和vfsName，vfsName为使用的VFS模块的名称</div><div class="line">    // sqlite3_open_v2里zVfs参数允许客户应用程序命名一个虚拟文件系统（Virtual File System）模块，用来与数据库连接。VFS作为SQlite library和底层存储系统（如某个文件系统）之间的一个抽象层，通常客户应用程序可以简单的给该参数传递一个NULL指针，以使用默认的VFS模块。</div><div class="line">    // sqlite3_open_v2比sqlite3_open和sqlite3_open16强大在它可以指定连接方式</div><div class="line">    int err = sqlite3_open_v2([self sqlitePath], (sqlite3**)&amp;_db, flags, [vfsName UTF8String]);</div><div class="line">    if(err != SQLITE_OK) &#123;</div><div class="line">        NSLog(@&quot;error opening!: %d&quot;, err);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</div><div class="line">        // set the handler</div><div class="line">        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">#else</div><div class="line">    NSLog(@&quot;openWithFlags requires SQLite 3.5&quot;);</div><div class="line">    return NO;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>open时会根据<code>_maxBusyRetryTimeInterval</code>来设置繁忙处理<code>busy handler</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">- (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout &#123;</div><div class="line">    </div><div class="line">    _maxBusyRetryTimeInterval = timeout;</div><div class="line">    </div><div class="line">    if (!_db) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);</div><div class="line">     第二个参数是回调函数（busy handler），如果设置了回调函数，那就需要设置sqlite3_busy_handler的第三个参数，这里传递给它的是一个void*的参数的拷贝；如果回调函数返回０时，将不再尝试再次访问数据库而返回SQLITE_BUSY或者SQLITE_IOERR_BLOCKED。如果回调函数返回非０,将会不断尝试操作数据库。</div><div class="line">     也就是说，程序运行过程中，如果有其他进程或者线程在读写数据库，那么sqlite3_busy_handler会不断调用回调函数，直到其他进程或者线程释放锁。获得锁之后，不会再调用回调函数，从而向下执行，进行数据库操作。该函数是在获取不到锁的时候，以执行回调函数的次数来进行延迟，等待其他进程或者线程操作数据库结束，从而获得锁操作数据库。</div><div class="line">     */</div><div class="line">    if (timeout &gt; 0) &#123;</div><div class="line">        // busy handler设置为FMDBDatabaseBusyHandler函数</div><div class="line">        sqlite3_busy_handler(_db, &amp;FMDBDatabaseBusyHandler, (__bridge void *)(self));</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // turn it off otherwise</div><div class="line">        // 关闭busy handler</div><div class="line">        sqlite3_busy_handler(_db, nil, nil);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这就是回调函数</div><div class="line">static int FMDBDatabaseBusyHandler(void *f, int count) &#123;</div><div class="line">    FMDatabase *self = (__bridge FMDatabase*)f;</div><div class="line">    </div><div class="line">    // 如果是第一次调用，调用[+ timeIntervalSinceReferenceDate]方法，获取当前时间与2001年1月1日00:00:00 UTC的时间间隔，并赋值给startBusyRetryTime</div><div class="line">    if (count == 0) &#123;</div><div class="line">        self-&gt;_startBusyRetryTime = [NSDate timeIntervalSinceReferenceDate];</div><div class="line">        // 返回1，则将不断尝试操作数据库</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    // 计算当前时间与2001年1月1日00:00:00 UTC的时间间隔和startBusyRetryTime的间隔</div><div class="line">    NSTimeInterval delta = [NSDate timeIntervalSinceReferenceDate] - (self-&gt;_startBusyRetryTime);</div><div class="line">    // 如果间隔时间小于最大的重试间隔时间</div><div class="line">    if (delta &lt; [self maxBusyRetryTimeInterval]) &#123;</div><div class="line">        // 产生一个从50-99的随机整数作为需要挂起毫秒时间</div><div class="line">        int requestedSleepInMillseconds = (int) arc4random_uniform(50) + 50;</div><div class="line">        // 调用sqlite3_sleep返回实际挂起毫秒时间，如果不一致，可能是因为SQLite构建时没有将HAVE_USLEEP设置为1</div><div class="line">        int actualSleepInMilliseconds = sqlite3_sleep(requestedSleepInMillseconds);</div><div class="line">        if (actualSleepInMilliseconds != requestedSleepInMillseconds) &#123;</div><div class="line">            NSLog(@&quot;WARNING: Requested sleep of %i milliseconds, but SQLite returned %i. Maybe SQLite wasn&apos;t built with HAVE_USLEEP=1?&quot;, requestedSleepInMillseconds, actualSleepInMilliseconds);</div><div class="line">        &#125;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (![db open]) &#123;</div><div class="line">	// do somthing        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u5355_u4E2A_u67E5_u8BE2SQL_u8BED_u53E5"><a href="#u6267_u884C_u5355_u4E2A_u67E5_u8BE2SQL_u8BED_u53E5" class="headerlink" title="执行单个查询SQL语句"></a>执行单个查询SQL语句</h4><p>主要执行的是<code>(FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code>方法，<code>sql</code>是执行SELECT语句，<code>dictionaryArgs</code>是对应于<code>sql</code>语句里<code>？</code>的<code>key</code>和<code>value</code>，在将<code>sql</code>语句转换成<code>prepared</code>语句时，这里先从缓存中获取，没有的话再去调用<code>sqlite3_prepare_v2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div></pre></td><td class="code"><pre><div class="line">- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123;</div><div class="line">    // 检查数据库是否存在</div><div class="line">    if (![self databaseExists]) &#123;</div><div class="line">        return 0x00;</div><div class="line">    &#125;</div><div class="line">    // 检查是否正在执行操作</div><div class="line">    if (_isExecutingStatement) &#123;</div><div class="line">        [self warnInUse];</div><div class="line">        return 0x00;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _isExecutingStatement = YES;</div><div class="line">    </div><div class="line">    int rc                  = 0x00;</div><div class="line">    sqlite3_stmt *pStmt     = 0x00;</div><div class="line">    FMStatement *statement  = 0x00;</div><div class="line">    FMResultSet *rs         = 0x00;</div><div class="line">    </div><div class="line">    if (_traceExecution &amp;&amp; sql) &#123;</div><div class="line">        NSLog(@&quot;%@ executeQuery: %@&quot;, self, sql);</div><div class="line">    &#125;</div><div class="line">    // 将sql语句转换成prepared语句</div><div class="line">    // 由于使用sqlite3_prepare_v2来生成sql对应的prepared语句代价很大</div><div class="line">    // 所以使用缓存机制来减少sqlite3_prepare_v2的使用</div><div class="line">    if (_shouldCacheStatements) &#123;</div><div class="line">        // 根据sql获取到缓存中的prepared语句</div><div class="line">        statement = [self cachedStatementForQuery:sql];</div><div class="line">        pStmt = statement ? [statement statement] : 0x00;</div><div class="line">        // 重置prepared语句</div><div class="line">        [statement reset];</div><div class="line">    &#125;</div><div class="line">    // 如果缓存中没有sql对应的prepared语句，那么需要用sqlite3_prepare_v2生成对应的prepared语句</div><div class="line">    if (!pStmt) &#123;</div><div class="line">        </div><div class="line">        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;pStmt, 0);</div><div class="line">        </div><div class="line">        // 如果生成失败，则打印错误日志</div><div class="line">        if (SQLITE_OK != rc) &#123;</div><div class="line">            if (_logsErrors) &#123;</div><div class="line">                NSLog(@&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</div><div class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</div><div class="line">                NSLog(@&quot;DB Path: %@&quot;, _databasePath);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (_crashOnErrors) &#123;</div><div class="line">                NSAssert(false, @&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</div><div class="line">                // 停止程序</div><div class="line">                abort();</div><div class="line">            &#125;</div><div class="line">            // 释放所有内部资源和FMStatement</div><div class="line">            sqlite3_finalize(pStmt);</div><div class="line">            _isExecutingStatement = NO;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id obj;</div><div class="line">    int idx = 0;</div><div class="line">    // sqlite3_bind_parameter_count 返回SQL语句参数的数量</div><div class="line">    int queryCount = sqlite3_bind_parameter_count(pStmt); // pointed out by Dominic Yu (thanks!)</div><div class="line">    </div><div class="line">    // If dictionaryArgs is passed in, that means we are using sqlite&apos;s named parameter support</div><div class="line">    if (dictionaryArgs) &#123;</div><div class="line">        </div><div class="line">        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &#123;</div><div class="line">            </div><div class="line">            // Prefix the key with a colon.</div><div class="line">            NSString *parameterName = [[NSString alloc] initWithFormat:@&quot;:%@&quot;, dictionaryKey];</div><div class="line">            </div><div class="line">            if (_traceExecution) &#123;</div><div class="line">                NSLog(@&quot;%@ = %@&quot;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // Get the index for the parameter name.</div><div class="line">            // 通过传入参数名来获取该参数的索引</div><div class="line">            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);</div><div class="line">            </div><div class="line">            FMDBRelease(parameterName);</div><div class="line">            // 如果索引大于0</div><div class="line">            if (namedIdx &gt; 0) &#123;</div><div class="line">                // Standard binding from here.</div><div class="line">                // 在prepared语句里将值绑定到索引位置</div><div class="line">                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];</div><div class="line">                // increment the binding count, so our check below works out</div><div class="line">                // 绑定数量加一</div><div class="line">                idx++;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                NSLog(@&quot;Could not find index for %@&quot;, dictionaryKey);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        </div><div class="line">        while (idx &lt; queryCount) &#123;</div><div class="line">            // 当调用下面三个方法时</div><div class="line">            // - (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...</div><div class="line">            // - (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments</div><div class="line">            // - (FMResultSet *)executeQuery:(NSString *)sql values:(NSArray *)values error:(NSError * __autoreleasing *)error</div><div class="line">            // 值是放在NSArray里面，循环取出来绑定</div><div class="line">            if (arrayArgs &amp;&amp; idx &lt; (int)[arrayArgs count]) &#123;</div><div class="line">                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];</div><div class="line">            &#125;</div><div class="line">            // 当调用下面两个方法时</div><div class="line">            // - (FMResultSet *)executeQuery:(NSString*)sql, ...</div><div class="line">            // - (FMResultSet *)executeQuery:(NSString*)sql withVAList:(va_list)args</div><div class="line">            // 值是放在va_list里面，循环取出来绑定</div><div class="line">            else if (args) &#123;</div><div class="line">                obj = va_arg(args, id);</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                //We ran out of arguments</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (_traceExecution) &#123;</div><div class="line">                if ([obj isKindOfClass:[NSData class]]) &#123;</div><div class="line">                    NSLog(@&quot;data: %ld bytes&quot;, (unsigned long)[(NSData*)obj length]);</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    NSLog(@&quot;obj: %@&quot;, obj);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            idx++;</div><div class="line">            // 绑定参数</div><div class="line">            [self bindObject:obj toColumn:idx inStatement:pStmt];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 如果绑定数量和参数数量不一致，打印错误，并释放资源</div><div class="line">    if (idx != queryCount) &#123;</div><div class="line">        NSLog(@&quot;Error: the bind count is not correct for the # of variables (executeQuery)&quot;);</div><div class="line">        sqlite3_finalize(pStmt);</div><div class="line">        _isExecutingStatement = NO;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    FMDBRetain(statement); // to balance the release below</div><div class="line">    </div><div class="line">    // 如果statement不为空，则缓存</div><div class="line">    if (!statement) &#123;</div><div class="line">        statement = [[FMStatement alloc] init];</div><div class="line">        [statement setStatement:pStmt];</div><div class="line">        </div><div class="line">        if (_shouldCacheStatements &amp;&amp; sql) &#123;</div><div class="line">            // 以sql作为key来缓存statement</div><div class="line">            [self setCachedStatement:statement forQuery:sql];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // the statement gets closed in rs&apos;s dealloc or [rs close];</div><div class="line">    // 根据statement和FMDataBase对象来初始化FMResultSet对象</div><div class="line">    rs = [FMResultSet resultSetWithStatement:statement usingParentDatabase:self];</div><div class="line">    [rs setQuery:sql];</div><div class="line">    </div><div class="line">    // 将FMResultSet对象加到_openResultSets里</div><div class="line">    NSValue *openResultSet = [NSValue valueWithNonretainedObject:rs];</div><div class="line">    [_openResultSets addObject:openResultSet];</div><div class="line">    // useCount+1</div><div class="line">    [statement setUseCount:[statement useCount] + 1];</div><div class="line">    </div><div class="line">    FMDBRelease(statement);</div><div class="line">    // 设置_isExecutingStatement操作结束</div><div class="line">    _isExecutingStatement = NO;</div><div class="line">    </div><div class="line">    return rs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rs = [newDb executeQuery:@&quot;select rowid,* from test where a = ?&quot;, @&quot;hi&apos;&quot;];</div><div class="line"></div><div class="line">rs = [db executeQueryWithFormat:@&quot;select * from t5 where a = %s and a = %@ and b = %d&quot;, &quot;text&quot;, @&quot;text&quot;, 42];</div><div class="line"></div><div class="line">rs = [db executeQuery:@&quot;select * from testOneHundredTwelvePointTwo where b &gt; ?&quot; withArgumentsInArray:[NSArray arrayWithObject:[NSNumber numberWithInteger:1]]];</div><div class="line"></div><div class="line">rs = [db executeQuery:@&quot;select * from namedparamcounttest where a = :a&quot; withParameterDictionary:dictionaryArgs];</div></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u5355_u4E2A_u66F4_u65B0SQL_u8BED_u53E5"><a href="#u6267_u884C_u5355_u4E2A_u66F4_u65B0SQL_u8BED_u53E5" class="headerlink" title="执行单个更新SQL语句"></a>执行单个更新SQL语句</h4><p><code>- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code>是主要函数，但是里面大部分处理和<code>- executeQuery: withArgumentsInArray: orDictionary: orVAList:</code>处理类似，不同处我已经注释说明，可以直接看注释部分代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div></pre></td><td class="code"><pre><div class="line">- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123;</div><div class="line">    </div><div class="line">    if (![self databaseExists]) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_isExecutingStatement) &#123;</div><div class="line">        [self warnInUse];</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _isExecutingStatement = YES;</div><div class="line">    </div><div class="line">    int rc                   = 0x00;</div><div class="line">    sqlite3_stmt *pStmt      = 0x00;</div><div class="line">    FMStatement *cachedStmt  = 0x00;</div><div class="line">    </div><div class="line">    if (_traceExecution &amp;&amp; sql) &#123;</div><div class="line">        NSLog(@&quot;%@ executeUpdate: %@&quot;, self, sql);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_shouldCacheStatements) &#123;</div><div class="line">        cachedStmt = [self cachedStatementForQuery:sql];</div><div class="line">        pStmt = cachedStmt ? [cachedStmt statement] : 0x00;</div><div class="line">        [cachedStmt reset];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!pStmt) &#123;</div><div class="line">        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;pStmt, 0);</div><div class="line">        </div><div class="line">        if (SQLITE_OK != rc) &#123;</div><div class="line">            if (_logsErrors) &#123;</div><div class="line">                NSLog(@&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</div><div class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</div><div class="line">                NSLog(@&quot;DB Path: %@&quot;, _databasePath);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (_crashOnErrors) &#123;</div><div class="line">                NSAssert(false, @&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</div><div class="line">                abort();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (outErr) &#123;</div><div class="line">                *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            sqlite3_finalize(pStmt);</div><div class="line">            </div><div class="line">            _isExecutingStatement = NO;</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id obj;</div><div class="line">    int idx = 0;</div><div class="line">    int queryCount = sqlite3_bind_parameter_count(pStmt);</div><div class="line">    </div><div class="line">    // If dictionaryArgs is passed in, that means we are using sqlite&apos;s named parameter support</div><div class="line">    if (dictionaryArgs) &#123;</div><div class="line">        </div><div class="line">        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &#123;</div><div class="line">            </div><div class="line">            // Prefix the key with a colon.</div><div class="line">            NSString *parameterName = [[NSString alloc] initWithFormat:@&quot;:%@&quot;, dictionaryKey];</div><div class="line">            </div><div class="line">            if (_traceExecution) &#123;</div><div class="line">                NSLog(@&quot;%@ = %@&quot;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);</div><div class="line">            &#125;</div><div class="line">            // Get the index for the parameter name.</div><div class="line">            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);</div><div class="line">            </div><div class="line">            FMDBRelease(parameterName);</div><div class="line">            </div><div class="line">            if (namedIdx &gt; 0) &#123;</div><div class="line">                // Standard binding from here.</div><div class="line">                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];</div><div class="line">                </div><div class="line">                // increment the binding count, so our check below works out</div><div class="line">                idx++;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                // 由于多了outErr，所以绑定时出错需要将error抛出</div><div class="line">                NSString *message = [NSString stringWithFormat:@&quot;Could not find index for %@&quot;, dictionaryKey];</div><div class="line">                </div><div class="line">                if (_logsErrors) &#123;</div><div class="line">                    NSLog(@&quot;%@&quot;, message);</div><div class="line">                &#125;</div><div class="line">                if (outErr) &#123;</div><div class="line">                    *outErr = [self errorWithMessage:message];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        </div><div class="line">        while (idx &lt; queryCount) &#123;</div><div class="line">            </div><div class="line">            if (arrayArgs &amp;&amp; idx &lt; (int)[arrayArgs count]) &#123;</div><div class="line">                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];</div><div class="line">            &#125;</div><div class="line">            else if (args) &#123;</div><div class="line">                obj = va_arg(args, id);</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                //We ran out of arguments</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (_traceExecution) &#123;</div><div class="line">                if ([obj isKindOfClass:[NSData class]]) &#123;</div><div class="line">                    NSLog(@&quot;data: %ld bytes&quot;, (unsigned long)[(NSData*)obj length]);</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    NSLog(@&quot;obj: %@&quot;, obj);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            idx++;</div><div class="line">            </div><div class="line">            [self bindObject:obj toColumn:idx inStatement:pStmt];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    if (idx != queryCount) &#123;</div><div class="line">        // 同样也是组装error抛出</div><div class="line">        NSString *message = [NSString stringWithFormat:@&quot;Error: the bind count (%d) is not correct for the # of variables in the query (%d) (%@) (executeUpdate)&quot;, idx, queryCount, sql];</div><div class="line">        if (_logsErrors) &#123;</div><div class="line">            NSLog(@&quot;%@&quot;, message);</div><div class="line">        &#125;</div><div class="line">        if (outErr) &#123;</div><div class="line">            *outErr = [self errorWithMessage:message];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        sqlite3_finalize(pStmt);</div><div class="line">        _isExecutingStatement = NO;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /* Call sqlite3_step() to run the virtual machine. Since the SQL being</div><div class="line">     ** executed is not a SELECT statement, we assume no data will be returned.</div><div class="line">     */</div><div class="line">    // sqlite3_prepare函数将SQL命令字符串解析并转换为一系列的命令字节码，这些字节码最终被传送到SQlite3的虚拟数据库引擎（VDBE: Virtual Database Engine）中执行，完成这项工作的是sqlite3_step函数。比如一个SELECT查询操作，sqlite3_step函数的每次调用都会返回结果集中的其中一行，直到再没有有效数据行了。每次调用sqlite3_step函数如果返回SQLITE_ROW，代表获得了有效数据行，可以通过sqlite3_column函数提取某列的值。如果调用sqlite3_step函数返回SQLITE_DONE，则代表prepared语句已经执行到终点了，没有有效数据了。很多命令第一次调用sqlite3_step函数就会返回SQLITE_DONE，因为这些SQL命令不会返回数据。对于INSERT，UPDATE，DELETE命令，会返回它们所修改的行号——一个单行单列的值。</div><div class="line">    /**</div><div class="line">     SQLITE_BUSY 数据库文件有锁</div><div class="line">     SQLITE_LOCKED 数据库中的某张表有锁</div><div class="line">     SQLITE_DONE sqlite3_step()执行完毕</div><div class="line">     SQLITE_ROW sqlite3_step()获取到下一行数据</div><div class="line">     SQLITE_ERROR 一般用于没有特别指定错误码的错误，就是说函数在执行过程中发生了错误，但无法知道错误发生的原因。</div><div class="line">     SQLITE_MISUSE 没有正确使用SQLite接口，比如一条语句在sqlite3_step函数执行之后，没有被重置之前，再次给其绑定参数，这时bind函数就会返回SQLITE_MISUSE。</div><div class="line">     **/</div><div class="line">    rc      = sqlite3_step(pStmt);</div><div class="line">    </div><div class="line">    if (SQLITE_DONE == rc) &#123;</div><div class="line">        // all is well, let&apos;s return.</div><div class="line">    &#125;</div><div class="line">    // sql操作被sqlite3_interrupt()函数终止</div><div class="line">    else if (SQLITE_INTERRUPT == rc) &#123;</div><div class="line">        if (_logsErrors) &#123;</div><div class="line">            NSLog(@&quot;Error calling sqlite3_step. Query was interrupted (%d: %s) SQLITE_INTERRUPT&quot;, rc, sqlite3_errmsg(_db));</div><div class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if (rc == SQLITE_ROW) &#123;</div><div class="line">        NSString *message = [NSString stringWithFormat:@&quot;A executeUpdate is being called with a query string &apos;%@&apos;&quot;, sql];</div><div class="line">        if (_logsErrors) &#123;</div><div class="line">            NSLog(@&quot;%@&quot;, message);</div><div class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</div><div class="line">        &#125;</div><div class="line">        if (outErr) &#123;</div><div class="line">            *outErr = [self errorWithMessage:message];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (outErr) &#123;</div><div class="line">            *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (SQLITE_ERROR == rc) &#123;</div><div class="line">            if (_logsErrors) &#123;</div><div class="line">                NSLog(@&quot;Error calling sqlite3_step (%d: %s) SQLITE_ERROR&quot;, rc, sqlite3_errmsg(_db));</div><div class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else if (SQLITE_MISUSE == rc) &#123;</div><div class="line">            // uh oh.</div><div class="line">            if (_logsErrors) &#123;</div><div class="line">                NSLog(@&quot;Error calling sqlite3_step (%d: %s) SQLITE_MISUSE&quot;, rc, sqlite3_errmsg(_db));</div><div class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // wtf?</div><div class="line">            if (_logsErrors) &#123;</div><div class="line">                NSLog(@&quot;Unknown error calling sqlite3_step (%d: %s) eu&quot;, rc, sqlite3_errmsg(_db));</div><div class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_shouldCacheStatements &amp;&amp; !cachedStmt) &#123;</div><div class="line">        cachedStmt = [[FMStatement alloc] init];</div><div class="line">        </div><div class="line">        [cachedStmt setStatement:pStmt];</div><div class="line">        </div><div class="line">        [self setCachedStatement:cachedStmt forQuery:sql];</div><div class="line">        </div><div class="line">        FMDBRelease(cachedStmt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int closeErrorCode;</div><div class="line">    </div><div class="line">    if (cachedStmt) &#123;</div><div class="line">        [cachedStmt setUseCount:[cachedStmt useCount] + 1];</div><div class="line">        closeErrorCode = sqlite3_reset(pStmt);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        /* Finalize the virtual machine. This releases all memory and other</div><div class="line">         ** resources allocated by the sqlite3_prepare() call above.</div><div class="line">         */</div><div class="line">        closeErrorCode = sqlite3_finalize(pStmt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (closeErrorCode != SQLITE_OK) &#123;</div><div class="line">        if (_logsErrors) &#123;</div><div class="line">            NSLog(@&quot;Unknown error finalizing or resetting statement (%d: %s)&quot;, closeErrorCode, sqlite3_errmsg(_db));</div><div class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _isExecutingStatement = NO;</div><div class="line">    return (rc == SQLITE_DONE || rc == SQLITE_OK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[db executeUpdate:@&quot;insert into t5 values (?, ?, ?, ?, ?)&quot; withErrorAndBindings:&amp;err, @&quot;text&quot;, [NSNumber numberWithInt:42], @&quot;BLOB&quot;, @&quot;d&quot;, [NSNumber numberWithInt:0]];</div><div class="line"></div><div class="line">[dbB executeUpdate:@&quot;create table attached (a text)&quot;];</div><div class="line"></div><div class="line">[dbB executeUpdate:@&quot;insert into attached values (?)&quot;, @&quot;test&quot;];</div><div class="line"></div><div class="line">[db executeUpdateWithFormat:@&quot;insert into t55 values (%c, %hi, %g)&quot;, &apos;a&apos;, testShort, testFloat];</div><div class="line"></div><div class="line">[db executeUpdate:@&quot;insert into testOneHundredTwelvePointTwo values (?, ?)&quot; withArgumentsInArray:[NSArray arrayWithObjects:@&quot;one&quot;, [NSNumber numberWithInteger:2], nil]];</div><div class="line"></div><div class="line">[db executeUpdate:@&quot;insert into namedparamtest values (:a, :b, :c, :d)&quot; withParameterDictionary:dictionaryArgs];</div></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u591A_u4E2ASQL_u8BED_u53E5"><a href="#u6267_u884C_u591A_u4E2ASQL_u8BED_u53E5" class="headerlink" title="执行多个SQL语句"></a>执行多个SQL语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 使用executeStatements:函数可以将多个SQL执行语句写在一个字符串中，并执行</div><div class="line">- (BOOL)executeStatements:(NSString *)sql &#123;</div><div class="line">    return [self executeStatements:sql withResultBlock:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)executeStatements:(NSString *)sql withResultBlock:(FMDBExecuteStatementsCallbackBlock)block &#123;</div><div class="line">    </div><div class="line">    int rc;</div><div class="line">    char *errmsg = nil;</div><div class="line">    /*</div><div class="line">     sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg)</div><div class="line">     </div><div class="line">     该例程提供了一个执行 SQL 命令的快捷方式，SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。</div><div class="line">     </div><div class="line">     在这里，第一个参数 sqlite3 是打开的数据库对象，sqlite_callback 是一个回调，data 作为其第一个参数，errmsg 将被返回用来获取程序生成的任何错误。</div><div class="line">     </div><div class="line">     sqlite3_exec() 程序解析并执行由 sql 参数所给的每个命令，直到字符串结束或者遇到错误为止。</div><div class="line">     */</div><div class="line">    rc = sqlite3_exec([self sqliteHandle], [sql UTF8String], block ? FMDBExecuteBulkSQLCallback : nil, (__bridge void *)(block), &amp;errmsg);</div><div class="line">    </div><div class="line">    if (errmsg &amp;&amp; [self logsErrors]) &#123;</div><div class="line">        NSLog(@&quot;Error inserting batch: %s&quot;, errmsg);</div><div class="line">        sqlite3_free(errmsg);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return (rc == SQLITE_OK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSString *sql = @&quot;create table messages1 (id integer primary key messageId, x text);&quot;</div><div class="line">                 &quot;create table messages2 (id integer primary key messageId, y text);&quot;</div><div class="line">				 &quot;insert into messages1 (x) values (&apos;X&apos;);&quot;</div><div class="line">                 &quot;insert into messages2 (y) values (&apos;Y&apos;);&quot;;</div><div class="line"></div><div class="line">success = [db executeStatements:sql];</div><div class="line"></div><div class="line">sql = @&quot;select count(*) as count from messages1;&quot;</div><div class="line">       &quot;select count(*) as count from messages2;&quot;;</div><div class="line"></div><div class="line">success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) &#123;</div><div class="line">    // do something</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="u83B7_u53D6_u6700_u540E_u4E00_u6761_u63D2_u5165_u6570_u636E_u7684RowId"><a href="#u83B7_u53D6_u6700_u540E_u4E00_u6761_u63D2_u5165_u6570_u636E_u7684RowId" class="headerlink" title="获取最后一条插入数据的RowId"></a>获取最后一条插入数据的RowId</h4><p>可以根据这个<code>id</code>拿到该数据，并且向上取数据库数据等操作都可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (sqlite_int64)lastInsertRowId &#123;</div><div class="line">    // 如果有正在执行语句，返回</div><div class="line">    if (_isExecutingStatement) &#123;</div><div class="line">        [self warnInUse];</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _isExecutingStatement = YES;</div><div class="line">    // sqlite3_last_insert_rowid 获取指定数据库最后一个插入的rowid</div><div class="line">    sqlite_int64 ret = sqlite3_last_insert_rowid(_db);</div><div class="line">    </div><div class="line">    _isExecutingStatement = NO;</div><div class="line">    </div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="u7EDF_u8BA1_u4E0A_u4E00_u6B21SQL_u8BED_u53E5_u53D7_u5F71_u54CD_u7684_u884C_u6570"><a href="#u7EDF_u8BA1_u4E0A_u4E00_u6B21SQL_u8BED_u53E5_u53D7_u5F71_u54CD_u7684_u884C_u6570" class="headerlink" title="统计上一次SQL语句受影响的行数"></a>统计上一次SQL语句受影响的行数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (int)changes &#123;</div><div class="line">    if (_isExecutingStatement) &#123;</div><div class="line">        [self warnInUse];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    _isExecutingStatement = YES;</div><div class="line">    </div><div class="line">    int ret = sqlite3_changes(_db);</div><div class="line">    </div><div class="line">    _isExecutingStatement = NO;</div><div class="line">    </div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="exclusive_u4E8B_u52A1_u548Cdeferred_u4E8B_u52A1"><a href="#exclusive_u4E8B_u52A1_u548Cdeferred_u4E8B_u52A1" class="headerlink" title="exclusive事务和deferred事务"></a>exclusive事务和deferred事务</h4><p>事务可以从<code>DEFERRED</code>，<code>IMMEDIATE</code>或者<code>EXCLUSIVE</code>，一个事务的类型在<code>BEGIN</code>命令中指定：<code>BEGIN [ DEFERRED | IMMEDIATE | EXCLUSIVE ] TRANSACTION</code></p>
<p>一个<code>deferred</code>事务不获取任何锁，直到它需要锁的时候，而且<code>BEGIN</code>语句本身也不会做什么事情——它开始于<code>UNLOCK</code>状态；默认情况下是这样的。如果仅仅用<code>BEGIN</code>开始一个事务，那么事务就是<code>DEFERRED</code>的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取<code>SHARED LOCK</code>；同样，当进行第一次写操作时，它会获取<code>RESERVED LOCK</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// 开始延迟事务</div><div class="line">- (BOOL)beginDeferredTransaction &#123;</div><div class="line">    </div><div class="line">    BOOL b = [self executeUpdate:@&quot;begin deferred transaction&quot;];</div><div class="line">    if (b) &#123;</div><div class="line">        _inTransaction = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。</div><div class="line"></div><div class="line">// 开始事务</div><div class="line">- (BOOL)beginTransaction &#123;</div><div class="line">    </div><div class="line">    BOOL b = [self executeUpdate:@&quot;begin exclusive transaction&quot;];</div><div class="line">    if (b) &#123;</div><div class="line">        _inTransaction = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 回滚事务</div><div class="line">- (BOOL)rollback &#123;</div><div class="line">    BOOL b = [self executeUpdate:@&quot;rollback transaction&quot;];</div><div class="line">    </div><div class="line">    if (b) &#123;</div><div class="line">        _inTransaction = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return b;</div><div class="line">&#125;</div><div class="line">// 提交事务</div><div class="line">- (BOOL)commit &#123;</div><div class="line">    BOOL b =  [self executeUpdate:@&quot;commit transaction&quot;];</div><div class="line">    </div><div class="line">    if (b) &#123;</div><div class="line">        _inTransaction = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="u6570_u636E_u5E93_u52A0_u5BC6_u53CA_u91CD_u7F6E"><a href="#u6570_u636E_u5E93_u52A0_u5BC6_u53CA_u91CD_u7F6E" class="headerlink" title="数据库加密及重置"></a>数据库加密及重置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (BOOL)setKeyWithData:(NSData *)keyData &#123;</div><div class="line">// SQLITE_HAS_CODEC 用来确定是否支持加密</div><div class="line">#ifdef SQLITE_HAS_CODEC</div><div class="line">    if (!keyData) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // int sqlite3_key( sqlite3 *db, const void *pKey, int nKey)</div><div class="line">    // db是指定的数据库，pKey是密钥，nKey是密钥的长度</div><div class="line">    // 例如：sqlite3_key(_db, &quot;gongcheng&quot;, 9);</div><div class="line">    int rc = sqlite3_key(_db, [keyData bytes], (int)[keyData length]);</div><div class="line">    </div><div class="line">    return (rc == SQLITE_OK);</div><div class="line">#else</div><div class="line">#pragma unused(keyData)</div><div class="line">    return NO;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (BOOL)rekeyWithData:(NSData *)keyData &#123;</div><div class="line">#ifdef SQLITE_HAS_CODEC</div><div class="line">    if (!keyData) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // int sqlite3_rekey( sqlite3 *db, const void *pKey, int nKey)</div><div class="line">    // db是指定的数据库，pKey是密钥，nKey是密钥的长度</div><div class="line">    // 例如：sqlite3_rekey(_db, &quot;yzy&quot;, 3);</div><div class="line">    int rc = sqlite3_rekey(_db, [keyData bytes], (int)[keyData length]);</div><div class="line">    </div><div class="line">    if (rc != SQLITE_OK) &#123;</div><div class="line">        NSLog(@&quot;error on rekey: %d&quot;, rc);</div><div class="line">        NSLog(@&quot;%@&quot;, [self lastErrorMessage]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return (rc == SQLITE_OK);</div><div class="line">#else</div><div class="line">#pragma unused(keyData)</div><div class="line">    return NO;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="u6570_u636E_u5E93_u56DE_u6EDA_u65F6_u8BBE_u7F6E_u56DE_u6EDA_u8282_u70B9"><a href="#u6570_u636E_u5E93_u56DE_u6EDA_u65F6_u8BBE_u7F6E_u56DE_u6EDA_u8282_u70B9" class="headerlink" title="数据库回滚时设置回滚节点"></a>数据库回滚时设置回滚节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (NSError*)inSavePoint:(void (^)(BOOL *rollback))block &#123;</div><div class="line">#if SQLITE_VERSION_NUMBER &gt;= 3007000</div><div class="line">    static unsigned long savePointIdx = 0;</div><div class="line">    // 设置节点名称</div><div class="line">    NSString *name = [NSString stringWithFormat:@&quot;dbSavePoint%ld&quot;, savePointIdx++];</div><div class="line">    // 默认不回滚</div><div class="line">    BOOL shouldRollback = NO;</div><div class="line">    </div><div class="line">    NSError *err = 0x00;</div><div class="line">    // 先对当前状态进行保存</div><div class="line">    if (![self startSavePointWithName:name error:&amp;err]) &#123;</div><div class="line">        return err;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (block) &#123;</div><div class="line">        block(&amp;shouldRollback);</div><div class="line">    &#125;</div><div class="line">    // 如果需要回滚，则回滚当上一个节点</div><div class="line">    if (shouldRollback) &#123;</div><div class="line">        // We need to rollback and release this savepoint to remove it</div><div class="line">        [self rollbackToSavePointWithName:name error:&amp;err];</div><div class="line">    &#125;</div><div class="line">    // 释放节点</div><div class="line">    [self releaseSavePointWithName:name error:&amp;err];</div><div class="line">    </div><div class="line">    return err;</div><div class="line">#else</div><div class="line">    NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil);</div><div class="line">    if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage);</div><div class="line">    return [NSError errorWithDomain:@&quot;FMDatabase&quot; code:0 userInfo:@&#123;NSLocalizedDescriptionKey : errorMessage&#125;];</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="u5173_u95ED_u6570_u636E_u5E93_u8FDE_u63A5"><a href="#u5173_u95ED_u6570_u636E_u5E93_u8FDE_u63A5" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (BOOL)close &#123;</div><div class="line">    // 清除缓存的prepared语句</div><div class="line">    [self clearCachedStatements];</div><div class="line">    // 关闭所有打开的FMResultSet对象</div><div class="line">    [self closeOpenResultSets];</div><div class="line">    </div><div class="line">    if (!_db) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    int  rc;</div><div class="line">    BOOL retry;</div><div class="line">    BOOL triedFinalizingOpenStatements = NO;</div><div class="line">    </div><div class="line">    do &#123;</div><div class="line">        retry   = NO;</div><div class="line">        // 调用sqlite3_close尝试关闭数据库</div><div class="line">        rc      = sqlite3_close(_db);</div><div class="line">        // 当返回结果是数据库繁忙或者被锁住了</div><div class="line">        if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &#123;</div><div class="line">            if (!triedFinalizingOpenStatements) &#123;</div><div class="line">                triedFinalizingOpenStatements = YES;</div><div class="line">                sqlite3_stmt *pStmt;</div><div class="line">                // 从关联的pDb数据里面对应的prepared语句开始往下找相应的prepared语句，</div><div class="line">                // 如果pStmt是NULL，则从pDb的第一个prepared语句开始找，</div><div class="line">                // 如果没有找到，则返回NULL</div><div class="line">                while ((pStmt = sqlite3_next_stmt(_db, nil)) !=0) &#123;</div><div class="line">                    // 找到之后，释放资源</div><div class="line">                    NSLog(@&quot;Closing leaked statement&quot;);</div><div class="line">                    sqlite3_finalize(pStmt);</div><div class="line">                    retry = YES;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else if (SQLITE_OK != rc) &#123;</div><div class="line">            NSLog(@&quot;error closing!: %d&quot;, rc);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (retry);</div><div class="line">    </div><div class="line">    _db = nil;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[newDb close];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的&lt;a href=&quot;http://zeeyang.com/2016/06/22/GCDAsyncSocket-socket-optimize/&quot;&gt;iOS Socket重构设计&lt;/a&gt;里面我有提到我们使用了FMDB做消息缓存，在数据库选型方面，我们&lt;a href=&quot;http://broccoliii.me/&quot;&gt;西兰花&lt;/a&gt;也对目前比较流行和成熟的&lt;code&gt;Realm&lt;/code&gt;、&lt;code&gt;FMDB&lt;/code&gt;和&lt;code&gt;Core Data&lt;/code&gt;做了调查，里面包括了安装、使用和性能比较，是个不错的参考例子&lt;/p&gt;
&lt;p&gt;在选型时，我们应该多选取几个作为对比，从使用方面评估学习成本，通过测试不同数据库操作来比较性能差异，了解有哪些大型的App使用了该数据库以及评价来侧面说明该数据库的成熟度和在使用过程中出现的问题，最后根据自己实际的业务需求来选型&lt;/p&gt;
&lt;p&gt;在选定使用&lt;code&gt;FMDB&lt;/code&gt;之后，我也只是简单的了解下&lt;code&gt;FMDB&lt;/code&gt;的使用，并未对内部的实现和设计思路做深入了解，但是在阅读了代码之后，&lt;code&gt;FMDB&lt;/code&gt;确实像其他博客里面提到的那样，是对原生的SQLite API进行了包装，暴露出相对友好的对外接口，只需传入SQL语句即可(但是对于习惯于使用Model操作的我们来说，直接写SQL语句还是比较麻烦的，所以GitHub上也就库对&lt;code&gt;FMDB&lt;/code&gt;进行了封装，省去写SQL语句，直接对Model进行操作)，并且&lt;code&gt;FMDB&lt;/code&gt;内部对SQL语句进行了缓存，再配合上多线程并发执行，在提高效率方面做了不少的优化，另外还扩展了内存/文件的IO操作和虚表的操作&lt;/p&gt;
&lt;p&gt;下面我会将API使用和源码结合起来讲，方便了解&lt;code&gt;FMDB&lt;/code&gt;以及对复习下原生的SQLite API&lt;/p&gt;
    
    </summary>
    
    
      <category term="FMDB" scheme="http://yuzeyang.github.io/tags/FMDB/"/>
    
  </entry>
  
  <entry>
    <title>IM UI性能优化之异步绘制</title>
    <link href="http://yuzeyang.github.io/2016/07/05/IM-UI-optimize/"/>
    <id>http://yuzeyang.github.io/2016/07/05/IM-UI-optimize/</id>
    <published>2016-07-05T14:35:44.000Z</published>
    <updated>2017-04-10T13:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>重构完Socket之后，最近我们也开始针对IM的UI做了优化，这次的优化我们主要是参考了<a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a>对于性能方面的优化，前期我的另一个小伙伴<a href="http://broccoliii.me/" target="_blank" rel="external">西兰花</a>也对<a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a>做了调研，不过这个库理解起来确实要费一番功夫，由于YYkit的核心思路基本上都是学习AsyncDisplayKit的，相信YYkit这个库大家都已经很熟悉了，不过可能还没有看过这个库，那下面我做一个简单的介绍</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/yykit.png" alt=""></p>
<p>YYKit的作者是<a href="http://blog.ibireme.com/" target="_blank" rel="external">郭曜源</a>，YYKit实际上是将它那些单独的iOS组件整合在了一起，类似于集合一样组成功能比较全面的组件，你也可以根据自己业务的需要单独使用其中的某些部分</p>
<h2 id="0x00__u524D_u671F_u51C6_u5907"><a href="#0x00__u524D_u671F_u51C6_u5907" class="headerlink" title="0x00 前期准备"></a>0x00 前期准备</h2><p>我们首先阅读了郭曜源在<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">对界面流畅性方面的见解</a>，里面提到了<code>异步绘制</code>，但是文字表述毕竟是抽象的，然后我们简单看了下他的YYText和YYAsyncLayer组件，看完之后实际上对如何使用他的YYAsyncLayer这个组件来实现异步绘制还是有点模糊的，后来我们直接看他的微博demo，我们逐渐理清了他是如何实现异步绘制以及几个性能优化方面的点</p>
<p>因为YYLabel Async Display里面加了是否异步绘制开关，所以我们直接用这个例子作为对比，首先我们来看下异步绘制的效果，开始的时候我们关闭异步绘制的开关，你会发现FPS瞬间掉到6了，屏幕滚动开始非常卡，但是打开开关之后，滚动时虽然FPS还是会掉到30-40，但是滑动的流畅度比之前要好很多，感觉这异步绘制的效果杠杠的好啊，那我们一定要看看他是怎么做的了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/YYAsyncLayer.gif!500x500" alt=""></p>
<h2 id="0x01__u5206_u6790"><a href="#0x01__u5206_u6790" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><p>其实整一个性能优化关键的点及流程有三个：</p>
<h5 id="1-_u6570_u636E_u6E90_u7684_u5F02_u6B65_u5904_u7406"><a href="#1-_u6570_u636E_u6E90_u7684_u5F02_u6B65_u5904_u7406" class="headerlink" title="1.数据源的异步处理"></a>1.数据源的异步处理</h5><p>当我们获取到数据源的时候，我们需要对数据源进行计算处理，计算出UI绘制所需要的属性比如宽高、颜色等等，而且这些计算要异步去做，否则会卡住主线程，等这些数据源计算完成之后，再去处理绘制，但是如果数据源过大，计算的耗时还是在的，所以会有较长时间的等待时间，此时我们需要考虑加上等待的友好处理</p>
<h5 id="2-_u91C7_u7528_u66F4_u8F7B_u91CF_u7EA7_u7684_u7ED8_u5236"><a href="#2-_u91C7_u7528_u66F4_u8F7B_u91CF_u7EA7_u7684_u7ED8_u5236" class="headerlink" title="2.采用更轻量级的绘制"></a>2.采用更轻量级的绘制</h5><p>在绘制时，对于不需要响应触摸事件的控件，我们应该尽量避免创建UIView对象，取而代之的是使用更为轻量的CALayer，并且对于一个layer包含多个subLayer的情况时，我们可以通过图层预合成的方法，将多个subLayer合成渲染成一张图片，通过上述的处理，不仅能减少CPU在创建UIKit对象的消耗，还能减少GPU在合成和渲染上的消耗，内存的占用也会少很多</p>
<h5 id="3-_u5F02_u6B65_u7ED8_u5236"><a href="#3-_u5F02_u6B65_u7ED8_u5236" class="headerlink" title="3.异步绘制"></a>3.异步绘制</h5><p>我们将使用<code>YYAsyncLayer</code>组件实现异步绘制</p>
<h2 id="0x02_YYAsyncLayer_u4ECB_u7ECD"><a href="#0x02_YYAsyncLayer_u4ECB_u7ECD" class="headerlink" title="0x02 YYAsyncLayer介绍"></a>0x02 YYAsyncLayer介绍</h2><p>前面两个优化点，平时在做的时候可能也都会去做，但是异步绘制这个该怎么去实现呢？我们直接来看下<code>YYAsyncLayer</code>的代码</p>
<p><code>YYAsyncLayer</code>组件里面一共包含了三个类：<code>YYAsyncLayer</code>、<code>YYSentinel</code>、<code>YYTransaction</code></p>
<p><code>YYAsyncLayer</code>类是我们主要用的类，它是CALayer的子类，是用来异步渲染layer内容</p>
<p><code>YYSentinel</code>类是用来给线程安全计数的，用于在多线程处理的场景</p>
<p><code>YYTransaction</code>类是利用runloop在休眠前的空闲时间来触发你预设的方法</p>
<p>因为我们没有用到<code>YYTransaction</code>类，所以我们直接将<code>YYAsyncLayer</code>、<code>YYSentinel</code>合成一个类，并做了混淆，这样可以少引用一个库</p>
<p>我们首先来看<code>YYAsyncLayer</code>的头文件</p>
<p><code>YYAsyncLayer</code>类只有一个<code>displaysAsynchronously</code>属性，就是设置渲染是否是异步执行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property BOOL displaysAsynchronously;</div></pre></td></tr></table></figure>
<p>然后还有个代理方法，这个代理方法的触发时机是在layer的内容需要更新的时候，此时你有个新的绘制任务，然后返回的是个<code>YYAsyncLayerDisplayTask</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;</div></pre></td></tr></table></figure>
<p><code>YYAsyncLayerDisplayTask</code>类只有三个block，即将绘制、绘制中、绘制完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);</div><div class="line">@property (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));</div><div class="line">@property (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);</div></pre></td></tr></table></figure>
<p>看到实现文件里面，触发这个代理的方法是<code>- setNeedsDisplay</code>方法，就是当layer需要更新内容的时候，它会向代理发起一个异步绘制的请求，将内容的渲染放到后台队列去做，所以我们在使用<code>YYAsyncLayer</code>类时，我们需要重写<code>+ layerClass</code>方法，返回<code>YYAsyncLayer</code>类，否则会直接调用<code>CALayer</code>的方法，不会触发代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)setNeedsDisplay &#123;</div><div class="line">    [self _cancelAsyncDisplay];</div><div class="line">    [super setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)display &#123;</div><div class="line">    super.contents = super.contents;</div><div class="line">    [self _displayAsync:_displaysAsynchronously];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Private</div><div class="line"></div><div class="line">- (void)_displayAsync:(BOOL)async &#123;</div><div class="line">    __strong id&lt;YYAsyncLayerDelegate&gt; delegate = self.delegate;</div><div class="line">    YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>- _displayAsync</code>方法里面主要分成三部分：</p>
<p>如果没有设置display回调，layer的内容会被清空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!task.display) &#123;</div><div class="line">    if (task.willDisplay) task.willDisplay(self);</div><div class="line">    self.contents = nil;</div><div class="line">    if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据之前<code>displaysAsynchronously</code>属性设置判断，如果是同步绘制的话，实际上的操作就是在调用完<code>display</code>block之后，将sublayer合成一张图作为layer的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[self increase];</div><div class="line">if (task.willDisplay) task.willDisplay(self);</div><div class="line">UIGraphicsBeginImageContextWithOptions(self.bounds.size,self.opaque,self.contentsScale);</div><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">task.display(context, self.bounds.size, ^&#123;return NO;&#125;);</div><div class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">UIGraphicsEndImageContext();</div><div class="line">self.contents = (__bridge id)(image.CGImage);</div><div class="line">if (task.didDisplay) task.didDisplay(self, YES);</div></pre></td></tr></table></figure>
<p>而异步渲染的处理和同步渲染大同小异，第一，多了一个<code>BOOL (^isCancelled)()</code>block，这个block的好处是，在<code>display</code>block调用绘制前，可以通过判断<code>isCancelled</code>布尔值的值来停止绘制，减少性能上的消耗，以及避免出现线程阻塞的情况，比如TableView快速滑动的时候，就可以通过这样的判断，来避免不必要的绘制，提升滑动的流畅性，第二，将上面同步的绘制处理放到了异步去做，绘制方式是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">if (task.willDisplay) task.willDisplay(self);</div><div class="line">int32_t value = self.value;</div><div class="line">BOOL (^isCancelled)() = ^BOOL() &#123;</div><div class="line">    return value != self.value;</div><div class="line">&#125;;</div><div class="line">CGSize size = self.bounds.size;</div><div class="line">BOOL opaque = self.opaque;</div><div class="line">CGFloat scale = self.contentsScale;</div><div class="line">if (size.width &lt; 1 || size.height &lt; 1) &#123;</div><div class="line">    CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</div><div class="line">    self.contents = nil;</div><div class="line">    if (image) &#123;</div><div class="line">        dispatch_async(FIMAsyncLayerGetReleaseQueue(), ^&#123;</div><div class="line">            CFRelease(image);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dispatch_async(FIMAsyncLayerGetDisplayQueue(), ^&#123;</div><div class="line">    if (isCancelled()) return;</div><div class="line">    UIGraphicsBeginImageContextWithOptions(size, opaque, scale);</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    task.display(context, size, isCancelled);</div><div class="line">    if (isCancelled()) &#123;</div><div class="line">        UIGraphicsEndImageContext();</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">        &#125;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    if (isCancelled()) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">        &#125;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        if (isCancelled()) &#123;</div><div class="line">            if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">        &#125; else &#123;</div><div class="line">            self.contents = (__bridge id)(image.CGImage);</div><div class="line">            if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个异步的队列也是自己创建的，在预设了一个队列最大值之后，通过获取运行该进程的系统处于激活状态的处理器数量来创建队列，使得绘制的效率达到最高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static dispatch_queue_t FIMAsyncLayerGetDisplayQueue() &#123;</div><div class="line">#define MAX_QUEUE_COUNT 16</div><div class="line">    static int queueCount;</div><div class="line">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    static int32_t counter = 0;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</div><div class="line">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</div><div class="line">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</div><div class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</div><div class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</div><div class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.FIMkit.render&quot;, attr);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</div><div class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.FIMkit.render&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    int32_t cur = OSAtomicIncrement32(&amp;counter);</div><div class="line">    if (cur &lt; 0) cur = -cur;</div><div class="line">    return queues[(cur) % queueCount];</div><div class="line">#undef MAX_QUEUE_COUNT</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x03__u8865_u5145"><a href="#0x03__u8865_u5145" class="headerlink" title="0x03 补充"></a>0x03 补充</h2><p>在<code>文本</code>的实现上，我们更加推荐使用CoreText，CoreText对象占用的内存少，而且适用于文本排版复杂的情况，虽然在实现上较为复杂，但是所带来的好处远远要多</p>
<p>在渲染<code>图片</code>时，我们应该在后台把图片绘制到<code>CGBitmapContext</code>中，然后从<code>Bitmap</code>直接创建图片，因为如果使用原来ImageView读取Image的方式是，在创建Image或者CGImageSource对象时，图片数据并不会立即解码，而是等到设置到ImageView或者layer.contents，layer被提交到GPU之前，才解码，并且这些操作都是在主线程进行，是相当耗性能的，所以我们应该用推荐的方式去绘制，而且AFNetworking在对图片处理的时候也是这么做的</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFURLResponseSerializationImage.png" alt=""></p>
<h2 id="0x04__u7B80_u5355_u5B9E_u73B0demo"><a href="#0x04__u7B80_u5355_u5B9E_u73B0demo" class="headerlink" title="0x04 简单实现demo"></a>0x04 简单实现demo</h2><p>对于上述优化点，我实现了一个简单的<a href="https://github.com/Yuzeyang/GCAsyncDisplayDemo" target="_blank" rel="external">CoreText demo</a>，可以看一下这个demo做进一步了解~</p>
<h2 id="0x05__u76F8_u5173_u63A8_u8350_u9605_u8BFB"><a href="#0x05__u76F8_u5173_u63A8_u8350_u9605_u8BFB" class="headerlink" title="0x05 相关推荐阅读"></a>0x05 相关推荐阅读</h2><p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=27&amp;uin=MjI5NjY4NTU%3D&amp;key=7b81aac53bd2393d5c4f70d3d589ce1750179035ed3e4fc89454779d85881a9acd97a28bef1484ddbcfcd3250861abc7&amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.11.6+build(15G31" target="_blank" rel="external">iOS 事件处理机制与图像渲染过程</a>&amp;version=12000110&amp;lang=zh_CN&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=JE1V0DIEopWtscTKwaYEiHN6qmvNRu9O60t4vUkn3Ek%3D)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重构完Socket之后，最近我们也开始针对IM的UI做了优化，这次的优化我们主要是参考了&lt;a href=&quot;https://github.com/ibireme/YYKit&quot;&gt;YYKit&lt;/a&gt;对于性能方面的优化，前期我的另一个小伙伴&lt;a href=&quot;http://broccoliii.me/&quot;&gt;西兰花&lt;/a&gt;也对&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit&quot;&gt;AsyncDisplayKit&lt;/a&gt;做了调研，不过这个库理解起来确实要费一番功夫，由于YYkit的核心思路基本上都是学习AsyncDisplayKit的，相信YYkit这个库大家都已经很熟悉了，不过可能还没有看过这个库，那下面我做一个简单的介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="IM 异步绘制" scheme="http://yuzeyang.github.io/tags/IM-%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS Socket重构设计</title>
    <link href="http://yuzeyang.github.io/2016/06/22/GCDAsyncSocket-socket-optimize/"/>
    <id>http://yuzeyang.github.io/2016/06/22/GCDAsyncSocket-socket-optimize/</id>
    <published>2016-06-22T15:02:22.000Z</published>
    <updated>2016-06-23T08:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前基于GCDAsyncSocket封装了一个Socket Manager类，但是由于业务复杂度的上升，之前设计的业务接口的数量逐渐增加，代理回调也随之增加，代理的使用也越来越麻烦，所以我们针对socket通信这块，进行了一次重构</p>
<p>这里有我们的新童鞋<a href="http://broccoliii.me/" target="_blank" rel="external">西兰花</a>很大的功劳哈~</p>
<p>代码地址：<a href="https://github.com/Yuzeyang/GCDAsyncSocketManager" target="_blank" rel="external">GCDAsyncSocketManager</a></p>
<a id="more"></a>
<p>之前的设计方案可以看这里：<a href="http://zeeyang.com/2016/01/17/GCDAsyncSocket-socket/" target="_blank" rel="external">socket重构前方案</a></p>
<p>针对老的设计，我们做出了以下几点修改方向：</p>
<h2 id="0x00__u62C6_u5206SocketManager"><a href="#0x00__u62C6_u5206SocketManager" class="headerlink" title="0x00 拆分SocketManager"></a>0x00 拆分SocketManager</h2><p>首先我们对SocketManager进行开刀，我们将socket相关的操作和业务相关的操作进行拆分，将业务相关的单独放到一个类里面完成，我们命名它为CommunicationManager</p>
<p>现在在SocketManager里面，我们只保留了<code>服务器读写数据</code>、<code>断开连接</code>、<code>心跳</code>、<code>重连</code>、<code>GCDAsyncSocket回调设置</code></p>
<p>在CommunicationManager里面，我们做所有业务的操作</p>
<h2 id="0x01__u4E1A_u52A1_u63A5_u53E3_u6539_u4E3A_u901A_u7528_u63A5_u53E3"><a href="#0x01__u4E1A_u52A1_u63A5_u53E3_u6539_u4E3A_u901A_u7528_u63A5_u53E3" class="headerlink" title="0x01 业务接口改为通用接口"></a>0x01 业务接口改为通用接口</h2><p>由于业务请求类型的不断增加，业务接口的数量也在不断增加，这样使得头文件一眼望不到底…自己看起来都很头疼，更别说是使用方了…</p>
<p>首先我们将不同的业务请求以枚举的方式列出来，方便外部调用的时候查看，并且最好在枚举后面加上注释，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  业务类型</div><div class="line"> */</div><div class="line">typedef NS_ENUM(NSInteger, FIMRequestType) &#123;</div><div class="line">    FIMRequestType_Beat = 1,                       //心跳</div><div class="line">    FIMRequestType_ConnectionAuthAppraisal,        //连接鉴权</div><div class="line">  	FIMRequestType_GetConversationsList,           //获取会话列表</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样我们就可以将业务接口用下面这一个通用的接口替换掉，只需要传<code>type</code>业务请求类型，<code>body</code>请求体和<code>callback</code>回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  向服务器发送数据</div><div class="line"> *</div><div class="line"> *  @param type    请求类型</div><div class="line"> *  @param body    请求体</div><div class="line"> */</div><div class="line">- (void)socketWriteDataWithRequestType:(FIMRequestType)type</div><div class="line">                           requestBody:(nonnull NSDictionary *)body</div><div class="line">                            completion:(nullable SocketDidReadBlock)callback;</div></pre></td></tr></table></figure>
<p>比如业务方可以如下使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSDictionary *requestBody = @&#123; @&quot;limit&quot;: @(10), @&quot;offset&quot;: @(0) &#125;;</div><div class="line">[[FIMCommunicationManager sharedInstance]</div><div class="line">socketWriteDataWithRequestType:FIMRequestType_GetConversationsList</div><div class="line">                   requestBody:requestBody</div><div class="line">                    completion:^(NSError *error, id data) &#123;</div><div class="line">                        // do something</div><div class="line">                    &#125;];</div></pre></td></tr></table></figure>
<h2 id="0x02__u544A_u522BDelegate_uFF0C_u4F7F_u7528Blcok"><a href="#0x02__u544A_u522BDelegate_uFF0C_u4F7F_u7528Blcok" class="headerlink" title="0x02 告别Delegate，使用Blcok"></a>0x02 告别Delegate，使用Blcok</h2><p>前面也提到，之前会对不同的业务请求，设定相应的delegate回调，但是数量一多，使用起来那真的是槽糕，所以我们参考<code>AFNetworking</code>的做法，发起请求时将block与一个唯一标识进行绑定，同时将这个唯一标识放到请求里面发给服务器（服务器对该标识不做任何处理），在等到GCDAsyncSocket回调回来的时候，我们通过服务器返回的这个标识，找到对应的block回调出去，这样对业务方来说，这个socket接口用起来其实和HTTP请求接口是一模一样的，将请求的上下文也关联起来了</p>
<p>如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/replaceDelegate.png" alt=""></p>
<p>具体实现：</p>
<p>发起请求时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)socketWriteDataWithRequestType:(FIMRequestType)type</div><div class="line">                           requestBody:(nonnull NSDictionary *)body</div><div class="line">                            completion:(nullable SocketDidReadBlock)callback &#123;</div><div class="line">  // ...                            </div><div class="line">   </div><div class="line">  // 生成唯一标识</div><div class="line">  NSString *blockRequestID = [self createRequestID];</div><div class="line">  if (callback) &#123;</div><div class="line">      // 将block和标识进行绑定，存到一个全局变量里面</div><div class="line">      [self.requestsMap setObject:callback forKey:blockRequestID];</div><div class="line">  &#125;</div><div class="line">                              </div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接收到GCDAsyncSocket回调时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &#123;</div><div class="line">  // ...</div><div class="line">  </div><div class="line">  // 根据服务器返回的标识得到相应的block</div><div class="line">  SocketDidReadBlock didReadBlock = self.requestsMap[requestID];</div><div class="line">  </div><div class="line">  switch (requestType) &#123;</div><div class="line">        case FIMRequestType_ConnectionAuthAppraisal: &#123;</div><div class="line">            if (didReadBlock) &#123;</div><div class="line">                didReadBlock(nil, nil);</div><div class="line">            &#125;</div><div class="line">        &#125; break;</div><div class="line">    	// ...</div><div class="line">    	default: &#123;</div><div class="line">            // do something</div><div class="line">        &#125; break;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x03__u4F7F_u7528_u6A21_u62DF_u670D_u52A1_u5668_u65F6_u95F4_uFF0C_u6765_u89E3_u51B3_u7F13_u5B58_u6D88_u606F_u4FDD_u5E8F_u95EE_u9898"><a href="#0x03__u4F7F_u7528_u6A21_u62DF_u670D_u52A1_u5668_u65F6_u95F4_uFF0C_u6765_u89E3_u51B3_u7F13_u5B58_u6D88_u606F_u4FDD_u5E8F_u95EE_u9898" class="headerlink" title="0x03 使用模拟服务器时间，来解决缓存消息保序问题"></a>0x03 使用模拟服务器时间，来解决缓存消息保序问题</h2><p>在socket模块里面，我们基于FMDB实现了一套缓存机制，但是聊天页面对数据库读写操作的场景非常复杂，而且我们对发送失败的消息也进行了缓存，如果使用msgID对消息进行保序，你要考虑发送成功和失败消息的排序，以及重发消息之后的排序，等等场景，这样实现起来也会很让人头大</p>
<p>所以我们采用<code>消息的创建时间</code>来进行保序，这样不管消息是怎么操作的，从数据库里面读出来的数据，我们只需要根据创建时间来排下序返回给业务层，如果业务层对数据进行修改的时候，我们更新消息的创建时间，这样下次取出来的顺序和UI展示的顺序也还是一样的</p>
<p>那这个创建时间是由服务器生成的，而且消息发送成功之后，服务器也不会返回给我们这条消息的创建时间，而且失败的消息服务器那边是不会存的，所以就需要我们本地模拟服务器来生成这个时间</p>
<p>因为考虑到本地时间和服务器时间存在偏差，所以我们在socket建立连接成功之后，返回给我们服务器时间，我们拿到服务器时间之后和手机的本地时间做个比较，记录下这个偏差值，然后业务层在调用发送消息的接口时，socket内部模拟出服务器创建时间赋值给该消息，然后存到数据库里面，这样就可以基本保证数据库存储消息的顺序和服务器的顺序是一致的</p>
<p>如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/serverCreateTime.png" alt=""></p>
<h2 id="0x04__u76D1_u542C_u7F51_u7EDC_u72B6_u6001_u6765_u6539_u53D8socket_u8FDE_u63A5_u72B6_u6001"><a href="#0x04__u76D1_u542C_u7F51_u7EDC_u72B6_u6001_u6765_u6539_u53D8socket_u8FDE_u63A5_u72B6_u6001" class="headerlink" title="0x04 监听网络状态来改变socket连接状态"></a>0x04 监听网络状态来改变socket连接状态</h2><p>我们对socket连接状态也做了微调，我们通过测试微信的连接，发现以下两点：</p>
<p>1、网络断开后，socket直接断开，显示“未连接”</p>
<p>2、有网但是socket连接不上时，socket会一直重连，重连n次后，休眠几秒后，再重连，如此循环</p>
<p>所以我们也对socket连接做了调整，用<code>AFNetWorking</code>库里面监测网络状态类<code>AFNetworkReachabilityManager</code>（<a href="http://zeeyang.com/2016/05/23/AFNetWorking-four/" target="_blank" rel="external">AFNetworkReachabilityManager原理</a>），在无网时，判断如果socket正在连接或者已连接时，我们主动调用<code>disconnect</code>断开连接，如果有网，判断如果socket未连接，我们主动建立连接，建立连接不成功的情况时，我们走重连的流程，只是我们依旧保持了重连n次后，n次失败后不再重连了，这个是与微信不同的地方</p>
<h2 id="0x05__u4F7F_u7528FIMSocketModel"><a href="#0x05__u4F7F_u7528FIMSocketModel" class="headerlink" title="0x05 使用FIMSocketModel"></a>0x05 使用FIMSocketModel</h2><p>因为请求的数据结构基本一样，所以我们定义了FIMSocketModel类来方便对数据的转化，我们定义了几个必传的字段，以及可能请求不同所需的一些非必传字段，由于之前我们body体里面的内容是做了2次JSON转化处理的，所以业务层传入body内容时叫苦连天，FIMSocketModel也增加了<code>- socketModelToJSONString</code>方法，方便Socket内部转化成JSON处理，这样业务层只需要传一个字典进来，Socket内部就会处理好一切，使用起来一下就方便了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前基于GCDAsyncSocket封装了一个Socket Manager类，但是由于业务复杂度的上升，之前设计的业务接口的数量逐渐增加，代理回调也随之增加，代理的使用也越来越麻烦，所以我们针对socket通信这块，进行了一次重构&lt;/p&gt;
&lt;p&gt;这里有我们的新童鞋&lt;a href=&quot;http://broccoliii.me/&quot;&gt;西兰花&lt;/a&gt;很大的功劳哈~&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCDAsyncSocketManager&quot;&gt;GCDAsyncSocketManager&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Socket" scheme="http://yuzeyang.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>客户端生成七牛上传token</title>
    <link href="http://yuzeyang.github.io/2016/06/13/Qiniu-token/"/>
    <id>http://yuzeyang.github.io/2016/06/13/Qiniu-token/</id>
    <published>2016-06-13T15:07:54.000Z</published>
    <updated>2016-06-13T16:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用七牛iOS SDK上传图片时需要用到上传的token，虽然七牛建议token不要在客户端生成，这样做是不安全的，但是我们还是需要了解下客户端是如何生成token的</p>
<a id="more"></a>
<p>我简单地对生成token和上传数据做了封装，这是代码地址：<a href="https://github.com/Yuzeyang/GCQiniuUploadManager" target="_blank" rel="external">provide simple interface to create token,upload file and upload files</a></p>
<p>首先我们需要用到三个参数<code>scope</code>、<code>AccessKey</code>和<code>SecretKey</code></p>
<p><code>scope</code>其实就是资源存放的文件夹名字，例如下图的<code>cmxj</code></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Qiniu_scope.png" alt=""></p>
<p><code>AccessKey</code>和<code>SecretKey</code>在个人面板 -&gt; 个人中心 -&gt; 密钥管理里面就能看到</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Qiniu_AK_SK.png" alt=""></p>
<p>接下来就可以创建token了，首先我们将上传策略中的<code>scope</code>和<code>deadline</code>序列化成json格式，里面的<code>liveTime</code>则是token的有效时间，可以以天为单位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary *authInfo = [NSMutableDictionary dictionary];</div><div class="line">[authInfo setObject:self.scope forKey:@&quot;scope&quot;];</div><div class="line">[authInfo</div><div class="line">setObject:[NSNumber numberWithLong:[[NSDate date] timeIntervalSince1970] + self.liveTime * 24 * 3600]</div><div class="line">   forKey:@&quot;deadline&quot;];</div><div class="line"></div><div class="line">NSData *jsonData =</div><div class="line">[NSJSONSerialization dataWithJSONObject:authInfo options:NSJSONWritingPrettyPrinted error:nil];</div></pre></td></tr></table></figure>
<p>再对json序列化后的上传策略进行URL安全的base64编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *encodedString = [self urlSafeBase64Encode:jsonData];</div></pre></td></tr></table></figure>
<p><code>QN_GTM_Base64</code>是七牛SDK提供给用户用来处理base64和WebSafeBase64编码的类，然后将里面的<code>+</code>和<code>/</code>替换成<code>_</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSString *)urlSafeBase64Encode:(NSData *)text &#123;</div><div class="line">    NSString *base64 =</div><div class="line">    [[NSString alloc] initWithData:[QN_GTM_Base64 encodeData:text] encoding:NSUTF8StringEncoding];</div><div class="line">    base64 = [base64 stringByReplacingOccurrencesOfString:@&quot;+&quot; withString:@&quot;-&quot;];</div><div class="line">    base64 = [base64 stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;_&quot;];</div><div class="line">    return base64;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后用secretKey对编码后的上传策略进行HMAC-SHA1加密，并且做安全的base64编码，得到encoded_signed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *encodedSignedString = [self HMACSHA1:self.secretKey text:encodedString];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (NSString *)HMACSHA1:(NSString *)key text:(NSString *)text &#123;</div><div class="line">    const char *cKey = [key cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    const char *cData = [text cStringUsingEncoding:NSUTF8StringEncoding];</div><div class="line"></div><div class="line">    char cHMAC[CC_SHA1_DIGEST_LENGTH];</div><div class="line"></div><div class="line">    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), cData, strlen(cData), cHMAC);</div><div class="line"></div><div class="line">    NSData *HMAC = [[NSData alloc] initWithBytes:cHMAC length:CC_SHA1_DIGEST_LENGTH];</div><div class="line">    NSString *hash = [self urlSafeBase64Encode:HMAC];</div><div class="line">    return hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后将accessKey、encodedSignedString和encodedString拼接，中间用：分开，得到的就是上传的token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *token =</div><div class="line">    [NSString stringWithFormat:@&quot;%@:%@:%@&quot;, self.accessKey, encodedSignedString, encodedString];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用七牛iOS SDK上传图片时需要用到上传的token，虽然七牛建议token不要在客户端生成，这样做是不安全的，但是我们还是需要了解下客户端是如何生成token的&lt;/p&gt;
    
    </summary>
    
    
      <category term="七牛 token" scheme="http://yuzeyang.github.io/tags/%E4%B8%83%E7%89%9B-token/"/>
    
  </entry>
  
  <entry>
    <title>模仿iOS7 task switcher的卡片动画</title>
    <link href="http://yuzeyang.github.io/2016/06/11/iOS-card-animation/"/>
    <id>http://yuzeyang.github.io/2016/06/11/iOS-card-animation/</id>
    <published>2016-06-11T02:20:29.000Z</published>
    <updated>2016-06-11T09:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一个iOS9的task switcher开源实现，但是没有删除功能，就想着干脆做一个模仿iOS7系统的效果，加上删除和重用卡片功能，效果图如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCCardViewController.gif!500x500" alt=""></p>
<p>这是代码地址：<a href="https://github.com/Yuzeyang/GCCardViewController" target="_blank" rel="external">https://github.com/Yuzeyang/GCCardViewController</a></p>
<a id="more"></a>
<p>实现上可以使用scrollView或者collectionView去做，这个我是用scrollView去做</p>
<p>功能点上分为三点：</p>
<p>1.卡片滑动的效果</p>
<p>2.卡片重用</p>
<p>3.卡片删除</p>
<h2 id="u5361_u7247_u6ED1_u52A8_u6548_u679C"><a href="#u5361_u7247_u6ED1_u52A8_u6548_u679C" class="headerlink" title="卡片滑动效果"></a>卡片滑动效果</h2><p>通过- [scrollViewDidScroll:]代理获取scrollView滑动时的contentOffset值，计算当前contentOffset和原先contentOffset之间的差值diff，再算出进度值progress，以及根据差值diff是否大于0来获取卡片的滑动方向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</div><div class="line">    CGFloat orginContentOffset = self.currentCardIndex*kGCScrollViewWidth;</div><div class="line">    CGFloat diff = scrollView.contentOffset.x - orginContentOffset;</div><div class="line">    CGFloat progress = fabs(diff)/(kGCViewWidth*0.8);</div><div class="line">    CardMoveDirection direction = diff &gt; 0 ? CardMoveDirectionLeft : CardMoveDirectionRight;</div><div class="line">    for (UIView *card in self.cards) &#123;</div><div class="line">        [self.cardDelegate updateCard:card withProgress:progress direction:direction];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 卡片重用</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用自己的cardDelegate方法更新卡片的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)updateCard:(UIView *)card withProgress:(CGFloat)progress direction:(CardMoveDirection)direction;</div></pre></td></tr></table></figure>
<p>当前卡片不管是左移还是右移，只需要根据progress来更新状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">card.layer.transform = CATransform3DMakeScale(1 - 0.1 * progress, 1 - 0.1 * progress, 1.0);</div><div class="line">card.layer.opacity = 1 - 0.2*progress;</div></pre></td></tr></table></figure>
<p>根据左移还是右移，来决定改变当前卡片下一张还是上一张卡片的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSInteger transCardTag = direction == CardMoveDirectionLeft ? [self.cardScrollView currentCard] + 1 : [self.cardScrollView currentCard] - 1;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">card.layer.transform = CATransform3DMakeScale(0.9 + 0.1*progress, 0.9 + 0.1*progress, 1.0);</div><div class="line">card.layer.opacity = 0.8 + 0.2*progress;</div></pre></td></tr></table></figure>
<h2 id="u5361_u7247_u91CD_u7528"><a href="#u5361_u7247_u91CD_u7528" class="headerlink" title="卡片重用"></a>卡片重用</h2><p>由于页面上只显示三张卡片，所以要重用卡片的话，我们需要初始化四张卡片，类似于tableViewCell的重用处理一样，当第一张卡片离开屏幕显示之后，将第一张卡片移到最后一张卡片的后面，反之，同理</p>
<p>在- [scrollViewDidScroll:]里面，根据contentOffset变化的绝对值大于scrollView宽度的80%时，对卡片进行重用，以及改变当前的index</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (fabs(diff) &gt;= kGCScrollViewWidth*0.8) &#123;</div><div class="line">        self.currentCardIndex = direction == CardMoveDirectionLeft ? self.currentCardIndex + 1 : self.currentCardIndex - 1;</div><div class="line">        [self reuseCardWithMoveDirection:direction];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在重用之前，并不是所有位置都需要重用，在index（index从0开始计算）小于2或者index大于总卡片数量-3的时候，才需要重用，左移时，取出cards数组里面第一个card，将card移到最后一个card后面，改变它的center就可以，右移时，取出最后一个card，移到第一个card前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)reuseCardWithMoveDirection:(CardMoveDirection)moveDirection &#123;</div><div class="line">    BOOL isLeft = moveDirection == CardMoveDirectionLeft;</div><div class="line">    UIView *card = nil;</div><div class="line">    if (isLeft) &#123;</div><div class="line">        if (self.currentCardIndex &gt; self.totalNumberOfCards - 3 || self.currentCardIndex &lt; 2) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        card = [self.cards objectAtIndex:0];</div><div class="line">        card.tag+=4;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (self.currentCardIndex &gt; self.totalNumberOfCards - 4 ||</div><div class="line">            self.currentCardIndex &lt; 1) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        card = [self.cards objectAtIndex:3];</div><div class="line">        card.tag-=4;</div><div class="line">    &#125;</div><div class="line">    card.center = [self centerForCardWithIndex:card.tag];</div><div class="line">    [self.cardDataSource cardReuseView:card atIndex:card.tag];</div><div class="line">    [self ascendingSortCards];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且调用- [cardReuseView:atIndex:]对重用的卡片改变数据源，最后按tag值升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (UIView *)cardReuseView:(UIView *)reuseView atIndex:(NSInteger)index &#123;</div><div class="line">    if (reuseView) &#123;</div><div class="line">        // you can set new style</div><div class="line">        return reuseView;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIView *card = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kGCCardWidth * 0.9, kGCCardHeight)];</div><div class="line">    card.layer.backgroundColor = [UIColor whiteColor].CGColor;</div><div class="line">    card.layer.cornerRadius = 4;</div><div class="line">    card.layer.masksToBounds = YES;</div><div class="line">    </div><div class="line">    return card;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="u5361_u7247_u5220_u9664"><a href="#u5361_u7247_u5220_u9664" class="headerlink" title="卡片删除"></a>卡片删除</h2><p>卡片删除是一个可选功能，通过设置canDeleteCard来添加手势</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, assign) BOOL canDeleteCard;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (self.canDeleteCard) &#123;</div><div class="line">    UIPanGestureRecognizer *deleteGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(deleteCard:)];</div><div class="line">    deleteGesture.minimumNumberOfTouches = 1;</div><div class="line">    deleteGesture.maximumNumberOfTouches = 1;</div><div class="line">    deleteGesture.delegate = self;</div><div class="line">    [card addGestureRecognizer:deleteGesture];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于卡片有拖动手势和scrollView也有拖动手势，这两个手势会出现冲突，所以我们需要根据手势的方向来判断到底应该是作用于卡片上还是scrollView上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123;</div><div class="line">    if ([gestureRecognizer isKindOfClass:[UIPanGestureRecognizer class]]) &#123;</div><div class="line">        CGPoint translatedPoint = [(UIPanGestureRecognizer *)gestureRecognizer translationInView:gestureRecognizer.view];</div><div class="line">        if (fabs(translatedPoint.y) &gt; fabs(translatedPoint.x)) &#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用卡片删除手势时，向下拖动时不做删除，向上拖动屏幕高度的一半后，删除卡片，并且重用删除后的卡片，这部分重用相对比较复杂</p>
<h5 id="u5F53_u5361_u7247_u5C0F_u4E8E_u7B49_u4E8E_u56DB_u5F20_u65F6_uFF0C_u6211_u4EEC_u76F4_u63A5_u79FB_u9664_u5F53_u524D_u7684_u5361_u7247"><a href="#u5F53_u5361_u7247_u5C0F_u4E8E_u7B49_u4E8E_u56DB_u5F20_u65F6_uFF0C_u6211_u4EEC_u76F4_u63A5_u79FB_u9664_u5F53_u524D_u7684_u5361_u7247" class="headerlink" title="当卡片小于等于四张时，我们直接移除当前的卡片"></a>当卡片小于等于四张时，我们直接移除当前的卡片</h5><p>-&gt; 如果当前卡片index为0时 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>-&gt; 如果当前卡片index为最后一张时 -&gt; 左边的卡片右移 -&gt; 左边卡片的tag不变</p>
<p>-&gt; 如果当前卡片index为中间时 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>最后按升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (self.totalNumberOfCards &lt;= 4) &#123;</div><div class="line">    [(UIView *)[self.cards objectAtIndex:index] removeFromSuperview];</div><div class="line">    [self resetTagFromIndex:index];</div><div class="line">    [self.cards removeObjectAtIndex:index];</div><div class="line">    [self ascendingSortCards];</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)resetTagFromIndex:(NSInteger)index &#123;</div><div class="line">    [self.cards enumerateObjectsUsingBlock:^(UIView *card, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        if ((NSInteger)idx &gt; index) &#123;</div><div class="line">            card.tag-=1;</div><div class="line">            [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">                card.center = [self centerForCardWithIndex:card.tag];</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当卡片超过四张时，我们需要重用删除的卡片</p>
<p>-&gt; 如果当前卡片index为0时 -&gt; 卡片的tag值加4 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>-&gt; 如果当前卡片index为最后一张时 -&gt; 卡片的tag值减4 -&gt; 左边的卡片右移 -&gt; 左边卡片的tag不变</p>
<p>-&gt; 如果当前卡片index为中间时 -&gt; 以四个卡片为一组，获取第一个卡片和最后一个卡片的tag值 -&gt; 判读最后一个卡片是否是最后一张卡片 -&gt; 如果是，则将卡片移到第一张卡片的左边，如果不是，则将卡片移到最后一张卡片的右边 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>最后按升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">UIView *card = [self.cards objectAtIndex:index];</div><div class="line">NSInteger fromIndex = index;</div><div class="line">if (index == 0) &#123;</div><div class="line">    card.tag+=4;</div><div class="line">    fromIndex = index - 1;</div><div class="line">&#125; else if (index == 3) &#123;</div><div class="line">    card.tag-=4;</div><div class="line">&#125; else &#123;</div><div class="line">    NSInteger lastTag = ((UIView *)[self.cards lastObject]).tag;</div><div class="line">    NSInteger firstTag = ((UIView *)[self.cards firstObject]).tag;</div><div class="line">    if (lastTag == self.totalNumberOfCards - 1) &#123;</div><div class="line">        card.tag = firstTag - 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        card.tag = lastTag + 1;</div><div class="line">        fromIndex = index - 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">card.center = [self centerForCardWithIndex:card.tag];</div><div class="line">[self ascendingSortCards];</div><div class="line">[self resetTagFromIndex:fromIndex];</div><div class="line">[self.cardDataSource cardReuseView:card atIndex:card.tag];</div></pre></td></tr></table></figure>
<p>最后只要改变scrollView的contentSize和卡片状态即可~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">    [self.scrollView setContentSize:CGSizeMake(kGCScrollViewWidth*self.totalNumberOfCards, kGCViewHeight)];</div><div class="line">    for (UIView *card in self.cards) &#123;</div><div class="line">        [self.cardDelegate updateCard:card withProgress:1 direction:CardMoveDirectionNone];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到一个iOS9的task switcher开源实现，但是没有删除功能，就想着干脆做一个模仿iOS7系统的效果，加上删除和重用卡片功能，效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCCardViewController.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCCardViewController&quot;&gt;https://github.com/Yuzeyang/GCCardViewController&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="task switcher" scheme="http://yuzeyang.github.io/tags/task-switcher/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（六）</title>
    <link href="http://yuzeyang.github.io/2016/05/27/AFNetWorking-six/"/>
    <id>http://yuzeyang.github.io/2016/05/27/AFNetWorking-six/</id>
    <published>2016-05-27T01:44:43.000Z</published>
    <updated>2016-06-12T15:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFURLResponseSerialization</code>是用来将返回的response处理成相应的格式，它通过协议对特定response的data进行解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response</div><div class="line">                           data:(nullable NSData *)data</div><div class="line">                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>AFHTTPResponseSerializer</code>可以通过<code>+ serializer</code>和<code>- init</code>方法进行初始化，实际上<code>+ serializer</code>内只是调用了<code>- init</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)serializer &#123;</div><div class="line">    return [[self alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">	// 设置字符串编码类型，可接受的状态码，可接受的MIME类型</div><div class="line">    self.stringEncoding = NSUTF8StringEncoding;</div><div class="line">	self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];</div><div class="line">    self.acceptableContentTypes = nil;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>acceptableStatusCodes和acceptableContentTypes可以通过外部进行设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy, nullable) NSIndexSet *acceptableStatusCodes;</div><div class="line">@property (nonatomic, copy, nullable) NSSet &lt;NSString *&gt; *acceptableContentTypes;</div></pre></td></tr></table></figure>
<p>然后可以调用<code>- [validateResponse:data:error:]</code>检查这个response是否包含可接受的状态码和可接受MIME类型来验证response的有效性，子类也可以增加特定域名检查，<code>- [responseObjectForResponse:data:error]</code>也是调用了这个方法，返回data</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    // 调用- [validateResponse:data:error:]方法，返回data </div><div class="line">    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];</div><div class="line"></div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</div><div class="line">                    data:(NSData *)data</div><div class="line">                   error:(NSError * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    // 设置初始值</div><div class="line">    BOOL responseIsValid = YES;</div><div class="line">    NSError *validationError = nil;</div><div class="line"></div><div class="line">    // 检查这个response是否包含可接受的状态码和可接受MIME类型</div><div class="line"></div><div class="line">    if (error &amp;&amp; !responseIsValid) &#123;</div><div class="line">        *error = validationError;</div><div class="line">    &#125;</div><div class="line">    // 返回response是否有效性</div><div class="line">    return responseIsValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查这个response是否包含可接受的状态码和可接受MIME类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// 检查response是否为空，以及response是否是NSHTTPURLResponse类</div><div class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</div><div class="line">        // acceptableContentTypes不为空并且response的MIME类型不在可接受的范围里</div><div class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]]) &#123;</div><div class="line">            </div><div class="line">            // 包装错误信息</div><div class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</div><div class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</div><div class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                                        &#125; mutableCopy];</div><div class="line">                if (data) &#123;</div><div class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line">        // acceptableStatusCodes不为空并且acceptableStatusCodes包含response的状态码，response的URL也存在</div><div class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</div><div class="line">            // 包装错误信息</div><div class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</div><div class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                       &#125; mutableCopy];</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>但是这里有个疑问，假如response为nil或者response不是<code>NSHTTPURLResponse</code>类，那下面的操作均不会对responseIsValid布尔值进行修改，最后返回的是个YES，但是这样的response不应该是NO么？</p>
<hr>
<p><code>AFJSONResponseSerializer</code>是继承于<code>AFHTTPResponseSerializer</code></p>
<p>外部可以设置<code>NSJSONReadingOptions</code>和是否移除空值的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, assign) NSJSONReadingOptions readingOptions;</div><div class="line">@property (nonatomic, assign) BOOL removesKeysWithNullValues;</div></pre></td></tr></table></figure>
<p>转换object的时候，会检查data是否是空格，这个是Safari的一个bug，具体请看<a href="https://github.com/rails/rails/issues/1742" target="_blank" rel="external">Workaround for behavior of Rails to return a single space for <code>head :ok</code> (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</div><div class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id responseObject = nil;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    // 判断是否是空格</div><div class="line">    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&quot; &quot; length:1]];</div><div class="line">    if (data.length &gt; 0 &amp;&amp; !isSpace) &#123;</div><div class="line">        responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];</div><div class="line">    &#125; else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    // 调用AFJSONObjectByRemovingKeysWithNullValues把空值的key都移除掉，返回object</div><div class="line">    if (self.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</div><div class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><code>AFXMLParserResponseSerializer</code>则是直接校验response后，用data初始化NSXMLParser对象并返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSHTTPURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</div><div class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [[NSXMLParser alloc] initWithData:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><code>AFPropertyListResponseSerializer</code>也是类似的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</div><div class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id responseObject;</div><div class="line">    NSError *serializationError = nil;</div><div class="line"></div><div class="line">    if (data) &#123;</div><div class="line">        responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&amp;serializationError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><code>AFImageResponseSerializer</code>在验证response之后，会根据设置是否自动解压automaticallyInflatesResponseImage布尔值，来对imageData按图片比例返回UIImage对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, assign) CGFloat imageScale;</div><div class="line">@property (nonatomic, assign) BOOL automaticallyInflatesResponseImage;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</div><div class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH</div><div class="line">    // iOS需要手动解压图片</div><div class="line">    if (self.automaticallyInflatesResponseImage) &#123;</div><div class="line">        return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);</div><div class="line">    &#125; else &#123;</div><div class="line">        return AFImageWithDataAtScale(data, self.imageScale);</div><div class="line">    &#125;</div><div class="line">#else</div><div class="line">    // MacOS可以直接使用NSBitmapImageRep来解压</div><div class="line">    NSBitmapImageRep *bitimage = [[NSBitmapImageRep alloc] initWithData:data];</div><div class="line">    NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize([bitimage pixelsWide], [bitimage pixelsHigh])];</div><div class="line">    [image addRepresentation:bitimage];</div><div class="line"></div><div class="line">    return image;</div><div class="line">#endif</div><div class="line"></div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不解压的话，就直接根据imageData和scale来创建Image，但是这有个疑问是，AF为什么要创建两次image，我觉得可以直接使用- [imageWithData:scale:]方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) &#123;</div><div class="line">    UIImage *image = [UIImage af_safeImageWithData:data];</div><div class="line">    if (image.images) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果用imageWithData转成UIImage对象后，由于网络图片PNG和JPG都是压缩格式，需要解压成bitmap后才能渲染到屏幕，这时会在主线程对图片进行解压操作，这是比较耗时的，可能还会对主线程造成阻塞，所以AF还提供了<code>AFInflatedImageFromResponseWithDataAtScale</code>方法，对PNG和JPG解压后，返回UIImage对象，这样避免了在主线程的解压操作，不会对主线程造成卡顿</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) &#123;</div><div class="line">    if (!data || [data length] == 0) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">	// 创建CGImageRef</div><div class="line">    CGImageRef imageRef = NULL;</div><div class="line">    // 用data创建CGDataProviderRef</div><div class="line">    CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);</div><div class="line"></div><div class="line">    if ([response.MIMEType isEqualToString:@&quot;image/png&quot;]) &#123;</div><div class="line">        imageRef = CGImageCreateWithPNGDataProvider(dataProvider,  NULL, true, kCGRenderingIntentDefault);</div><div class="line">    &#125; else if ([response.MIMEType isEqualToString:@&quot;image/jpeg&quot;]) &#123;</div><div class="line">        imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);</div><div class="line"></div><div class="line">        if (imageRef) &#123;</div><div class="line">            CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);</div><div class="line">            CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);</div><div class="line"></div><div class="line">            // 如果色彩空间是CMKY，CGImageCreateWithJPEGDataProvider是不会进行处理的，也就是不进行解压，将调用AFImageWithDataAtScale返回image</div><div class="line">            if (imageColorSpaceModel == kCGColorSpaceModelCMYK) &#123;</div><div class="line">                CGImageRelease(imageRef);</div><div class="line">                imageRef = NULL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CGDataProviderRelease(dataProvider);</div><div class="line">	// 不符合解压条件的，将调用AFImageWithDataAtScale返回image，但是这里如果符合解压条件的也会调用，以及下面会对超出大小的，直接返回image，这里我觉得应该统一对不符合条件的返回image，符合条件的就不需要调用AFImageWithDataAtScale</div><div class="line">    UIImage *image = AFImageWithDataAtScale(data, scale);</div><div class="line">    if (!imageRef) &#123;</div><div class="line">        if (image.images || !image) &#123;</div><div class="line">            return image;</div><div class="line">        &#125;</div><div class="line">		// 这里调用CGImageCreateCopy，只会对图形本身结构进行拷贝，底层的数据是不会拷贝的</div><div class="line">        imageRef = CGImageCreateCopy([image CGImage]);</div><div class="line">        if (!imageRef) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	// 设置图片的宽和高和存储一个像素所需要用到的字节</div><div class="line">    size_t width = CGImageGetWidth(imageRef);</div><div class="line">    size_t height = CGImageGetHeight(imageRef);</div><div class="line">    size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);</div><div class="line">	// 如果图片大小宽高乘积超过1024*1024或者bitsPerComponent大于8都不解压了，因为bitmap是一直存在UIImage对象里的，可能会把内存爆了</div><div class="line">    if (width * height &gt; 1024 * 1024 || bitsPerComponent &gt; 8) &#123;</div><div class="line">        CGImageRelease(imageRef);</div><div class="line"></div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 画布参数</div><div class="line">    size_t bytesPerRow = 0;</div><div class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);</div><div class="line">    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);</div><div class="line"></div><div class="line">    if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;</div><div class="line">        uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;</div><div class="line">        if (alpha == kCGImageAlphaNone) &#123;</div><div class="line">            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</div><div class="line">            bitmapInfo |= kCGImageAlphaNoneSkipFirst;</div><div class="line">        &#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;</div><div class="line">            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</div><div class="line">            bitmapInfo |= kCGImageAlphaPremultipliedFirst;</div><div class="line">        &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">    &#125;</div><div class="line">	// 创建画布</div><div class="line">    CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);</div><div class="line"></div><div class="line">    CGColorSpaceRelease(colorSpace);</div><div class="line"></div><div class="line">    if (!context) &#123;</div><div class="line">        CGImageRelease(imageRef);</div><div class="line"></div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line">	// 在画布上画出图片</div><div class="line">    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);</div><div class="line">    // 保存成CGImageRef</div><div class="line">  	CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);</div><div class="line"></div><div class="line">    CGContextRelease(context);</div><div class="line">	// 再转成UIImage对象</div><div class="line">    UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];</div><div class="line"></div><div class="line">    CGImageRelease(inflatedImageRef);</div><div class="line">    CGImageRelease(imageRef);</div><div class="line"></div><div class="line">    return inflatedImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><code>AFCompoundResponseSerializer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    // 遍历responseSerializers                    </div><div class="line">    for (id &lt;AFURLResponseSerialization&gt; serializer in self.responseSerializers) &#123;</div><div class="line">        // 如果serializer不是AFHTTPResponseSerializer类，则继续</div><div class="line">      	if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        NSError *serializerError = nil;</div><div class="line">        // 一层一层的调用自己的- [responseObjectForResponse:data:error:]，直到返回responseObject</div><div class="line">        id responseObject = [serializer responseObjectForResponse:response data:data error:&amp;serializerError];</div><div class="line">        if (responseObject) &#123;</div><div class="line">            if (error) &#123;</div><div class="line">                *error = AFErrorWithUnderlyingError(serializerError, *error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return responseObject;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [super responseObjectForResponse:response data:data error:error];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFURLResponseSerialization&lt;/code&gt;是用来将返回的response处理成相应的格式，它通过协议对特定response的data进行解码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                           data:(nullable NSData *)data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（五）</title>
    <link href="http://yuzeyang.github.io/2016/05/25/AFNetWorking-five/"/>
    <id>http://yuzeyang.github.io/2016/05/25/AFNetWorking-five/</id>
    <published>2016-05-25T12:49:32.000Z</published>
    <updated>2016-06-12T15:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFURLRequestSerialization</code>是用来对发出的请求进行一些处理</p>
<a id="more"></a>
<p><code>AFPercentEscapedStringFromString</code>方法将string里面的:#[]@!$&amp;’()*+,;=字符替换成%</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">NSString * AFPercentEscapedStringFromString(NSString *string) &#123;</div><div class="line">  	static NSString * const kAFCharactersGeneralDelimitersToEncode = @&quot;:#[]@&quot;; // does not include &quot;?&quot; or &quot;/&quot; due to RFC 3986 - Section 3.4</div><div class="line">    static NSString * const kAFCharactersSubDelimitersToEncode = @&quot;!$&amp;&apos;()*+,;=&quot;;</div><div class="line">	</div><div class="line">  	// 从可用字符替换删除掉:#[]@!$&amp;&apos;()*+,;=这些字符</div><div class="line">    NSMutableCharacterSet * allowedCharacterSet = [[NSCharacterSet URLQueryAllowedCharacterSet] mutableCopy];</div><div class="line">    [allowedCharacterSet removeCharactersInString:[kAFCharactersGeneralDelimitersToEncode stringByAppendingString:kAFCharactersSubDelimitersToEncode]];</div><div class="line"></div><div class="line">	// FIXME: https://github.com/AFNetworking/AFNetworking/pull/3028</div><div class="line">    // return [string stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet];</div><div class="line">	</div><div class="line">  	// 声明批量处理的大小为50</div><div class="line">    static NSUInteger const batchSize = 50;</div><div class="line"></div><div class="line">    NSUInteger index = 0;</div><div class="line">    NSMutableString *escaped = @&quot;&quot;.mutableCopy;</div><div class="line">	</div><div class="line">  	// 循环将string里面:#[]@!$&amp;&apos;()*+,;=的字符替换成%</div><div class="line">    while (index &lt; string.length) &#123;</div><div class="line">#pragma GCC diagnostic push</div><div class="line">#pragma GCC diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">        NSUInteger length = MIN(string.length - index, batchSize);</div><div class="line">#pragma GCC diagnostic pop</div><div class="line">        NSRange range = NSMakeRange(index, length);</div><div class="line"></div><div class="line">        // To avoid breaking up character sequences such as 👴🏻👮🏽</div><div class="line">        range = [string rangeOfComposedCharacterSequencesForRange:range];</div><div class="line"></div><div class="line">        NSString *substring = [string substringWithRange:range];</div><div class="line">        NSString *encoded = [substring stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet];</div><div class="line">        [escaped appendString:encoded];</div><div class="line"></div><div class="line">        index += range.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	return escaped;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>AFQueryStringPair</code>类里面有个<code>- URLEncodedStringValue</code>方法，将请求里面的URL参数转成field=value形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSString *)URLEncodedStringValue &#123;</div><div class="line">    if (!self.value || [self.value isEqual:[NSNull null]]) &#123;</div><div class="line">        return AFPercentEscapedStringFromString([self.field description]);</div><div class="line">    &#125; else &#123;</div><div class="line">        return [NSString stringWithFormat:@&quot;%@=%@&quot;, AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字典里面是我们查询的key和value，我们通过将字典内容转成<code>AFQueryStringPair</code>对象，调用<code>- URLEncodedStringValue</code>方法，转成key=value，放到mutablePairs数组里，最后用&amp;符拼接起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123;</div><div class="line">    NSMutableArray *mutablePairs = [NSMutableArray array];</div><div class="line">    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</div><div class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123;</div><div class="line">    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];</div><div class="line"></div><div class="line">    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];</div><div class="line">	</div><div class="line">  	// 如果是字典，遍历后返回key[nestedKey]=nestedValue</div><div class="line">    if ([value isKindOfClass:[NSDictionary class]]) &#123;</div><div class="line">        NSDictionary *dictionary = value;</div><div class="line">        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</div><div class="line">        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</div><div class="line">            id nestedValue = dictionary[nestedKey];</div><div class="line">            if (nestedValue) &#123;</div><div class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; // 如果是数组，遍历后返回key[]=nestedValue</div><div class="line">  	else if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class="line">        NSArray *array = value;</div><div class="line">        for (id nestedValue in array) &#123;</div><div class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];</div><div class="line">        &#125;</div><div class="line">    &#125; // 如果是集合，遍历后返回key=obj</div><div class="line">  	else if ([value isKindOfClass:[NSSet class]]) &#123;</div><div class="line">        NSSet *set = value;</div><div class="line">        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</div><div class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</div><div class="line">        &#125;</div><div class="line">    &#125; // 其他返回key=value </div><div class="line">  	else &#123;</div><div class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableQueryStringComponents;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设传入的是，我将key,value放到数组里面，再放到mutableQueryStringComponents里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSSet *afSet = [NSSet setWithObjects:@(1),@(2), nil];</div><div class="line">NSDictionary *afDic = @&#123;@&quot;dickey&quot;: @&#123;@&quot;nestKey&quot;: @&quot;nestValue&quot;&#125;,</div><div class="line">                        @&quot;arrayKey&quot;: @[@[@(1)]],</div><div class="line">                        @&quot;setKey&quot;: afSet,</div><div class="line">                        @&quot;generalKey&quot;: @&quot;generalValue&quot;&#125;;</div><div class="line">NSArray *resultArray = AFQueryStringPairsFromKeyAndValue(nil, afDic);</div></pre></td></tr></table></figure>
<p>打印得到的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[arrayKey, 1],</div><div class="line"> [dickey[nestKey], nestValue],</div><div class="line"> [generalKey, generalValue],</div><div class="line"> [setKey, 1]，</div><div class="line"> [setKey,2]]</div></pre></td></tr></table></figure>
<p>我们使用<code>AFHTTPRequestSerializer</code>对HTTP请求的头部进行处理</p>
<p>首先调用<code>+ serializer</code>进行初始化，里面调用了自己init方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)serializer &#123;</div><div class="line">    return [[self alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>init里面先将Accept-Language存到mutableHTTPRequestHeaders里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 将mainBundle里面根据使用语言的优先顺序放到acceptLanguagesComponents里面，再用&quot;,&quot;分隔，存到mutableHTTPRequestHeaders字典里面</div><div class="line">  	NSMutableArray *acceptLanguagesComponents = [NSMutableArray array];</div><div class="line">    [[NSLocale preferredLanguages] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">        float q = 1.0f - (idx * 0.1f);</div><div class="line">        [acceptLanguagesComponents addObject:[NSString stringWithFormat:@&quot;%@;q=%0.1g&quot;, obj, q]];</div><div class="line">        *stop = q &lt;= 0.5f;</div><div class="line">    &#125;];</div><div class="line">    [self setValue:[acceptLanguagesComponents componentsJoinedByString:@&quot;, &quot;] forHTTPHeaderField:@&quot;Accept-Language&quot;];</div></pre></td></tr></table></figure>
<p>然后拼接User-Agent，格式为”%@/%@ (%@; iOS %@; Scale/%0.2f)”，里面需要5个参数，第一个参数先获取项目名，如果没有，就用BundleIdentifier，第二个参数先获取短版本号，如果没有就用版本号，第三个参数是当前设备的类型，第四个参数是当前设备的版本号，第五个参数是屏幕的比例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSString *userAgent = nil;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">#if TARGET_OS_IOS</div><div class="line">    userAgent = [NSString stringWithFormat:@&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleShortVersionString&quot;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];</div><div class="line">#elif TARGET_OS_WATCH</div><div class="line">    // ... </div><div class="line">#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)</div><div class="line">    // ...</div><div class="line">#endif</div><div class="line">#pragma clang diagnostic pop</div><div class="line">if (userAgent) &#123;</div><div class="line">        if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &#123;</div><div class="line">            NSMutableString *mutableUserAgent = [userAgent mutableCopy];</div><div class="line">            if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@&quot;Any-Latin; Latin-ASCII; [:^ASCII:] Remove&quot;, false)) &#123;</div><div class="line">                userAgent = mutableUserAgent;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        [self setValue:userAgent forHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后设置属性的监听，这些属性在头文件里面都可以找到，实现文件里面也实现了set方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">self.mutableObservedChangedKeyPaths = [NSMutableSet set];</div><div class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</div><div class="line">        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123;</div><div class="line">            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123;</div><div class="line">    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _AFHTTPRequestSerializerObservedKeyPaths;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过KVO判断是否是新值，如果是的话，就加到mutableObservedChangedKeyPaths里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(__unused id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context</div><div class="line">&#123;</div><div class="line">    if (context == AFHTTPRequestSerializerObserverContext) &#123;</div><div class="line">        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123;</div><div class="line">            [self.mutableObservedChangedKeyPaths removeObject:keyPath];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self.mutableObservedChangedKeyPaths addObject:keyPath];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置验证字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username</div><div class="line">                                       password:(NSString *)password</div><div class="line">&#123;</div><div class="line">    NSData *basicAuthCredentials = [[NSString stringWithFormat:@&quot;%@:%@&quot;, username, password] dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];</div><div class="line">    [self setValue:[NSString stringWithFormat:@&quot;Basic %@&quot;, base64AuthCredentials] forHTTPHeaderField:@&quot;Authorization&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化之后，需要调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</div><div class="line">                                 URLString:(NSString *)URLString</div><div class="line">                                parameters:(id)parameters</div><div class="line">                                     error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    // 断言                                     </div><div class="line">    NSParameterAssert(method);</div><div class="line">    NSParameterAssert(URLString);</div><div class="line">	</div><div class="line">    NSURL *url = [NSURL URLWithString:URLString];</div><div class="line"></div><div class="line">    NSParameterAssert(url);</div><div class="line">	// 根据url初始化request</div><div class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</div><div class="line">    // 设置HTTP方法                                   </div><div class="line">    mutableRequest.HTTPMethod = method;</div><div class="line">	// 根据mutableObservedChangedKeyPaths存储的属性，设置到mutableRequest</div><div class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</div><div class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</div><div class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	// 调用- [requestBySerializingRequest:withParameters:error]方法</div><div class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</div><div class="line"></div><div class="line">	return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    // 断言                                      </div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line">    // 根据HTTPRequestHeaders来设置mutableRequest的头部字段</div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">	</div><div class="line">    NSString *query = nil;</div><div class="line">    if (parameters) &#123;</div><div class="line">        if (self.queryStringSerialization) &#123;</div><div class="line">          	// 如果设置了queryStringSerialization这个block的话，就需要设置一个自定义的查询语句序列化方法，转成query查询参数</div><div class="line">            NSError *serializationError;</div><div class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                if (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">          	// 如果没有设置，则调用AFQueryStringFromParameters方法，转成query查询参数</div><div class="line">            switch (self.queryStringSerializationStyle) &#123;</div><div class="line">                case AFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    // 将拼接好的query语句放到 mutableRequest.URL或者放到                                    mutableRequest的HTTPBody里</div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        if (query) &#123;</div><div class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</div><div class="line">        if (!query) &#123;</div><div class="line">            query = @&quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的话，基本都是对多部分数据进行组装</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFURLRequestSerialization&lt;/code&gt;是用来对发出的请求进行一些处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（四）</title>
    <link href="http://yuzeyang.github.io/2016/05/23/AFNetWorking-four/"/>
    <id>http://yuzeyang.github.io/2016/05/23/AFNetWorking-four/</id>
    <published>2016-05-23T15:24:24.000Z</published>
    <updated>2016-06-21T08:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFNetworkReachabilityManager</code>是用来监测网络状态的类，可以通过设置状态改变回调来获得当前网络状态</p>
<a id="more"></a>
<p>网络的状态值有以下四种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;</div><div class="line">    AFNetworkReachabilityStatusUnknown          = -1,// 未知</div><div class="line">    AFNetworkReachabilityStatusNotReachable     = 0, // 不可用</div><div class="line">    AFNetworkReachabilityStatusReachableViaWWAN = 1, // 无线广域网连接</div><div class="line">    AFNetworkReachabilityStatusReachableViaWiFi = 2, // WiFi连接</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>AFNetworkReachabilityManager</code>提供了五种初始化的方法</p>
<p>可以通过单例方法初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager &#123;</div><div class="line">    static AFNetworkReachabilityManager *_sharedManager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        // 调用+ manager初始化方法</div><div class="line">        _sharedManager = [self manager];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _sharedManager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单例里面调用了第二种通过默认的socket地址初始化方法，返回一个manager对象，sin_family表示协议族，AF_INET表示TCP/IP协议族的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager</div><div class="line">&#123;</div><div class="line">#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</div><div class="line">    struct sockaddr_in6 address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin6_len = sizeof(address);</div><div class="line">    address.sin6_family = AF_INET6;</div><div class="line">#else</div><div class="line">    // 声明sockaddr_in结构体</div><div class="line">    struct sockaddr_in address;</div><div class="line">    // address清零</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    // address赋值</div><div class="line">    address.sin_len = sizeof(address);</div><div class="line">    address.sin_family = AF_INET;</div><div class="line">#endif</div><div class="line">    // 调用+ [managerForAddress:]方法 </div><div class="line">    return [self managerForAddress:&amp;address];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里又调用了第三种通过传入一个socket地址来初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)managerForAddress:(const void *)address &#123;</div><div class="line">    // 生成SCNetworkReachabilityRef</div><div class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);</div><div class="line">    // 调用- [initWithReachability:]方法</div><div class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</div><div class="line"></div><div class="line">    CFRelease(reachability);</div><div class="line">    </div><div class="line">    return manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面又调用了第五种初始化方法，因为该方法的后缀里面有<code>NS_DESIGNATED_INITIALIZER</code>，所以最终都会调到它，这里就是做了初始化的工作，将起始的网络状态定为Unknown</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _networkReachability = CFRetain(reachability);</div><div class="line">    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后剩下一种方法就是可以根据特定的域来初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)managerForDomain:(NSString *)domain &#123;</div><div class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);</div><div class="line"></div><div class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</div><div class="line">    </div><div class="line">    CFRelease(reachability);</div><div class="line"></div><div class="line">    return manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在初始化结束之后，我们需要设置网络状态改变的回调，在开启监听之后，会将网络状态回调给外部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)setReachabilityStatusChangeBlock:(void (^)(AFNetworkReachabilityStatus status))block &#123;</div><div class="line">    self.networkReachabilityStatusBlock = block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后就是开启监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (void)startMonitoring &#123;</div><div class="line">    // 停止监听</div><div class="line">    [self stopMonitoring];</div><div class="line"></div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 收到callback调用后，将status通过networkReachabilityStatusBlock回调出去</div><div class="line">    __weak __typeof(self)weakSelf = self;</div><div class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line"></div><div class="line">        strongSelf.networkReachabilityStatus = status;</div><div class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</div><div class="line">            strongSelf.networkReachabilityStatusBlock(status);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">  	// 声明SCNetworkReachabilityContext结构体</div><div class="line">    SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;;</div><div class="line">    // 设置回调</div><div class="line">  	SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</div><div class="line">    // 加到Main runloop里面对其进行监测</div><div class="line">  	SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line">	</div><div class="line">  	// 获取当前的网络状态，调用callback</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123;</div><div class="line">        SCNetworkReachabilityFlags flags;</div><div class="line">        if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123;</div><div class="line">            AFPostReachabilityStatusChange(flags, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有设置回调的话，也可以通过注册通知的方式，收到网络状态的变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &#123;</div><div class="line">    // 获取当前的status</div><div class="line">  	AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        // 返回status值</div><div class="line">      	if (block) &#123;</div><div class="line">            block(status);</div><div class="line">        &#125;</div><div class="line">      	// 同时会发送一个通知</div><div class="line">        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];</div><div class="line">        NSDictionary *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</div><div class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>停止监听的话，就是取消在Main Runloop里面的监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)stopMonitoring &#123;</div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>使用方式例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">AFNetworkReachabilityManager *networkManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">[networkManager startMonitoring];</div><div class="line">[networkManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">    switch (status) &#123;</div><div class="line">        case AFNetworkReachabilityStatusNotReachable:</div><div class="line">      		// do something</div><div class="line">            break;</div><div class="line">        case AFNetworkReachabilityStatusReachableViaWWAN:</div><div class="line">      		// do something</div><div class="line">      		break;</div><div class="line">        case AFNetworkReachabilityStatusReachableViaWiFi:</div><div class="line">      		// do something</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt;是用来监测网络状态的类，可以通过设置状态改变回调来获得当前网络状态&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（三）</title>
    <link href="http://yuzeyang.github.io/2016/05/22/AFNetWorking-three/"/>
    <id>http://yuzeyang.github.io/2016/05/22/AFNetWorking-three/</id>
    <published>2016-05-22T13:35:11.000Z</published>
    <updated>2016-06-12T15:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS9之后，在默认情况下是不能发送HTTP请求，推荐使用HTTPS，当然你可以在plist里面设置<code>NSAppTransportSecurity</code>的NSAllowsArbitraryLoads为true，App就依然支持HTTP请求</p>
<p>而AFSecurityPolicy主要的作用就是验证HTTPS请求的证书的有效性</p>
<a id="more"></a>
<p>AFSecurityPolicy是安全策略类，有三种SSL Pinning模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123;</div><div class="line">    AFSSLPinningModeNone,// 在证书列表中校验服务端返回的证书</div><div class="line">    AFSSLPinningModePublicKey,// 客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥</div><div class="line">    AFSSLPinningModeCertificate,// 客户端要有服务端的证书拷贝，第一步先验证证书域名/有效期等信息，第二步对服务端返回的证书和客户端返回的是否一致</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个是证书集合，泛型里面表示了集合里面是NSData类型，表明这个是用来存证书数据的集合，这些证书根据SSL Pinning模式来和服务器进行校验，默认是没有证书的，我们需要调用+ certificatesInBundle:方法将bundle里面的证书文件转成里面是data类型的集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong, nullable) NSSet &lt;NSData *&gt; *pinnedCertificates;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123;</div><div class="line">    // 获取证书</div><div class="line">  	NSArray *paths = [bundle pathsForResourcesOfType:@&quot;cer&quot; inDirectory:@&quot;.&quot;];</div><div class="line"></div><div class="line">    NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]];</div><div class="line">    // 将证书文件转成data</div><div class="line">  	for (NSString *path in paths) &#123;</div><div class="line">        NSData *certificateData = [NSData dataWithContentsOfFile:path];</div><div class="line">        [certificates addObject:certificateData];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [NSSet setWithSet:certificates];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有三种初始化的方法，一种是默认策略，AFSSLPinningModeNone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)defaultPolicy &#123;</div><div class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</div><div class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</div><div class="line"></div><div class="line">    return securityPolicy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种是自定义一个安全策略，然后读取cer文件放到集合里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</div><div class="line">    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)defaultPinnedCertificates &#123;</div><div class="line">    static NSSet *_defaultPinnedCertificates = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        NSBundle *bundle = [NSBundle bundleForClass:[self class]];</div><div class="line">        _defaultPinnedCertificates = [self certificatesInBundle:bundle];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _defaultPinnedCertificates;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三种则是需要我们多传入一个证书集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123;</div><div class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</div><div class="line">    securityPolicy.SSLPinningMode = pinningMode;</div><div class="line"></div><div class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</div><div class="line"></div><div class="line">    return securityPolicy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置证书的时候，就是把上面初始化时传入的证书取出公钥，再把公钥保存到mutablePinnedPublicKeys集合中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123;</div><div class="line">    _pinnedCertificates = pinnedCertificates;</div><div class="line"></div><div class="line">    if (self.pinnedCertificates) &#123;</div><div class="line">        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];</div><div class="line">        for (NSData *certificate in self.pinnedCertificates) &#123;</div><div class="line">            // 取出公钥</div><div class="line">          	id publicKey = AFPublicKeyForCertificate(certificate);</div><div class="line">            if (!publicKey) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            // 将公钥存到集合</div><div class="line">            [mutablePinnedPublicKeys addObject:publicKey];</div><div class="line">        &#125;</div><div class="line">        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];</div><div class="line">    &#125; else &#123;</div><div class="line">        self.pinnedPublicKeys = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>AFPublicKeyForCertificate</code>方法里面，做了一系列操作后返回公钥，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">static id AFPublicKeyForCertificate(NSData *certificate) &#123;</div><div class="line">    id allowedPublicKey = nil;</div><div class="line">    SecCertificateRef allowedCertificate;</div><div class="line">    SecCertificateRef allowedCertificates[1];</div><div class="line">    CFArrayRef tempCertificates = nil;</div><div class="line">    SecPolicyRef policy = nil;</div><div class="line">    SecTrustRef allowedTrust = nil;</div><div class="line">    SecTrustResultType result;</div><div class="line"></div><div class="line">  	// 取出证书SecCertificateRef</div><div class="line">    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);</div><div class="line">    __Require_Quiet(allowedCertificate != NULL, _out);</div><div class="line">	</div><div class="line">  	// 生成证书数组</div><div class="line">    allowedCertificates[0] = allowedCertificate;</div><div class="line">    tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);</div><div class="line"></div><div class="line">  	// 生成SecPolicyRef</div><div class="line">    policy = SecPolicyCreateBasicX509();</div><div class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust), _out);</div><div class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out);</div><div class="line">	</div><div class="line">  	// 从SecPolicyRef中取出公钥</div><div class="line">    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);</div><div class="line"></div><div class="line">_out:</div><div class="line">    // 一些资源的释放</div><div class="line"></div><div class="line">    return allowedPublicKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>-[evaluateServerTrust:forDomain:]</code>方法是<code>AFSecurityPolicy</code>类最长也是最重要的方法，它用来验证服务端是否是受信的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</div><div class="line">                  forDomain:(NSString *)domain</div><div class="line">&#123;</div><div class="line">    // 苹果文档中表示不要隐式地信任自己签名的证书，取而代之的是应该增加自己的CA证书到受信列表里</div><div class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</div><div class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // policies增加SecPolicyRef</div><div class="line">    NSMutableArray *policies = [NSMutableArray array];</div><div class="line">    if (self.validatesDomainName) &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</div><div class="line">    &#125; else &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    // 设置信任的policies应当被验证</div><div class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</div><div class="line">	</div><div class="line">    // 向系统内置的根证书验证服务端返回的证书是否合法</div><div class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">    &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    // 根据SSLPinningMode对服务端是否受信进行校验</div><div class="line">    switch (self.SSLPinningMode) &#123;</div><div class="line">        case AFSSLPinningModeNone:</div><div class="line">        default:</div><div class="line">            return NO;</div><div class="line">        case AFSSLPinningModeCertificate: &#123;</div><div class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</div><div class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</div><div class="line">            &#125;</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</div><div class="line"></div><div class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                return NO;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA)</div><div class="line">            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line">            </div><div class="line">            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</div><div class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                    return YES;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        case AFSSLPinningModePublicKey: &#123;</div><div class="line">            NSUInteger trustedPublicKeyCount = 0;</div><div class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">            for (id trustChainPublicKey in publicKeys) &#123;</div><div class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</div><div class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                        trustedPublicKeyCount += 1;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return trustedPublicKeyCount &gt; 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS9之后，在默认情况下是不能发送HTTP请求，推荐使用HTTPS，当然你可以在plist里面设置&lt;code&gt;NSAppTransportSecurity&lt;/code&gt;的NSAllowsArbitraryLoads为true，App就依然支持HTTP请求&lt;/p&gt;
&lt;p&gt;而AFSecurityPolicy主要的作用就是验证HTTPS请求的证书的有效性&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建GitHub blog</title>
    <link href="http://yuzeyang.github.io/2016/04/29/hexo_build_github_blog/"/>
    <id>http://yuzeyang.github.io/2016/04/29/hexo_build_github_blog/</id>
    <published>2016-04-28T16:00:00.000Z</published>
    <updated>2016-07-06T08:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你厌倦了使用了第三方的博客平台，你可以考虑一下用hexo和github来搭建自己的博客</p>
<hr>
<p>用hexo来搭建github blog很简单，只需要五步~</p>
<h2 id="1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93"><a href="#1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93" class="headerlink" title="1.在github上面新建一个仓库"></a>1.在github上面新建一个仓库</h2><p>首先我们需要在自己的github上新建一个仓库，将仓库的命名为xxx.github.io，一定要按该格式命名，否则不能搭建成功</p>
<a id="more"></a>
<h2 id="2-_u914D_u7F6E_u73AF_u5883"><a href="#2-_u914D_u7F6E_u73AF_u5883" class="headerlink" title="2.配置环境"></a>2.配置环境</h2><p>在使用搭建之前，我们需要配置好下面环境</p>
<h4 id="u5B89_u88C5Homebrew"><a href="#u5B89_u88C5Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<h4 id="u5B89_u88C5node-js"><a href="#u5B89_u88C5node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p>node.js集成带有了npm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install node</div></pre></td></tr></table></figure>
<h4 id="u5B89_u88C5hexo-cli"><a href="#u5B89_u88C5hexo-cli" class="headerlink" title="安装hexo-cli"></a>安装hexo-cli</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install -g hexo-cli</div></pre></td></tr></table></figure>
<h2 id="3-_u5728blog_u76EE_u5F55_u4E0B_uFF0C_u521D_u59CB_u5316hexo"><a href="#3-_u5728blog_u76EE_u5F55_u4E0B_uFF0C_u521D_u59CB_u5316hexo" class="headerlink" title="3.在blog目录下，初始化hexo"></a>3.在blog目录下，初始化hexo</h2><p>接下来我们需要新建一个文件夹来存放blog内容，假设我新建了一个blog文件夹，然后我cd到该路径下面，然后我们需要对该目录进行初始化，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init $&#123;blog路径&#125;</div></pre></td></tr></table></figure>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/hexoinit.png" alt=""></p>
<p>（图中中间出现的报错不要在意，因为我使用了插件，提示未找到该插件）</p>
<h2 id="4-_u751F_u6210_u9759_u6001_u9875_u9762"><a href="#4-_u751F_u6210_u9759_u6001_u9875_u9762" class="headerlink" title="4.生成静态页面"></a>4.生成静态页面</h2><p>初始化好之后，我们先来看看页面是不是能正常显示打开了，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<h4 id="u6CE8_u610F_uFF1A"><a href="#u6CE8_u610F_uFF1A" class="headerlink" title="注意："></a>注意：</h4><p>第一次部署的时候会因为找不到git而报错，需要安装下，再提交一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/hexog.png" alt=""></p>
<h2 id="5-_u521D_u59CB_u5316_u4F9D_u8D56"><a href="#5-_u521D_u59CB_u5316_u4F9D_u8D56" class="headerlink" title="5.初始化依赖"></a>5.初始化依赖</h2><p>在第一次安装运行时，我们需要初始化依赖，否则后面启动服务或者生成静态界面会出错…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install</div></pre></td></tr></table></figure>
<h2 id="6-_u542F_u52A8_u670D_u52A1"><a href="#6-_u542F_u52A8_u670D_u52A1" class="headerlink" title="6.启动服务"></a>6.启动服务</h2><p>然后我们启动一下服务看看，我们的博客是不是能打开了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/hexoserver.png" alt=""></p>
<p>我们打开<a href="http://0.0.0.0:4000/" target="_blank" rel="external">http://0.0.0.0:4000/</a>看看，如果前面一切顺利的话，你就能看到你搭建成功的博客了~（注意此时打开的还不是自己的github博客地址哦，只是hexo默认配置的地址）</p>
<h2 id="7-_u4FEE_u6539blog_u76EE_u5F55_u4E0B_u7684_config-yml_u914D_u7F6E_u6587_u4EF6"><a href="#7-_u4FEE_u6539blog_u76EE_u5F55_u4E0B_u7684_config-yml_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="7.修改blog目录下的_config.yml配置文件"></a>7.修改blog目录下的_config.yml配置文件</h2><p>接下来我们需要将hexo打开的博客地址改成自己的地址，打开blog目录下面的_config.yml文件，找到deploy，将部署类型改成git或者GItHub，仓库改成自己的github blog地址格式，分支改成master，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> <span class="string">git</span>    <span class="comment">#部署类型</span></div><div class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/Yuzeyang/yuzeyang.github.io.git</span>   <span class="comment">#部署的仓库的SSH</span></div><div class="line"><span class="attr">  branch:</span> <span class="string">master</span>   <span class="comment">#部署分支,一般使用master主分支</span></div></pre></td></tr></table></figure>
<p>注意：type/repository/branch:和内容之间是有空格的，而且是一定要有的，否则在重新生成静态页面的时候，会找不到仓库路径</p>
<h2 id="8-_u9009_u53D6_u559C_u6B22_u7684_u4E3B_u9898"><a href="#8-_u9009_u53D6_u559C_u6B22_u7684_u4E3B_u9898" class="headerlink" title="8.选取喜欢的主题"></a>8.选取喜欢的主题</h2><p>作为爱装逼的程序员怎么能用默认的主题呢，我们可以先在hexo主题网赚挑选一个自己喜欢的主题：<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo主题</a>，当然你有一定的前端基础可以自己写一套主题玩玩，分享给大家</p>
<h2 id="9-_u91CD_u65B0_u90E8_u7F72_u4F60_u7684_u9759_u6001_u7F51_u9875"><a href="#9-_u91CD_u65B0_u90E8_u7F72_u4F60_u7684_u9759_u6001_u7F51_u9875" class="headerlink" title="9.重新部署你的静态网页"></a>9.重新部署你的静态网页</h2><p>修改完配置之后，我们重新部署一下，看看效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d -g</div></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy -generate</div></pre></td></tr></table></figure>
<h2 id="10-_u518D_u5237_u65B0_u4E00_u4E0B_u4F60_u7684_u7F51_u9875_uFF0CDuang_7E"><a href="#10-_u518D_u5237_u65B0_u4E00_u4E0B_u4F60_u7684_u7F51_u9875_uFF0CDuang_7E" class="headerlink" title="10.再刷新一下你的网页，Duang~"></a>10.再刷新一下你的网页，Duang~</h2><p>因为首页图片加载太慢了…我换了个主题…</p>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/blog.jpg" alt=""></p>
<h2 id="11-_u4E0A_u4F20_u6587_u7AE0"><a href="#11-_u4E0A_u4F20_u6587_u7AE0" class="headerlink" title="11.上传文章"></a>11.上传文章</h2><p>你可以运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new &quot;新的文章标题&quot;</div></pre></td></tr></table></figure>
<p>这样会自动生成好</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: Hexo搭建GitHub blog</div><div class="line">date: 2016-4-29 17:00:00</div><div class="line">tags: Hexo</div><div class="line">---</div></pre></td></tr></table></figure>
<p>或者， 把文章放到blog/source/._posts目录下面</p>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/upload.jpg" alt=""></p>
<p>在文章的内容前面需要加上标题、时间和标签，这样才能在首页显示出你的标题，你也可以添加文章的时间和文章的tag，例如：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: Hexo搭建GitHub blog</div><div class="line">date: 2016-4-29</div><div class="line">tags: Hexo</div><div class="line">---</div></pre></td></tr></table></figure>
<p>再起一下服务，看看有没有修改成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>修改成功后，再重新部署一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d -g</div></pre></td></tr></table></figure>
<p>最后再确认一下</p>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/update.jpg" alt=""></p>
<p>上传成功~！</p>
<h2 id="12-_u7533_u8BF7_u4E2A_u4EBA_u57DF_u540D"><a href="#12-_u7533_u8BF7_u4E2A_u4EBA_u57DF_u540D" class="headerlink" title="12.申请个人域名"></a>12.申请个人域名</h2><p>使用xxx.github.io，其实还不是很方便，也没有xxx.com或者xxx.me这样的域名好（zhuang）记（bi），所以一般都会自己去申请一个个人域名</p>
<p>我们打开google，搜索一下<code>个人域名</code></p>
<p>恩，跳出<a href="https://wanwang.aliyun.com/?utm_content=se_97054&amp;gclid=CITQ0ce8vs0CFQqkvQodNFUPrA" target="_blank" rel="external">万网</a>和<a href="https://sg.godaddy.com/zh/offers/default.aspx?tmskey=1dom_23&amp;isc=gennlcn10&amp;countrview=1&amp;currencytype=CNY&amp;cvosrc=ppc.google.+%C3%A4%C2%B8%C2%AA%C3%A4%C2%BA%C2%BA%C3%A5%C2%9F%C2%9F%C3%A5%C2%90%C2%8D&amp;cvo_crid=103919011486&amp;matchtype=b" target="_blank" rel="external">GoDaddy</a>，不过好像GoDaddy续费比较贵，万网好像能查到你的个人信息资料…</p>
<p>所以我咨询了下同事，他们推荐了我<a href="https://www.namesilo.com/" target="_blank" rel="external">namesilo</a>，续费便宜，还能开启隐私保护~</p>
<p>进到首页之后我们在箭头位置搜索下我们想要的域名</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/namesilo.png" alt=""></p>
<p>然后我们就能看到哪些是已经注册，哪些是可以使用的</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/namesiloRes.png" alt=""></p>
<p>在支付前看下价格，这上面显示的价格只是低价，类似于起拍价，实际价格在支付页可以看到，购买前请仔细看下数字…别付了好几万…（可以支持支付宝哦~）</p>
<p>然后我们到<a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPOD</a>里，对我们的xxx.github.io进行DNS转移到xxx.com</p>
<p>登录后，在域名解析里面，添加我们的个人域名，然后将默认的NS类型的记录值拷贝出来，回到我们的namesilo里面，将nameserver修改成NS类型的记录值，保存，然后过一会儿才会生效</p>
<p>在Github的xxx.github.io仓库的目录下面，新建一个CNAME文件，写上你的个人域名</p>
<p>在web导航栏里面输出你的个人域名，就可以正常访问了~</p>
<h2 id="13-_u589E_u52A0_u8BC4_u8BBA_u529F_u80FD"><a href="#13-_u589E_u52A0_u8BC4_u8BBA_u529F_u80FD" class="headerlink" title="13.增加评论功能"></a>13.增加评论功能</h2><p>目前用的比较多的评论插件有<a href="https://disqus.com/" target="_blank" rel="external">disqus</a>、<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>、<a href="http://www.uyan.cc/" target="_blank" rel="external">友言</a></p>
<p>但是多说和友言界面有点丑…相比之下disqus还是比较符合我的口味的~</p>
<p>那我就来介绍怎么加disqus</p>
<p>首先注册登录，然后点击右上角的设置按钮</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/SettingsDisqus.png!400x400" alt=""></p>
<p>选择左侧的<code>Account</code>，在Username里面填上你的域名名称，例如我的域名是<code>zeeyang.com</code>，那么我就填<code>zeeyang</code></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/SettingsDisqusUsername.png" alt=""></p>
<p>然后打开你的hexo配置文件，在最后加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disqus_shortname: 域名名称(例如：zeeyang)</div></pre></td></tr></table></figure>
<p>然后打开主题配置文件，也同样加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disqus: 域名名称(例如：zeeyang)</div></pre></td></tr></table></figure>
<p>然后提交修改，再刷新下网页</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/disqusComplete.png" alt=""></p>
<p>这下子别人可以在你的文章下面留言啦~（我后来更换了apollo主题，比较清爽）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你厌倦了使用了第三方的博客平台，你可以考虑一下用hexo和github来搭建自己的博客&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;用hexo来搭建github blog很简单，只需要五步~&lt;/p&gt;
&lt;h2 id=&quot;1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot;&gt;&lt;a href=&quot;#1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot; class=&quot;headerlink&quot; title=&quot;1.在github上面新建一个仓库&quot;&gt;&lt;/a&gt;1.在github上面新建一个仓库&lt;/h2&gt;&lt;p&gt;首先我们需要在自己的github上新建一个仓库，将仓库的命名为xxx.github.io，一定要按该格式命名，否则不能搭建成功&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yuzeyang.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>iOS 同时修改button位置和文字问题</title>
    <link href="http://yuzeyang.github.io/2016/04/09/button-location-title-bug/"/>
    <id>http://yuzeyang.github.io/2016/04/09/button-location-title-bug/</id>
    <published>2016-04-09T03:27:16.000Z</published>
    <updated>2016-05-21T03:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在写App的登录注册界面，其中登录和注册之间的切换和印象笔记一样<br><img src="http://7xtit4.com1.z0.glb.clouddn.com/Evernote.gif!500x500" alt="印象笔记登录界面"></p>
<hr>
<p>中间的登录按钮会有一个下移以及更改文字的操作，但是我在加了下移动画之后，再修改按钮的文字，就出现了很奇怪的现象，按钮会先下移然后修改文字之后，又跳回到最初的位置</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Evernote%20bug.gif!500x500" alt="问题操作"><br>这就奇怪了，看逻辑上一点错误也没有，那怎么会这样呢？</p>
<p>检查了下按钮的类型也是自定义的，那会不会是动画影响的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);</div></pre></td></tr></table></figure></p>
<p>在block里面，我在setTitle:forState的方法外面，去掉动画的影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[UIView setAnimationsEnabled:NO];</div><div class="line">[self.loginButton setTitle:@&quot;注   册&quot; forState:UIControlStateNormal];</div><div class="line">[self.loginButton layoutIfNeeded];</div><div class="line">[UIView setAnimationsEnabled:YES];</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[UIView performWithoutAnimation:^&#123;</div><div class="line">        [self.loginButton setTitle:@&quot;注   册&quot; forState:UIControlStateNormal];</div><div class="line">        [self.loginButton layoutIfNeeded];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>都还是不行。。。</p>
<p>干脆把动画方法去掉，直接改变按钮的位置再试试。。结果还是一样，那就纳闷了。。</p>
<p>后来找了很久的资料发现，原来是受到了autolayout的影响，因为在广泛开始使用autolayout之后，在storyboard，nib和实现文件里面，我们可能不像以前那样去繁琐的计算坐标了，我们通过自适应的方式，去确定控件的位置</p>
<p>因为我的登录按钮是自适应的，所以在修改了按钮位置后，再修改文字，就会出现这样的问题，但是我打印了很多方法，都没有发现调用，所以不知道系统在设置文字的时候，又调用了哪个方法</p>
<p>我试着调用了修改其他的属性的方法，比如背景色，setImage：forState，这些都没事，凡是调用了title相关的三个设置都会这样。。我就满脸黑线了。。</p>
<p>所以目前能找到的解决办法就是，该按钮<strong>用坐标计算的方式添加</strong></p>
<p>如果哪位大神找到更好的解决办法，欢迎留言~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在写App的登录注册界面，其中登录和注册之间的切换和印象笔记一样&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Evernote.gif!500x500&quot; alt=&quot;印象笔记登录界面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;中
    
    </summary>
    
    
      <category term="button" scheme="http://yuzeyang.github.io/tags/button/"/>
    
  </entry>
  
  <entry>
    <title>iOS 简单下载动画</title>
    <link href="http://yuzeyang.github.io/2016/03/27/simple-download-animation/"/>
    <id>http://yuzeyang.github.io/2016/03/27/simple-download-animation/</id>
    <published>2016-03-27T03:22:17.000Z</published>
    <updated>2016-05-21T03:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个动画比较简单基础，首先我们来看一下这个动画模拟的动图<br><img src="http://7xtit4.com1.z0.glb.clouddn.com/downloadAnimation.gif!500x500" alt="下载动画"></p>
<hr>
<p>动画一共有四个状态，<strong>开始下载</strong>、<strong>下载结束</strong>、<strong>下载成功</strong>和<strong>下载失败</strong></p>
<p>为什么会分有<strong>下载结束</strong>这样的状态呢？因为考虑到实际场景，可能会有在加载过程中，用户返回上级界面，我们需要结束下载动画</p>
<hr>
<p>我们按状态来实现，首先先看开始加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *rotationZAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">rotationZAnimation.fromValue = @(0);</div><div class="line">rotationZAnimation.toValue = @(M_PI*2);</div><div class="line">rotationZAnimation.repeatDuration = HUGE_VAL;</div><div class="line">rotationZAnimation.duration = 1.0;</div><div class="line">rotationZAnimation.cumulative = YES;</div><div class="line">rotationZAnimation.beginTime = CACurrentMediaTime();</div><div class="line">[self.loadingLayer addAnimation:rotationZAnimation forKey:@&quot;rotationZAnimation&quot;];</div><div class="line">        </div><div class="line">NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth];</div><div class="line">CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];</div><div class="line">[self.loadingLayer addAnimation:boundsAnimation forKey:nil];</div></pre></td></tr></table></figure></p>
<p>这里分为两个动画，一个是<strong>旋转动画</strong>，一个是<strong>放大缩小的动画</strong><br><strong>旋转动画</strong>，我们只有一个初始值和末值，所以我们只需要使用CABasicAnimation就可以了，不需要使用CAKeyframeAnimation，CAKeyframeAnimation是用来处理关键帧动画的，它的values属性用来存储关键帧的值，这就是我们用来做处理<strong>放大缩小动画</strong>，上面代码可以看到我将它抽成了一个方法来用，因为在下载成功和失败的时候，成功和失败也是有放大缩小的动画，这三个其实是一个动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)valueArrayWithWidth:(CGFloat)width &#123;</div><div class="line">    return @[[NSValue valueWithCGRect:CGRectMake(0, 0, width * 0.7, width * 0.7)],</div><div class="line">             [NSValue valueWithCGRect:CGRectMake(0, 0, width, width)],</div><div class="line">             [NSValue valueWithCGRect:CGRectMake(0, 0, width * 0.9, width * 0.9)]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CAKeyframeAnimation *)bounsAnimationWithValues:(NSArray *)values &#123;</div><div class="line">    CAKeyframeAnimation *boundsAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;bounds&quot;];</div><div class="line">    boundsAnimation.duration = 0.6;</div><div class="line">    boundsAnimation.beginTime = CACurrentMediaTime();</div><div class="line">    boundsAnimation.values = values;</div><div class="line">    boundsAnimation.keyTimes = @[@(0),@(0.3),@(0.6)];</div><div class="line">    boundsAnimation.timingFunctions = @[[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],</div><div class="line">                                        [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut],</div><div class="line">                                        [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];</div><div class="line">    boundsAnimation.removedOnCompletion = NO;</div><div class="line">    boundsAnimation.fillMode = kCAFillModeForwards;</div><div class="line">    return boundsAnimation;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们统一设置动画的values值，这里传入的width值是下载的背景大小，因为下载圆圈有个放大的过程，所以我们需要圆圈的原始大小要比背景的大小小，所以我默认设置圆圈的大小是背景大小的0.9倍，所以动画的效果是圆圈从背景大小的0.7倍-&gt;背景大小-&gt;背景大小的0.9倍（圆圈的原始大小）<br>在设置这个动画的时候，因为动画的值不止是初始值和末值，还是中间值，所以我使用CAKeyframeAnimation来做，每个关键帧之间的动画时间设置为0.3秒，这是最适合的动画时间，当然这是时间还是由自己反复调试动画决定的</p>
<hr>
<p>下载结束我们只要将转圈的动画移除掉即可，这样转圈就恢复到原来的状态了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.loadingLayer removeAllAnimations];</div></pre></td></tr></table></figure></p>
<hr>
<p>下载成功我们也需要将转圈动画移除，然后出现成功的动画，并且将成功图层的透明度从0变到1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[self.loadingLayer removeAllAnimations];</div><div class="line">self.failLayer.opacity = 0.0;</div><div class="line">NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth * 0.5];</div><div class="line">CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];</div><div class="line">[self.doneLayer addAnimation:boundsAnimation forKey:nil];</div><div class="line">        </div><div class="line">[UIView animateWithDuration:1.0 animations:^&#123;</div><div class="line">    self.doneLayer.opacity = 1.0;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<hr>
<p>下载失败也是同理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[self.loadingLayer removeAllAnimations];</div><div class="line">self.doneLayer.opacity = 0.0;</div><div class="line">NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth * 0.5];</div><div class="line">CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];</div><div class="line">[self.failLayer addAnimation:boundsAnimation forKey:nil];</div><div class="line">        </div><div class="line">[UIView animateWithDuration:1.0 animations:^&#123;</div><div class="line">     self.failLayer.opacity = 1.0;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>好了，动画主要的原理就是这样，具体的代码实现可以看这里：<a href="https://github.com/Yuzeyang/DownloadingAnimation" target="_blank" rel="external">https://github.com/Yuzeyang/DownloadingAnimation</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个动画比较简单基础，首先我们来看一下这个动画模拟的动图&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/downloadAnimation.gif!500x500&quot; alt=&quot;下载动画&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;动画
    
    </summary>
    
    
      <category term="下载动画" scheme="http://yuzeyang.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（二）</title>
    <link href="http://yuzeyang.github.io/2016/03/15/AFNetWorking-two/"/>
    <id>http://yuzeyang.github.io/2016/03/15/AFNetWorking-two/</id>
    <published>2016-03-15T07:34:30.000Z</published>
    <updated>2016-06-12T15:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFHTTPSessionManager</code>继承于<code>AFURLSessionManager</code>，提供了更方便的HTTP请求方法，包括了GET、POST、PUT、PATCH、DELETE这五种方式，并且AF鼓励我们在<code>AFHTTPSessionManager</code>再进行一次封装来满足我们自己的业务需求</p>
<a id="more"></a>
<hr>
<p>在开始的地方，AF一直提醒到一个属性<code>baseURL</code>，这个变量你可以在进一步封装的时候，将<code>baseURL</code>写成你自己的HTTP请求原始地址，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSURL *)baseURL &#123;</div><div class="line">    return [NSURL URLWithString:kBaseURLString];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在对<code>baseURL</code>进行拼接的时候，也需要注意一下几点，防止出现请求的URL出现问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSURL *baseURL = [NSURL URLWithString:@&quot;http://example.com/v1/&quot;];</div><div class="line">    [NSURL URLWithString:@&quot;foo&quot; relativeToURL:baseURL];                  // http://example.com/v1/foo</div><div class="line">    [NSURL URLWithString:@&quot;foo?bar=baz&quot; relativeToURL:baseURL];          // http://example.com/v1/foo?bar=baz</div><div class="line">    [NSURL URLWithString:@&quot;/foo&quot; relativeToURL:baseURL];                 // http://example.com/foo</div><div class="line">    [NSURL URLWithString:@&quot;foo/&quot; relativeToURL:baseURL];                 // http://example.com/v1/foo</div><div class="line">    [NSURL URLWithString:@&quot;/foo/&quot; relativeToURL:baseURL];                // http://example.com/foo/</div><div class="line">    [NSURL URLWithString:@&quot;http://example2.com/&quot; relativeToURL:baseURL]; // http://example2.com/</div></pre></td></tr></table></figure>
<p>在初始化的方法里面，我们看到这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</div><div class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p><code>NS_DESIGNATED_INITIALIZER</code>的作用是什么呢？<br>指定的构造器通过发送初始化消息到父类来保证object被完全初始化，指定构造器有以下几个规则：</p>
<p>1.指定构造器必须调用父类的指定构造器</p>
<p>2.任何一个便利构造器必须调用最终指向指定构造器的其他构造器</p>
<p>3.具有指定构造器的类必须实现父类的所有指定构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    // 指向- [initWithBaseURL:]</div><div class="line">  	return [self initWithBaseURL:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(NSURL *)url &#123;</div><div class="line">    // 指向- [initWithBaseURL:sessionConfiguration:]</div><div class="line">    return [self initWithBaseURL:url sessionConfiguration:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</div><div class="line">    // 指向- [initWithBaseURL:sessionConfiguration:]</div><div class="line">    return [self initWithBaseURL:nil sessionConfiguration:configuration];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(NSURL *)url</div><div class="line">           sessionConfiguration:(NSURLSessionConfiguration *)configuration</div><div class="line">&#123;</div><div class="line">    // 调用父类的- [initWithSessionConfiguration:]</div><div class="line">    self = [super initWithSessionConfiguration:configuration];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // baseURL赋值，AFHTTPRequestSerializer和AFJSONResponseSerializer序列化</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DEPRECATED_ATTRIBUTE</code>这个相信大家见得比较多了，字面意思就是这个API不建议开发者再使用了，再使用时，会出现编译警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div></pre></td></tr></table></figure>
<hr>
<p>下面POST、GET、PUT、PATCH、DELETE方法传参基本都是大同小异</p>
<p><code>URLString</code>表示请求的URL，<code>parameters</code>表示客户端请求内容的存储器，<code>progress</code>表示请求的进度，<code>constructingBodyWithBlock</code>里面只有一个formData用来拼接到HTTP的请求体，<code>success</code>表示请求成功后的block回调，<code>failure</code>表示请求失败的block回调</p>
<p>那么这几个请求有什么区别呢？</p>
<p>1、POST请求是向服务端发送数据的，用来更新资源信息，它可以改变数据的种类等资源</p>
<p>2、GET请求是向服务端发起请求数据，用来获取或查询资源信息</p>
<p>3、PUT请求和POST请求很像，都是发送数据的，但是PUT请求不能改变数据的种类等资源，它只能修改内容</p>
<p>4、DELETE请求就是用来删除某个资源的</p>
<p>5、PATCH请求和PUT请求一样，也是用来进行数据更新的，它是HTTP verb推荐用于更新的</p>
<p>在实际开发过程中，我们还是使用POST和GET请求是最多的</p>
<hr>
<p>在请求实现的部分，都是调用了<code>-[dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure]</code>方法创建<code>NSURLSessionDataTask</code>对象</p>
<p>传参的内容基本都是和上一层方法一样，<code>method</code>指的就是请求的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        // 失败成功处理</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;继承于&lt;code&gt;AFURLSessionManager&lt;/code&gt;，提供了更方便的HTTP请求方法，包括了GET、POST、PUT、PATCH、DELETE这五种方式，并且AF鼓励我们在&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;再进行一次封装来满足我们自己的业务需求&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（一）</title>
    <link href="http://yuzeyang.github.io/2016/02/21/AFNetWorking-one/"/>
    <id>http://yuzeyang.github.io/2016/02/21/AFNetWorking-one/</id>
    <published>2016-02-21T03:47:48.000Z</published>
    <updated>2017-03-21T14:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先来介绍下AFNetWorking，官方介绍如下：</p>
<blockquote>
<p>AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">Foundation URL Loading System</a>, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p>
<p>Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.</p>
<p>Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did!</p>
</blockquote>
<p>翻译过来简单来说就是</p>
<p>AFNetworking是一个适用于iOS和Mac OS X两个平台的网络库，它是基于<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">Foundation URL Loading System</a>上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking.png" alt=""></p>
<p>相信从star数和fork数来看，大家都能明白这个库是多么的受欢迎了，所以了解这个库对于一个iOS开发来说是极为重要的！</p>
<p>这个是AFNetworking的github地址：<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">GitHub - AFNetworking/AFNetworking: A delightful networking framework for iOS</a></p>
<p>在使用前阅读README是非常重要的，里面往往包括了这个库的介绍、安装和使用等等，对于快速了解一个库来说，这是非常有帮助的</p>
<hr>
<p>首先我们在<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetWorking源码地址</a>里download下来，打开工程文件，可以看到里面内容分为两个部分，一个是AFNetworking，另一个是UIKit+AFNetworking</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking_file.png" alt=""></p>
<p>很明显，第一个是用来做网络请求相关的，第二个则是和UI使用相关的，我们先看第一个</p>
<p>在看完头文件和README之后，你会发现<code>AFURLSessionManager</code>和<code>AFHTTPSessionManager</code>是里面比较重要的两个类</p>
<p>这里我先讲<code>AFURLSessionManager</code>这个类</p>
<p>首先浏览完这个类从API，发现其主要提供了数据的请求、上传和下载功能</p>
<p>在属性方面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@property(readonly,nonatomic,strong)NSArray *tasks;</div><div class="line"></div><div class="line">@property(readonly,nonatomic,strong)NSArray *dataTasks;</div><div class="line"></div><div class="line">@property(readonly,nonatomic,strong)NSArray *uploadTasks;</div><div class="line"></div><div class="line">@property(readonly,nonatomic,strong)NSArray *downloadTasks;</div></pre></td></tr></table></figure>
<p>通过这四个属性，我们分别可以拿到总的任务集合、数据任务集合、上传任务集合和下载任务集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,assign)BOOL attemptsToRecreateUploadTasksForBackgroundSessions;</div></pre></td></tr></table></figure>
<p>这个属性非常重要，注释里面写到，在iOS7中存在一个bug，在创建后台上传任务时，有时候会返回nil，所以为了解决这个问题，AFNetworking遵照了苹果的建议，在创建失败的时候，会重新尝试创建，次数默认为3次，所以你的应用如果有场景会有在后台上传的情况的话，记得将该值设为YES，避免出现上传失败的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;</div></pre></td></tr></table></figure>
<p>在对外提供的notification key里面，使用了<code>FOUNDATION_EXPORT</code>来定义常量，使用<code>FOUNDATION_EXPORT</code>和<code>extern</code>或者<code>define</code>有什么区别呢？</p>
<p><code>FOUNDATION_EXPORT</code>在c文件编译下是和extern等同，在c++文件编译下是和extern “C”等同，在32位机的环境下又是另外编译情况，在兼容性方面，<code>FOUNDATION_EXPORT</code>做的会更好。</p>
<p>这里还提到了效率方面的问题：<a href="http://www.jianshu.com/p/f547eb0368c4" target="_blank" rel="external">iOS开发的一些奇巧淫技3</a></p>
<hr>
<p>进入到实现文件里面，我们可以看到在外部API调用dataTask、uploadTask、downloadTask方法实际上都是completionHanlder block返回出来的，但是我们知道网络请求是delegate返回结果的，AF内部做了巧妙的操作，他对每个task都增加代理设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line">	__block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">	// 每个task里面都会调用addDelegate方法</div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在设置里面，每个task会在内部创建<code>AFURLSessionManagerTaskDelegate</code>对象，并设置completionHandler、uploadProgressBlock、downloadProgressBlock回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    // 初始化delegate对象</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    // 将task的completionHandler赋给delegate，系统网络请求delegate 调用该block，返回结果</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    // 对task进行delegate</div><div class="line">    [self setDelegate:delegate forTask:dataTask];</div><div class="line">	// 设置上传和下载进度回调</div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后delegate对象利用kvo将task对一些方法进行监听，并且监听到变化时，通过block返回，将delegate转成block出去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    // 断言</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    // task使用kvo对一些方法监听，返回上传或者下载的进度</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    // sessionManager对暂停task和恢复task进行注册通知</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在原先IM的设计时，因为接口的数量并不多，所以在AsyncSocket的delegate回调后，我们依旧是采用delegate回调给业务层，但是随着接口数量的增加，业务层对于回调的处理更加困难和不可控，在重构IM的时候，我们也参考学习了AF的做法，我们通过对唯一标识和每个请求做一一绑定，将请求的上下文关联起来，这样让socket长连接的请求的也想http请求一样，都由block回去，对于业务层的处理也方便更多</p>
<p><code>setupProgressForTask</code>方法主要是对task和progress设置监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    __weak __typeof__(task) weakTask = task;</div><div class="line"></div><div class="line">    // 设置上传和下载的大小</div><div class="line">    </div><div class="line">    // 设置上传和下载中允许取消和暂停</div><div class="line">  </div><div class="line">  	// 设置上传和下载响应恢复处理方法后恢复上传或下载</div><div class="line">    </div><div class="line">    // task对接收到的字节数、期望接收到的字节数、发送的字节数、期望发送的字节数设置监听</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">          forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">	// 上传和下载设置完成的分数监听</div><div class="line">    [self.downloadProgress addObserver:self</div><div class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                               options:NSKeyValueObservingOptionNew</div><div class="line">                               context:NULL];</div><div class="line">    [self.uploadProgress addObserver:self</div><div class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                             options:NSKeyValueObservingOptionNew</div><div class="line">                             context:NULL];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</div><div class="line">        // 设置上传和下载的新值</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</div><div class="line">        if (self.downloadProgressBlock) &#123;</div><div class="line">            self.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</div><div class="line">        if (self.uploadProgressBlock) &#123;</div><div class="line">            self.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在第一个if判断里面，object判断是否是<code>NSURLSessionTask</code>类或者是否是<code>NSURLSessionDownloadTask</code>类，但是进到<code>NSURLSessionDownloadTask</code>的时候，我们可以看到<code>NSURLSessionDownloadTask</code>是<code>NSURLSessionTask</code>的子类，那为什么还要判断这个呢？</p>
<p><code>NSURLSessionTask</code>实际上是<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ClassCluster.html" target="_blank" rel="external">Class cluster</a>，通过<code>NSURLSession</code>生成的task返回的并不一定是指定的task类型。因此kindOfClass并不总会生效，具体可以参见<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L382~L414" target="_blank" rel="external">AFURLSessionManager.m在load方法中的说明</a>。<br>特定于当前问题，是由于iOS 7上<strong>NSCFURLSessionDownloadTask的基类并不是</strong><code>NSCFURLSessionTask</code>，因此isKindOfClass会出错。查看对应的<a href="https://github.com/AFNetworking/AFNetworking/commit/a745be4fcd75de75b560dce1d689b6bcc11f42ba#diff-dd81ac1f455a60ac8065ade41f06881f" target="_blank" rel="external">commit</a>就可以知道了。</p>
<p>在<code>NSURLSessionTaskDelegate</code>的代理里面，只是做了两件事情，第一个是获取数据，将responseSerializer和downloadFileURL或data存到userInfo里面，第二个是根据error是否为空值，做下一步处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#pragma mark - NSURLSessionTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">    // 获取数据，将responseSerializer和downloadFileURL或data存到userInfo里面</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">      // 有error时处理</div><div class="line">    &#125; else &#123;</div><div class="line">      // 无error时正常处理</div><div class="line">    &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在有error时，userInfo先存储error，然后检查manager是否有completionGroup和completionQueue，没有的话，就创建一个dispatch_group_t和在主线程上做completionHandler的操作，并在主线程中发送一个AFNetworkingTaskDidCompleteNotification通知，这个通知在UIKit+AFNetworking里UIRefreshControl +AFNetworking里也会接收到，用来停止刷新，如果你不使用AF的UI部分，你可以通过接收这个通知来做操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (self.completionHandler) &#123;</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>在没有error时，会先对数据进行一次序列化操作，然后下面的处理就和有error的那部分一样了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123;</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (self.completionHandler) &#123;</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>一开始我们就看到了clang命令，这个的作用是用来消除特定区域的clang的编译警告，-Wgnu则是消除?:警告，这个是clang的警告message列表<a href="http://fuckingclangwarnings.com/" target="_blank" rel="external">Which Clang Warning Is Generating This Message?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line"></div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line"></div><div class="line">// some codes</div><div class="line"></div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再下面两个则是收到数据和下载文件的回调处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#pragma mark - NSURLSessionDataTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    [self.mutableData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDownloadTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    NSError *fileManagerError = nil;</div><div class="line">    self.downloadFileURL = nil;</div><div class="line"></div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (self.downloadFileURL) &#123;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            if (fileManagerError) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在刚才说到的load方法里面，对系统的resume和suspend方法进行了替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</div><div class="line">    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));</div><div class="line">    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>替换之后，只是增加了通知处理而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)af_resume &#123;</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_resume];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_suspend &#123;</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_suspend];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateSuspended) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用替换和增加方法时候，用到了关键字inline，inline是为了防止反汇编之后，在符号表里面看不到你所调用的该方法，否则别人可以通过篡改你的返回值来造成攻击，<a href="http://www.blogfshare.com/ioss-static-inline.html" target="_blank" rel="external">iOS安全–使用static inline方式编译函数，防止静态分析</a>，特别是在使用swizzling的时候，那除了使用swizzling动态替换函数方法之外，还有别的方法么？有，修改IMP指针指向的方法，<a href="http://www.cocoachina.com/ios/20150717/12623.html" target="_blank" rel="external">轻松学习之 IMP指针的作用 - CocoaChina_让移动开发更简单</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</div><div class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</div><div class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;</div><div class="line">    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在+ load方法中，我们又看到了GCC命令，那clang和GCC在使用的时机有没有什么区别？<a href="http://stackoverflow.com/questions/11838379/should-i-use-pragma-gcc-or-pragma-clang-in-xcode" target="_blank" rel="external">通常情况下，在GCC特有的处理或者是在GCC，clang和其他兼容GCC的编译器时，尽量使用<strong>#pragma GCC</strong>，clang特有的处理时，使用<strong>#pragma clang</strong></a>，这个是<a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html" target="_blank" rel="external">GCC的message表</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    // ...</div><div class="line">#pragma GCC diagnostic push</div><div class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</div><div class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>看完之后，有个疑问，查了资料也没有找到：</p>
<p>在NSURLSessionDelegate的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L974~L979" target="_blank" rel="external">URLSession:didReceiveChallenge:completionHandler:方法里面disposition会对credential对象做非空判断然后再赋值校验类型</a>，但是NSURLSessionTaskDelegate的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L1025~L1026" target="_blank" rel="external">-  [URLSession:task:didReceiveChallenge:completionHandler:]方法里面disposition并不对credential对象做判断，而是直接就赋值校验类型</a>，有知道的，欢迎留言交流</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先来介绍下AFNetWorking，官方介绍如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot;&gt;Foundation URL Loading System&lt;/a&gt;, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.&lt;/p&gt;
&lt;p&gt;Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.&lt;/p&gt;
&lt;p&gt;Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来简单来说就是&lt;/p&gt;
&lt;p&gt;AFNetworking是一个适用于iOS和Mac OS X两个平台的网络库，它是基于&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot;&gt;Foundation URL Loading System&lt;/a&gt;上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS 不付费看微信红包照片</title>
    <link href="http://yuzeyang.github.io/2016/01/26/red-packet/"/>
    <id>http://yuzeyang.github.io/2016/01/26/red-packet/</id>
    <published>2016-01-26T15:11:50.000Z</published>
    <updated>2016-05-18T15:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信今天微信红包照片已经席卷了朋友圈，微信这次创意是非常好的，对发布的照片进行了模糊处理，打开一看，是要发红包才能看到照片的，那怎么办呢？</p>
<p>这怎么能难倒我们这些技术男，一招破解！</p>
<a id="more"></a>
<p>第一种方法Charles</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/hongbaozhaopian.png!600x600" alt=""></p>
<p>来我们一起来抓包看看~</p>
<p>首先设置好自己的WiFi的http代理，绑定好自己的Mac ip地址，打开Charles，选择allow</p>
<p>然后打开你的微信朋友圈，你在Charles里面可以看到</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/zhuabaojieguo.jpg!500x500" alt=""></p>
<p>然后在overview的URL里面，你就可以看到图片的URL地址了，将其拷贝出来，放到浏览器里面打开</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/yuanshitu.png!600x600" alt=""></p>
<p>ok~就这么简单~</p>
<hr>
<p><strong>下面讲下第二种方法</strong></p>
<p>用另一个iOS工具，叫做Replica</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/replica.png!600x600" alt=""></p>
<p>打开Replica之后，启动Start，然后会打开VPN，按操作一步一步即可</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/replica_start.png!600x600" alt=""></p>
<p>然后打开微信朋友圈，再返回到Replica，进到Analytics，点击最新的session，里面会有最新的POST/GET的数据</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/post_get_data.png!600x600" alt=""></p>
<p>然后找到180.163开头的GET请求，点进去，切到Response，可以看到这个GET请求到的数据类型是image，然后打开Image Viewer</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/180.163.png!600x600" alt=""></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/yuanshitu2.png!600x600" alt=""></p>
<p>也是可以将图片显示出来的</p>
<p>我们可以发现照片的模糊处理是在本地做的</p>
<p>当然这个我们只是娱乐为主，这次的产品设计还是非常不错的，点个赞喔~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信今天微信红包照片已经席卷了朋友圈，微信这次创意是非常好的，对发布的照片进行了模糊处理，打开一看，是要发红包才能看到照片的，那怎么办呢？&lt;/p&gt;
&lt;p&gt;这怎么能难倒我们这些技术男，一招破解！&lt;/p&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="http://yuzeyang.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS 给App添加TouchID验证</title>
    <link href="http://yuzeyang.github.io/2016/01/19/TouchID/"/>
    <id>http://yuzeyang.github.io/2016/01/19/TouchID/</id>
    <published>2016-01-19T14:47:27.000Z</published>
    <updated>2016-05-18T15:04:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>TouchID验证这个在iOS8中已经对开发者开放使用了，而且需在5s以上真机才能使用，这个出来已经比较早了，相信很多人都应该已经知道怎么使用TouchID了，但是就目前我使用的App来说，看到使用TouchID验证的占得数量并不多，对于一些涉及到安全性的App来说，很有可能你的解锁验证、App登录以及支付验证都是用的TouchID使用TouchID验证还是有风险的，但是有些App增加使用TouchID作为一种验证还是不错的选择，既快捷又方便，对于开发者来说增加的成本也很低</p>
<a id="more"></a>
<p>这个是我所讲的demo的源码<a href="https://github.com/Yuzeyang/TouchIDDemo" target="_blank" rel="external">TouchID demo</a>，代码量非常少</p>
<hr>
<p>下面我就来介绍下怎么给App增加TouchID验证吧</p>
<p>首先，要使用TouchID，得先引入LocalAuthentication.framework这个库，这里面只有四个头文件，但实际使用到的只有LAContext.h和LAError.h这两个头文件</p>
<p>在做验证时，我们只需要使用到LAContext中的两个方法</p>
<p>我们先初始化一个LAContext对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LAContext *ctx = [[LAContext alloc] init];</div></pre></td></tr></table></figure>
<p>然后调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError*__autoreleasing*)error;</div></pre></td></tr></table></figure>
<p>方法来确定当前指定的验证方法能否使用，LAPolicy是个枚举，里面只有两个值，一个是LAPolicyDeviceOwnerAuthenticationWithBiometrics（使用该设备的TouchID验证），LAPolicyDeviceOwnerAuthentication（使用该设备的TouchID和设备密码验证）</p>
<p>这里返回的是一个布尔值，错误处理我等下一起说明，当返回可以使用当前指定的验证法方法时，我们调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)evaluatePolicy:(LAPolicy)policy localizedReason:(NSString*)localizedReason reply:(void(^)(BOOLsuccess,NSError*__nullableerror))reply;</div></pre></td></tr></table></figure>
<p>方法开始使用TouchID验证，localizedReason指的是在弹出TouchID验证框时提示的文字，reply指的是在做指纹验证或者密码验证后的结果返回，我将localizedReason用@”通过Home键验证已有手机指纹”作为提示，下图比较直观</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/TouchID1.png!600x600" alt=""></p>
<p>刚才布尔值的错误对应的是哪些呢？</p>
<p>这就用到了LAError.h这个类，这个类定义了目前所有的验证失败的错误code，我直接将它copy过来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">typedefNS_ENUM(NSInteger, LAError)</div><div class="line">&#123;</div><div class="line">	/// 校验失败</div><div class="line">	LAErrorAuthenticationFailed =kLAErrorAuthenticationFailed,</div><div class="line"></div><div class="line">    /// 用户取消验证</div><div class="line">	LAErrorUserCancel=kLAErrorUserCancel,</div><div class="line"></div><div class="line">	/// 用户回退（返回密码校验）</div><div class="line">	LAErrorUserFallback=kLAErrorUserFallback,</div><div class="line"></div><div class="line">	/// 系统取消校验</div><div class="line">	LAErrorSystemCancel=kLAErrorSystemCancel,</div><div class="line"></div><div class="line">	/// 密码未设置</div><div class="line">	LAErrorPasscodeNotSet=kLAErrorPasscodeNotSet,</div><div class="line"></div><div class="line">	/// 指纹不正确</div><div class="line">	LAErrorTouchIDNotAvailable=kLAErrorTouchIDNotAvailable,</div><div class="line"></div><div class="line">	/// 没有录入指纹</div><div class="line">	LAErrorTouchIDNotEnrolled=kLAErrorTouchIDNotEnrolled,</div><div class="line"></div><div class="line">	/// TouchID被锁定</div><div class="line">	LAErrorTouchIDLockoutNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorTouchIDLockout,</div><div class="line"></div><div class="line">	/// App取消验证</div><div class="line">	LAErrorAppCancelNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorAppCancel,</div><div class="line"></div><div class="line">	/// 无效的上下文环境</div><div class="line">	LAErrorInvalidContextNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorInvalidContext</div><div class="line">&#125;NS_ENUM_AVAILABLE(10_10,8_0);</div></pre></td></tr></table></figure>
<p>而前四种error是针对于能确定使用验证后，在验证后返回的错误</p>
<p>后六种error是针对于不能使用验证的原因</p>
<p>你可以针对这些原因做一些相应的操作，比如弹窗等等</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TouchID验证这个在iOS8中已经对开发者开放使用了，而且需在5s以上真机才能使用，这个出来已经比较早了，相信很多人都应该已经知道怎么使用TouchID了，但是就目前我使用的App来说，看到使用TouchID验证的占得数量并不多，对于一些涉及到安全性的App来说，很有可能你的解锁验证、App登录以及支付验证都是用的TouchID使用TouchID验证还是有风险的，但是有些App增加使用TouchID作为一种验证还是不错的选择，既快捷又方便，对于开发者来说增加的成本也很低&lt;/p&gt;
    
    </summary>
    
    
      <category term="TouchID" scheme="http://yuzeyang.github.io/tags/TouchID/"/>
    
  </entry>
  
  <entry>
    <title>iOS 基于GCDAsyncSocket快速开发Socket通信</title>
    <link href="http://yuzeyang.github.io/2016/01/17/GCDAsyncSocket-socket/"/>
    <id>http://yuzeyang.github.io/2016/01/17/GCDAsyncSocket-socket/</id>
    <published>2016-01-17T14:10:53.000Z</published>
    <updated>2016-08-05T03:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>GCDAsyncSocket是CocoaAsyncSocket第三方库中的其中一个类，本文介绍的就是基于这一个类来做快速的socket通信开发，而且该库已经支持IPv4和IPv6</p>
<p>我们对GCDAsyncSocket做了一层封装调用，它包含了建连、断开、重连、心跳、自定义请求</p>
<a id="more"></a>
<hr>
<p>首先，介绍一下CocoaAsyncSocket第三方库的用途</p>
<blockquote>
<p>CocoaAsyncSocket provides easy-to-use and powerful asynchronous socket libraries for Mac and iOS. </p>
</blockquote>
<p>翻译成：</p>
<blockquote>
<p>CocoaAsyncSocket为Mac和iOS提供了易于使用且强大的异步通信库</p>
</blockquote>
<p>在Podfile文件中，只要加上这句话就可以使用了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;CocoaAsyncSocket&apos;, &apos;7.4.1&apos;</div></pre></td></tr></table></figure>
<hr>
<p>简单的Socket通信包括了建连、断开连接、发送socket业务请求、重连这四个基本功能</p>
<p>下面，我就按照这个四个基本功能来讲一下，怎么来使用CocoaAsyncSocket中GCDAsyncSocket这个类来开发Socket通信</p>
<p>首先，Socket在第一步时，需要建连才能开始通信</p>
<p>在GCDAsyncSocket中提供了四种初始化的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (id)init;</div><div class="line">- (id)initWithSocketQueue:(dispatch_queue_t)sq;</div><div class="line">- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq;</div><div class="line">- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq;</div><div class="line"></div><div class="line">@property (atomic, weak, readwrite) id delegate;</div><div class="line">#if OS_OBJECT_USE_OBJC</div><div class="line">@property (atomic, strong, readwrite) dispatch_queue_t delegateQueue;</div><div class="line">#else</div><div class="line">@property (atomic, assign, readwrite) dispatch_queue_t delegateQueue;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>sq是socket的线程，这个是可选的设置，如果你写null，GCDAsyncSocket内部会帮你创建一个它自己的socket线程，如果你要自己提供一个socket线程的话，千万不要提供一个并发线程，在频繁socket通信过程中，可能会阻塞掉，个人建议是不用创建</p>
<p>aDelegate就是socket的代理</p>
<p>dq是delegate的线程</p>
<p>必须要需要设置socket的代理以及代理的线程，否则socket的回调你压根儿就不知道了，</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.socket =[[GCDAsyncSocket alloc] initWithDelegate:delegate delegateQueue:dispatch_get_main_queue()];</div></pre></td></tr></table></figure>
<p>接着，在设置代理之后，你需要尝试连接到相应的地址来确定你的socket是否能连通了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (BOOL)connectToHost:(NSString *)host</div><div class="line">               onPort:(uint16_t)port</div><div class="line">          withTimeout:(NSTimeInterval)timeout</div><div class="line">                error:(NSError **)errPtr;</div></pre></td></tr></table></figure>
<p>host是主机地址，port是端口号</p>
<p>如果建连成功之后，会收到socket成功的回调，在成功里面你可以做你需要做的一些事情，我这边的话，是做了心跳的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port;</div></pre></td></tr></table></figure>
<p>如果建连失败了，会收到失败的回调，我这边在失败里面做了重连的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err;</div></pre></td></tr></table></figure>
<p>重连操作其实比较简单，只需要再调用一次建连请求，我这边设置的重连规则是重连次数为5次，每次的时间间隔为2的n次方，超过次数之后，就不再去重连了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)socketDidDisconnect:(GCDAsyncSocket*)sock withError:(NSError*)err &#123;</div><div class="line"></div><div class="line">	self.status= -1;</div><div class="line"></div><div class="line">	if(self.reconnection_time&gt;=0 &amp;&amp; self.reconnection_time &lt;= kMaxReconnection_time) &#123;</div><div class="line"></div><div class="line">		[self.timer invalidate];</div><div class="line"></div><div class="line">		self.timer=nil;</div><div class="line"></div><div class="line">		int time =pow(2,self.reconnection_time);</div><div class="line"></div><div class="line">		self.timer= [NSTimer scheduledTimerWithTimeInterval:time target:selfselector:@selector(reconnection) userInfo:nil repeats:NO];</div><div class="line"></div><div class="line">		self.reconnection_time++;</div><div class="line"></div><div class="line">		NSLog(@&quot;socket did reconnection,after %ds try again&quot;,time);</div><div class="line"></div><div class="line">	&#125; else &#123;</div><div class="line"></div><div class="line">		self.reconnection_time=0;</div><div class="line"></div><div class="line">		NSLog(@&quot;socketDidDisconnect:%p withError: %@&quot;, sock, err);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我用status来标记socket的连接状态</p>
<p>那么socket已经建连了，该怎么发起socket通信呢？</p>
<p>你需要和后端开发人员商定好socket协议格式，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[NSString stringWithFormat:@&quot;&#123;\&quot;version\&quot;:%d,\&quot;reqType\&quot;:%d,\&quot;body\&quot;:\&quot;%@\&quot;&#125;\r\n&quot;,PROTOCOL_VERSION,reqType,reqBody];</div></pre></td></tr></table></figure>
<p>中间应该大家都能看得懂，那为什么后面需要加上\r\n呢？</p>
<p>这个\r\n是socket消息的边界符，是为了防止发生消息黏连，没有\r\n的话，可能由于某种原因，后端会收到两条socket请求，但是后端不知道怎么拆分这两个请求</p>
<p>同理，在收到socket请求回调时，也会根据这个边界符去拆分</p>
<p>那为什么要用\r\n呢？</p>
<p>而且GCDAsyncSocket不支持自定义边界符，它提供了四种边界符供你使用\r\n、\r、\n、空字符串</p>
<p>在拼装好socket请求之后，你需要调用GCDAsyncSocket的写方法，来发送请求，然后在写完成之后你会收到写的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.socket writeData:requestData withTimeout:-1 tag:0];</div></pre></td></tr></table></figure>
<p>timeout是超时时间，这个根据实际的需要去设置</p>
<p>这个是写的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)socket:(GCDAsyncSocket*)sock didWriteDataWithTag:(long)tag；</div></pre></td></tr></table></figure>
<p>在写之后，需要再调用读方法，这样才能收到你发出请求后从服务器那边收到的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.socketreadDataToData:[GCDAsyncSocket CRLFData] withTimeout:10 maxLength:50000 tag:0];</div></pre></td></tr></table></figure>
<p>[GCDAsyncSocket CRLFData]这里是设置边界符，maxLength是设置你收到的请求数据内容的最大值</p>
<p>在读回调里面，你可以根据不同业务来执行不同的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)socket:(GCDAsyncSocket*)sock didReadData:(NSData*)data withTag:(long)tag;</div></pre></td></tr></table></figure>
<p>最后一个则是断开连接，这个只需要调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.socket disconnect];</div></pre></td></tr></table></figure>
<p>ok，这样的话，最简单基础的socket通信，你已经大致能完成了~</p>
<hr>
<p>2016.4.26更新</p>
<p>在网络环境以及其他因素下，很有可能会造成客户端或者后端没有接收到回调或者请求，那该怎么办？</p>
<p>我们需要加上消息回执的处理</p>
<p>客户端发出请求的时候，可以将该请求放到存到数组里面，等到后端的相应回调在移除掉，如果该请求超时或者在一段时间内没有收到确认返回，说明后端没有接收到我们的请求，我们可以将该请求重新发送</p>
<p>客户端接收请求的时候，后端将数据发给客户端，客户端需要增加回执处理，告诉后端，客户端接收到数据了，如果后端没接收到，也重新推一遍数据，客户端和后端双向保护来解决丢失问题</p>
<p>2016.8.5更新</p>
<p>有些时候，不能定位是否是后端问题还是客户端/SDK问题的时候，可以用命令行抓一下socket包看看（用Charles只能抓http和https包）</p>
<p>命令行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i any -n -X port 7070</div></pre></td></tr></table></figure>
<p>Tip：7070端口号请根据实际的调试端口号修改</p>
<p>效果如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/socketPacket.png" alt=""></p>
<p>红色部分就是socket包的内容了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCDAsyncSocket是CocoaAsyncSocket第三方库中的其中一个类，本文介绍的就是基于这一个类来做快速的socket通信开发，而且该库已经支持IPv4和IPv6&lt;/p&gt;
&lt;p&gt;我们对GCDAsyncSocket做了一层封装调用，它包含了建连、断开、重连、心跳、自定义请求&lt;/p&gt;
    
    </summary>
    
    
      <category term="GCDAsyncSocket,Socket" scheme="http://yuzeyang.github.io/tags/GCDAsyncSocket-Socket/"/>
    
  </entry>
  
  <entry>
    <title>零下三十度的哈尔滨之行</title>
    <link href="http://yuzeyang.github.io/2016/01/12/Harbin-travel/"/>
    <id>http://yuzeyang.github.io/2016/01/12/Harbin-travel/</id>
    <published>2016-01-12T11:37:10.000Z</published>
    <updated>2016-05-18T15:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在年假过期之前，我和同事们想着用这个年假去哪儿浪，后来商量之后，决定去一趟哈尔滨看看，当然对于一直从未感受过零下十度以下的南方汉子们，特别是IT宅男们来说，那里的冷是根本想象不到的。（多图预警！！！）</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/afraid.jpg" alt=""></p>
<p>我们定在1月7日出发，刚好和元旦错开了，但是没办法，冰雪节在元旦之后才开始..哎，不然玩的时间就更长了。</p>
<p>前期的准备还是很重要的！</p>
<p><strong>1.帽子-防风防寒</strong></p>
<p><strong>2.口罩-棉/厚（戴眼镜的人极其痛苦…根本不能带口罩）</strong></p>
<p><strong>3.围巾-厚</strong></p>
<p><strong>4.耳套</strong></p>
<p><strong>5.保暖内衣.羊毛衫.抓绒外套.羽绒服 至少四层</strong></p>
<p><strong>6.棉毛裤.棉裤.冲锋裤 至少穿三层</strong></p>
<p><strong>7.厚袜子 至少两双</strong></p>
<p><strong>8.手套</strong></p>
<p><strong>9.棉鞋.雪地靴</strong></p>
<p><strong>10.雪套（这个好像我带去都没有用到）</strong></p>
<p><strong>11.保温杯</strong></p>
<p><strong>12、暖宝宝（这个用到的时间不是很多，不过站在雪地的时候，可以贴一个在脚底抵挡一些寒冷）</strong></p>
<p>千等万等，终于等到出发的日子了，我们一行人也是高高兴兴的粗发啦，坐的是四川航空，空姐和空少都有点胖胖的…好桑心…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/INeedAV.jpg" alt=""></p>
<p>从杭州到哈尔滨的飞机需要三个小时左右的行程，快到哈尔滨的时候，从飞机上往下看，地都是雪白雪白的，这叫尔等南方来的汉子们很是激动啊，白茫茫的一片~</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/snow.jpeg!600x600" alt="飞机上俯瞰的雪景"></p>
<p>飞机降落之后，我们打车到中央大街，在打车的时候要注意一点，有些司机会向你收取<strong>高速路的过路费</strong>，并且让你取消订单，用现金支付。现金支付是可以的，因为听说最近某滴已经开始向司机收取好像20%的服务费了，但<strong>你千万不要给司机高速路的过路费</strong>，因为高速路的过路费，在从哈尔滨到机场的路上，有其他乘客已经帮你付了，这个是没有办法的，但是返程从机场到哈尔滨是不用付的，这个是司机想多赚你的钱！</p>
<p>在进过的路上，我也不知道什么路…有用冰砖搭的一座城，很是漂亮，从没有近距离的看过…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/snow2.jpeg!600x600" alt="冰城"></p>
<p>经过快一个小时的车程（还是有点堵的），到了中央大街，据说这个一条非常热闹而且有名的街（因为之前吃住全是另外一个同事订好的..所以我都没有提前去了解..），下了飞机之后感觉瞬间变冷，得赶紧去旅馆加上衣服，基本按照上面必备的那么穿就不冷了，哈尔滨的天气衣服穿够了，身上不冷，但是风打在脸上还是很冷的，时间一长，鼻子就受不了了。</p>
<p>逛中央大街的时候，门口就有个烤肠，非常好吃！但是不要买多…吃了一两根之后我感觉就有点吃不下了…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/xiangchang.jpeg!600x600" alt="烤肠"></p>
<p>在旅馆门口还有一个用冰砖搭起来的滑梯，要收费，10元滑一次，因为想到晚上要去冰雪大世界了，也就没上去玩了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/binghuati.jpeg!600x600" alt="冰滑梯"></p>
<p>中央大街上面有很多非常有特色店：马迭尔冰棍（这个冰棍买的人特别多），华梅西餐厅（据说连哈尔滨人也都排队还吃不上，最后一天我们想去吃，但是排队的人实在太多了，就没吃了，好可惜），老厨家（这个很有历史也很好吃）等等，那里的店大多都很有特色</p>
<p>沿着中央大街走就可以走到防洪纪念塔，在纪念塔后面就是松花江，江面全部都结冰了，看得我都傻了..上面都是游人在滑冰，玩耍，冰面还是比较滑的，要小心，里面的娱乐项目看情况选择玩吧，出来玩，开心还是最重要的（我一般都是这么想的，飞机票、吃住都花了这么多了，不差这点娱乐的钱了…）</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/songhuajiang.jpeg!600x600" alt="松花江"></p>
<p>晚上就出发去了冰雪大世界玩，在那里鞋一定要穿暖，因为有些项目是需要排队的，站那脚特别冷..而且可以考虑先去排队玩大滑梯，据说很刺激，但是因为排队的人太多了，我们就很遗憾的没有去玩了，里面玩的都是滑梯，看冰雕，感受下冰的魅力，对于南方来的我们玩的还是非常开心的~但是很遗憾我没有找到冰雪大世界的照片，不过同事那里有，之后我会更新上来</p>
<p>在冰雪大世界这么疯狂的消耗体力之后，肯定会饿了，我们用美团搜到了一家非常好吃的烧烤店叫1981烧烤（好像是这个名字），价格也不贵，烤的非常好吃，以致于有个同事一连三天拉着我吃烧烤，别说，北方的烧烤还真的比南方要好吃一点，哈哈</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/1981shaokao.jpeg!600x600" alt="1981烧烤"></p>
<p>第二天，我们选择去了雪乡，听说那里是因为拍了爸爸去哪了之后，才火起来的，但是因为客服的原因，把我们的名单弄错了，导致没坐上大巴车，结果搞了辆小面包，后面的事情就更凄惨了…雪乡的路上有个坡，路面滑，怎么都上不去，装防滑条，断了，装防滑链，装不上…啊…真的是日了够了，搞了一两个小时，本来出发时间就耽搁了，这么一搞就更晚了，结果一辆路过的大巴车救了我们，达到雪乡花了我们12个小时…醉了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/zhuangfanghualian.jpeg!600x600" alt="装防滑链"></p>
<p>但是雪乡沿途的风景还是很漂亮的，厚厚的雪，还有雾凇</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/xuejing.jpeg!600x600" alt="雪景"></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/wusong.jpeg!600x600" alt="雾凇"></p>
<p>到雪乡之后，就是夜晚了，虽然还是5点多钟，但天黑的特别早，雪乡一进来就给人的感觉是商业化比较严重，已经很难看出原来的风土人情了。雪乡里面能看到雪橇犬，还是马拉车，车还是有牌照的…</p>
<p>我们因为路途的劳累也没出去逛，雪乡之行还是意外的可惜，草草的就结束了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/xuexiangyejing.jpeg!600x600" alt="雪乡夜景"></p>
<p>我们一行人睡的是五人炕，但是后来听北方的同事说，那个好像是电子炕，不是火烧那种了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/wurenkang.jpeg!600x600" alt="五人炕"></p>
<p>在那里我们买了冰柿子，冰草莓，冰梨，发现太硬了太冷了…后来放那软了就扔了…后来听说那个是要放冷水里化开了再吃的…吃的..的，我们就忧伤了…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/bingcaomei.jpeg!600x600" alt="冰草莓"></p>
<p>第三天我们就从雪乡出发，去往亚布力滑雪，第一次滑雪的我来说可兴奋了ヾ(o◕∀◕)ﾉヾ，同事说去30°坡的滑雪场，我说太平了是不是不好玩，我说要45°的，后来少数服从多数，我们还是去了30°的滑雪场，到那里存好东西之后，有条件的可以请个教练带一带你，没有的，可以让会的同事带你，不然就像我一样，从坡上面一直摔到了坡下面….因为不懂怎么刹车…就一直摔…好疼…而且穿着滑雪鞋，容易崴脚，最后我去了儿童区，还是摔/(ㄒoㄒ)/~~</p>
<p>回来的晚上我们好好的逛了下中央大街，在老厨家吃了顿放，和北方的同事聚了一下，总结了一下北方的菜有点咸，但是量特足，5个人基本点3个菜就差不多了</p>
<p>中央大街的夜景也非常漂亮，街道两旁都有大型的冰雕，品牌赞助…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/shengdanshu.jpeg!600x600" alt="圣诞树"></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/beijixiong.jpeg!600x600" alt="北极熊小屋"></p>
<p>最后一天我们就去了圣索菲亚大教堂，据说教堂里面是没有什么好看的，都是买纪念品，只要外面参观下就可以了，而且有鸽子的区域没有我想象中的那么大，就那一小块地方…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/jiaotang.jpeg!600x600" alt="教堂正面"></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/gezi.jpeg!600x600" alt="教堂旁的鸽子"></p>
<p>匆匆的哈尔滨之行就愉快的结束了，好期待下一次的旅行~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在年假过期之前，我和同事们想着用这个年假去哪儿浪，后来商量之后，决定去一趟哈尔滨看看，当然对于一直从未感受过零下十度以下的南方汉子们，特别是IT宅男们来说，那里的冷是根本想象不到的。（多图预警！！！）&lt;/p&gt;
    
    </summary>
    
    
      <category term="哈尔滨" scheme="http://yuzeyang.github.io/tags/%E5%93%88%E5%B0%94%E6%BB%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS TableView上拉下拉刷新控件（二）</title>
    <link href="http://yuzeyang.github.io/2016/01/06/iOS_TableView_refresh_controller-two/"/>
    <id>http://yuzeyang.github.io/2016/01/06/iOS_TableView_refresh_controller-two/</id>
    <published>2016-01-06T14:59:44.000Z</published>
    <updated>2016-05-17T15:22:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇我们来讲如何将loading圆圈动画和TableView结合起来一起使用。</p>
<a id="more"></a>
<p>首先，我们需要将loading圆圈和提示label加到一个view上去显示，实现的主要点有两点：第一，在上拉或者下拉的过程中，我们通过progress值去控制loading圆圈的动画和label的alpha值，第二，通过设置拉动的方向来设置label提示的内容</p>
<p>然后，我们该怎么去获得这个progress值呢？</p>
<p>首先，我们在初始化的时候需要监听所关联的scrollView的contentOffset值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.scrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</div></pre></td></tr></table></figure>
<p>然后在observeValueForKeyPath里面，我们获取contentOffset的最新值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGPoint contentOffset = [[change valueForKey:NSKeyValueChangeNewKey] CGPointValue];</div></pre></td></tr></table></figure>
<p>然后再通过计算来改变progress值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.progress = MAX(0.0, MIN(fabs((self.originOffset + contentOffset.y)/kMaxPullDownDistance), 1.0));</div></pre></td></tr></table></figure>
<p>（注：在这里有个originOffset值，这个是我用来处理是否有导航栏的情况，有则该值为64.0，没有则为0.0）</p>
<p>计算的思路是我们通过所关联的scrollView的contentOffset与我们所设置的最大的拉动距离值相除作比较，得到的就是拉动的一个范围比例，因为contentOffset会超出我们设置的最大拉动距离，所以我们需要再取最小最大值，来获取到最后的progress值。</p>
<hr>
<p>在这里插一个小的知识点，因为这个是在写上拉时，所必须知道的一个点，contentOffset是怎么算的？</p>
<p>contentOffset是scrollview当前显示区域顶点相对于frame顶点的偏移量</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/contentOffset.png" alt=""></p>
<p>但当上拉刷新之后，此时scrollview的contentSize变化了，（contentSize指的是可显示区域），在计算contentOffset时，需要将contentSize减去scrollView的高度，来和contentOffset作比较。</p>
<p>拿到progress之后，此时我们离完成这个控件的任务就差不多了。</p>
<p>首先，我们需要将progress赋值给loading圆圈和提示label，</p>
<p>然后如果我们拉动的距离超过了设置最大值的时候，我们做loading，并且通过block让外部做一些网络请求或者其他的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[self startLoading:self.refreshView];</div><div class="line">                </div><div class="line">// 0.3s animation time is the best experience</div><div class="line">[UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">    self.scrollView.contentInset = UIEdgeInsetsMake(kMaxPullDownDistance + self.originOffset, 0, 0, 0);</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">    if (self.refreshingBlock) &#123;</div><div class="line">        self.refreshingBlock();</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>在上拉时，有一点不同，scrollView的contentSize可能是会变化的，而我们的控件是要始终显示在它的最下方的，所以我们在上拉时，需要对contentSize也加监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.scrollView addObserver:self forKeyPath:@&quot;contentSize&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</div></pre></td></tr></table></figure>
<p>并且在observeValueForKeyPath里面，需要设置控件的center来改变我们的显示位置，以及progress值，其他操作都和下拉刷新一样。</p>
<p>ok，我们的上拉下拉刷新控件完成喽~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇我们来讲如何将loading圆圈动画和TableView结合起来一起使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TableView" scheme="http://yuzeyang.github.io/tags/TableView/"/>
    
  </entry>
  
  <entry>
    <title>iOS TableView上拉下拉刷新控件（一）</title>
    <link href="http://yuzeyang.github.io/2016/01/05/iOS_TableView_refresh_controller_one/"/>
    <id>http://yuzeyang.github.io/2016/01/05/iOS_TableView_refresh_controller_one/</id>
    <published>2016-01-05T14:29:07.000Z</published>
    <updated>2016-05-17T15:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>注：此刷新控件的效果是来自KittenYang的一个GIF图，他有很多动画分析和写得都不错，大家可以关注一下~</p>
<p>推荐一个非常好的动画效果网站：<a href="http://uimovement.com/" target="_blank" rel="external">UI Movement</a>，里面很多设计出的动画效果都非常好，都可以一一实现看看哦</p>
<a id="more"></a>
<hr>
<p>话不多说，先看下我要讲的刷新控件效果：</p>
<p>1.无导航栏的刷新控件效果图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/TableRefreshAnimation1.gif" alt=""></p>
<p>2.有导航栏的刷新控件效果图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/TableRefreshAnimation2.gif" alt="">            </p>
<hr>
<p>好了，进入正题。</p>
<p>首先看到这个控件的时候，我们要去分析，这个控件是由哪几部分组成的，可以看到这个控件是只是由一个loading圆圈和label提示文字组成的，而label比较简单，在这里我就不具体说怎么实现了，大家可以直接看源码，这篇文章，我主要讲怎么实现这个loading圆圈的转圈效果。</p>
<p>首先这个转圈分成两部分，我们将它分成0.0-0.5和0.5-1.0这两个阶段。</p>
<p>在0.0-0.5这个过程的动画是这样的：</p>
<p>​    <img src="http://7xtit4.com1.z0.glb.clouddn.com/refresh0-0.5.gif" alt=""></p>
<p>以左边的线为例，上顶点为B点，下顶点为A点，实际上这个过程只是，A，B两点的y值在随着progress的变化而变化，x是不变的，所以我们可以得到A，B两点的坐标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGPoint leftA = CGPointMake(kCenterX - kLineLength, kCenterY + 2*kLineLength - self.progress/0.5*kLineLength);</div><div class="line">CGPoint leftB = CGPointMake(leftA.x, leftA.y - kLineLength);</div></pre></td></tr></table></figure>
<p>然后我们用贝塞尔曲线，将两点连起来，从A点到B点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[leftPath moveToPoint:leftA];</div><div class="line">[leftPath addLineToPoint:leftB];</div></pre></td></tr></table></figure>
<p>那这个尖角怎么办呢？我们利用以前学过的数学知识，假设尖角的角度是30°，那x值就是leftB.x-kArrowLength<em>sin(kArrowAngle)，y值就是leftB.y+kArrowLength</em>cos(kArrowAngle)，假设这个点是C点，最后就是将C点和B点相连</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[arrowPath moveToPoint:leftB];</div><div class="line">[arrowPath addLineToPoint:CGPointMake(leftB.x - kArrowLength*sin(kArrowAngle), leftB.y + kArrowLength*cos(kArrowAngle))];</div><div class="line">[leftPath appendPath:arrowPath];</div></pre></td></tr></table></figure>
<p>这样我们就完成了0.0-0.5的动画，这个一部分还是比较简单的。</p>
<p>下面是0.5-1.0的动画过程：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/refresh0.5-1.gif" alt=""></p>
<p>当到达0.5的时候，原先的B点开始保持不动，它的位置始终是CGPointMake(kCenterX-kLineLength,kCenterY)，而A点也渐渐向B点靠近，CGPointMake(kCenterX-kLineLength,kCenterY+kLineLength- (self.progress-0.5)/0.5*kLineLength)，那这个圆弧是怎么出来的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);</div></pre></td></tr></table></figure>
<p>在绘制贝塞尔曲线里面，有一个绘制圆弧的方法，center是以某一个点为圆心绘制圆弧，</p>
<p>radius是半径，startAngle是开始角度，endAngle是结束角度，clockwise是是否以顺时针绘制，ok，我们就用这个来绘制我们的圆弧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[leftPath moveToPoint:leftA];</div><div class="line">[leftPath addLineToPoint:leftB];</div><div class="line">[leftPath addArcWithCenter:CGPointMake(kCenterX, kCenterY) radius:kLineLength startAngle:M_PI endAngle:M_PI+M_PI*(self.progress - 0.5)/0.5*9/10 clockwise:YES];</div></pre></td></tr></table></figure>
<p>恩，圆弧也画好了，那我们的尖角是不是也按照刚才的那样写就可以了？恩，差不多哦，只是我们在原有尖角30°的基础上，需要加上我们圆弧旋转的角度，才是真正尖角与圆弧顶点的切线角度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGPointMake(leftPath.currentPoint.x - kArrowLength*sin(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10),leftPath.currentPoint.y + kArrowLength*cos(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10))</div></pre></td></tr></table></figure>
<p>好了，尖角顶点也知道了，那连接只要和原来一样就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[arrowPath moveToPoint:leftPath.currentPoint];</div><div class="line">[arrowPath addLineToPoint:CGPointMake(leftPath.currentPoint.x - kArrowLength*sin(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10),</div><div class="line">                                              leftPath.currentPoint.y + kArrowLength*cos(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10))];</div><div class="line">[leftPath appendPath:arrowPath];</div></pre></td></tr></table></figure>
<p>好了，左边的动画是这样，右边的只要对称即可~</p>
<p>是不是看上去比较复杂的动画，将它分解开来，就变得简单了呢？</p>
<p>下一篇，我会讲怎么将这个动画和tableview结合起来使用~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：此刷新控件的效果是来自KittenYang的一个GIF图，他有很多动画分析和写得都不错，大家可以关注一下~&lt;/p&gt;
&lt;p&gt;推荐一个非常好的动画效果网站：&lt;a href=&quot;http://uimovement.com/&quot;&gt;UI Movement&lt;/a&gt;，里面很多设计出的动画效果都非常好，都可以一一实现看看哦&lt;/p&gt;
    
    </summary>
    
    
      <category term="TableView" scheme="http://yuzeyang.github.io/tags/TableView/"/>
    
  </entry>
  
  <entry>
    <title>TextField字数限制处理</title>
    <link href="http://yuzeyang.github.io/2015/09/17/TextField_count_limit_handle/"/>
    <id>http://yuzeyang.github.io/2015/09/17/TextField_count_limit_handle/</id>
    <published>2015-09-17T14:40:44.000Z</published>
    <updated>2016-05-16T15:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在第三方键盘加入之后，对于字数限制的处理不再像之前那么简单了</p>
<a id="more"></a>
<p>纯数字、字符输入（不包括粘贴）这样的字数限制还是相对比较简单的，你可以用两种方法进行处理</p>
<p>第一种是<strong>textfield的delegate</strong>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123;</div><div class="line">    if (range.length + range.location &gt; textField.text.length) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    NSUInteger newLength = textField.text.length + string.length - range.length;</div><div class="line">    return newLength&lt;=kMaxCharacterCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种<strong>是注册一个通知</strong>，在textfield编辑时做处理：</p>
<p>首先你在viewDidLoad中注册通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFiledEditChanged:) name:UITextFieldTextDidChangeNotification object:self.shopName];</div></pre></td></tr></table></figure>
<p>再实现通知里面的方法，在超过最大值时，取最大的字数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (self.shopName.text.length &gt; kMaxCharacterCount) &#123;</div><div class="line">        self.shopName.text = [self.shopName.text substringToIndex:kMaxCharacterCount];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，在中文的限制上面情况就复杂了，当时在调试的时候，因为使用的是第三方键盘，所以当时没有发现问题，但是在使用系统键盘的时候，一下子就蛋疼了….</p>
<p>下面我开始分析一下，两者的区别：</p>
<p>1、第三方键盘在输入字符时，一般是不会将字符直接输入到textfield中，而是将字符显示在它自己的view上方，但是系统键盘会直接输入到textfield中，而且它会占2个字符长度，比如你输入”abcd”，在textfield中显示的是”a b c d”，并且”a b c d”是处在高亮中的，并不算是真正输入到textfield中，所以我们不应把高亮的字符计算在内，我们应该计算真正输入的字符</p>
<p>2、如果我们使用的是delegate做处理的时候，系统中文输入的时候会有联想，但是联想的那个字并不会调用delegate，比如你输入一个”你”，在系统的联想里面可能会出现”的”,”们”这样的联想，但是你选择”的”的时候，delegate并不会调用，（尼玛….），我猜想联想输入应该不算做keyboard所触发的事件，所以他并不会触发delegate，但是如果你注册的是通知，他倒是会调用，（还好有救）</p>
<p>另外提醒一下，有时候在自测输入的时候，要考虑全面，比如粘贴这也是一种输入，当时没考虑，我也是跪了</p>
<p>好了，分析了主要的区别下面我们就来看看具体怎么实现吧~</p>
<p>在实现注册通知方法里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#pragma mark - UITextViewDelegate</div><div class="line">- (void)textViewDidChange:(UITextView *)textView &#123;</div><div class="line">    if (textView.text.length == 0) &#123;</div><div class="line">        self.recommendTips.hidden = NO;</div><div class="line">    &#125;else&#123;</div><div class="line">        self.recommendTips.hidden = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSString *toBeString = textView.text;</div><div class="line">    NSString *lang = self.textInputMode.primaryLanguage; // 键盘输入模式</div><div class="line">    if ([lang isEqualToString:@&quot;zh-Hans&quot;]) &#123; // 简体中文输入，包括简体拼音，健体五笔，简体手写</div><div class="line">        UITextRange *selectedRange = [textView markedTextRange];</div><div class="line">        //获取高亮部分</div><div class="line">        UITextPosition *position = [textView positionFromPosition:selectedRange.start offset:0];</div><div class="line">        // 没有高亮选择的字，则对已输入的文字进行字数统计和限制</div><div class="line">        if (!position || !selectedRange) &#123;</div><div class="line">            if (toBeString.length &gt; 200) &#123;</div><div class="line">                textView.text = [toBeString substringToIndex:200];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 有高亮选择的字符串，则暂不对文字进行统计和限制</div><div class="line">        else&#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况</div><div class="line">    else&#123;</div><div class="line">        if (toBeString.length &gt; 200) &#123;</div><div class="line">            textView.text = [toBeString substringToIndex:200];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们根据键盘的输入模式进行区分，英文的比较简单就和上面一样，直接取最大的字符数就好了，在中文输入的时候，我们用markedTextRange方法获取到当前的光标位置，再用textField positionFromPosition:selectedRange.start offset:0获取到高亮部分，然后判断是否有高亮，这个时候系统会调用两次通知方法，第一次是将高亮的字符输入，第二次是将高亮的字符转换成中文输入（这个时候就没有高亮了，然后再取最大的字符数），但是在iOS7的设备上测试时发现，position都不会为nil，在iOS8以上都正常，但是获取到光标的range，却是正常的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NS_CLASS_AVAILABLE_IOS(3_2) @interface UITextRange : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, readonly, getter=isEmpty) BOOL empty;     //  Whether the range is zero-length.</div><div class="line">@property (nonatomic, readonly) UITextPosition *start;</div><div class="line">@property (nonatomic, readonly) UITextPosition *end;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们可以看到系统的UITextRange，有两个变量，一个是start，一个是end，这正是对于的高亮区域！</p>
<p>所以既然position不能使用，那我们干脆就使用range，通过判断range的存在，来对文字进行限制处理。（粘贴也适用）</p>
<p>结果也是棒棒的！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第三方键盘加入之后，对于字数限制的处理不再像之前那么简单了&lt;/p&gt;
    
    </summary>
    
    
      <category term="TextField" scheme="http://yuzeyang.github.io/tags/TextField/"/>
    
  </entry>
  
</feed>
