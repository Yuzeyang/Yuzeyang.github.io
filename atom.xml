<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宫城</title>
  <subtitle>Talk is cheap,show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuzeyang.github.io/"/>
  <updated>2016-05-12T08:45:07.000Z</updated>
  <id>http://yuzeyang.github.io/</id>
  
  <author>
    <name>宫城</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo搭建GitHub blog</title>
    <link href="http://yuzeyang.github.io/2016/04/29/hexo_build_github_blog/"/>
    <id>http://yuzeyang.github.io/2016/04/29/hexo_build_github_blog/</id>
    <published>2016-04-28T16:00:00.000Z</published>
    <updated>2016-05-12T08:45:07.000Z</updated>
    
    <content type="html">&lt;p&gt;如果你厌倦了使用了第三方的博客平台，你可以考虑一下用hexo和github来搭建自己的博客&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;用hexo来搭建github blog很简单，只需要五步~&lt;/p&gt;
&lt;h4 id=&quot;1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot;&gt;&lt;a href=&quot;#1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot; class=&quot;headerlink&quot; title=&quot;1.在github上面新建一个仓库&quot;&gt;&lt;/a&gt;1.在github上面新建一个仓库&lt;/h4&gt;&lt;p&gt;首先我们需要在自己的github上新建一个仓库，将仓库的命名为xxx.github.io，一定要按该格式命名，否则不能搭建成功&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;2-_u914D_u7F6E_u73AF_u5883&quot;&gt;&lt;a href=&quot;#2-_u914D_u7F6E_u73AF_u5883&quot; class=&quot;headerlink&quot; title=&quot;2.配置环境&quot;&gt;&lt;/a&gt;2.配置环境&lt;/h4&gt;&lt;p&gt;在使用搭建之前，我们需要配置好下面环境&lt;/p&gt;
&lt;h4 id=&quot;u5B89_u88C5Homebrew&quot;&gt;&lt;a href=&quot;#u5B89_u88C5Homebrew&quot; class=&quot;headerlink&quot; title=&quot;安装Homebrew&quot;&gt;&lt;/a&gt;安装Homebrew&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ruby -e &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u5B89_u88C5node-js&quot;&gt;&lt;a href=&quot;#u5B89_u88C5node-js&quot; class=&quot;headerlink&quot; title=&quot;安装node.js&quot;&gt;&lt;/a&gt;安装node.js&lt;/h4&gt;&lt;p&gt;node.js集成带有了npm&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u5B89_u88C5hexo-cli&quot;&gt;&lt;a href=&quot;#u5B89_u88C5hexo-cli&quot; class=&quot;headerlink&quot; title=&quot;安装hexo-cli&quot;&gt;&lt;/a&gt;安装hexo-cli&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3-_u5728blog_u76EE_u5F55_u4E0B_uFF0C_u521D_u59CB_u5316hexo&quot;&gt;&lt;a href=&quot;#3-_u5728blog_u76EE_u5F55_u4E0B_uFF0C_u521D_u59CB_u5316hexo&quot; class=&quot;headerlink&quot; title=&quot;3.在blog目录下，初始化hexo&quot;&gt;&lt;/a&gt;3.在blog目录下，初始化hexo&lt;/h4&gt;&lt;p&gt;接下来我们需要新建一个文件夹来存放blog内容，假设我新建了一个blog文件夹，然后我cd到该路径下面，然后我们需要对该目录进行初始化，运行&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init $&amp;#123;blog&amp;#36335;&amp;#24452;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/hexoinit.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（图中中间出现的报错不要在意，因为我使用了插件，提示未找到该插件）&lt;/p&gt;
&lt;h4 id=&quot;4-_u751F_u6210_u9759_u6001_u9875_u9762&quot;&gt;&lt;a href=&quot;#4-_u751F_u6210_u9759_u6001_u9875_u9762&quot; class=&quot;headerlink&quot; title=&quot;4.生成静态页面&quot;&gt;&lt;/a&gt;4.生成静态页面&lt;/h4&gt;&lt;p&gt;初始化好之后，我们先来看看页面是不是能正常显示打开了，运行&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等同于&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u6CE8_u610F_uFF1A&quot;&gt;&lt;a href=&quot;#u6CE8_u610F_uFF1A&quot; class=&quot;headerlink&quot; title=&quot;注意：&quot;&gt;&lt;/a&gt;注意：&lt;/h4&gt;&lt;p&gt;第一次部署的时候会因为找不到git而报错，需要安装下，再提交一次&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo-deployer-git --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/hexog.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;5-_u521D_u59CB_u5316_u4F9D_u8D56&quot;&gt;&lt;a href=&quot;#5-_u521D_u59CB_u5316_u4F9D_u8D56&quot; class=&quot;headerlink&quot; title=&quot;5.初始化依赖&quot;&gt;&lt;/a&gt;5.初始化依赖&lt;/h4&gt;&lt;p&gt;在第一次安装运行时，我们需要初始化依赖，否则后面启动服务或者生成静态界面会出错…&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;6-_u542F_u52A8_u670D_u52A1&quot;&gt;&lt;a href=&quot;#6-_u542F_u52A8_u670D_u52A1&quot; class=&quot;headerlink&quot; title=&quot;6.启动服务&quot;&gt;&lt;/a&gt;6.启动服务&lt;/h4&gt;&lt;p&gt;然后我们启动一下服务看看，我们的博客是不是能打开了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/hexoserver.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们打开&lt;a href=&quot;http://0.0.0.0:4000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://0.0.0.0:4000/&lt;/a&gt;看看，如果前面一切顺利的话，你就能看到你搭建成功的博客了~（注意此时打开的还不是自己的github博客地址哦，只是hexo默认配置的地址）&lt;/p&gt;
&lt;h4 id=&quot;7-_u4FEE_u6539blog_u76EE_u5F55_u4E0B_u7684_config-yml_u914D_u7F6E_u6587_u4EF6&quot;&gt;&lt;a href=&quot;#7-_u4FEE_u6539blog_u76EE_u5F55_u4E0B_u7684_config-yml_u914D_u7F6E_u6587_u4EF6&quot; class=&quot;headerlink&quot; title=&quot;7.修改blog目录下的_config.yml配置文件&quot;&gt;&lt;/a&gt;7.修改blog目录下的_config.yml配置文件&lt;/h4&gt;&lt;p&gt;接下来我们需要将hexo打开的博客地址改成自己的地址，打开blog目录下面的_config.yml文件，找到deploy，将部署类型改成git或者GItHub，仓库改成自己的github blog地址格式，分支改成master，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&amp;#10;  type: git    #&amp;#37096;&amp;#32626;&amp;#31867;&amp;#22411;&amp;#10;  repository: https://github.com/Yuzeyang/yuzeyang.github.io.git   #&amp;#37096;&amp;#32626;&amp;#30340;&amp;#20179;&amp;#24211;&amp;#30340;SSH&amp;#10;  branch: master   #&amp;#37096;&amp;#32626;&amp;#20998;&amp;#25903;,&amp;#19968;&amp;#33324;&amp;#20351;&amp;#29992;master&amp;#20027;&amp;#20998;&amp;#25903;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：type/repository/branch:和内容之间是有空格的，而且是一定要有的，否则在重新生成静态页面的时候，会找不到仓库路径&lt;/p&gt;
&lt;h4 id=&quot;8-_u9009_u53D6_u559C_u6B22_u7684_u4E3B_u9898&quot;&gt;&lt;a href=&quot;#8-_u9009_u53D6_u559C_u6B22_u7684_u4E3B_u9898&quot; class=&quot;headerlink&quot; title=&quot;8.选取喜欢的主题&quot;&gt;&lt;/a&gt;8.选取喜欢的主题&lt;/h4&gt;&lt;p&gt;作为爱装逼的程序员怎么能用默认的主题呢，我们可以先在hexo主题网赚挑选一个自己喜欢的主题：&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo主题&lt;/a&gt;，当然你有一定的前端基础可以自己写一套主题玩玩，分享给大家&lt;/p&gt;
&lt;h4 id=&quot;9-_u91CD_u65B0_u90E8_u7F72_u4F60_u7684_u9759_u6001_u7F51_u9875&quot;&gt;&lt;a href=&quot;#9-_u91CD_u65B0_u90E8_u7F72_u4F60_u7684_u9759_u6001_u7F51_u9875&quot; class=&quot;headerlink&quot; title=&quot;9.重新部署你的静态网页&quot;&gt;&lt;/a&gt;9.重新部署你的静态网页&lt;/h4&gt;&lt;p&gt;修改完配置之后，我们重新部署一下，看看效果&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo d -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等同于&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy -generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;10-_u518D_u5237_u65B0_u4E00_u4E0B_u4F60_u7684_u7F51_u9875_uFF0CDuang_7E&quot;&gt;&lt;a href=&quot;#10-_u518D_u5237_u65B0_u4E00_u4E0B_u4F60_u7684_u7F51_u9875_uFF0CDuang_7E&quot; class=&quot;headerlink&quot; title=&quot;10.再刷新一下你的网页，Duang~&quot;&gt;&lt;/a&gt;10.再刷新一下你的网页，Duang~&lt;/h4&gt;&lt;p&gt;因为首页图片加载太慢了…我换了个主题…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/blog.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;11-_u4E0A_u4F20_u6587_u7AE0&quot;&gt;&lt;a href=&quot;#11-_u4E0A_u4F20_u6587_u7AE0&quot; class=&quot;headerlink&quot; title=&quot;11.上传文章&quot;&gt;&lt;/a&gt;11.上传文章&lt;/h4&gt;&lt;p&gt;你可以运行&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &amp;#34;&amp;#26032;&amp;#30340;&amp;#25991;&amp;#31456;&amp;#26631;&amp;#39064;&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样会自动生成好&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;title: Hexo搭建GitHub blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2016-4-29 17:00:00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: Hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者， 把文章放到blog/source/._posts目录下面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/upload.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在文章的内容前面需要加上标题、时间和标签，这样才能在首页显示出你的标题，你也可以添加文章的时间和文章的tag，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;title: Hexo搭建GitHub blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2016-4-29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: Hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再起一下服务，看看有没有修改成功&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;修改成功后，再重新部署一下&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo d -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后再确认一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/update.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上传成功~！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如果你厌倦了使用了第三方的博客平台，你可以考虑一下用hexo和github来搭建自己的博客&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;用hexo来搭建github blog很简单，只需要五步~&lt;/p&gt;
&lt;h4 id=&quot;1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot;&gt;&lt;a href=&quot;#1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot; class=&quot;headerlink&quot; title=&quot;1.在github上面新建一个仓库&quot;&gt;&lt;/a&gt;1.在github上面新建一个仓库&lt;/h4&gt;&lt;p&gt;首先我们需要在自己的github上新建一个仓库，将仓库的命名为xxx.github.io，一定要按该格式命名，否则不能搭建成功&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yuzeyang.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>iOS 同时修改button位置和文字问题</title>
    <link href="http://yuzeyang.github.io/2016/04/09/button-location-title-bug/"/>
    <id>http://yuzeyang.github.io/2016/04/09/button-location-title-bug/</id>
    <published>2016-04-09T03:27:16.000Z</published>
    <updated>2016-05-21T03:39:19.000Z</updated>
    
    <content type="html">&lt;p&gt;今天在写App的登录注册界面，其中登录和注册之间的切换和印象笔记一样&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Evernote.gif!500x500&quot; alt=&quot;印象笔记登录界面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;中间的登录按钮会有一个下移以及更改文字的操作，但是我在加了下移动画之后，再修改按钮的文字，就出现了很奇怪的现象，按钮会先下移然后修改文字之后，又跳回到最初的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Evernote%20bug.gif!500x500&quot; alt=&quot;问题操作&quot;&gt;&lt;br&gt;这就奇怪了，看逻辑上一点错误也没有，那怎么会这样呢？&lt;/p&gt;
&lt;p&gt;检查了下按钮的类型也是自定义的，那会不会是动画影响的呢？&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在block里面，我在setTitle:forState的方法外面，去掉动画的影响&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[UIView setAnimationsEnabled:NO];&amp;#10;[self.loginButton setTitle:@&amp;#34;&amp;#27880; &amp;#160; &amp;#20876;&amp;#34; forState:UIControlStateNormal];&amp;#10;[self.loginButton layoutIfNeeded];&amp;#10;[UIView setAnimationsEnabled:YES];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[UIView performWithoutAnimation:^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [self.loginButton setTitle:@&amp;#34;&amp;#27880; &amp;#160; &amp;#20876;&amp;#34; forState:UIControlStateNormal];&amp;#10;        [self.loginButton layoutIfNeeded];&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;都还是不行。。。&lt;/p&gt;
&lt;p&gt;干脆把动画方法去掉，直接改变按钮的位置再试试。。结果还是一样，那就纳闷了。。&lt;/p&gt;
&lt;p&gt;后来找了很久的资料发现，原来是受到了autolayout的影响，因为在广泛开始使用autolayout之后，在storyboard，nib和实现文件里面，我们可能不像以前那样去繁琐的计算坐标了，我们通过自适应的方式，去确定控件的位置&lt;/p&gt;
&lt;p&gt;因为我的登录按钮是自适应的，所以在修改了按钮位置后，再修改文字，就会出现这样的问题，但是我打印了很多方法，都没有发现调用，所以不知道系统在设置文字的时候，又调用了哪个方法&lt;/p&gt;
&lt;p&gt;我试着调用了修改其他的属性的方法，比如背景色，setImage：forState，这些都没事，凡是调用了title相关的三个设置都会这样。。我就满脸黑线了。。&lt;/p&gt;
&lt;p&gt;所以目前能找到的解决办法就是，该按钮&lt;strong&gt;用坐标计算的方式添加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果哪位大神找到更好的解决办法，欢迎留言~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在写App的登录注册界面，其中登录和注册之间的切换和印象笔记一样&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Evernote.gif!500x500&quot; alt=&quot;印象笔记登录界面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;中
    
    </summary>
    
    
      <category term="button" scheme="http://yuzeyang.github.io/tags/button/"/>
    
  </entry>
  
  <entry>
    <title>iOS 简单下载动画</title>
    <link href="http://yuzeyang.github.io/2016/03/27/simple-download-animation/"/>
    <id>http://yuzeyang.github.io/2016/03/27/simple-download-animation/</id>
    <published>2016-03-27T03:22:17.000Z</published>
    <updated>2016-05-21T03:40:35.000Z</updated>
    
    <content type="html">&lt;p&gt;这个动画比较简单基础，首先我们来看一下这个动画模拟的动图&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/downloadAnimation.gif!500x500&quot; alt=&quot;下载动画&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;动画一共有四个状态，&lt;strong&gt;开始下载&lt;/strong&gt;、&lt;strong&gt;下载结束&lt;/strong&gt;、&lt;strong&gt;下载成功&lt;/strong&gt;和&lt;strong&gt;下载失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么会分有&lt;strong&gt;下载结束&lt;/strong&gt;这样的状态呢？因为考虑到实际场景，可能会有在加载过程中，用户返回上级界面，我们需要结束下载动画&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们按状态来实现，首先先看开始加载&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *rotationZAnimation = [CABasicAnimation animationWithKeyPath:@&amp;#34;transform.rotation.z&amp;#34;];&amp;#10;rotationZAnimation.fromValue = @(0);&amp;#10;rotationZAnimation.toValue = @(M_PI*2);&amp;#10;rotationZAnimation.repeatDuration = HUGE_VAL;&amp;#10;rotationZAnimation.duration = 1.0;&amp;#10;rotationZAnimation.cumulative = YES;&amp;#10;rotationZAnimation.beginTime = CACurrentMediaTime();&amp;#10;[self.loadingLayer addAnimation:rotationZAnimation forKey:@&amp;#34;rotationZAnimation&amp;#34;];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth];&amp;#10;CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];&amp;#10;[self.loadingLayer addAnimation:boundsAnimation forKey:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里分为两个动画，一个是&lt;strong&gt;旋转动画&lt;/strong&gt;，一个是&lt;strong&gt;放大缩小的动画&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;旋转动画&lt;/strong&gt;，我们只有一个初始值和末值，所以我们只需要使用CABasicAnimation就可以了，不需要使用CAKeyframeAnimation，CAKeyframeAnimation是用来处理关键帧动画的，它的values属性用来存储关键帧的值，这就是我们用来做处理&lt;strong&gt;放大缩小动画&lt;/strong&gt;，上面代码可以看到我将它抽成了一个方法来用，因为在下载成功和失败的时候，成功和失败也是有放大缩小的动画，这三个其实是一个动画&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSArray *)valueArrayWithWidth:(CGFloat)width &amp;#123;&amp;#10;&amp;#160; &amp;#160; return @[[NSValue valueWithCGRect:CGRectMake(0, 0, width * 0.7, width * 0.7)],&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSValue valueWithCGRect:CGRectMake(0, 0, width, width)],&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSValue valueWithCGRect:CGRectMake(0, 0, width * 0.9, width * 0.9)]];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (CAKeyframeAnimation *)bounsAnimationWithValues:(NSArray *)values &amp;#123;&amp;#10;&amp;#160; &amp;#160; CAKeyframeAnimation *boundsAnimation = [CAKeyframeAnimation animationWithKeyPath:@&amp;#34;bounds&amp;#34;];&amp;#10;&amp;#160; &amp;#160; boundsAnimation.duration = 0.6;&amp;#10;&amp;#160; &amp;#160; boundsAnimation.beginTime = CACurrentMediaTime();&amp;#10;&amp;#160; &amp;#160; boundsAnimation.values = values;&amp;#10;&amp;#160; &amp;#160; boundsAnimation.keyTimes = @[@(0),@(0.3),@(0.6)];&amp;#10;&amp;#160; &amp;#160; boundsAnimation.timingFunctions = @[[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut],&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];&amp;#10;&amp;#160; &amp;#160; boundsAnimation.removedOnCompletion = NO;&amp;#10;&amp;#160; &amp;#160; boundsAnimation.fillMode = kCAFillModeForwards;&amp;#10;&amp;#160; &amp;#160; return boundsAnimation;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们统一设置动画的values值，这里传入的width值是下载的背景大小，因为下载圆圈有个放大的过程，所以我们需要圆圈的原始大小要比背景的大小小，所以我默认设置圆圈的大小是背景大小的0.9倍，所以动画的效果是圆圈从背景大小的0.7倍-&amp;gt;背景大小-&amp;gt;背景大小的0.9倍（圆圈的原始大小）&lt;br&gt;在设置这个动画的时候，因为动画的值不止是初始值和末值，还是中间值，所以我使用CAKeyframeAnimation来做，每个关键帧之间的动画时间设置为0.3秒，这是最适合的动画时间，当然这是时间还是由自己反复调试动画决定的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下载结束我们只要将转圈的动画移除掉即可，这样转圈就恢复到原来的状态了&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.loadingLayer removeAllAnimations];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下载成功我们也需要将转圈动画移除，然后出现成功的动画，并且将成功图层的透明度从0变到1&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.loadingLayer removeAllAnimations];&amp;#10;self.failLayer.opacity = 0.0;&amp;#10;NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth * 0.5];&amp;#10;CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];&amp;#10;[self.doneLayer addAnimation:boundsAnimation forKey:nil];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;[UIView animateWithDuration:1.0 animations:^&amp;#123;&amp;#10;&amp;#160; &amp;#160; self.doneLayer.opacity = 1.0;&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下载失败也是同理&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.loadingLayer removeAllAnimations];&amp;#10;self.doneLayer.opacity = 0.0;&amp;#10;NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth * 0.5];&amp;#10;CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];&amp;#10;[self.failLayer addAnimation:boundsAnimation forKey:nil];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;[UIView animateWithDuration:1.0 animations:^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160;self.failLayer.opacity = 1.0;&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;好了，动画主要的原理就是这样，具体的代码实现可以看这里：&lt;a href=&quot;https://github.com/Yuzeyang/DownloadingAnimation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Yuzeyang/DownloadingAnimation&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个动画比较简单基础，首先我们来看一下这个动画模拟的动图&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/downloadAnimation.gif!500x500&quot; alt=&quot;下载动画&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;动画
    
    </summary>
    
    
      <category term="下载动画" scheme="http://yuzeyang.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS 不付费看微信红包照片</title>
    <link href="http://yuzeyang.github.io/2016/01/26/red-packet/"/>
    <id>http://yuzeyang.github.io/2016/01/26/red-packet/</id>
    <published>2016-01-26T15:11:50.000Z</published>
    <updated>2016-05-18T15:26:36.000Z</updated>
    
    <content type="html">&lt;p&gt;相信今天微信红包照片已经席卷了朋友圈，微信这次创意是非常好的，对发布的照片进行了模糊处理，打开一看，是要发红包才能看到照片的，那怎么办呢？&lt;/p&gt;
&lt;p&gt;这怎么能难倒我们这些技术男，一招破解！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;第一种方法Charles&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/hongbaozhaopian.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来我们一起来抓包看看~&lt;/p&gt;
&lt;p&gt;首先设置好自己的WiFi的http代理，绑定好自己的Mac ip地址，打开Charles，选择allow&lt;/p&gt;
&lt;p&gt;然后打开你的微信朋友圈，你在Charles里面可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/zhuabaojieguo.jpg!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后在overview的URL里面，你就可以看到图片的URL地址了，将其拷贝出来，放到浏览器里面打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/yuanshitu.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;ok~就这么简单~&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;下面讲下第二种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用另一个iOS工具，叫做Replica&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/replica.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;打开Replica之后，启动Start，然后会打开VPN，按操作一步一步即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/replica_start.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后打开微信朋友圈，再返回到Replica，进到Analytics，点击最新的session，里面会有最新的POST/GET的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/post_get_data.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后找到180.163开头的GET请求，点进去，切到Response，可以看到这个GET请求到的数据类型是image，然后打开Image Viewer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/180.163.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/yuanshitu2.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也是可以将图片显示出来的&lt;/p&gt;
&lt;p&gt;我们可以发现照片的模糊处理是在本地做的&lt;/p&gt;
&lt;p&gt;当然这个我们只是娱乐为主，这次的产品设计还是非常不错的，点个赞喔~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;相信今天微信红包照片已经席卷了朋友圈，微信这次创意是非常好的，对发布的照片进行了模糊处理，打开一看，是要发红包才能看到照片的，那怎么办呢？&lt;/p&gt;
&lt;p&gt;这怎么能难倒我们这些技术男，一招破解！&lt;/p&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="http://yuzeyang.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS 给App添加TouchID验证</title>
    <link href="http://yuzeyang.github.io/2016/01/19/TouchID/"/>
    <id>http://yuzeyang.github.io/2016/01/19/TouchID/</id>
    <published>2016-01-19T14:47:27.000Z</published>
    <updated>2016-05-18T15:04:09.000Z</updated>
    
    <content type="html">&lt;p&gt;TouchID验证这个在iOS8中已经对开发者开放使用了，而且需在5s以上真机才能使用，这个出来已经比较早了，相信很多人都应该已经知道怎么使用TouchID了，但是就目前我使用的App来说，看到使用TouchID验证的占得数量并不多，对于一些涉及到安全性的App来说，很有可能你的解锁验证、App登录以及支付验证都是用的TouchID使用TouchID验证还是有风险的，但是有些App增加使用TouchID作为一种验证还是不错的选择，既快捷又方便，对于开发者来说增加的成本也很低&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这个是我所讲的demo的源码&lt;a href=&quot;https://github.com/Yuzeyang/TouchIDDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TouchID demo&lt;/a&gt;，代码量非常少&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面我就来介绍下怎么给App增加TouchID验证吧&lt;/p&gt;
&lt;p&gt;首先，要使用TouchID，得先引入LocalAuthentication.framework这个库，这里面只有四个头文件，但实际使用到的只有LAContext.h和LAError.h这两个头文件&lt;/p&gt;
&lt;p&gt;在做验证时，我们只需要使用到LAContext中的两个方法&lt;/p&gt;
&lt;p&gt;我们先初始化一个LAContext对象&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;LAContext *ctx = [[LAContext alloc] init];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后调用&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError*__autoreleasing*)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法来确定当前指定的验证方法能否使用，LAPolicy是个枚举，里面只有两个值，一个是LAPolicyDeviceOwnerAuthenticationWithBiometrics（使用该设备的TouchID验证），LAPolicyDeviceOwnerAuthentication（使用该设备的TouchID和设备密码验证）&lt;/p&gt;
&lt;p&gt;这里返回的是一个布尔值，错误处理我等下一起说明，当返回可以使用当前指定的验证法方法时，我们调用&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)evaluatePolicy:(LAPolicy)policy localizedReason:(NSString*)localizedReason reply:(void(^)(BOOLsuccess,NSError*__nullableerror))reply;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法开始使用TouchID验证，localizedReason指的是在弹出TouchID验证框时提示的文字，reply指的是在做指纹验证或者密码验证后的结果返回，我将localizedReason用@”通过Home键验证已有手机指纹”作为提示，下图比较直观&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/TouchID1.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;刚才布尔值的错误对应的是哪些呢？&lt;/p&gt;
&lt;p&gt;这就用到了LAError.h这个类，这个类定义了目前所有的验证失败的错误code，我直接将它copy过来了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedefNS_ENUM(NSInteger, LAError)&amp;#10;&amp;#123;&amp;#10;&amp;#9;/// &amp;#26657;&amp;#39564;&amp;#22833;&amp;#36133;&amp;#10;&amp;#9;LAErrorAuthenticationFailed =kLAErrorAuthenticationFailed,&amp;#10;&amp;#10;    /// &amp;#29992;&amp;#25143;&amp;#21462;&amp;#28040;&amp;#39564;&amp;#35777;&amp;#10;&amp;#9;LAErrorUserCancel=kLAErrorUserCancel,&amp;#10;&amp;#10;&amp;#9;/// &amp;#29992;&amp;#25143;&amp;#22238;&amp;#36864;&amp;#65288;&amp;#36820;&amp;#22238;&amp;#23494;&amp;#30721;&amp;#26657;&amp;#39564;&amp;#65289;&amp;#10;&amp;#9;LAErrorUserFallback=kLAErrorUserFallback,&amp;#10;&amp;#10;&amp;#9;/// &amp;#31995;&amp;#32479;&amp;#21462;&amp;#28040;&amp;#26657;&amp;#39564;&amp;#10;&amp;#9;LAErrorSystemCancel=kLAErrorSystemCancel,&amp;#10;&amp;#10;&amp;#9;/// &amp;#23494;&amp;#30721;&amp;#26410;&amp;#35774;&amp;#32622;&amp;#10;&amp;#9;LAErrorPasscodeNotSet=kLAErrorPasscodeNotSet,&amp;#10;&amp;#10;&amp;#9;/// &amp;#25351;&amp;#32441;&amp;#19981;&amp;#27491;&amp;#30830;&amp;#10;&amp;#9;LAErrorTouchIDNotAvailable=kLAErrorTouchIDNotAvailable,&amp;#10;&amp;#10;&amp;#9;/// &amp;#27809;&amp;#26377;&amp;#24405;&amp;#20837;&amp;#25351;&amp;#32441;&amp;#10;&amp;#9;LAErrorTouchIDNotEnrolled=kLAErrorTouchIDNotEnrolled,&amp;#10;&amp;#10;&amp;#9;/// TouchID&amp;#34987;&amp;#38145;&amp;#23450;&amp;#10;&amp;#9;LAErrorTouchIDLockoutNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorTouchIDLockout,&amp;#10;&amp;#10;&amp;#9;/// App&amp;#21462;&amp;#28040;&amp;#39564;&amp;#35777;&amp;#10;&amp;#9;LAErrorAppCancelNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorAppCancel,&amp;#10;&amp;#10;&amp;#9;/// &amp;#26080;&amp;#25928;&amp;#30340;&amp;#19978;&amp;#19979;&amp;#25991;&amp;#29615;&amp;#22659;&amp;#10;&amp;#9;LAErrorInvalidContextNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorInvalidContext&amp;#10;&amp;#125;NS_ENUM_AVAILABLE(10_10,8_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而前四种error是针对于能确定使用验证后，在验证后返回的错误&lt;/p&gt;
&lt;p&gt;后六种error是针对于不能使用验证的原因&lt;/p&gt;
&lt;p&gt;你可以针对这些原因做一些相应的操作，比如弹窗等等&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;TouchID验证这个在iOS8中已经对开发者开放使用了，而且需在5s以上真机才能使用，这个出来已经比较早了，相信很多人都应该已经知道怎么使用TouchID了，但是就目前我使用的App来说，看到使用TouchID验证的占得数量并不多，对于一些涉及到安全性的App来说，很有可能你的解锁验证、App登录以及支付验证都是用的TouchID使用TouchID验证还是有风险的，但是有些App增加使用TouchID作为一种验证还是不错的选择，既快捷又方便，对于开发者来说增加的成本也很低&lt;/p&gt;
    
    </summary>
    
    
      <category term="TouchID" scheme="http://yuzeyang.github.io/tags/TouchID/"/>
    
  </entry>
  
  <entry>
    <title>iOS 基于GCDAsyncSocket快速开发Socket通信</title>
    <link href="http://yuzeyang.github.io/2016/01/17/GCDAsyncSocket-socket/"/>
    <id>http://yuzeyang.github.io/2016/01/17/GCDAsyncSocket-socket/</id>
    <published>2016-01-17T14:10:53.000Z</published>
    <updated>2016-05-18T14:45:49.000Z</updated>
    
    <content type="html">&lt;p&gt;GCDAsyncSocket是CocoaAsyncSocket第三方库中的其中一个类，本文介绍的就是基于这一个类来做快速的socket通信开发，而且该库已经支持IPv4和IPv6&lt;/p&gt;
&lt;p&gt;我们对GCDAsyncSocket做了一层封装调用，它包含了建连、断开、重连、心跳、自定义请求&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;首先，介绍一下CocoaAsyncSocket第三方库的用途&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CocoaAsyncSocket provides easy-to-use and powerful asynchronous socket libraries for Mac and iOS. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CocoaAsyncSocket为Mac和iOS提供了易于使用且强大的异步通信库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Podfile文件中，只要加上这句话就可以使用了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;#39;CocoaAsyncSocket&amp;#39;, &amp;#39;7.4.1&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;简单的Socket通信包括了建连、断开连接、发送socket业务请求、重连这四个基本功能&lt;/p&gt;
&lt;p&gt;下面，我就按照这个四个基本功能来讲一下，怎么来使用CocoaAsyncSocket中GCDAsyncSocket这个类来开发Socket通信&lt;/p&gt;
&lt;p&gt;首先，Socket在第一步时，需要建连才能开始通信&lt;/p&gt;
&lt;p&gt;在GCDAsyncSocket中提供了四种初始化的方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)init;&amp;#10;- (id)initWithSocketQueue:(dispatch_queue_t)sq;&amp;#10;- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq;&amp;#10;- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq;&amp;#10;&amp;#10;@property (atomic, weak, readwrite) id delegate;&amp;#10;#if OS_OBJECT_USE_OBJC&amp;#10;@property (atomic, strong, readwrite) dispatch_queue_t delegateQueue;&amp;#10;#else&amp;#10;@property (atomic, assign, readwrite) dispatch_queue_t delegateQueue;&amp;#10;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;sq是socket的线程，这个是可选的设置，如果你写null，GCDAsyncSocket内部会帮你创建一个它自己的socket线程，如果你要自己提供一个socket线程的话，千万不要提供一个并发线程，在频繁socket通信过程中，可能会阻塞掉，个人建议是不用创建&lt;/p&gt;
&lt;p&gt;aDelegate就是socket的代理&lt;/p&gt;
&lt;p&gt;dq是delegate的线程&lt;/p&gt;
&lt;p&gt;必须要需要设置socket的代理以及代理的线程，否则socket的回调你压根儿就不知道了，&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.socket =[[GCDAsyncSocket alloc] initWithDelegate:delegate delegateQueue:dispatch_get_main_queue()];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接着，在设置代理之后，你需要尝试连接到相应的地址来确定你的socket是否能连通了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)connectToHost:(NSString *)host&amp;#10;               onPort:(uint16_t)port&amp;#10;          withTimeout:(NSTimeInterval)timeout&amp;#10;                error:(NSError **)errPtr;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;host是主机地址，port是端口号&lt;/p&gt;
&lt;p&gt;如果建连成功之后，会收到socket成功的回调，在成功里面你可以做你需要做的一些事情，我这边的话，是做了心跳的处理&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果建连失败了，会收到失败的回调，我这边在失败里面做了重连的操作&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重连操作其实比较简单，只需要再调用一次建连请求，我这边设置的重连规则是重连次数为5次，每次的时间间隔为2的n次方，超过次数之后，就不再去重连了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socketDidDisconnect:(GCDAsyncSocket*)sock withError:(NSError*)err &amp;#123;&amp;#10;&amp;#10;&amp;#9;self.status= -1;&amp;#10;&amp;#10;&amp;#9;if(self.reconnection_time&amp;#62;=0 &amp;#38;&amp;#38; self.reconnection_time &amp;#60;= kMaxReconnection_time) &amp;#123;&amp;#10;&amp;#10;&amp;#9;&amp;#9;[self.timer invalidate];&amp;#10;&amp;#10;&amp;#9;&amp;#9;self.timer=nil;&amp;#10;&amp;#10;&amp;#9;&amp;#9;int time =pow(2,self.reconnection_time);&amp;#10;&amp;#10;&amp;#9;&amp;#9;self.timer= [NSTimer scheduledTimerWithTimeInterval:time target:selfselector:@selector(reconnection) userInfo:nil repeats:NO];&amp;#10;&amp;#10;&amp;#9;&amp;#9;self.reconnection_time++;&amp;#10;&amp;#10;&amp;#9;&amp;#9;NSLog(@&amp;#34;socket did reconnection,after %ds try again&amp;#34;,time);&amp;#10;&amp;#10;&amp;#9;&amp;#125; else &amp;#123;&amp;#10;&amp;#10;&amp;#9;&amp;#9;self.reconnection_time=0;&amp;#10;&amp;#10;&amp;#9;&amp;#9;NSLog(@&amp;#34;socketDidDisconnect:%p withError: %@&amp;#34;, sock, err);&amp;#10;&amp;#9;&amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我用status来标记socket的连接状态&lt;/p&gt;
&lt;p&gt;那么socket已经建连了，该怎么发起socket通信呢？&lt;/p&gt;
&lt;p&gt;你需要和后端开发人员商定好socket协议格式，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[NSString stringWithFormat:@&amp;#34;&amp;#123;\&amp;#34;version\&amp;#34;:%d,\&amp;#34;reqType\&amp;#34;:%d,\&amp;#34;body\&amp;#34;:\&amp;#34;%@\&amp;#34;&amp;#125;\r\n&amp;#34;,PROTOCOL_VERSION,reqType,reqBody];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;中间应该大家都能看得懂，那为什么后面需要加上\r\n呢？&lt;/p&gt;
&lt;p&gt;这个\r\n是socket消息的边界符，是为了防止发生消息黏连，没有\r\n的话，可能由于某种原因，后端会收到两条socket请求，但是后端不知道怎么拆分这两个请求&lt;/p&gt;
&lt;p&gt;同理，在收到socket请求回调时，也会根据这个边界符去拆分&lt;/p&gt;
&lt;p&gt;那为什么要用\r\n呢？&lt;/p&gt;
&lt;p&gt;而且GCDAsyncSocket不支持自定义边界符，它提供了四种边界符供你使用\r\n、\r、\n、空字符串&lt;/p&gt;
&lt;p&gt;在拼装好socket请求之后，你需要调用GCDAsyncSocket的写方法，来发送请求，然后在写完成之后你会收到写的回调&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.socket writeData:requestData withTimeout:-1 tag:0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;timeout是超时时间，这个根据实际的需要去设置&lt;/p&gt;
&lt;p&gt;这个是写的回调&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socket:(GCDAsyncSocket*)sock didWriteDataWithTag:(long)tag&amp;#65307;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在写之后，需要再调用读方法，这样才能收到你发出请求后从服务器那边收到的数据&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.socketreadDataToData:[GCDAsyncSocket CRLFData] withTimeout:10 maxLength:50000 tag:0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;[GCDAsyncSocket CRLFData]这里是设置边界符，maxLength是设置你收到的请求数据内容的最大值&lt;/p&gt;
&lt;p&gt;在读回调里面，你可以根据不同业务来执行不同的操作&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socket:(GCDAsyncSocket*)sock didReadData:(NSData*)data withTag:(long)tag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后一个则是断开连接，这个只需要调用&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.socket disconnect];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ok，这样的话，最简单基础的socket通信，你已经大致能完成了~&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2016.4.26更新&lt;/p&gt;
&lt;p&gt;在网络环境以及其他因素下，很有可能会造成客户端或者后端没有接收到回调或者请求，那该怎么办？&lt;/p&gt;
&lt;p&gt;我们需要加上消息回执的处理&lt;/p&gt;
&lt;p&gt;客户端发出请求的时候，可以将该请求放到存到数组里面，等到后端的相应回调在移除掉，如果该请求超时或者在一段时间内没有收到确认返回，说明后端没有接收到我们的请求，我们可以将该请求重新发送&lt;/p&gt;
&lt;p&gt;客户端接收请求的时候，后端将数据发给客户端，客户端需要增加回执处理，告诉后端，客户端接收到数据了，如果后端没接收到，也重新推一遍数据，客户端和后端双向保护来解决丢失问题&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;GCDAsyncSocket是CocoaAsyncSocket第三方库中的其中一个类，本文介绍的就是基于这一个类来做快速的socket通信开发，而且该库已经支持IPv4和IPv6&lt;/p&gt;
&lt;p&gt;我们对GCDAsyncSocket做了一层封装调用，它包含了建连、断开、重连、心跳、自定义请求&lt;/p&gt;
    
    </summary>
    
    
      <category term="GCDAsyncSocket,Socket" scheme="http://yuzeyang.github.io/tags/GCDAsyncSocket-Socket/"/>
    
  </entry>
  
  <entry>
    <title>零下三十度的哈尔滨之行</title>
    <link href="http://yuzeyang.github.io/2016/01/12/Harbin-travel/"/>
    <id>http://yuzeyang.github.io/2016/01/12/Harbin-travel/</id>
    <published>2016-01-12T11:37:10.000Z</published>
    <updated>2016-05-18T15:01:53.000Z</updated>
    
    <content type="html">&lt;p&gt;在年假过期之前，我和同事们想着用这个年假去哪儿浪，后来商量之后，决定去一趟哈尔滨看看，当然对于一直从未感受过零下十度以下的南方汉子们，特别是IT宅男们来说，那里的冷是根本想象不到的。（多图预警！！！）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/afraid.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们定在1月7日出发，刚好和元旦错开了，但是没办法，冰雪节在元旦之后才开始..哎，不然玩的时间就更长了。&lt;/p&gt;
&lt;p&gt;前期的准备还是很重要的！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.帽子-防风防寒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.口罩-棉/厚（戴眼镜的人极其痛苦…根本不能带口罩）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.围巾-厚&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.耳套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.保暖内衣.羊毛衫.抓绒外套.羽绒服 至少四层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.棉毛裤.棉裤.冲锋裤 至少穿三层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.厚袜子 至少两双&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.手套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9.棉鞋.雪地靴&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10.雪套（这个好像我带去都没有用到）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11.保温杯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12、暖宝宝（这个用到的时间不是很多，不过站在雪地的时候，可以贴一个在脚底抵挡一些寒冷）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;千等万等，终于等到出发的日子了，我们一行人也是高高兴兴的粗发啦，坐的是四川航空，空姐和空少都有点胖胖的…好桑心…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/INeedAV.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从杭州到哈尔滨的飞机需要三个小时左右的行程，快到哈尔滨的时候，从飞机上往下看，地都是雪白雪白的，这叫尔等南方来的汉子们很是激动啊，白茫茫的一片~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/snow.jpeg!600x600&quot; alt=&quot;飞机上俯瞰的雪景&quot;&gt;&lt;/p&gt;
&lt;p&gt;飞机降落之后，我们打车到中央大街，在打车的时候要注意一点，有些司机会向你收取&lt;strong&gt;高速路的过路费&lt;/strong&gt;，并且让你取消订单，用现金支付。现金支付是可以的，因为听说最近某滴已经开始向司机收取好像20%的服务费了，但&lt;strong&gt;你千万不要给司机高速路的过路费&lt;/strong&gt;，因为高速路的过路费，在从哈尔滨到机场的路上，有其他乘客已经帮你付了，这个是没有办法的，但是返程从机场到哈尔滨是不用付的，这个是司机想多赚你的钱！&lt;/p&gt;
&lt;p&gt;在进过的路上，我也不知道什么路…有用冰砖搭的一座城，很是漂亮，从没有近距离的看过…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/snow2.jpeg!600x600&quot; alt=&quot;冰城&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过快一个小时的车程（还是有点堵的），到了中央大街，据说这个一条非常热闹而且有名的街（因为之前吃住全是另外一个同事订好的..所以我都没有提前去了解..），下了飞机之后感觉瞬间变冷，得赶紧去旅馆加上衣服，基本按照上面必备的那么穿就不冷了，哈尔滨的天气衣服穿够了，身上不冷，但是风打在脸上还是很冷的，时间一长，鼻子就受不了了。&lt;/p&gt;
&lt;p&gt;逛中央大街的时候，门口就有个烤肠，非常好吃！但是不要买多…吃了一两根之后我感觉就有点吃不下了…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/xiangchang.jpeg!600x600&quot; alt=&quot;烤肠&quot;&gt;&lt;/p&gt;
&lt;p&gt;在旅馆门口还有一个用冰砖搭起来的滑梯，要收费，10元滑一次，因为想到晚上要去冰雪大世界了，也就没上去玩了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/binghuati.jpeg!600x600&quot; alt=&quot;冰滑梯&quot;&gt;&lt;/p&gt;
&lt;p&gt;中央大街上面有很多非常有特色店：马迭尔冰棍（这个冰棍买的人特别多），华梅西餐厅（据说连哈尔滨人也都排队还吃不上，最后一天我们想去吃，但是排队的人实在太多了，就没吃了，好可惜），老厨家（这个很有历史也很好吃）等等，那里的店大多都很有特色&lt;/p&gt;
&lt;p&gt;沿着中央大街走就可以走到防洪纪念塔，在纪念塔后面就是松花江，江面全部都结冰了，看得我都傻了..上面都是游人在滑冰，玩耍，冰面还是比较滑的，要小心，里面的娱乐项目看情况选择玩吧，出来玩，开心还是最重要的（我一般都是这么想的，飞机票、吃住都花了这么多了，不差这点娱乐的钱了…）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/songhuajiang.jpeg!600x600&quot; alt=&quot;松花江&quot;&gt;&lt;/p&gt;
&lt;p&gt;晚上就出发去了冰雪大世界玩，在那里鞋一定要穿暖，因为有些项目是需要排队的，站那脚特别冷..而且可以考虑先去排队玩大滑梯，据说很刺激，但是因为排队的人太多了，我们就很遗憾的没有去玩了，里面玩的都是滑梯，看冰雕，感受下冰的魅力，对于南方来的我们玩的还是非常开心的~但是很遗憾我没有找到冰雪大世界的照片，不过同事那里有，之后我会更新上来&lt;/p&gt;
&lt;p&gt;在冰雪大世界这么疯狂的消耗体力之后，肯定会饿了，我们用美团搜到了一家非常好吃的烧烤店叫1981烧烤（好像是这个名字），价格也不贵，烤的非常好吃，以致于有个同事一连三天拉着我吃烧烤，别说，北方的烧烤还真的比南方要好吃一点，哈哈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/1981shaokao.jpeg!600x600&quot; alt=&quot;1981烧烤&quot;&gt;&lt;/p&gt;
&lt;p&gt;第二天，我们选择去了雪乡，听说那里是因为拍了爸爸去哪了之后，才火起来的，但是因为客服的原因，把我们的名单弄错了，导致没坐上大巴车，结果搞了辆小面包，后面的事情就更凄惨了…雪乡的路上有个坡，路面滑，怎么都上不去，装防滑条，断了，装防滑链，装不上…啊…真的是日了够了，搞了一两个小时，本来出发时间就耽搁了，这么一搞就更晚了，结果一辆路过的大巴车救了我们，达到雪乡花了我们12个小时…醉了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/zhuangfanghualian.jpeg!600x600&quot; alt=&quot;装防滑链&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是雪乡沿途的风景还是很漂亮的，厚厚的雪，还有雾凇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/xuejing.jpeg!600x600&quot; alt=&quot;雪景&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/wusong.jpeg!600x600&quot; alt=&quot;雾凇&quot;&gt;&lt;/p&gt;
&lt;p&gt;到雪乡之后，就是夜晚了，虽然还是5点多钟，但天黑的特别早，雪乡一进来就给人的感觉是商业化比较严重，已经很难看出原来的风土人情了。雪乡里面能看到雪橇犬，还是马拉车，车还是有牌照的…&lt;/p&gt;
&lt;p&gt;我们因为路途的劳累也没出去逛，雪乡之行还是意外的可惜，草草的就结束了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/xuexiangyejing.jpeg!600x600&quot; alt=&quot;雪乡夜景&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们一行人睡的是五人炕，但是后来听北方的同事说，那个好像是电子炕，不是火烧那种了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/wurenkang.jpeg!600x600&quot; alt=&quot;五人炕&quot;&gt;&lt;/p&gt;
&lt;p&gt;在那里我们买了冰柿子，冰草莓，冰梨，发现太硬了太冷了…后来放那软了就扔了…后来听说那个是要放冷水里化开了再吃的…吃的..的，我们就忧伤了…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/bingcaomei.jpeg!600x600&quot; alt=&quot;冰草莓&quot;&gt;&lt;/p&gt;
&lt;p&gt;第三天我们就从雪乡出发，去往亚布力滑雪，第一次滑雪的我来说可兴奋了ヾ(o◕∀◕)ﾉヾ，同事说去30°坡的滑雪场，我说太平了是不是不好玩，我说要45°的，后来少数服从多数，我们还是去了30°的滑雪场，到那里存好东西之后，有条件的可以请个教练带一带你，没有的，可以让会的同事带你，不然就像我一样，从坡上面一直摔到了坡下面….因为不懂怎么刹车…就一直摔…好疼…而且穿着滑雪鞋，容易崴脚，最后我去了儿童区，还是摔/(ㄒoㄒ)/~~&lt;/p&gt;
&lt;p&gt;回来的晚上我们好好的逛了下中央大街，在老厨家吃了顿放，和北方的同事聚了一下，总结了一下北方的菜有点咸，但是量特足，5个人基本点3个菜就差不多了&lt;/p&gt;
&lt;p&gt;中央大街的夜景也非常漂亮，街道两旁都有大型的冰雕，品牌赞助…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/shengdanshu.jpeg!600x600&quot; alt=&quot;圣诞树&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/beijixiong.jpeg!600x600&quot; alt=&quot;北极熊小屋&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后一天我们就去了圣索菲亚大教堂，据说教堂里面是没有什么好看的，都是买纪念品，只要外面参观下就可以了，而且有鸽子的区域没有我想象中的那么大，就那一小块地方…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/jiaotang.jpeg!600x600&quot; alt=&quot;教堂正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/gezi.jpeg!600x600&quot; alt=&quot;教堂旁的鸽子&quot;&gt;&lt;/p&gt;
&lt;p&gt;匆匆的哈尔滨之行就愉快的结束了，好期待下一次的旅行~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在年假过期之前，我和同事们想着用这个年假去哪儿浪，后来商量之后，决定去一趟哈尔滨看看，当然对于一直从未感受过零下十度以下的南方汉子们，特别是IT宅男们来说，那里的冷是根本想象不到的。（多图预警！！！）&lt;/p&gt;
    
    </summary>
    
    
      <category term="哈尔滨" scheme="http://yuzeyang.github.io/tags/%E5%93%88%E5%B0%94%E6%BB%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS TableView上拉下拉刷新控件（二）</title>
    <link href="http://yuzeyang.github.io/2016/01/06/iOS_TableView_refresh_controller-two/"/>
    <id>http://yuzeyang.github.io/2016/01/06/iOS_TableView_refresh_controller-two/</id>
    <published>2016-01-06T14:59:44.000Z</published>
    <updated>2016-05-17T15:22:07.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇我们来讲如何将loading圆圈动画和TableView结合起来一起使用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先，我们需要将loading圆圈和提示label加到一个view上去显示，实现的主要点有两点：第一，在上拉或者下拉的过程中，我们通过progress值去控制loading圆圈的动画和label的alpha值，第二，通过设置拉动的方向来设置label提示的内容&lt;/p&gt;
&lt;p&gt;然后，我们该怎么去获得这个progress值呢？&lt;/p&gt;
&lt;p&gt;首先，我们在初始化的时候需要监听所关联的scrollView的contentOffset值，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.scrollView addObserver:self forKeyPath:@&amp;#34;contentOffset&amp;#34; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在observeValueForKeyPath里面，我们获取contentOffset的最新值，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGPoint contentOffset = [[change valueForKey:NSKeyValueChangeNewKey] CGPointValue];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后再通过计算来改变progress值，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.progress = MAX(0.0, MIN(fabs((self.originOffset + contentOffset.y)/kMaxPullDownDistance), 1.0));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（注：在这里有个originOffset值，这个是我用来处理是否有导航栏的情况，有则该值为64.0，没有则为0.0）&lt;/p&gt;
&lt;p&gt;计算的思路是我们通过所关联的scrollView的contentOffset与我们所设置的最大的拉动距离值相除作比较，得到的就是拉动的一个范围比例，因为contentOffset会超出我们设置的最大拉动距离，所以我们需要再取最小最大值，来获取到最后的progress值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在这里插一个小的知识点，因为这个是在写上拉时，所必须知道的一个点，contentOffset是怎么算的？&lt;/p&gt;
&lt;p&gt;contentOffset是scrollview当前显示区域顶点相对于frame顶点的偏移量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/contentOffset.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但当上拉刷新之后，此时scrollview的contentSize变化了，（contentSize指的是可显示区域），在计算contentOffset时，需要将contentSize减去scrollView的高度，来和contentOffset作比较。&lt;/p&gt;
&lt;p&gt;拿到progress之后，此时我们离完成这个控件的任务就差不多了。&lt;/p&gt;
&lt;p&gt;首先，我们需要将progress赋值给loading圆圈和提示label，&lt;/p&gt;
&lt;p&gt;然后如果我们拉动的距离超过了设置最大值的时候，我们做loading，并且通过block让外部做一些网络请求或者其他的操作&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self startLoading:self.refreshView];&amp;#10;                &amp;#10;// 0.3s animation time is the best experience&amp;#10;[UIView animateWithDuration:0.3 animations:^&amp;#123;&amp;#10;    self.scrollView.contentInset = UIEdgeInsetsMake(kMaxPullDownDistance + self.originOffset, 0, 0, 0);&amp;#10;&amp;#125; completion:^(BOOL finished) &amp;#123;&amp;#10;    if (self.refreshingBlock) &amp;#123;&amp;#10;        self.refreshingBlock();&amp;#10;    &amp;#125;&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上拉时，有一点不同，scrollView的contentSize可能是会变化的，而我们的控件是要始终显示在它的最下方的，所以我们在上拉时，需要对contentSize也加监听&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.scrollView addObserver:self forKeyPath:@&amp;#34;contentSize&amp;#34; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并且在observeValueForKeyPath里面，需要设置控件的center来改变我们的显示位置，以及progress值，其他操作都和下拉刷新一样。&lt;/p&gt;
&lt;p&gt;ok，我们的上拉下拉刷新控件完成喽~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇我们来讲如何将loading圆圈动画和TableView结合起来一起使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TableView" scheme="http://yuzeyang.github.io/tags/TableView/"/>
    
  </entry>
  
  <entry>
    <title>iOS TableView上拉下拉刷新控件（一）</title>
    <link href="http://yuzeyang.github.io/2016/01/05/iOS_TableView_refresh_controller_one/"/>
    <id>http://yuzeyang.github.io/2016/01/05/iOS_TableView_refresh_controller_one/</id>
    <published>2016-01-05T14:29:07.000Z</published>
    <updated>2016-05-17T15:21:52.000Z</updated>
    
    <content type="html">&lt;p&gt;注：此刷新控件的效果是来自KittenYang的一个GIF图，他有很多动画分析和写得都不错，大家可以关注一下~&lt;/p&gt;
&lt;p&gt;推荐一个非常好的动画效果网站：&lt;a href=&quot;http://uimovement.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI Movement&lt;/a&gt;，里面很多设计出的动画效果都非常好，都可以一一实现看看哦&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;话不多说，先看下我要讲的刷新控件效果：&lt;/p&gt;
&lt;p&gt;1.无导航栏的刷新控件效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/TableRefreshAnimation1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.有导航栏的刷新控件效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/TableRefreshAnimation2.gif&quot; alt=&quot;&quot;&gt;            &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好了，进入正题。&lt;/p&gt;
&lt;p&gt;首先看到这个控件的时候，我们要去分析，这个控件是由哪几部分组成的，可以看到这个控件是只是由一个loading圆圈和label提示文字组成的，而label比较简单，在这里我就不具体说怎么实现了，大家可以直接看源码，这篇文章，我主要讲怎么实现这个loading圆圈的转圈效果。&lt;/p&gt;
&lt;p&gt;首先这个转圈分成两部分，我们将它分成0.0-0.5和0.5-1.0这两个阶段。&lt;/p&gt;
&lt;p&gt;在0.0-0.5这个过程的动画是这样的：&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/refresh0-0.5.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以左边的线为例，上顶点为B点，下顶点为A点，实际上这个过程只是，A，B两点的y值在随着progress的变化而变化，x是不变的，所以我们可以得到A，B两点的坐标&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGPoint leftA = CGPointMake(kCenterX - kLineLength, kCenterY + 2*kLineLength - self.progress/0.5*kLineLength);&amp;#10;CGPoint leftB = CGPointMake(leftA.x, leftA.y - kLineLength);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我们用贝塞尔曲线，将两点连起来，从A点到B点&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[leftPath moveToPoint:leftA];&amp;#10;[leftPath addLineToPoint:leftB];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那这个尖角怎么办呢？我们利用以前学过的数学知识，假设尖角的角度是30°，那x值就是leftB.x-kArrowLength&lt;em&gt;sin(kArrowAngle)，y值就是leftB.y+kArrowLength&lt;/em&gt;cos(kArrowAngle)，假设这个点是C点，最后就是将C点和B点相连&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[arrowPath moveToPoint:leftB];&amp;#10;[arrowPath addLineToPoint:CGPointMake(leftB.x - kArrowLength*sin(kArrowAngle), leftB.y + kArrowLength*cos(kArrowAngle))];&amp;#10;[leftPath appendPath:arrowPath];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样我们就完成了0.0-0.5的动画，这个一部分还是比较简单的。&lt;/p&gt;
&lt;p&gt;下面是0.5-1.0的动画过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/refresh0.5-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当到达0.5的时候，原先的B点开始保持不动，它的位置始终是CGPointMake(kCenterX-kLineLength,kCenterY)，而A点也渐渐向B点靠近，CGPointMake(kCenterX-kLineLength,kCenterY+kLineLength- (self.progress-0.5)/0.5*kLineLength)，那这个圆弧是怎么出来的？&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在绘制贝塞尔曲线里面，有一个绘制圆弧的方法，center是以某一个点为圆心绘制圆弧，&lt;/p&gt;
&lt;p&gt;radius是半径，startAngle是开始角度，endAngle是结束角度，clockwise是是否以顺时针绘制，ok，我们就用这个来绘制我们的圆弧&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[leftPath moveToPoint:leftA];&amp;#10;[leftPath addLineToPoint:leftB];&amp;#10;[leftPath addArcWithCenter:CGPointMake(kCenterX, kCenterY) radius:kLineLength startAngle:M_PI endAngle:M_PI+M_PI*(self.progress - 0.5)/0.5*9/10 clockwise:YES];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;恩，圆弧也画好了，那我们的尖角是不是也按照刚才的那样写就可以了？恩，差不多哦，只是我们在原有尖角30°的基础上，需要加上我们圆弧旋转的角度，才是真正尖角与圆弧顶点的切线角度&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGPointMake(leftPath.currentPoint.x - kArrowLength*sin(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10),leftPath.currentPoint.y + kArrowLength*cos(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好了，尖角顶点也知道了，那连接只要和原来一样就可以了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[arrowPath moveToPoint:leftPath.currentPoint];&amp;#10;[arrowPath addLineToPoint:CGPointMake(leftPath.currentPoint.x - kArrowLength*sin(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10),&amp;#10;                                              leftPath.currentPoint.y + kArrowLength*cos(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10))];&amp;#10;[leftPath appendPath:arrowPath];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好了，左边的动画是这样，右边的只要对称即可~&lt;/p&gt;
&lt;p&gt;是不是看上去比较复杂的动画，将它分解开来，就变得简单了呢？&lt;/p&gt;
&lt;p&gt;下一篇，我会讲怎么将这个动画和tableview结合起来使用~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;注：此刷新控件的效果是来自KittenYang的一个GIF图，他有很多动画分析和写得都不错，大家可以关注一下~&lt;/p&gt;
&lt;p&gt;推荐一个非常好的动画效果网站：&lt;a href=&quot;http://uimovement.com/&quot;&gt;UI Movement&lt;/a&gt;，里面很多设计出的动画效果都非常好，都可以一一实现看看哦&lt;/p&gt;
    
    </summary>
    
    
      <category term="TableView" scheme="http://yuzeyang.github.io/tags/TableView/"/>
    
  </entry>
  
  <entry>
    <title>TextField字数限制处理</title>
    <link href="http://yuzeyang.github.io/2015/09/17/TextField_count_limit_handle/"/>
    <id>http://yuzeyang.github.io/2015/09/17/TextField_count_limit_handle/</id>
    <published>2015-09-17T14:40:44.000Z</published>
    <updated>2016-05-16T15:23:06.000Z</updated>
    
    <content type="html">&lt;p&gt;在第三方键盘加入之后，对于字数限制的处理不再像之前那么简单了&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;纯数字、字符输入（不包括粘贴）这样的字数限制还是相对比较简单的，你可以用两种方法进行处理&lt;/p&gt;
&lt;p&gt;第一种是&lt;strong&gt;textfield的delegate&lt;/strong&gt;实现：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &amp;#123;&amp;#10;    if (range.length + range.location &amp;#62; textField.text.length) &amp;#123;&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    NSUInteger newLength = textField.text.length + string.length - range.length;&amp;#10;    return newLength&amp;#60;=kMaxCharacterCount;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种&lt;strong&gt;是注册一个通知&lt;/strong&gt;，在textfield编辑时做处理：&lt;/p&gt;
&lt;p&gt;首先你在viewDidLoad中注册通知&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFiledEditChanged:) name:UITextFieldTextDidChangeNotification object:self.shopName];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再实现通知里面的方法，在超过最大值时，取最大的字数&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (self.shopName.text.length &amp;#62; kMaxCharacterCount) &amp;#123;&amp;#10;        self.shopName.text = [self.shopName.text substringToIndex:kMaxCharacterCount];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，在中文的限制上面情况就复杂了，当时在调试的时候，因为使用的是第三方键盘，所以当时没有发现问题，但是在使用系统键盘的时候，一下子就蛋疼了….&lt;/p&gt;
&lt;p&gt;下面我开始分析一下，两者的区别：&lt;/p&gt;
&lt;p&gt;1、第三方键盘在输入字符时，一般是不会将字符直接输入到textfield中，而是将字符显示在它自己的view上方，但是系统键盘会直接输入到textfield中，而且它会占2个字符长度，比如你输入”abcd”，在textfield中显示的是”a b c d”，并且”a b c d”是处在高亮中的，并不算是真正输入到textfield中，所以我们不应把高亮的字符计算在内，我们应该计算真正输入的字符&lt;/p&gt;
&lt;p&gt;2、如果我们使用的是delegate做处理的时候，系统中文输入的时候会有联想，但是联想的那个字并不会调用delegate，比如你输入一个”你”，在系统的联想里面可能会出现”的”,”们”这样的联想，但是你选择”的”的时候，delegate并不会调用，（尼玛….），我猜想联想输入应该不算做keyboard所触发的事件，所以他并不会触发delegate，但是如果你注册的是通知，他倒是会调用，（还好有救）&lt;/p&gt;
&lt;p&gt;另外提醒一下，有时候在自测输入的时候，要考虑全面，比如粘贴这也是一种输入，当时没考虑，我也是跪了&lt;/p&gt;
&lt;p&gt;好了，分析了主要的区别下面我们就来看看具体怎么实现吧~&lt;/p&gt;
&lt;p&gt;在实现注册通知方法里面：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - UITextViewDelegate&amp;#10;- (void)textViewDidChange:(UITextView *)textView &amp;#123;&amp;#10;    if (textView.text.length == 0) &amp;#123;&amp;#10;        self.recommendTips.hidden = NO;&amp;#10;    &amp;#125;else&amp;#123;&amp;#10;        self.recommendTips.hidden = YES;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    NSString *toBeString = textView.text;&amp;#10;    NSString *lang = self.textInputMode.primaryLanguage; // &amp;#38190;&amp;#30424;&amp;#36755;&amp;#20837;&amp;#27169;&amp;#24335;&amp;#10;    if ([lang isEqualToString:@&amp;#34;zh-Hans&amp;#34;]) &amp;#123; // &amp;#31616;&amp;#20307;&amp;#20013;&amp;#25991;&amp;#36755;&amp;#20837;&amp;#65292;&amp;#21253;&amp;#25324;&amp;#31616;&amp;#20307;&amp;#25340;&amp;#38899;&amp;#65292;&amp;#20581;&amp;#20307;&amp;#20116;&amp;#31508;&amp;#65292;&amp;#31616;&amp;#20307;&amp;#25163;&amp;#20889;&amp;#10;        UITextRange *selectedRange = [textView markedTextRange];&amp;#10;        //&amp;#33719;&amp;#21462;&amp;#39640;&amp;#20142;&amp;#37096;&amp;#20998;&amp;#10;        UITextPosition *position = [textView positionFromPosition:selectedRange.start offset:0];&amp;#10;        // &amp;#27809;&amp;#26377;&amp;#39640;&amp;#20142;&amp;#36873;&amp;#25321;&amp;#30340;&amp;#23383;&amp;#65292;&amp;#21017;&amp;#23545;&amp;#24050;&amp;#36755;&amp;#20837;&amp;#30340;&amp;#25991;&amp;#23383;&amp;#36827;&amp;#34892;&amp;#23383;&amp;#25968;&amp;#32479;&amp;#35745;&amp;#21644;&amp;#38480;&amp;#21046;&amp;#10;        if (!position || !selectedRange) &amp;#123;&amp;#10;            if (toBeString.length &amp;#62; 200) &amp;#123;&amp;#10;                textView.text = [toBeString substringToIndex:200];&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        // &amp;#26377;&amp;#39640;&amp;#20142;&amp;#36873;&amp;#25321;&amp;#30340;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#65292;&amp;#21017;&amp;#26242;&amp;#19981;&amp;#23545;&amp;#25991;&amp;#23383;&amp;#36827;&amp;#34892;&amp;#32479;&amp;#35745;&amp;#21644;&amp;#38480;&amp;#21046;&amp;#10;        else&amp;#123;&amp;#10;            &amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#20013;&amp;#25991;&amp;#36755;&amp;#20837;&amp;#27861;&amp;#20197;&amp;#22806;&amp;#30340;&amp;#30452;&amp;#25509;&amp;#23545;&amp;#20854;&amp;#32479;&amp;#35745;&amp;#38480;&amp;#21046;&amp;#21363;&amp;#21487;&amp;#65292;&amp;#19981;&amp;#32771;&amp;#34385;&amp;#20854;&amp;#20182;&amp;#35821;&amp;#31181;&amp;#24773;&amp;#20917;&amp;#10;    else&amp;#123;&amp;#10;        if (toBeString.length &amp;#62; 200) &amp;#123;&amp;#10;            textView.text = [toBeString substringToIndex:200];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，我们根据键盘的输入模式进行区分，英文的比较简单就和上面一样，直接取最大的字符数就好了，在中文输入的时候，我们用markedTextRange方法获取到当前的光标位置，再用textField positionFromPosition:selectedRange.start offset:0获取到高亮部分，然后判断是否有高亮，这个时候系统会调用两次通知方法，第一次是将高亮的字符输入，第二次是将高亮的字符转换成中文输入（这个时候就没有高亮了，然后再取最大的字符数），但是在iOS7的设备上测试时发现，position都不会为nil，在iOS8以上都正常，但是获取到光标的range，却是正常的&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NS_CLASS_AVAILABLE_IOS(3_2) @interface UITextRange : NSObject&amp;#10;&amp;#10;@property (nonatomic, readonly, getter=isEmpty) BOOL empty;     //  Whether the range is zero-length.&amp;#10;@property (nonatomic, readonly) UITextPosition *start;&amp;#10;@property (nonatomic, readonly) UITextPosition *end;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到系统的UITextRange，有两个变量，一个是start，一个是end，这正是对于的高亮区域！&lt;/p&gt;
&lt;p&gt;所以既然position不能使用，那我们干脆就使用range，通过判断range的存在，来对文字进行限制处理。（粘贴也适用）&lt;/p&gt;
&lt;p&gt;结果也是棒棒的！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在第三方键盘加入之后，对于字数限制的处理不再像之前那么简单了&lt;/p&gt;
    
    </summary>
    
    
      <category term="TextField" scheme="http://yuzeyang.github.io/tags/TextField/"/>
    
  </entry>
  
</feed>
