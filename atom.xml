<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宫城</title>
  <subtitle>Talk is cheap,show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuzeyang.github.io/"/>
  <updated>2018-08-11T12:27:00.208Z</updated>
  <id>http://yuzeyang.github.io/</id>
  
  <author>
    <name>宫城</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Protocol Buffers Encoding</title>
    <link href="http://yuzeyang.github.io/2018/08/11/protobuf-encoding/"/>
    <id>http://yuzeyang.github.io/2018/08/11/protobuf-encoding/</id>
    <published>2018-08-11T01:51:22.000Z</published>
    <updated>2018-08-11T12:27:00.208Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protocol Buffers</a> 是 Google 提出的一种序列化数据格式，最早的 public release 是在08年的7月份推出。相比于 XML 和 JSON ，它的传输大小更小，速度更快，结构更简单，在数据传输和存储的场景下更具有优势。同时 Google 非常友好的提供了<a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">不同平台的版本</a>供开发者们使用，其对外的简洁性旨在让开发者们更注重业务的细节。不过本文并没有对源码进行剖析，我们重点分析的是 Protocol Buffers 是如何做到减小体积，也就是 Encoding 的过程。</p>
<a id="more"></a>
<p>为了便于理解，以下均已官网例子为例。</p>
<h3 id="Message-定义"><a href="#Message-定义" class="headerlink" title="Message 定义"></a>Message 定义</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从 Message 定义入手，这是一个简单的 Test1 Message 定义，里面有一个 int32 类型的 a 属性。假设我们将</p>
<p>a 赋值为150，那么在序列化后它在流中的内容是<code>08 96 01</code>，大小只有3字节，而经过 JSON 序列化后有17字节。相比之下大小减小了很多，那<code>08 96 01</code>的含义是什么呢？我们先来认识一下 <code>varints</code> 。</p>
<h3 id="Base-128-Varints"><a href="#Base-128-Varints" class="headerlink" title="Base 128 Varints"></a>Base 128 Varints</h3><p>Varints 是一种用一个或多个字节来表示一个整数的方法。</p>
<p>简单一点，比如整数1用一个字节就表示为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
<p>当超过128时，比如整数300，它的表示方式则稍微复杂一点了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1010</span> <span class="number">1100</span> <span class="number">0000</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure>
<p>这个是不是有点看不懂。首先 varint 中<strong>除去最后一个字节</strong>，其余都设有一个<code>最高有效位</code>，用来表示是否有其他的字节出现。而一个字节中的低七位用于保存一个数的二补数码表示。在多组字节进行联合计算的时候，低位有效组优先，也就将字节的顺序反序。</p>
<p>根据 varint 的三条规则，我们推导一下<code>1010 1100 0000 0010</code>是如何得到300的。</p>
<p>首先去掉每个字节中的最高有效位（因为最后一个字节的最高有效位是0，说明这是数字的尾端）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1010</span> <span class="number">1100</span> <span class="number">0000</span> <span class="number">0010</span></span><br><span class="line">→ <span class="number">010</span> <span class="number">1100</span>  <span class="number">000</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure>
<p>再将字节反序后拼接计算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> <span class="number">0010</span>  <span class="number">010</span> <span class="number">1100</span></span><br><span class="line">→  <span class="number">000</span> <span class="number">0010</span> ++ <span class="number">010</span> <span class="number">1100</span></span><br><span class="line">→  <span class="number">100101100</span></span><br><span class="line">→  <span class="number">256</span> + <span class="number">32</span> + <span class="number">8</span> + <span class="number">4</span> = <span class="number">300</span></span><br></pre></td></tr></table></figure>
<h3 id="Message-结构"><a href="#Message-结构" class="headerlink" title="Message 结构"></a>Message 结构</h3><p>回到最初的例子，我们可以看到每个字段由四部分组成：<code>field rule</code> 、 <code>field type</code> 、<code>field name</code> 和 <code>field number</code>。具体可见：<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">Language Guide (proto3)</a></p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 protocol buffer message 是由一系列的键值对组成，在转换成二进制的过程中只用 <code>field number</code> 和 <code>wire type</code> 作为键，name 和定义的 type 需配合 <code>.proto</code> 文件解析得到，这样可以极大的减小传输体积，不过需要留意的是 .proto 文件中字段的定义和顺序，否则会解析出错。</p>
<p>wire type 这里实在不知道该如何翻译…暂且叫做<code>编码后的类型</code>。下表是定义的 type 和编码后类型的对应的关系：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/PB_wire_types" alt=""></p>
<p>上面提到的键则是经过 <code>(field_number &lt;&lt; 3) | wire_type</code> 的计算得出，也就是后三位表示 wire type。</p>
<p>现在我们来分析一下<code>08 96 01</code> 。它是一个 key/value 对，我们将其拆成两块<code>08</code> 和 <code>96 01</code>。</p>
<p>08转换为二进制表示<code>0000 1000</code>，首先后三位的值为0，对应上表中 Varint，用于 int32， int64等等，a 定义的类型 int32 属于其中。然后再右移三位得到<code>0000 0001</code> ，值为1，也就是 a 的 field numer 。对照 <code>.proto</code> 文件就解析出 a 字段的位置了。</p>
<p>96 01转换为二进制表示<code>1001 0110  0000 0001</code>，根据 varint 的三条规则，我们来还原它的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">96</span> <span class="number">01</span> = <span class="number">1001</span> <span class="number">0110</span>  <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">       → <span class="number">000</span> <span class="number">0001</span>  ++  <span class="number">001</span> <span class="number">0110</span></span><br><span class="line">       → <span class="number">10010110</span></span><br><span class="line">       → <span class="number">128</span> + <span class="number">16</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">150</span></span><br></pre></td></tr></table></figure>
<p>综合一下这就是我们想要得到的 <code>a = 150</code>。</p>
<h3 id="Messages-嵌套"><a href="#Messages-嵌套" class="headerlink" title="Messages 嵌套"></a>Messages 嵌套</h3><p>Message 定义也支持嵌套，比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Test3 &#123;</span><br><span class="line">  optional Test1 c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样 Test1 中 a 的值为150，它在流中的内容是<code>1a 03 08 96 01</code> ，最后三个字节就是上面 a 的内容。<code>1a 03</code> 我们同样拆分为<code>1a</code> 和 <code>03</code>。</p>
<p>1a 转换为二进制表示<code>0001 1010</code>，对应的 wire type 为2，包含了 <code>embedded messages</code>，对应的 field number 为3。</p>
<p>03 这个的含义有所不同 ，它表示后面有三个字节，也就是<code>08 96 01</code>。</p>
<h3 id="WebSocket-Protocol-Buffer"><a href="#WebSocket-Protocol-Buffer" class="headerlink" title="WebSocket + Protocol Buffer"></a>WebSocket + Protocol Buffer</h3><p>客户端用 <a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a> ，服务端用 Node ，搭建一套 WebSocket 的环境。</p>
<p>以及用 Pods 安装 <a href="https://github.com/google/protobuf/tree/master/objectivec" target="_blank" rel="noopener">protobuf OC 版本</a>，npm 安装 <a href="https://github.com/dcodeIO/ProtoBuf.js/" target="_blank" rel="noopener">JS 版本</a>。</p>
<p>首先我们定义一个简单的 Message 结构 Person，里面包含了 name 和 age 两个字段，生成 .proto 文件，在客户端和服务端各自维护一份。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们启动后端服务，监听1234端口，并对接收到的数据根据 Person.proto 文件定义的结构进行 decode，然后打印数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"><span class="keyword">const</span> pro = <span class="built_in">require</span>(<span class="string">'protobufjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>: <span class="number">1234</span>&#125;);</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"conntected"</span>);</span><br><span class="line">  </span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    pro.load(<span class="string">'Person.proto'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, root</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> Person = root.lookupType(<span class="string">'personPackage.Person'</span>);</span><br><span class="line">      <span class="keyword">var</span> data = Person.decode(message);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'name is %s'</span>, data.name);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'age is %i'</span>, data.age);</span><br><span class="line">    &#125;);</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'received: %s'</span>, message);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  ws.send(<span class="string">'something'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>服务启动成功之后，开始在客户端建立连接，在收到连接成功的回调之后，将 person 对象进行encode 并发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_ws = [[SRWebSocket alloc] initWithURL:[NSURL URLWithString:@&quot;ws://localhost:1234&quot;]];</span><br><span class="line">_ws.delegate = self;</span><br><span class="line">[_ws open];</span><br><span class="line"></span><br><span class="line">#pragma mark - SRWebSocketDelegate</span><br><span class="line">- (void)webSocketDidOpen:(SRWebSocket *)webSocket &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    Person *person = [Person new];</span><br><span class="line">    person.name = @&quot;yzy&quot;;</span><br><span class="line">    person.age = 28;</span><br><span class="line"></span><br><span class="line">    NSData *data = [person data];</span><br><span class="line">    NSLog(@&quot;%@&quot;, data);</span><br><span class="line">    </span><br><span class="line">    [webSocket send:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端 log 中我们看到输出的 data 内容为 <code>0a03797a 79101c</code> ，你可以尝试一下对其 decode ，看它和定义的是否一致。</p>
<p>在服务端对应的 log 中也正确输出了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name is yzy</span><br><span class="line">age is 28</span><br></pre></td></tr></table></figure>
<p>这样一个简单的 Protobuf 的使用就完成了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Protocol Buffers&lt;/a&gt; 是 Google 提出的一种序列化数据格式，最早的 public release 是在08年的7月份推出。相比于 XML 和 JSON ，它的传输大小更小，速度更快，结构更简单，在数据传输和存储的场景下更具有优势。同时 Google 非常友好的提供了&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/tutorials&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不同平台的版本&lt;/a&gt;供开发者们使用，其对外的简洁性旨在让开发者们更注重业务的细节。不过本文并没有对源码进行剖析，我们重点分析的是 Protocol Buffers 是如何做到减小体积，也就是 Encoding 的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Protocol Buffers" scheme="http://yuzeyang.github.io/tags/Protocol-Buffers/"/>
    
  </entry>
  
  <entry>
    <title>跨平台长连接组件设计及可插拔改造</title>
    <link href="http://yuzeyang.github.io/2018/04/03/cross-platform-architecture%20design-and-pluggable/"/>
    <id>http://yuzeyang.github.io/2018/04/03/cross-platform-architecture design-and-pluggable/</id>
    <published>2018-04-03T12:15:57.000Z</published>
    <updated>2018-04-27T04:27:32.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在提出开发跨平台组件之前， iOS 和 Android 客户端分别使用一套长连接组件，需要双倍的人力开发和维护；在产品需求调整上，为了在实现细节上保持一致性也具有一定的难度；Web 端与客户端长连接的形式不同，前者使用 WebSocket，后者使用 Socket ，无形中也增加了后端的维护成本。为了解决这些问题，我们基于 WebSocket 协议开发了一套跨平台的长连接组件。</p>
<a id="more"></a>
<h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p>组件自上而下分为五层：</p>
<ul>
<li><strong>Native 层</strong>：负责业务请求封装和数据解析，与原生进行交互</li>
<li><strong>Chat 层</strong>：负责提供底层通信使用的 c 接口，包含连接、读写和关闭</li>
<li><strong>WebSocket 层</strong>：实现 WebSocket 协议及维护心跳</li>
<li><strong>TLS 层 </strong>：基于 <code>mbedTLS</code> 实现 TLS 协议及数据加解密</li>
<li><strong>TCP 层</strong>：基于 <code>libuv</code> 实现 TCP 连接和数据的读写</li>
</ul>
<p>整体架构如下图所示：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/3681522755222_.pic.jpg!600x600" alt=""></p>
<h3 id="TCP-层"><a href="#TCP-层" class="headerlink" title="TCP 层"></a>TCP 层</h3><p>TCP 层我们是基于 <a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>  进行开发， libuv 是一个异步 I/O 库，并且支持了多个平台（ Linux ，Windows 和 Darwin ），一开始主要应用于开发 Node.js ，后来逐渐在其他项目也开始使用。文件、 网络和管道 等操作是 I/O 操作 ，libuv 为此抽象出了相关的接口，底层使用各平台上最优的 I/O 模型实现。</p>
<p>它的核心是提供了一个 <code>event loop</code> ，每个 event loop 包含了六个阶段：</p>
<ul>
<li><strong>timers 阶段</strong>：这个阶段执行 timer（ <code>setTimeout</code> 、 <code>setInterval</code> ）的回调</li>
<li><strong>I/O callbacks 阶段</strong>：执行一些系统调用错误，比如网络通信的错误回调</li>
<li><strong>idle , prepare 阶段</strong>：仅 node 内部使用</li>
<li><strong>poll 阶段</strong>：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li>
<li><strong>check 阶段</strong>：执行 <code>setImmediate()</code> 的回调</li>
<li><strong>close callbacks 阶段</strong>：执行 <code>socket</code> 的 <code>close</code> 事件回调</li>
</ul>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/libuv-event-loop.png" alt=""></p>
<h3 id="TLS-层"><a href="#TLS-层" class="headerlink" title="TLS 层"></a>TLS 层</h3><p>mbedTLS（前身PolarSSL）是实现了一套易用的加解密算法和 SSL / TLS 库。TLS 以及前身 SSL 是传输层安全协议，给网络通信提供安全和数据完整性的保障，所以它能很好的解决数据明文和劫持篡改的问题。并且其分为记录层和传输层，记录层用来确定传输层数据的封装格式，传输层则用于数据传输，而在传输之前，通信双方需要经过握手，其包含了<code>双方身份验证</code>，<code>协商加密算法</code>，<code>交换加密密钥</code>。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/ssl_handshake.png" alt=""></p>
<h3 id="WebSocket-层"><a href="#WebSocket-层" class="headerlink" title="WebSocket 层"></a>WebSocket 层</h3><p>WebSocket 层包含了对协议的实现和心跳的维护。</p>
<p>其最新的协议是 <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">13 RFC 6455</a>。协议的实现分为握手，数据发送/读取，关闭连接。</p>
<h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p>握手要从请求头去理解。</p>
<p>WebSocket 首先发起一个 HTTP 请求，在请求头加上 <code>Upgrade</code> 字段，该字段用于改变 HTTP 协议版本或者是换用其他协议，这里我们把 <code>Upgrade</code> 的值设为 <code>websocket</code> ，将它升级为 WebSocket 协议。</p>
<p>同时要注意 <code>Sec-WebSocket-Key</code> 字段，它由客户端生成并发给服务端，用于证明服务端接收到的是一个可受信的连接握手，可以帮助服务端排除自身接收到的由非 WebSocket 客户端发起的连接，该值是一串随机经过 <code>base64</code> 编码的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>收到请求后，服务端也会做一次响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>
<p>里面重要的是 <code>Sec-WebSocket-Accept</code> ，服务端通过从客户端请求头中读取 <code>Sec-WebSocket-Key</code> 与一串全局唯一的标识字符串（俗称魔串）“258EAFA5-E914-47DA- 95CA-C5AB0DC85B11”做拼接，生成长度为160位的 <code>SHA-1</code> 字符串，然后进行 <code>base64</code> 编码，作为 <code>Sec-WebSocket-Accept</code> 的值回传给客户端，客户端再去解析这个值，与自己加密编码后的字符串进行比较。</p>
<p>处理握手 HTTP 响应解析的时候，可以用 <a href="https://github.com/nodejs/http-parser" target="_blank" rel="noopener">http-paser</a> ，解析方式也比较简单，就是对头信息的逐字读取再处理，具体处理你可以看一下它的状态机实现。解析完成后你需要对其内容进行解析，看返回是否正确，同时去管理你的握手状态。</p>
<h4 id="数据发送-读取"><a href="#数据发送-读取" class="headerlink" title="数据发送/读取"></a>数据发送/读取</h4><p>数据的处理需要用帧协议图来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>首先我们来看看数字的含义，数字表示位，0-7表示有8位，等于1个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br></pre></td></tr></table></figure>
<p>所以如果要组装一个帧数据可以这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *rev = (rev *)malloc(4);</span><br><span class="line">rev[0] = (char)(0x81 &amp; 0xff);</span><br><span class="line">rev[1] = 126 &amp; 0x7f;</span><br><span class="line">rev[2] = 1;</span><br><span class="line">rev[3] = 0;</span><br></pre></td></tr></table></figure>
<p>ok，了解了帧数据的样子，我们反过来去理解值对应的帧字段。</p>
<p>首先<code>0x81</code>是什么，这个是十六进制数据，转换成二进制就是<code>1000 0001</code>， 是一个字节的长度，也就是这一段里面每一位的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 </span><br><span class="line">+-+-+-+-+-------+</span><br><span class="line">|F|R|R|R| opcode|</span><br><span class="line">|I|S|S|S|  (4)  |</span><br><span class="line">|N|V|V|V|       |</span><br><span class="line">| |1|2|3|       |</span><br><span class="line">+-+-+-+-+-------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>FIN</code> 表示该帧是不是消息的最后一帧，1表示结束，0表示还有下一帧。</p>
</li>
<li><p><code>RSV1, RSV2, RSV3</code> 必须为0，除非扩展协商定义了一个非0的值，如果没有定义非0值，且收到了非0的 <code>RSV</code> ，那么 WebSocket 的连接会失效，建议是断开连接。</p>
</li>
<li><p><code>opcode</code> 用来描述 <code>Payload data</code> 的定义，如果收到了一个未知的 <code>opcode</code> ，同样会使 WebSocket 连接失效，协议定义了以下值：</p>
<ul>
<li>%x0 表示连续的帧</li>
<li>%x1 表示 text 帧</li>
<li>%x2 表示二进制帧</li>
<li>%x3-7 预留给非控制帧</li>
<li>%x8 表示关闭连接帧</li>
<li>%x9 表示 ping</li>
<li>%xA 表示 pong</li>
<li>%xB-F 预留给控制帧</li>
</ul>
<p>连续帧是和 FIN 值相关联的，它表明可能由于消息分片的原因，将原本一个帧的数据分为多个帧，这时候前一帧的 opcode 就是0，FIN 也是0，最后一帧的 opcode 就不再是0，FIN 就是1了。</p>
<p>再可以看到 opcode 预留了非控制帧和控制帧，这两个又是什么？</p>
<p>控制帧表示 WebSocket 的状态信息，像是定义的分片，关闭连接，ping和pong。</p>
<p>非控制帧就是数据帧，像是 text 帧，二进制帧。</p>
</li>
</ul>
<p><code>0xff</code> 作用就是取出需要的二进制值。</p>
<p>下面再来看<code>126</code>，126则表示的是 <code>Payload len</code> ，也就是 Payload 的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">                +-+-------------+-------------------------------+</span><br><span class="line">                |M| Payload len |    Extended payload length    |</span><br><span class="line">                |A|     (7)     |             (16/64)           |</span><br><span class="line">                |S|             |   (if payload len==126/127)   |</span><br><span class="line">                |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |           Payload Data        |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MASK</code> 表示<code>Playload data</code> 是否要加掩码，如果设成1，则需要赋值 <code>Masking-key</code> 。所有从客户端发到服务端的帧都要加掩码</li>
<li><p><code>Playload le</code> 表示 Payload 的长度，这里分为三种情况</p>
<ul>
<li>长度小于126，则只需要7位</li>
<li>长度是126，则需要额外2个字节的大小，也就是 <code>Extended payload length</code></li>
<li>长度是127，则需要额外8个字节的大小，也就是 <code>Extended payload length</code> + <code>Extended payload length continued</code> ，<code>Extended payload length</code> 是2个字节，<code>Extended payload length continued</code> 是6个字节</li>
</ul>
</li>
<li><code>Extended Playload len</code> 则表示 <code>Extension data</code> 与 <code>Application data</code> 的和</li>
<li><code>Masking-key</code> 是在 <code>MASK</code> 设置成1之后，随机生成的4字节长度的数据，然后和 <code>Payload Data</code>做异或运算</li>
<li><code>Payload Data</code> 就是我们发送的数据</li>
</ul>
<p>而数据的发送和读取就是对帧的封装和解析。</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><p>关闭连接分为两种：服务端发起关闭和客户端主动关闭。</p>
<p>服务端跟客户端的处理基本一致，以服务端为例：</p>
<p>服务端发起关闭的时候，会客户端发送一个关闭帧，客户端在接收到帧的时候通过解析出帧的opcode来判断是否是关闭帧，然后同样向服务端再发送一个关闭帧作为回应。</p>
<h3 id="Chat-层"><a href="#Chat-层" class="headerlink" title="Chat 层"></a>Chat 层</h3><p>Chat 层比较简单，只是提供一些通用的<strong>连接</strong>、<strong>读写数据</strong>和<strong>断开</strong>接口和回调，同时维护一个 loop 用于重连。</p>
<h3 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h3><p>这一层负责和原生进行交互，由于组件是用 c 代码编写的，所以为了调用原生方法，Android 采用 JNI 的方式，iOS 采用 runtime 的方式来实现。</p>
<p>JNI ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_youzan_mobile_im_network_Channel_nativeDisconnect(JNIEnv *env, jobject jobj) &#123;</span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(jobj);</span><br><span class="line">    jfieldID fieldID = env-&gt;GetFieldID(clazz, CONTEXT_VARIABLE, <span class="string">"J"</span>);</span><br><span class="line">    context *c = (context *) env-&gt;GetLongField(jobj, fieldID);</span><br><span class="line">    im_close(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runtime: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">int</span> cId, <span class="keyword">int</span> mId, <span class="keyword">int</span> version, <span class="keyword">int</span> mv, <span class="keyword">const</span> <span class="keyword">char</span> *req_id, <span class="keyword">const</span> <span class="keyword">char</span> *data &#123;</span></span></span><br><span class="line">    context *ctx = (context *)objc_msgSend(g_obj, sel_registerName("ctx"));</span><br><span class="line">    send_request(ctx, cId, mId, version, mv, req_id, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插拔式架构改造"><a href="#插拔式架构改造" class="headerlink" title="插拔式架构改造"></a>插拔式架构改造</h2><p>在实现了一套跨端长连接组件之后，最近我们又完成了其插件化的改造，为什么要做这样的改造呢？由于业务环境复杂和运维的相关限制，有的业务方可以配置 TLS 组成 WSS；有的业务方不能配置，只能以明文 WebSocket 的方式传输；有的业务方甚至连 WebSocket 的承载也不要，转而使用自定义的协议。随着对接的业务方增多，我们没办法进行为他们一一定制。我们当初设计的结构是 Worker (负责和业务层通信) -&gt; WebSocket -&gt; TLS -&gt; TCP ，这四层结构是耦合在一起的，这时候如果需要剔除 TLS 或者扩展一个新的功能，就会改动相当多的代码。基于以上几点，我们发现，原先的定向设计完全不符合要求，为了接下来可能会有新增协议解析的预期，同时又不改变使用 libuv 进行跨平台的初衷，所以我们就实施了插件化的改造，最重要的目的是为了<code>解耦</code>，同时也为了提高组件的灵活性，实现<code>可插拔（冷插拔）</code>。</p>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>首先我们要对四层结构的职责进行明确</p>
<ul>
<li><strong>Worker</strong> ：提供业务接口和回调</li>
<li><strong>WebSocket</strong> ：负责 WebSocket 握手，封装/解析帧数据和维护心跳</li>
<li><strong>TLS</strong> ：负责 TLS 握手和数据的加解密</li>
<li><strong>TCP</strong>：TCP 连接和数据的读写</li>
</ul>
<p>以及整理出结构间的执行调用：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/chat_puggable.png" alt=""></p>
<p>其中 connect 包含了<code>连接</code>和<code>握手</code>两个过程。在完成链路层连接后，我们认为协议层握手完成，才算是真正的连接成功。</p>
<p>同样的，数据读写、连接关闭、连接销毁和重置都会严格按照结构的顺序依次调用。</p>
<h2 id="可插拔改造"><a href="#可插拔改造" class="headerlink" title="可插拔改造"></a>可插拔改造</h2><p>解耦完成之后我们发现对于接口的调用都是显式的，比如 Worker send data 中调用 WebSocket send data ， WebSocket send data 中又调用 TLS send data ，这样的显式调用是因为我们知道这些接口是可用的，但在插件化中某个插件可能没有被使用，这样接口的调用会在某一层中断而导致整个组件的不可用。</p>
<h3 id="结构体改造"><a href="#结构体改造" class="headerlink" title="结构体改造"></a>结构体改造</h3><p>所以我们首先考虑到的是抽象出一个结构体，将插件的接口及回调统一，然后利用<code>函数指针</code>实现插件方法的调用，以下是对函数指针声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_init)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">map_t</span> params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_conn)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_write_data)</span><span class="params">(<span class="keyword">dul_node_t</span> *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *payload,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span> *params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_read_data)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">void</span> *params, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">char</span> *payload, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint64_t</span> size)</span></span>;                    </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_close)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;                           </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_destroy)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_reset)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* callback */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_conn_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_write_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">int</span> status)</span></span>;                         </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_recv_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">void</span> *params, <span class="keyword">uv_buf_t</span> *buf, <span class="keyword">ssize_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_close_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但如果仅仅声明这些函数指针，在使用时还必须知道插件的结构体类型才能调用到函数的实现，这样插件之间仍然是耦合的。所以我们必须将插件提前关联起来，通过结构体指针来寻找上一个或者下一个插件，OK，这样就很容易联想到<code>双向链表</code>正好能够满足我们的需求。所以加上 <code>pre</code>  、 <code>next</code> 以及一些必要参数后，最终我们整理的结构体为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dul_node_s</span> &#123;</span></span><br><span class="line"> 	<span class="comment">// 前、后插件</span></span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre;</span><br><span class="line">    <span class="keyword">dul_node_t</span> *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必要参数</span></span><br><span class="line">    <span class="keyword">char</span> *host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">map_t</span> params;</span><br><span class="line"></span><br><span class="line">    node_init init;</span><br><span class="line">    node_conn conn;</span><br><span class="line">    node_write_data write_data;</span><br><span class="line">    node_read_data read_data;</span><br><span class="line">    node_close close;</span><br><span class="line">    node_destroy destroy;</span><br><span class="line">    node_reset reset;</span><br><span class="line"></span><br><span class="line">    node_conn_cb conn_cb;</span><br><span class="line">    node_write_cb write_cb;</span><br><span class="line">    node_recv_cb recv_cb;</span><br><span class="line">    node_close_cb close_cb;</span><br><span class="line">&#125; <span class="keyword">dul_node_t</span>;</span><br></pre></td></tr></table></figure>
<p>接着我们再对原有的结构体进行调整，将结构体前面的成员调整为 <code>dul_node_s</code> 结构体的成员，后面再加上自己的成员。这样在插件初始化的时候统一以 <code>dul_node_s</code> 结构体初始化，而在用到具体某一个插件时我们进行结构体类型强转即可，这里有点像继承里父类和子类的概念。</p>
<h3 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h3><p>在插件使用前我们按需配置好用到的插件，但如果把插件接口直接暴露给业务方来配置，就需要让业务方接触到 C 代码，这点比较难以控制。基于这个原因，我们讨论了一下，想到前端里面 <code>webpack</code> 对于插件配置的相关操作，于是我们查阅了<a href="https://webpack.js.org/concepts/loaders/#inline" target="_blank" rel="noopener"> webpack 的相关文档</a>，最终我们仿照这个方式实现了我们的插件配置：<code>&quot;ws?path=/!tls!uv&quot;</code> 。不同插件以 <code>!</code> 分割，通过循环将插件依次创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separate_loaders</span><span class="params">(<span class="keyword">tokenizer_t</span> *tokenizer, <span class="keyword">char</span> *loaders, context *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *outer_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p = strtok_r(loaders, <span class="string">"!"</span>, &amp;outer_ptr);</span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre_loader = (<span class="keyword">dul_node_t</span> *)c;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        pre_loader = processor_loader(tokenizer, p, pre_loader);</span><br><span class="line">        p = strtok_r(<span class="literal">NULL</span>, <span class="string">"!"</span>, &amp;outer_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单个插件所需要额外的 params 以 <code>query string</code> 形式拼接，在插件创建中用 <code>?</code> 分割出来 ，以 kv 形式放入到一个 hashmap 中。再根据插件的名称调用对应的初始化方法，并根据传入的 <code>pre_loader</code> 绑定双向链表的前后关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*oper_func[])(<span class="keyword">dul_node_t</span> **) = &#123;</span><br><span class="line">    ws_alloc,</span><br><span class="line">    tls_alloc,</span><br><span class="line">    uv_alloc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *loaders[] = &#123;</span><br><span class="line">    <span class="string">"ws"</span>, <span class="string">"tls"</span>, <span class="string">"uv"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dul_node_t</span> *processor_loader(<span class="keyword">tokenizer_t</span> *tokenizer, <span class="keyword">const</span> <span class="keyword">char</span> *loader, <span class="keyword">dul_node_t</span> *pre_loader) &#123;</span><br><span class="line">    <span class="keyword">char</span> *p = loader;</span><br><span class="line">    <span class="keyword">char</span> *inner_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* params 提取组装 */</span></span><br><span class="line">    p = strtok_r(p, <span class="string">"?"</span>, &amp;inner_ptr);</span><br><span class="line">    <span class="keyword">dul_node_t</span> *node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">map_t</span> params = hashmap_new();</span><br><span class="line">    params_parser(inner_ptr, params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里采用转移表，进行插件初始化 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(loaders[sqe], p) != <span class="number">0</span>) &#123;</span><br><span class="line">        sqe++;</span><br><span class="line">    &#125;</span><br><span class="line">    oper_func[sqe](&amp;node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;init(node, params);</span><br><span class="line">    hashmap_free(params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表前后关系绑定</span></span><br><span class="line">    pre_loader-&gt;next = node;</span><br><span class="line">    node-&gt;pre = pre_loader;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* params string 解析 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">params_parser</span><span class="params">(<span class="keyword">char</span> *query, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *outer_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = strtok_r(query, <span class="string">"&amp;"</span>, &amp;outer_ptr);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">char</span> *inner_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *key =  strtok_r(p, <span class="string">"="</span>, &amp;inner_ptr);</span><br><span class="line">        hashmap_put(params, key, inner_ptr);</span><br><span class="line">        p = strtok_r(<span class="literal">NULL</span>, <span class="string">"&amp;"</span>, &amp;outer_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips：随着插件的增加，对应初始化的代码也会越来越多，而且都是重复代码，为了减少这部分工作，我们可以采取宏来定义函数。后续如果增加一个插件，只需要在底下加一行 <code>LOADER_ALLOC(zim_xx, xx)</code> 即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOADER_ALLOC(type, name)                    \</span></span><br><span class="line">    <span class="keyword">void</span> name##_alloc(<span class="keyword">dul_node_t</span> **ctx) &#123;           \</span><br><span class="line">        type##<span class="keyword">_t</span> **loader = (type##<span class="keyword">_t</span> **)ctx;       \</span><br><span class="line">        (*loader) = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type##<span class="keyword">_t</span>));       \</span><br><span class="line">        (*loader)-&gt;init = &amp;name##_init;             \</span><br><span class="line">        (*loader)-&gt;next = <span class="literal">NULL</span>;                     \</span><br><span class="line">        (*loader)-&gt;pre = <span class="literal">NULL</span>;                      \</span><br><span class="line">    &#125;                       </span><br><span class="line"></span><br><span class="line">LOADER_ALLOC(websocket, ws);</span><br><span class="line">LOADER_ALLOC(zim_tls, tls);</span><br><span class="line">LOADER_ALLOC(zim_uv, uv);</span><br></pre></td></tr></table></figure>
<h3 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h3><p>再回到一开始我们思考接口调用的问题，由于有了函数指针变量，我们就需要在插件的初始化中把函数的地址存储在这些变量中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ws_init</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">websocket_t</span> *ws = (<span class="keyword">websocket_t</span> *)ctx;</span><br><span class="line">    bzero(ws, <span class="keyword">sizeof</span>(<span class="keyword">websocket_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略中间初始化过程</span></span><br><span class="line">  </span><br><span class="line">    ws-&gt;init = &amp;ws_init;</span><br><span class="line">    ws-&gt;conn = &amp;ws_connect;</span><br><span class="line">    ws-&gt;close = &amp;ws_close;</span><br><span class="line">    ws-&gt;destroy = &amp;ws_destroy;</span><br><span class="line">    ws-&gt;reset = &amp;ws_reset;</span><br><span class="line">    ws-&gt;write_data = &amp;ws_send;</span><br><span class="line">    ws-&gt;read_data = &amp;ws_read;</span><br><span class="line">    ws-&gt;conn_cb = &amp;ws_conn_cb;</span><br><span class="line">    ws-&gt;write_cb = &amp;ws_send_cb;</span><br><span class="line">    ws-&gt;recv_cb = &amp;ws_recv_cb;</span><br><span class="line">    ws-&gt;close_cb = &amp;ws_close_cb;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比接口前后调用的方式，前者需要知道下一个 connect 函数，并进行显式调用，如果在 TLS 和 TCP 中新增一层，就需要改动 connect 函数的调用。但后者完全没有这个顾虑，不论是新增还是删除插件，它都可以通过指针找到对应的结构体，调用其 connect 函数，插件内部无需任何改动，岂不妙哉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 改造前 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tls_ws_connect</span><span class="params">(<span class="keyword">tls_ws_t</span> *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                   tls_ws_conn_cb conn_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                   tls_ws_close_cb close_cb)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uv_tls_connect(tls,</span><br><span class="line">                          handle-&gt;host,</span><br><span class="line">                          handle-&gt;port,</span><br><span class="line">                          on__tls_connect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改造后 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tls_connect</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_tls_t</span> *tls = (<span class="keyword">zim_tls_t</span> *)ctx;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tls-&gt;next &amp;&amp; tls-&gt;next-&gt;conn) &#123;</span><br><span class="line">        tls-&gt;next-&gt;host = tls-&gt;host;</span><br><span class="line">        tls-&gt;next-&gt;port = tls-&gt;port;</span><br><span class="line">        tls-&gt;next-&gt;conn(tls-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增插件"><a href="#新增插件" class="headerlink" title="新增插件"></a>新增插件</h3><p>基于改造后组件，新增插件只需要改动三处，以日志插件为例：</p>
<ul>
<li>增加日志文件</li>
</ul>
<p>在头文件中定义 <code>zim_log_s</code> 结构体（这里没有额外的成员）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zim_log_s</span> <span class="title">zim_log_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zim_log_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre;</span><br><span class="line">    <span class="keyword">dul_node_t</span> *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">map_t</span> params;</span><br><span class="line"></span><br><span class="line">    node_init init;</span><br><span class="line">    node_conn conn;</span><br><span class="line">    node_write_data write_data;</span><br><span class="line">    node_read_data read_data;</span><br><span class="line">    node_close close;</span><br><span class="line">    node_destroy destroy;</span><br><span class="line">    node_reset reset;</span><br><span class="line"></span><br><span class="line">    node_conn_cb conn_cb;</span><br><span class="line">    node_write_cb write_cb;</span><br><span class="line">    node_recv_cb recv_cb;</span><br><span class="line">    node_close_cb close_cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在实现文件中实现接口及回调，<strong>注意：即使接口或回调内没有额外的操作，仍然需要实现，例如此处的 log_conn_cb 和 log_connect ，否则上一个插件或下一个插件在日志层调用时会中断</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* callback */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_conn_cb</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;pre &amp;&amp; <span class="built_in">log</span>-&gt;pre-&gt;conn_cb) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;pre-&gt;conn_cb(<span class="built_in">log</span>-&gt;pre, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略中间直接回调 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_recv_cb</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">void</span> *params, <span class="keyword">uv_buf_t</span> *buf, <span class="keyword">ssize_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 收集接收到的数据 */</span></span><br><span class="line">    recv_data_from_server(buf-&gt;base, params, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 继续向上一层插件回调接收到的数据 */</span></span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;pre &amp;&amp; <span class="built_in">log</span>-&gt;pre-&gt;recv_cb) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;pre-&gt;recv_cb(<span class="built_in">log</span>-&gt;pre, opcode, buf, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* log hanlder */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_init</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    bzero(<span class="built_in">log</span>, <span class="keyword">sizeof</span>(<span class="keyword">zim_log_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span>-&gt;init = &amp;log_init;</span><br><span class="line">    <span class="built_in">log</span>-&gt;conn = &amp;log_connect;</span><br><span class="line">    <span class="built_in">log</span>-&gt;write_data = &amp;log_write;</span><br><span class="line">    <span class="built_in">log</span>-&gt;read_data = &amp;log_read;</span><br><span class="line">    <span class="built_in">log</span>-&gt;close = &amp;log_close;</span><br><span class="line">    <span class="built_in">log</span>-&gt;destroy = &amp;log_destroy;</span><br><span class="line">    <span class="built_in">log</span>-&gt;reset = &amp;log_reset;</span><br><span class="line">    <span class="built_in">log</span>-&gt;conn_cb = &amp;log_conn_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;write_cb = &amp;log_write_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;recv_cb = &amp;log_recv_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;close_cb = &amp;log_close_cb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_connect</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;next &amp;&amp; <span class="built_in">log</span>-&gt;next-&gt;conn) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;host = <span class="built_in">log</span>-&gt;host;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;port = <span class="built_in">log</span>-&gt;port;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;conn(<span class="built_in">log</span>-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略中间直接调用 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_write</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">char</span> *payload, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 收集发送数据 */</span></span><br><span class="line">    send_data_to_server(payload, payload_size, params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 继续往下一层插件写入数据 */</span></span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;next &amp;&amp; <span class="built_in">log</span>-&gt;next-&gt;write_data) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;write_data(<span class="built_in">log</span>-&gt;next, payload, payload_size, flags);</span><br><span class="line">    &#125;                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>增加日志初始化函数及修改转移表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOADER_ALLOC(zim_log, <span class="built_in">log</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> (*oper_func[])(<span class="keyword">dul_node_t</span> **) = &#123;</span><br><span class="line">    ws_alloc,</span><br><span class="line">    tls_alloc,</span><br><span class="line">    uv_alloc,</span><br><span class="line">    log_alloc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *loaders[] = &#123;</span><br><span class="line">    <span class="string">"ws"</span>, <span class="string">"tls"</span>, <span class="string">"uv"</span>, <span class="string">"log"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改插件注册</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 增加日志前 */</span></span><br><span class="line"><span class="keyword">char</span> loaders[] = <span class="string">"ws?path=/!tls!uv"</span>;</span><br><span class="line">context_init(c, <span class="string">"127.0.0.1"</span>, <span class="number">443</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="literal">NULL</span>, loaders);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加日志后 */</span></span><br><span class="line"><span class="keyword">char</span> loaders[] = <span class="string">"log!ws?path=/!log!tls!uv"</span>;</span><br><span class="line">context_init(c, <span class="string">"127.0.0.1"</span>, <span class="number">443</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="literal">NULL</span>, loaders);</span><br></pre></td></tr></table></figure>
<p>我们重新运行程序，就能发现日志功能已经成功的配置上去，能够将接受和发送的数据上报：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/zim_log.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下跨平台长连接组件的设计，我们使用 libuv 和 mbedtls 分别实现 TCP 和 TLS ，参照 WebSocket 协议实现了其握手及数据读写，同时抽象出通信接口及回调，为了和原生层交互，iOS 和 Android 分别采用 runtime 消息发送和 JNI 进行原生方法调用。</p>
<p>但这样的定向设计完全不符合后期可能会有新增协议解析的预期，所以我们进行了插件化改造，其三个核心点是<code>结构体改造</code>、<code>双向链表</code>和<code>函数指针</code>。</p>
<p>我们通过将插件行为抽象出一个结构体，利用双向链表将前后插件绑定在一起，使用函数指针调用具体插件的函数或回调。</p>
<p>这样做的优点是使得插件之间不存在耦合关系，只需保持逻辑顺序上的关系，同时通过修改插件的注册提高了灵活性，使得组件具有可插拔性（冷插拔）。</p>
<p>但在新增组件中我们需要实现所有的接口和回调，如果数量多的话，这还真是一件比较繁琐的事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们在提出开发跨平台组件之前， iOS 和 Android 客户端分别使用一套长连接组件，需要双倍的人力开发和维护；在产品需求调整上，为了在实现细节上保持一致性也具有一定的难度；Web 端与客户端长连接的形式不同，前者使用 WebSocket，后者使用 Socket ，无形中也增加了后端的维护成本。为了解决这些问题，我们基于 WebSocket 协议开发了一套跨平台的长连接组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="跨平台 长连接 架构设计 可插拔" scheme="http://yuzeyang.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0-%E9%95%BF%E8%BF%9E%E6%8E%A5-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E5%8F%AF%E6%8F%92%E6%8B%94/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 笔记</title>
    <link href="http://yuzeyang.github.io/2017/09/24/https/"/>
    <id>http://yuzeyang.github.io/2017/09/24/https/</id>
    <published>2017-09-24T06:51:26.000Z</published>
    <updated>2017-09-24T10:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPS 是被广泛应用在网络中的一种加密通信协议，也被叫做在 TLS 之上的 HTTP。TLS 以及前身 SSL 是传输层安全协议，给网络通信提供安全和数据完整性的保障，所以它能很好的解决 HTTP 的数据明文和劫持篡改的问题。并且其分为记录层和传输层，记录层用来确定传输层数据的封装格式，传输层则用于数据传输，而在传输之前，通信双方如何彼此信任和建立一个安全通信方式，是需要我们深入了解的。</p>
<p>目前推荐的 TLS 版本是 1.2，协议具体内容可以在 <a href="https://tools.ietf.org/html/rfc5246#section-7.4.2" target="_blank" rel="noopener">The Transport Layer Security (TLS) Protocol Version 1.2</a> 中去仔细了解，它是08年8月发表的。 TLS 1.3 到16年1月都还只是草案。</p>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>这里我使用 <a href="https://www.wireshark.org/download.html" target="_blank" rel="noopener">Wireshark</a> 来抓包看 HTTPS 的握手过程，首先我们需要开启网卡</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /dev/bpf*</span><br></pre></td></tr></table></figure>
<p>否则会提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no interface can be used for capturing in this system with the current configuration</span><br></pre></td></tr></table></figure>
<p>开启之后，我们在浏览器内访问一个 <a href="https://xxx" target="_blank" rel="noopener">https://xxx</a> 的网站，再过滤出 ssl，不难找到我们所需要的信息。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我截取了其中一段</p>
<p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_handshake" alt=""></p>
<p>握手总结起来就是双方身份验证，协商加密算法，交换加密密钥。</p>
<p>而这些步骤有些服务器是合并在一起发送，例如：</p>
<p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_another_example" alt=""></p>
<h3 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h3><p>首先客户端会发送一个 Hello 消息给服务端：</p>
<p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_client_hello" alt=""></p>
<p> <code>Version: TLS 1.2</code> 是其版本信息，<code>Random</code> 是由客户端生成的随机数，长度为28个字节（用于协商密钥），<code>Cipher Suites</code> 是客户端支持的加密算法，让服务端从中选择一个，<code>Compression Methods</code> 是压缩方法，以及一些额外的信息。</p>
<p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_client_extension" alt=""></p>
<h3 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h3><p>服务端在收到客户端发起的 Hello 之后，同样回给客户端一个 Hello：</p>
<p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_server_hello" alt=""></p>
<p>里面包含了协商后的版本信息 TLS 1.2，使用的加密算法 <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code> 和压缩方法，以及服务端生成的随机数（用于协商密钥）。</p>
<h3 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h3><p>同时服务端也会配置并返回对应的证书，用来身份验证和密钥交换。</p>
<p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_server_cer" alt=""></p>
<h4 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h4><p>申请者需要向颁发证书的可信第三方CA机构提交域名、公钥和请求文件(.cer文件)，CA机构验证信息的合法真实性后颁发证书，里面分为明文信息和签名信息，明文信息包括域名，申请者信息和颁发机构，有效期，公钥等信息，签名信息是通过CA私钥对明文信息进行加密后的内容，申请者在安装证书后，可以通过证书公钥来对签名信息和明文信息进行验证。</p>
<h4 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h4><p>验证分为两部分，验证证书本身的合法性和验证颁发者的合法性。</p>
<p>我们知道证书是分层级的，下一级的证书需要用上一级证书的<code>私钥</code>签名，所以需要通过使用上一级证书的公钥来解密得到下一级的签名摘要，同时客户端也如此操作，最后对摘要进行对比验证。</p>
<p>颁发者合法性则是检查浏览器和操作系统中的可信证书列表。所以有时候不要乱安装一些奇奇怪怪的证书。</p>
<h3 id="Server-Key-Exchange-Server-Hello-Done"><a href="#Server-Key-Exchange-Server-Hello-Done" class="headerlink" title="Server Key Exchange, Server Hello Done"></a>Server Key Exchange, Server Hello Done</h3><p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_server_exchange_key" alt=""></p>
<p><code>Server Key Exchange</code> 用来加密下一步中的 Client Key Exchange ，只有当证书中不包含公钥的时候才需要，比如用 <code>Diffie Hellman</code> 密钥交换算法。</p>
<p><code>Server Hello Done</code> 表示服务端 Hello 的结束。</p>
<h3 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h3><p>此时客户端在验证证书通过之后，客户端需要再传递一个随机数给客户端，这里涉及到两种方式，一种是通过 <a href="https://tools.ietf.org/html/rfc5246#section-7.4.7.1" target="_blank" rel="noopener">RSA 加密</a>，客户端先生成48字节的随机数，再用证书的公钥加密，然后发给服务端，另一种是这里客户端用的是 <a href="https://tools.ietf.org/html/rfc5246#section-7.4.7.2" target="_blank" rel="noopener">Diffie-Hellman</a> 密钥交换算法，所以这条消息会包含客户端的 Diffie-Hellman 公钥。</p>
<p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_client_exchange_key" alt=""></p>
<h3 id="Encrypted-Handshake-Message-Application-Data"><a href="#Encrypted-Handshake-Message-Application-Data" class="headerlink" title="Encrypted Handshake Message, Application Data"></a>Encrypted Handshake Message, Application Data</h3><p>此时双方根据客户端生成的2个随机数和服务端生成的1个随机数，使用相同的算法得到一个协商密钥，对数据进行对称加密得到 <code>Encrypted Application Data</code>，然后再进行通信，对方再进行解密，从而保证数据传输的安全性。</p>
<p><img src="http://7xt7s8.com2.z0.glb.clouddn.com/https_application_data" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTPS 请求过程主要分为握手和数据传输两步，握手是在双方验证身份之后，协商出一个密钥，数据传输则是使用之前协商的密钥，对数据进行加密传输。</p>
<p>本文是对 HTTPS 请求的一个简单的理解笔记，欢迎大家一起学习交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTPS 是被广泛应用在网络中的一种加密通信协议，也被叫做在 TLS 之上的 HTTP。TLS 以及前身 SSL 是传输层安全协议，给网络通信提供安全和数据完整性的保障，所以它能很好的解决 HTTP 的数据明文和劫持篡改的问题。并且其分为记录层和传输层，记录层用来确定传输层数据的封装格式，传输层则用于数据传输，而在传输之前，通信双方如何彼此信任和建立一个安全通信方式，是需要我们深入了解的。&lt;/p&gt;
&lt;p&gt;目前推荐的 TLS 版本是 1.2，协议具体内容可以在 &lt;a href=&quot;https://tools.ietf.org/html/rfc5246#section-7.4.2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Transport Layer Security (TLS) Protocol Version 1.2&lt;/a&gt; 中去仔细了解，它是08年8月发表的。 TLS 1.3 到16年1月都还只是草案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTPS" scheme="http://yuzeyang.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>用 Fastlane 升级私有 Pod 库</title>
    <link href="http://yuzeyang.github.io/2017/09/09/fastlane-pod-spec-upgrade/"/>
    <id>http://yuzeyang.github.io/2017/09/09/fastlane-pod-spec-upgrade/</id>
    <published>2017-09-09T06:26:37.000Z</published>
    <updated>2017-09-09T09:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近我们完成了用 <code>Fastlane</code> 自动化打包上传 iTunes Counnet ，为了将 Fastlane 的功能进一步的使用，后面希望能将 Pod 集成和升级也自动化，我也抽空研究了一下私有 Pod 库的升级、 Fastlane Action的制作和 Fastlane Plugin 的制作。</p>
<a id="more"></a>
<p>ok，开始我们的正文。</p>
<p>首先，简单介绍一下 <a href="https://github.com/fastlane/fastlane" target="_blank" rel="noopener">Fastlane </a>，它是用 <code>Ruby</code> 来实现自动化构建和打包的工具，并且能和 <code>Jenkins</code> 等 CI 平台结合使用。 Fastlane 对于 iOS 开发来说，实在是太友好，从它提供的 <a href="https://docs.fastlane.tools/actions/" target="_blank" rel="noopener">actions</a> 和 <a href="https://docs.fastlane.tools/plugins/available-plugins/" target="_blank" rel="noopener">plugins</a> 来看，足以满足大部分的自动化任务，如果不够的话，可以自定义 Action，并且可以制作成 Plugin 提交到 <code>RubyGems</code> 上供其他开发者使用。</p>
<h3 id="升级私有-Pod-库"><a href="#升级私有-Pod-库" class="headerlink" title="升级私有 Pod 库"></a>升级私有 Pod 库</h3><p>对 Fastlane 的配置这里就不说了，配置好后最简单的文件结构就是只有一个 <code>Appfile</code> 和 <code>Fastfile</code> ，Appfile 包含刚才初始化时配置，而 Fastfile 负责执行任务。</p>
<p>首先我们来分析一下我们平时在升级私有 Pod 库时的步骤（看注释部分）</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git_pull <span class="comment"># 拉取最新代码</span></span><br><span class="line">ensure_git_branch <span class="comment"># 确保当前是 master 分支</span></span><br><span class="line">pod_spec_lint(<span class="symbol">allow_warnings:</span> <span class="literal">true</span>) <span class="comment"># 检查 Podspec 有效性</span></span><br><span class="line">version_bump_podspec(<span class="symbol">path:</span> path, <span class="symbol">version_number:</span> version) <span class="comment"># 修改 podspec 中版本</span></span><br><span class="line">git_commit(<span class="symbol">path:</span> <span class="string">"."</span>, <span class="symbol">message:</span> <span class="string">"update version to <span class="subst">#&#123;version&#125;</span>"</span>) <span class="comment"># commit</span></span><br><span class="line">push_to_git_remote <span class="comment"># 提交本地改动到远程分支</span></span><br><span class="line">add_git_tag(<span class="symbol">tag:</span> version) <span class="comment"># 添加 tag</span></span><br><span class="line">push_git_tags <span class="comment"># push 本地 tags</span></span><br><span class="line">pod_push(<span class="symbol">path:</span> path, <span class="symbol">allow_warnings:</span> <span class="literal">true</span>) <span class="comment"># push podspec 到仓库</span></span><br></pre></td></tr></table></figure>
<p>再回到注释对应的 fastlane 命令，实际上 fastlane 的 actions 里都能找到 Pod 对应的命令，我们对照文档填充好参数之后，整个升级的核心功能已经实现了。最后我们考虑命令需要的哪些入参，我们需要知道 Project 的名字和升级到哪一个版本</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">version = options[<span class="symbol">:version</span>]</span><br><span class="line">project = options[<span class="symbol">:project</span>]</span><br></pre></td></tr></table></figure>
<p>完成之后我们后面升级只需要一行命令</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane pod_repo_push <span class="symbol">project:</span>[projectname] <span class="symbol">version:</span>[version]</span><br></pre></td></tr></table></figure>
<p>详见：<a href="https://github.com/Yuzeyang/Fastfile/blob/master/fastlane/Fastfile" target="_blank" rel="noopener">Fastfile</a></p>
<h3 id="自定义-Action"><a href="#自定义-Action" class="headerlink" title="自定义 Action"></a>自定义 Action</h3><p>上面升级库中用到了一个命令 <code>pod_spec_lint</code> ，这个并没有在官方提供的 Actions 里，是我自定义的，为什么要用 pod_spec_lint 不用 <code>pod_lib_lint</code> 呢？当时我在在测试升级的时候，把私有库更新传到 Github 上时，pod_lib_lint 验证通过，但是 push 到 remote 的时候就报错源文件找不到，这就让我很纳闷了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[22:46:42]: --------------------------</span><br><span class="line">[22:46:42]: --- Step: pod_lib_lint ---</span><br><span class="line">[22:46:42]: --------------------------</span><br><span class="line">[22:46:42]: $ pod lib lint --allow-warnings</span><br><span class="line">[22:46:52]: ▸ -&gt; FastlanePodspecDemo (0.1.1)</span><br><span class="line">[22:46:52]: ▸ - WARN | summary: The summary is not meaningful.</span><br><span class="line">[22:46:52]: ▸ - WARN | description: The description is equal to the summary.</span><br><span class="line">[22:46:52]: ▸ - WARN | [iOS] license: Unable to find a license file</span><br><span class="line">[22:46:52]: ▸ FastlanePodspecDemo passed validation.</span><br><span class="line">[22:46:52]: Pod lib lint Successfully ⬆️</span><br><span class="line">[22:46:52]: ----------------------------------</span><br><span class="line">...</span><br><span class="line">[22:47:34]: --- Step: pod_push ---</span><br><span class="line">[22:47:34]: ----------------------</span><br><span class="line">[22:47:34]: $ pod trunk push &apos;FastlanePodspecDemo.podspec&apos; --allow-warnings</span><br><span class="line">[22:47:34]: ▸ Updating spec repo master</span><br><span class="line">[22:49:36]: ▸ CocoaPods 1.3.1 is available.</span><br><span class="line">[22:49:36]: ▸ To update use: sudo gem install cocoapods</span><br><span class="line">[22:49:36]: ▸ For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.1</span><br><span class="line">[22:49:36]: ▸ Validating podspec</span><br><span class="line">[22:49:51]: ▸ -&gt; FastlanePodspecDemo (0.1.2)</span><br><span class="line">[22:49:51]: ▸ - WARN | summary: The summary is not meaningful.</span><br><span class="line">[22:49:51]: ▸ - WARN | description: The description is equal to the summary.</span><br><span class="line">[22:49:51]: ▸ - ERROR | [iOS] file patterns: The source_files pattern did not match any file.</span><br><span class="line">[22:49:51]: ▸ - ERROR | [iOS] file patterns: The resources pattern did not match any file.</span><br><span class="line">[22:49:51]: ▸ - WARN | [iOS] license: Unable to find a license file</span><br><span class="line">[22:49:51]: ▸ [!] The spec did not pass validation, due to 2 errors.</span><br><span class="line">[22:49:51]: ▸ [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a .swift-version file to set the version for your Pod. For example to use Swift 2.3, run:</span><br><span class="line">[22:49:51]: ▸ echo &quot;2.3 &quot; &gt; .swift-version.</span><br></pre></td></tr></table></figure>
<p>然后我看到了这篇解释 <a href="https://stackoverflow.com/questions/32304421/whats-the-difference-between-pod-spec-lint-and-pod-lib-lint" target="_blank" rel="noopener"><a href="https://stackoverflow.com/questions/32304421/whats-the-difference-between-pod-spec-lint-and-pod-lib-lint" target="_blank" rel="noopener">What’s the difference between ‘pod spec lint’ and ‘pod lib lint’?</a></a> ，pod lib lint 只会 lint 你本地的 pod ，以及确保你提供的东西是否正确，但是代码推到远程后如果 lint 不过也还是没用，而 pod spec lint 除了 pod lib lint 的验证步骤之外，还有会 lint 远程的pod ，真正确保 podspec 的有效性。</p>
<p>所以我基于原来的 pod_lib_lint 命令做了简单的修改，通过运行 <code>fatslant new_action</code> 生成<code>action/pod_sepc_lint.rb</code> 文件，详见：<a href="https://github.com/Yuzeyang/Fastfile/blob/master/fastlane/actions/pod_spec_lint.rb" target="_blank" rel="noopener">pod_spec_lint.rb</a> ，写好之后可以运行 <code>bundle exec rspec</code> 跑一下测试是否能通过，也可以运行 <code>bundle exec rubocop -a</code> 检查一下代码是否符合 fastlane action的规范。最后我试着提交一个 PR 看看能否给官方加上，后来官方回应已经不能在加 actions 了，只能添加到 plugin 里。</p>
<p>后来使用自定义的 pod_spec_lint 命令之后就解决了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[22:58:00]: Get started using a Gemfile for fastlane https://docs.fastlane.tools/getting-started/ios/setup/#use-a-gemfile</span><br><span class="line">...</span><br><span class="line">[22:58:06]: --- Step: pod_spec_lint ---</span><br><span class="line">[22:58:06]: ---------------------------</span><br><span class="line">[22:58:06]: $ pod spec lint --allow-warnings</span><br><span class="line">[22:58:19]: ▸ -&gt; FastlanePodspecDemo (0.1.2)</span><br><span class="line">[22:58:19]: ▸ - WARN | summary: The summary is not meaningful.</span><br><span class="line">[22:58:19]: ▸ - WARN | description: The description is equal to the summary.</span><br><span class="line">[22:58:19]: ▸ - WARN | [iOS] license: Unable to find a license file</span><br><span class="line">[22:58:19]: ▸ Analyzed 1 podspec.</span><br><span class="line">[22:58:19]: ▸ FastlanePodspecDemo.podspec passed validation.</span><br><span class="line">[22:58:19]: Pod spec lint Successfully ⬆️</span><br><span class="line">[22:58:19]: ----------------------------------</span><br><span class="line">...</span><br><span class="line">[22:58:40]: --- Step: pod_push ---</span><br><span class="line">[22:58:40]: ----------------------</span><br><span class="line">[22:58:40]: $ pod trunk push &apos;FastlanePodspecDemo.podspec&apos; --allow-warnings</span><br><span class="line">[22:58:41]: ▸ Updating spec repo master</span><br><span class="line">[23:04:01]: ▸ CocoaPods 1.3.1 is available.</span><br><span class="line">[23:04:01]: ▸ To update use: sudo gem install cocoapods</span><br><span class="line">[23:04:01]: ▸ For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.1</span><br><span class="line">[23:04:01]: ▸ Validating podspec</span><br><span class="line">[23:04:29]: ▸ -&gt; FastlanePodspecDemo (0.1.3)</span><br><span class="line">[23:04:29]: ▸ - WARN | summary: The summary is not meaningful.</span><br><span class="line">[23:04:29]: ▸ - WARN | description: The description is equal to the summary.</span><br><span class="line">[23:04:29]: ▸ - WARN | [iOS] license: Unable to find a license file</span><br><span class="line">[23:04:29]: ▸ Updating spec repo master</span><br><span class="line">[23:05:45]: ▸ CocoaPods 1.3.1 is available.</span><br><span class="line">[23:05:45]: ▸ To update use: sudo gem install cocoapods</span><br><span class="line">[23:05:45]: ▸ For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.1</span><br><span class="line">[23:05:46]: ▸ --------------------------------------------------------------------------------</span><br><span class="line">[23:05:46]: ▸ 🎉 Congrats</span><br><span class="line">[23:05:46]: ▸ 🚀 FastlanePodspecDemo (0.1.3) successfully published</span><br><span class="line">[23:05:46]: ▸ 📅 September 3rd, 09:04</span><br><span class="line">[23:05:46]: ▸ 🌎 https://cocoapods.org/pods/FastlanePodspecDemo</span><br><span class="line">[23:05:46]: ▸ 👍 Tell your friends!</span><br><span class="line">[23:05:46]: ▸ --------------------------------------------------------------------------------</span><br><span class="line">[23:05:46]: Successfully pushed Podspec ⬆️</span><br><span class="line">[23:05:46]: push success, current version is 0.1.3</span><br><span class="line"></span><br><span class="line">+------+-------------------------------------+-------------+</span><br><span class="line">| fastlane summary |</span><br><span class="line">+------+-------------------------------------+-------------+</span><br><span class="line">| Step | Action | Time (in s) |</span><br><span class="line">+------+-------------------------------------+-------------+</span><br><span class="line">| 1 | Verifying required fastlane version | 0 |</span><br><span class="line">| 2 | default_platform | 0 |</span><br><span class="line">| 3 | git_pull | 3 |</span><br><span class="line">| 4 | ensure_git_branch | 0 |</span><br><span class="line">| 5 | pod_spec_lint | 13 |</span><br><span class="line">| 6 | version_bump_podspec | 0 |</span><br><span class="line">| 7 | git_add | 0 |</span><br><span class="line">| 8 | git_commit | 5 |</span><br><span class="line">| 9 | push_to_git_remote | 7 |</span><br><span class="line">| 10 | add_git_tag | 0 |</span><br><span class="line">| 11 | push_git_tags | 7 |</span><br><span class="line">| 12 | pod_push | 425 |</span><br><span class="line">+------+-------------------------------------+-------------+</span><br><span class="line"></span><br><span class="line">[23:05:46]: fastlane.tools just saved you 8 minutes! 🎉</span><br></pre></td></tr></table></figure>
<h3 id="制作-Plugin"><a href="#制作-Plugin" class="headerlink" title="制作 Plugin"></a>制作 Plugin</h3><p>这一部分我并没有实现通，我在注册 <code>RubyGems</code> 的账号时邮箱验证过之后还是不能登录，提示未验证….不知道什么原因，有遇到解决了的，麻烦留言告诉我一下。下面是对官方的 Plugin 制作的解释：</p>
<p>创建好目录之后，运行</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane new_plugin [plugin_name]</span><br></pre></td></tr></table></figure>
<p>fastlane 会创建一个有效的 Ruby gem 的文件结构，然后你编辑 <code>lib/fastlane/plugin/[plugin_name]/actions/[plugin_name].rb</code> 去实现你的 action ，把上面自定义的 action 的内容拷贝到里面，然后把创建出来的文件推到你的 Github 仓库，更新 <code>fastlane-plugin-[plugin_name].gemspec</code> 文件来指向你的仓库，最后运行</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bundle install</span><br><span class="line">rake install</span><br><span class="line">rake release</span><br></pre></td></tr></table></figure>
<p>ok~大功告成，现在你可以运行 <code>fastlane add_plugin [plugin_name]</code> 安装使用你的 Plugin 了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我们完成了用 &lt;code&gt;Fastlane&lt;/code&gt; 自动化打包上传 iTunes Counnet ，为了将 Fastlane 的功能进一步的使用，后面希望能将 Pod 集成和升级也自动化，我也抽空研究了一下私有 Pod 库的升级、 Fastlane Action的制作和 Fastlane Plugin 的制作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Fastlane" scheme="http://yuzeyang.github.io/tags/Fastlane/"/>
    
  </entry>
  
  <entry>
    <title>基于 NSURLProtocol 实现 Debug 环境切换工具</title>
    <link href="http://yuzeyang.github.io/2017/09/09/debug-tool-base-on-NSURLProtocol/"/>
    <id>http://yuzeyang.github.io/2017/09/09/debug-tool-base-on-NSURLProtocol/</id>
    <published>2017-09-09T03:21:28.000Z</published>
    <updated>2017-09-24T14:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司内一般对调试环境会分为<code>线上</code>、<code>预发布</code>和<code>QA测试</code>三种，而在切换环境的时候大多还是通过网页或桌面应用，当在调试客户端应用时这样的方式就比较麻烦了，所以我们组<code>社会光哥</code>将整套环境切换和请求转发的原理理清晰之后实现了 Android 版的 Debug 环境切换工具，而我则根据其原理实现了 iOS 版。客户端接入该工具之后，只需在应用内即可切换环境和指定调试目录（每个目录独立部署代码）。</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h3><p>先简单介绍下环境切换原理（From 光哥）</p>
<p>不同环境对应不同的内网 IP 机器，它是一台反向代理服务器，将网络请求代理到对应环境的云端机器上处理，处理完成之后通过反向代理服务器再返回给请求方。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/proxy.png" alt=""></p>
<p>环境设置实际是向对应的地址发送一个网络请求，携带上自己的 WiFi IP（如果开启 Charles 等代理工具后，则是电脑的 WiFi IP），以及云端机器的 IP 和 Port进行绑定，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *URLString = [@&quot;http://&quot; stringByAppendingFormat:@&quot;%@:12345/index&quot;, [self IPByEnv:self.env]];</span><br><span class="line">NSURL *URL = [NSURL URLWithString:URLString];</span><br><span class="line">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];</span><br><span class="line">request.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">[request setValue:self.proxyIP forHTTPHeaderField:@&quot;X-Forward-For&quot;];</span><br><span class="line"></span><br><span class="line">GCCarmenModel *carmenModel = [self carmenConfig];</span><br><span class="line">[request setHTTPBody:[[carmenModel toPostBodyString] dataUsingEncoding:NSUTF8StringEncoding]];</span><br></pre></td></tr></table></figure>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>我们需要使用 <code>NSURLProtocol</code> 拦截客户端发出的所有请求，我们继承 <code>NSURLProtocol</code> 后需要在 AppDelegate 中注册其子类，而  <code>NSURLProtocol</code>  的执行顺序和注册顺序是相反的，所以一般情况我们把它放在最后注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">    [NSURLProtocol registerClass:NSClassFromString(@&quot;ZanDNSProtocol&quot;)];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>目前大多数网络库我们用的都是 <code>AFNetworking</code> ，是基于 <code>NSURLSession</code> 的网络请求，所以在构造 <code>NSURLSessionConfiguration</code> 之后，需要指定它的 <code>protocolClasses</code> ，但为了不破坏 AF 源码，我们可以 <code>Swizzling</code> 系统 <code>NSURLSession</code> 的 API <code>sessionWithConfiguration:delegate:delegateQueue:</code> ，做到对网络库无侵入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSURLSession (DNSSwizzling)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">  #ifdef DEBUG</span><br><span class="line">      dns_classMethodSwizzle(self, @selector(sessionWithConfiguration:delegate:delegateQueue:), @selector(zan_sessionWithConfiguration:delegate:delegateQueue:));</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSURLSession *)zan_sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue &#123;</span><br><span class="line">    configuration.protocolClasses = @[NSClassFromString(@&quot;ZanDNSProtocol&quot;)];</span><br><span class="line">    return [self zan_sessionWithConfiguration:configuration delegate:delegate delegateQueue:queue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接着在 <code>ZanDNSProtocol</code> （ NSURLProtocol 子类）中实现父类方法，一共四步：</p>
<p>第一步判断是否需要拦截，本地我们维护了一份 DNS 列表，我们只拦截在列表中的域名请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    NSString *host = request.URL.host;</span><br><span class="line">    NSDictionary *DNSConfig = [ZanDNSManager sharedInstance].DNSConfig;</span><br><span class="line">    if ([[DNSConfig allKeys] containsObject:host]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步我们修改拦截到的请求，我们解析出当前环境下 Host 对应列表中的 IP 地址，然后在 <code>URL</code> 中用 IP 替换掉 Host，并在请求头中加上 <code>Host</code>，目的是为了防止开启代理之后，代理工具做 DNS 解析，解析到线上的 IP 地址，这样转发的请求还是往线上发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    NSMutableURLRequest *forwardRequest = [request mutableCopy];</span><br><span class="line">    </span><br><span class="line">    NSString *URLString = forwardRequest.URL.absoluteString;</span><br><span class="line">    NSString *originalHost = forwardRequest.URL.host;</span><br><span class="line">    NSDictionary *DNSConfig = [ZanDNSManager sharedInstance].DNSConfig;</span><br><span class="line">    NSString *IP = DNSConfig[originalHost];</span><br><span class="line">    URLString = [URLString stringByReplacingOccurrencesOfString:originalHost withString:IP];</span><br><span class="line">    forwardRequest.URL = [NSURL URLWithString:URLString];</span><br><span class="line">    [forwardRequest setValue:originalHost forHTTPHeaderField:@&quot;Host&quot;];</span><br><span class="line">    [forwardRequest setValue:[ZanDNSManager sharedInstance].proxyIP forHTTPHeaderField:@&quot;X-Forward-For&quot;];</span><br><span class="line">    </span><br><span class="line">    return forwardRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步就是发送请求，如果我们开启了代理，可以配置 <code>NSURLSessionConfiguration</code> 的 <code>connectionProxyDictionary</code> ，好处是我们可以不用再下载 Charles 证书到手机，可以直接代理到 Charles 来抓包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)startLoading &#123;</span><br><span class="line">    [NSURLProtocol setProperty:@(YES) forKey:propertyKey inRequest:[self.request mutableCopy]];</span><br><span class="line">    NSURLSessionConfiguration *configuration;</span><br><span class="line">    if ([ZanDNSManager sharedInstance].openProxy) &#123;</span><br><span class="line">        NSDictionary *proxyDic = @&#123;@&quot;HTTPEnable&quot;: @(YES),</span><br><span class="line">                                   (NSString *)kCFStreamPropertyHTTPProxyHost: [ZanDNSManager sharedInstance].proxyIP,</span><br><span class="line">                                   (NSString *)kCFStreamPropertyHTTPProxyPort: @([ZanDNSManager sharedInstance].proxyPort),</span><br><span class="line">                                   @&quot;HTTPSEnable&quot;: @(YES),</span><br><span class="line">                                   (NSString *)kCFStreamPropertyHTTPSProxyHost: [ZanDNSManager sharedInstance].proxyIP,</span><br><span class="line">                                   (NSString *)kCFStreamPropertyHTTPSProxyPort: @([ZanDNSManager sharedInstance].proxyPort)&#125;;</span><br><span class="line">        configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">        configuration.connectionProxyDictionary = proxyDic;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    self.session = [NSURLSession zan_sessionWithConfiguration:configuration delegate:self delegateQueue:nil];</span><br><span class="line">    NSURLSessionDataTask *task = [self.session dataTaskWithRequest:self.request];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步是我们对请求过程中信任所有证书</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *_Nullable))completionHandler &#123;</span><br><span class="line">    if (!challenge) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    NSString *host = self.request.allHTTPHeaderFields[@&quot;host&quot;];</span><br><span class="line">    if (![challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">        completionHandler(disposition, nil);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSURLCredential *credential = nil;</span><br><span class="line">    if ([self evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:host]) &#123;</span><br><span class="line">        disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">        credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(disposition, credential);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们完成了一整套环境切换和请求拦截转发的方案，但是该工具还未能做到拦截转发 <code>WKWebView</code> 的请求，欢迎大家一起来交流交流~</p>
<h3 id="2018年9月24日更新："><a href="#2018年9月24日更新：" class="headerlink" title="2018年9月24日更新："></a>2018年9月24日更新：</h3><p>看到<a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">腾讯在使用 WK 时遇到的坑</a>里面提到对 WK 的网络拦截，简单的说可以通过注册 http(s) scheme 来拦截到 WK 的网络请求，但是由于 WK 是在独立进程中进行网络通信的，使用 NSURLProtocol 将网络请求拦截到 App 进程时，出于性能原因，IPC 会将 HTTPBody 和 HTTPStream 丢弃，所以 POST 请求的 Body 内容会丢失，不能做到完美的拦截。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司内一般对调试环境会分为&lt;code&gt;线上&lt;/code&gt;、&lt;code&gt;预发布&lt;/code&gt;和&lt;code&gt;QA测试&lt;/code&gt;三种，而在切换环境的时候大多还是通过网页或桌面应用，当在调试客户端应用时这样的方式就比较麻烦了，所以我们组&lt;code&gt;社会光哥&lt;/code&gt;将整套环境切换和请求转发的原理理清晰之后实现了 Android 版的 Debug 环境切换工具，而我则根据其原理实现了 iOS 版。客户端接入该工具之后，只需在应用内即可切换环境和指定调试目录（每个目录独立部署代码）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NSURLProtocol" scheme="http://yuzeyang.github.io/tags/NSURLProtocol/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket 实现原理</title>
    <link href="http://yuzeyang.github.io/2017/07/02/websocket/"/>
    <id>http://yuzeyang.github.io/2017/07/02/websocket/</id>
    <published>2017-07-02T02:28:06.000Z</published>
    <updated>2017-07-20T14:26:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前我们将 <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a> 作为底层实现，在其上面封装了一套 Socket 通信机制以及业务接口，最近我们开始研究 WebSocket ，并用来替换掉原先的 CocoaAsyncSocket ，简单来说一下两者的关系，WebSocket 和 Socket 虽然名称上很像，但两者是完全不同的东西， WebSocket 是建立在 TCP/IP 协议之上，属于应用层的协议，而 Socket 是在应用层和传输层中的一个抽象层，它是将 TCP/IP 层的复杂操作抽象成几个简单的接口来提供给应用层调用。为什么要做这次替换呢？原因是我们服务端在做改造，同时网页版 IM 已经使用了 WebSocket ，客户端也采用的话对于服务端来说维护一套代码会更好更方便，而且 WebSocket 在体积、实时性和扩展上都具有一定的优势。</p>
<p>WebSocket 最新的协议是 <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">13 RFC 6455</a> ，要理解 WebSocket 的实现，一定要去理解它的协议！~</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>WebSocket 的实现分为握手，数据发送/读取，关闭连接。</p>
<p>这里首先放上一张我们组 <a href="https://geminiwen.com/" target="_blank" rel="noopener">@省长</a> （推荐大家去读一读省长的博客，干货很多👍）整理出来的流程图，方便大家去理解，其中mbedTLS做的是数据的加解密，可以暂时不用关心：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/libchat%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h2 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h2><p>握手要从请求头去理解。</p>
<p>WebSocket 首先发起一个 HTTP 请求，在请求头加上  <code>Upgrade</code> 字段，该字段用于改变 HTTP 协议版本或者是换用其他协议，这里我们把 <code>Upgrade</code> 的值设为 <code>websocket</code> ，将它升级为 WebSocket 协议。</p>
<p>同时要注意 <code>Sec-WebSocket-Key</code> 字段，它由客户端生成并发给服务端，用于证明服务端接收到的是一个可受信的连接握手，可以帮助服务端排除自身接收到的由非 WebSocket 客户端发起的连接，该值是一串随机经过 <code>base64</code> 编码的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>我们可以简化请求头，将请求以字符串方式发送出去，当然别忘了最后的两个空行作为包结束：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fmt = <span class="string">"GET %s HTTP/1.1\r\n"</span></span><br><span class="line">                   <span class="string">"Upgrade: websocket\r\n"</span></span><br><span class="line">                   <span class="string">"Connection: Upgrade\r\n"</span></span><br><span class="line">                   <span class="string">"Host: %s\r\n"</span></span><br><span class="line">                   <span class="string">"Sec-WebSocket-Key: %s\r\n"</span></span><br><span class="line">                   <span class="string">"Sec-WebSocket-Version: 13\r\n"</span></span><br><span class="line">                   <span class="string">"\r\n"</span>;</span><br><span class="line">size = <span class="built_in">strlen</span>(fmt) + <span class="built_in">strlen</span>(path) + <span class="built_in">strlen</span>(host) + <span class="built_in">strlen</span>(ws-&gt;key);</span><br><span class="line">buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, fmt, path, host, ws-&gt;key);</span><br><span class="line">size = <span class="built_in">strlen</span>(buf);</span><br><span class="line">nbytes = ws-&gt;io_send(ws, ws-&gt;context, buf, size);</span><br></pre></td></tr></table></figure>
<p>收到请求后，服务端也会做一次响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>
<p>里面重要的是 <code>Sec-WebSocket-Accept</code> ，服务端通过从客户端请求头中读取 <code>Sec-WebSocket-Key</code> 与一串全局唯一的标识字符串（俗称魔串）“258EAFA5-E914-47DA-   95CA-C5AB0DC85B11”做拼接，生成长度为160位的 <code>SHA-1</code> 字符串，然后进行 <code>base64</code> 编码，作为 <code>Sec-WebSocket-Accept</code> 的值回传给客户端，客户端再去解析这个值，与自己加密编码后的字符串进行比较。</p>
<p>处理握手 HTTP 响应解析的时候，可以用 nodejs 的 <a href="https://github.com/nodejs/http-parser" target="_blank" rel="noopener">http-paser</a> ，解析方式也比较简单，就是对头信息的逐字读取再处理，具体处理你可以看一下它的状态机实现。解析完成后你需要对其内容进行解析，看返回是否正确，同时去管理你的握手状态。</p>
<h2 id="数据发送-读取"><a href="#数据发送-读取" class="headerlink" title="数据发送/读取"></a>数据发送/读取</h2><p>数据的处理就要拿这个帧协议图来说明了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>首先我们来看看数字的含义，数字表示位，0-7表示有8位，等于1个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br></pre></td></tr></table></figure>
<p>所以如果要组装一个帧数据可以这样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *rev = (rev *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">rev[<span class="number">0</span>] = (<span class="keyword">char</span>)(<span class="number">0x81</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">rev[<span class="number">1</span>] = <span class="number">126</span> &amp; <span class="number">0x7f</span>;</span><br><span class="line">rev[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">rev[<span class="number">3</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>ok，了解了帧数据的样子，我们反过来去理解值对应的帧字段。</p>
<p>首先<code>0x81</code>是什么，这个是十六进制数据，转换成二进制就是<code>1000 0001</code>， 是一个字节的长度，也就是这一段里面每一位的值：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 </span><br><span class="line">+-+-+-+-+-------+</span><br><span class="line">|F|R|R|R| opcode|</span><br><span class="line">|I|S|S|S|  (4)  |</span><br><span class="line">|N|V|V|V|       |</span><br><span class="line">| |1|2|3|       |</span><br><span class="line">+-+-+-+-+-------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>FIN</code> 表示该帧是不是消息的最后一帧，1表示结束，0表示还有下一帧。</p>
</li>
<li><p><code>RSV1, RSV2, RSV3</code> 必须为0，除非扩展协商定义了一个非0的值，如果没有定义非0值，且收到了非0的  <code>RSV</code> ，那么 WebSocket 的连接会失效，建议是断开连接。</p>
</li>
<li><p><code>opcode</code> 用来描述 <code>Payload data</code> 的定义，如果收到了一个未知的 <code>opcode</code> ，同样会使 WebSocket 连接失效，协议定义了以下值：</p>
<ul>
<li>%x0 表示连续的帧</li>
<li>%x1 表示 text 帧</li>
<li>%x2 表示二进制帧</li>
<li>%x3-7 预留给非控制帧</li>
<li>%x8 表示关闭连接帧</li>
<li>%x9 表示 ping</li>
<li>%xA 表示 pong</li>
<li>%xB-F 预留给控制帧</li>
</ul>
<p>连续帧是和 FIN 值相关联的，它表明可能由于消息分片的原因，将原本一个帧的数据分为多个帧，这时候前一帧的 opcode 就是0，FIN 也是0，最后一帧的 opcode 就不再是0，FIN 就是1了。</p>
<p>再可以看到 opcode 预留了非控制帧和控制帧，这两个又是什么？</p>
<p>控制帧表示 WebSocket 的状态信息，像是定义的分片，关闭连接，ping和pong。</p>
<p>非控制帧就是数据帧，像是 text 帧，二进制帧。</p>
</li>
</ul>
<p><code>0xff</code> 作用就是取出需要的二进制值。</p>
<p>下面再来看<code>126</code>，126则表示的是 <code>Payload len</code> ，也就是 Payload 的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">                +-+-------------+-------------------------------+</span><br><span class="line">                |M| Payload len |    Extended payload length    |</span><br><span class="line">                |A|     (7)     |             (16/64)           |</span><br><span class="line">                |S|             |   (if payload len==126/127)   |</span><br><span class="line">                |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |           Payload Data        |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MASK</code>  表示<code>Playload data</code> 是否要加掩码，如果设成1，则需要赋值 <code>Masking-key</code> 。所有从客户端发到服务端的帧都要加掩码</li>
<li><code>Playload len</code> 表示 Payload 的长度，这里分为三种情况<ul>
<li>长度小于126，则只需要7位</li>
<li>长度是126，则需要额外2个字节的大小，也就是 <code>Extended payload length</code> </li>
<li>长度是127，则需要额外8个字节的大小，也就是 <code>Extended payload length</code> + <code>Extended payload length continued</code> ，<code>Extended payload length</code> 是2个字节，<code>Extended payload length continued</code> 是6个字节</li>
</ul>
</li>
<li><code>Playload len</code> 则表示 <code>Extension data</code> 与 <code>Application data</code> 的和</li>
<li><code>Masking-key</code> 是在 <code>MASK</code> 设置成1之后，随机生成的4字节长度的数据，然后和 <code>Payload Data</code> 做异或运算</li>
<li><code>Payload Data</code> 就是我们发送的数据</li>
</ul>
<p>而数据的发送和读取就是对帧的封装和解析。</p>
<p>数据发送:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ws__wrap_packet</span><span class="params">(_WS_IN <span class="keyword">websocket_t</span> *ws,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _WS_IN <span class="keyword">const</span> <span class="keyword">char</span> *payload,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _WS_IN <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _WS_IN <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _WS_OUT <span class="keyword">char</span>** out,</span></span></span><br><span class="line"><span class="function"><span class="params">                     _WS_OUT <span class="keyword">uint64_t</span> *out_size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">char</span> mask[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask_int;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> payload_len_bits;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> payload_bit_offset = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extend_payload_len_bits, i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> frame_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MASK_BIT_LEN = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    srand(tv.tv_usec * tv.tv_sec);</span><br><span class="line">    mask_int = rand();</span><br><span class="line">    <span class="built_in">memcpy</span>(mask, &amp;mask_int, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * payload_len bits</span></span><br><span class="line"><span class="comment">     * ref to https://tools.ietf.org/html/rfc6455#section-5.2</span></span><br><span class="line"><span class="comment">     * If 0-125, that is the payload length</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If payload length is equals 126, the following 2 bytes interpreted as a</span></span><br><span class="line"><span class="comment">     * 16-bit unsigned integer are the payload length</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the</span></span><br><span class="line"><span class="comment">     * most significant bit MUST be 0) are the payload length.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (payload_size &lt;= <span class="number">125</span>) &#123;</span><br><span class="line">        <span class="comment">// consts of ((fin + rsv1/2/3 + opcode) + payload-len bits + mask bit len + payload len)</span></span><br><span class="line">        extend_payload_len_bits = <span class="number">0</span>;</span><br><span class="line">        frame_size = <span class="number">1</span> + <span class="number">1</span> + MASK_BIT_LEN + payload_size;</span><br><span class="line"></span><br><span class="line">        payload_len_bits = payload_size;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (payload_size &gt; <span class="number">125</span> &amp;&amp; payload_size &lt;= <span class="number">0xffff</span>) &#123;</span><br><span class="line">        extend_payload_len_bits = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// consts of ((fin + rsv1/2/3 + opcode) + payload-len bits + extend-payload-len bites + mask bit len + payload len)</span></span><br><span class="line">        frame_size = <span class="number">1</span> + <span class="number">1</span> + extend_payload_len_bits + MASK_BIT_LEN + payload_size;</span><br><span class="line">        payload_len_bits = <span class="number">126</span>;</span><br><span class="line"></span><br><span class="line">        payload_bit_offset += extend_payload_len_bits;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (payload_size &gt; <span class="number">0xffff</span> &amp;&amp; payload_size &lt;= <span class="number">0xffffffffffffffff</span>LL) &#123;</span><br><span class="line">        extend_payload_len_bits = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// consts of ((fin + rsv1/2/3 + opcode) + payload-len bits + extend-payload-len bites + mask bit len + payload len)</span></span><br><span class="line">        frame_size = <span class="number">1</span> + <span class="number">1</span> + extend_payload_len_bits + MASK_BIT_LEN + payload_size;</span><br><span class="line">        payload_len_bits = <span class="number">127</span>;</span><br><span class="line">        payload_bit_offset += extend_payload_len_bits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ws-&gt;error_cb) &#123;</span><br><span class="line">            <span class="keyword">ws_error_t</span> *err = ws_new_error(WS_SEND_DATA_TOO_LARGE_ERR);</span><br><span class="line">            ws-&gt;error_cb(ws, err);</span><br><span class="line">            <span class="built_in">free</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> WS_SEND_SEND_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *out_size = frame_size;</span><br><span class="line">    <span class="keyword">char</span> *data = (*out) = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(frame_size);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ws-&gt;error_cb) &#123;</span><br><span class="line">            <span class="keyword">ws_error_t</span> *err = ws_new_error(WS_SEND_SEND_ERR);</span><br><span class="line">            ws-&gt;error_cb(ws, err);</span><br><span class="line">            <span class="built_in">free</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *buf_offset = data;</span><br><span class="line"></span><br><span class="line">    bzero(data, frame_size);</span><br><span class="line">    *data = flags &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    buf_offset = data + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set mask bit = 1</span></span><br><span class="line">    *(buf_offset) = payload_len_bits | <span class="number">0x80</span>; <span class="comment">//payload length with mask bit on</span></span><br><span class="line"></span><br><span class="line">    buf_offset = data + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (payload_len_bits == <span class="number">126</span>) &#123;</span><br><span class="line">        payload_size &amp;= <span class="number">0xffff</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (payload_len_bits == <span class="number">127</span>) &#123;</span><br><span class="line">        payload_size &amp;= <span class="number">0xffffffffffffffff</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; extend_payload_len_bits; i++) &#123;</span><br><span class="line">        *(buf_offset + i) = *((<span class="keyword">char</span> *)&amp;payload_size + (extend_payload_len_bits - i - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * according to https://tools.ietf.org/html/rfc6455#section-5.3</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * buf_offset is set to mask bit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    buf_offset = data + payload_bit_offset - <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">         *(buf_offset + i) = mask[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mask the payload data </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    buf_offset = data + payload_bit_offset;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf_offset, payload, payload_size);</span><br><span class="line">    mask_payload(mask, buf_offset, payload_size);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mask_payload</span><span class="params">(<span class="keyword">char</span> mask[<span class="number">4</span>], <span class="keyword">char</span> *payload, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; payload_size; i++) &#123;</span><br><span class="line">        *(payload + i) ^= mask[i % <span class="number">4</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ws_recv</span><span class="params">(<span class="keyword">websocket_t</span> *ws)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ws-&gt;state &lt; WS_STATE_HANDSHAKE_COMPLETED) &#123;</span><br><span class="line">        <span class="keyword">return</span> ws_do_handshake(ws);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        ret = ws__recv(ws);</span><br><span class="line">        <span class="keyword">if</span> (ret != OK) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ws__recv</span><span class="params">(<span class="keyword">websocket_t</span> *ws)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ws-&gt;state &lt; WS_STATE_HANDSHAKE_COMPLETED) &#123;</span><br><span class="line">        <span class="keyword">return</span> ws_do_handshake(ws);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = OK, i;</span><br><span class="line">    <span class="keyword">int</span> state = ws-&gt;rd_state;</span><br><span class="line">    <span class="keyword">char</span> *rd_buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(state) &#123;</span><br><span class="line">        <span class="keyword">case</span> WS_READ_IDLE: &#123;</span><br><span class="line">            ret = ws__make_up(ws, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">ws_frame_t</span> * frame;</span><br><span class="line">            <span class="keyword">if</span> (ws-&gt;c_frame == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ws__append_frame(ws);</span><br><span class="line">            &#125;</span><br><span class="line">            frame = ws-&gt;c_frame;</span><br><span class="line">            rd_buf = ws-&gt;buf;</span><br><span class="line">            frame-&gt;fin = (*(rd_buf) &amp; <span class="number">0x80</span>) == <span class="number">0x80</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            frame-&gt;op_code = *(rd_buf) &amp; <span class="number">0x0f</span>u;</span><br><span class="line">            frame-&gt;payload_len = *(rd_buf + <span class="number">1</span>) &amp; <span class="number">0x7f</span>u;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;payload_len &lt; <span class="number">126</span>) &#123;</span><br><span class="line">                frame-&gt;payload_bit_offset = <span class="number">2</span>;</span><br><span class="line">                ws-&gt;rd_state = WS_READ_PAYLOAD;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame -&gt; payload_len == <span class="number">126</span>) &#123;</span><br><span class="line">                frame-&gt;payload_bit_offset = <span class="number">4</span>;</span><br><span class="line">                ws-&gt;rd_state = WS_READ_EXTEND_PAYLOAD_2_WORDS;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                frame-&gt;payload_bit_offset = <span class="number">8</span>;</span><br><span class="line">                ws-&gt;rd_state = WS_READ_EXTEND_PAYLOAD_8_WORDS;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ws__reset_buf(ws, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> WS_READ_EXTEND_PAYLOAD_2_WORDS: &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAYLOAD_LEN_BITS 2</span></span><br><span class="line">            ret = ws__make_up(ws, PAYLOAD_LEN_BITS);</span><br><span class="line">            <span class="keyword">if</span> (ret != OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            rd_buf = ws-&gt;buf;</span><br><span class="line">            <span class="keyword">ws_frame_t</span> * frame = ws-&gt;c_frame;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> *payload_len_bytes = (<span class="keyword">char</span> *)&amp;frame-&gt;payload_len;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PAYLOAD_LEN_BITS; i++) &#123;</span><br><span class="line">                *(payload_len_bytes + i) = rd_buf[PAYLOAD_LEN_BITS - <span class="number">1</span> - i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ws__reset_buf(ws, PAYLOAD_LEN_BITS);</span><br><span class="line">            ws-&gt;rd_state = WS_READ_PAYLOAD;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PAYLOAD_LEN_BITS</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> WS_READ_EXTEND_PAYLOAD_8_WORDS: &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAYLOAD_LEN_BITS 8</span></span><br><span class="line">            ret = ws__make_up(ws, PAYLOAD_LEN_BITS);</span><br><span class="line">            <span class="keyword">if</span> (ret != OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rd_buf = ws-&gt;buf;</span><br><span class="line">            <span class="keyword">ws_frame_t</span> * frame = ws-&gt;c_frame;</span><br><span class="line">            <span class="keyword">char</span> *payload_len_bytes = (<span class="keyword">char</span> *)&amp;frame-&gt;payload_len;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PAYLOAD_LEN_BITS; i++) &#123;</span><br><span class="line">                *(payload_len_bytes + i) = rd_buf[PAYLOAD_LEN_BITS - <span class="number">1</span> - i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ws__reset_buf(ws, PAYLOAD_LEN_BITS);</span><br><span class="line">            ws-&gt;rd_state = WS_READ_PAYLOAD;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PAYLOAD_LEN_BITS</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> WS_READ_PAYLOAD: &#123;</span><br><span class="line">            <span class="keyword">ws_frame_t</span> * frame = ws-&gt;c_frame;</span><br><span class="line">            <span class="keyword">uint64_t</span> payload_len = frame-&gt;payload_len;</span><br><span class="line">            ret = ws__make_up(ws, payload_len);</span><br><span class="line">            <span class="keyword">if</span> (ret != OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            rd_buf = ws-&gt;buf;</span><br><span class="line">            frame-&gt;payload = <span class="built_in">malloc</span>(payload_len);</span><br><span class="line">            <span class="built_in">memcpy</span>(frame-&gt;payload, rd_buf, payload_len);</span><br><span class="line"></span><br><span class="line">            ws__reset_buf(ws, payload_len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;fin == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// is control frame</span></span><br><span class="line">                ws__dispatch_msg(ws, frame);</span><br><span class="line">                ws__clean_frame(ws);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ws__append_frame(ws);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ws-&gt;rd_state = WS_READ_IDLE;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭连接分为两种：服务端发起关闭和客户端主动关闭。</p>
<p>服务端跟客户端的处理基本一致，以服务端为例：</p>
<p>服务端发起关闭的时候，会客户端发送一个关闭帧，客户端在接收到帧的时候通过解析出帧的opcode来判断是否是关闭帧，然后同样向服务端再发送一个关闭帧作为回应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op_code == OP_CLOSE) &#123;</span><br><span class="line">    <span class="keyword">int</span> status_code;</span><br><span class="line">    <span class="keyword">char</span> *reason;</span><br><span class="line">    <span class="keyword">char</span> *status_code_buf = (<span class="keyword">char</span> *)&amp;status_code;</span><br><span class="line">    status_code_buf[<span class="number">0</span>] = payload[<span class="number">1</span>];</span><br><span class="line">    status_code_buf[<span class="number">1</span>] = payload[<span class="number">0</span>];</span><br><span class="line">    reason = payload + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ws-&gt;state != WS_STATE_CLOSED) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * should send response to remote server</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        ws_send(ws, <span class="literal">NULL</span>, <span class="number">0</span>, OP_CLOSE | FLAG_FIN);</span><br><span class="line">        ws-&gt;state = WS_STATE_CLOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close connection</span></span><br><span class="line">    <span class="keyword">if</span> (ws-&gt;close_cb) &#123;</span><br><span class="line">        ws-&gt;close_cb(ws, status_code, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对WebSocket的学习主要是对协议的理解，理解了协议，上面复杂的代码自然而然就会明白~</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对于I/O操作的原理，推荐大家可以看看这个：<a href="https://www.zhihu.com/question/20122137/answer/14049112#" target="_blank" rel="noopener">epoll 或者 kqueue 的原理是什么？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前我们将 &lt;a href=&quot;https://github.com/robbiehanson/CocoaAsyncSocket&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CocoaAsyncSocket&lt;/a&gt; 作为底层实现，在其上面封装了一套 Socket 通信机制以及业务接口，最近我们开始研究 WebSocket ，并用来替换掉原先的 CocoaAsyncSocket ，简单来说一下两者的关系，WebSocket 和 Socket 虽然名称上很像，但两者是完全不同的东西， WebSocket 是建立在 TCP/IP 协议之上，属于应用层的协议，而 Socket 是在应用层和传输层中的一个抽象层，它是将 TCP/IP 层的复杂操作抽象成几个简单的接口来提供给应用层调用。为什么要做这次替换呢？原因是我们服务端在做改造，同时网页版 IM 已经使用了 WebSocket ，客户端也采用的话对于服务端来说维护一套代码会更好更方便，而且 WebSocket 在体积、实时性和扩展上都具有一定的优势。&lt;/p&gt;
&lt;p&gt;WebSocket 最新的协议是 &lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;13 RFC 6455&lt;/a&gt; ，要理解 WebSocket 的实现，一定要去理解它的协议！~&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebSocket" scheme="http://yuzeyang.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Mantle 解析</title>
    <link href="http://yuzeyang.github.io/2017/06/18/Mantle/"/>
    <id>http://yuzeyang.github.io/2017/06/18/Mantle/</id>
    <published>2017-06-18T06:56:57.000Z</published>
    <updated>2017-07-02T02:32:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>对 JSON 解析库目前流行的也是非常的多，<a href="https://github.com/jsonmodel/jsonmodel" target="_blank" rel="noopener">jsonmodel</a> 、<a href="https://github.com/Mantle/Mantle" target="_blank" rel="noopener">Mantle</a> 、<a href="https://github.com/ibireme/YYModel" target="_blank" rel="noopener">YYModel</a> 等都是大家常用的，使用这些库的好处就是你无需关心数据解析转换和复杂的类型判断处理，你只需要确定好客户端的数据结构能够与后端数据结构相对应即可，而这些库里面对于解析的处理也都是大同小异，无非是在使用、性能和异常处理上有些差别，这里推荐一下郭曜源大神（ YYModel 的作者）的文章，内容是对<a href="http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/" target="_blank" rel="noopener">各大解析库进行了比较</a>，对于开发者来说，了解其解析过程是最为基础的，这次看完 Mantle 的解析处理，我也做个简单的总结，大家可以互相学习交流。</p>
<a id="more"></a>
<p>首先 Mantle 对于 JSON 解析的过程分为三步：</p>
<p>第一步是对 Model 字段的转换处理</p>
<p>第二步是对 JSON Dictionary 值的转换处理</p>
<p>第三步是对 Model 的赋值</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>对于解析 JSON 数据，我们比较常用是以下这个方法，<code>modelClass</code> 指的是继承于 <code>MTLModel</code> 的子类，也是我们需要解析成的目标 Model 类， <code>JSONDictionary</code> 则是需要解析的 JSON 数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</span><br><span class="line">	MTLJSONAdapter *adapter = [[self alloc] initWithModelClass:modelClass];</span><br><span class="line"></span><br><span class="line">	return [adapter modelFromJSONDictionary:JSONDictionary error:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现上看就两步，先根据 modelClass 初始化一个适配器，再根据 JSON 数据返回 model 对象。</p>
<p>初始化适配器的内容比较多，我们分段来说几个关键的地方。</p>
<p>首先检查的就是 Model 是否实现了 <code>MTLJSONSerializing</code> 协议，未实现的话会触发断言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithModelClass:(Class)modelClass &#123;</span><br><span class="line">	NSParameterAssert(modelClass != nil);</span><br><span class="line">	NSParameterAssert([modelClass conformsToProtocol:@protocol(MTLJSONSerializing)]);</span><br><span class="line">  </span><br><span class="line">  	self = [super init];</span><br><span class="line">	if (self == nil) return nil;</span><br><span class="line"></span><br><span class="line">	_modelClass = modelClass;</span><br><span class="line"></span><br><span class="line">	_JSONKeyPathsByPropertyKey = [modelClass JSONKeyPathsByPropertyKey];</span><br><span class="line">  	</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么先来看下  <code>MTLJSONSerializing</code> 协议，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@protocol MTLJSONSerializing &lt;MTLModel&gt;</span><br><span class="line">@required</span><br><span class="line">+ (NSDictionary *)JSONKeyPathsByPropertyKey;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;</span><br><span class="line">+ (Class)classForParsingJSONDictionary:(NSDictionary *)JSONDictionary;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p> <code>JSONKeyPathsByPropertyKey</code> 方法是里面唯一一个必须要实现的，它是用于将属性和 JSON 的解析路径做关联，它不仅仅可以用于给属性起“别名”，还可以用于多级解析和多层嵌套，用官方例子来举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (NSDictionary *)JSONKeyPathsByPropertyKey &#123;</span><br><span class="line">   return @&#123;</span><br><span class="line">       @&quot;name&quot;: @&quot;POI.name&quot;,</span><br><span class="line">       @&quot;point&quot;: @[ @&quot;latitude&quot;, @&quot;longitude&quot; ],</span><br><span class="line">       @&quot;starred&quot;: @&quot;starred&quot;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在映射过程中 starred 与 JSONDictionary[@&quot;starred&quot;] 做映射，</span><br><span class="line">name 与 JSONDictionary[@&quot;POI&quot;][@&quot;name&quot;] 做映射，</span><br><span class="line">point 则等同于以下这个 dictionary</span><br><span class="line">@&#123;</span><br><span class="line">   @&quot;latitude&quot;: JSONDictionary[@&quot;latitude&quot;],</span><br><span class="line">   @&quot;longitude&quot;: JSONDictionary[@&quot;longitude&quot;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这样的设计很是方便，可以自由定义映射解析之间的关系，但是在实现的时候会发现，我们在处理对于像 starred 这样普通的解析关系时，仍旧需要一个一个重新在定义一遍，如果我们的数据结构内容非常的多，那就是个体力活了，而且不定义就无法解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithModelClass:(Class)modelClass &#123;</span><br><span class="line">	...</span><br><span class="line">  	</span><br><span class="line">    NSSet *propertyKeys = [self.modelClass propertyKeys];</span><br><span class="line">      </span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSSet *)propertyKeys &#123;</span><br><span class="line">	NSSet *cachedKeys = objc_getAssociatedObject(self, MTLModelCachedPropertyKeysKey);</span><br><span class="line">	if (cachedKeys != nil) return cachedKeys;</span><br><span class="line"></span><br><span class="line">	NSMutableSet *keys = [NSMutableSet set];</span><br><span class="line"></span><br><span class="line">	[self enumeratePropertiesUsingBlock:^(objc_property_t property, BOOL *stop) &#123;</span><br><span class="line">		NSString *key = @(property_getName(property));</span><br><span class="line"></span><br><span class="line">		if ([self storageBehaviorForPropertyWithKey:key] != MTLPropertyStorageNone) &#123;</span><br><span class="line">			 [keys addObject:key];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	objc_setAssociatedObject(self, MTLModelCachedPropertyKeysKey, keys, OBJC_ASSOCIATION_COPY);</span><br><span class="line"></span><br><span class="line">	return keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>propertyKeys</code> 是遍历 MTLModel 子类的属性，判断其拷贝行为，过滤掉不做存储的属性，注意它同时会对 hash 、 superclass 、 description 、 debugDescription 这四个属性进行判断，在 NSObject 内这四个都是 readonly 的，如果你不去将它设为 readwrite 的话，它们是不做存储的。</p>
<p>说到存储行为，MTLModel用了一个枚举 <code>MTLPropertyStorage</code> 来标记一个属性的拷贝行为，分为三类，</p>
<p>第一类 <code>MTLPropertyStorageNone</code> ：属性不做任何存储，在 MTLModel里判断不存储的条件是1.没有该属性，自然不用存储 2.该属性没有使用 @dynamic 指令，但是没有成员变量，并且没有对应的setter和getter方法 3. MTLModel 类中属性是只读，且没有成员变量。</p>
<p>第二类 <code>MTLPropertyStorageTransitory</code> ：属性只做暂时性的存储，在官方解释里看到一句话 <code>It may disappear at any time</code> ，感觉指的是弱引用的属性，但是在 MTLModel 里并没有看到返回  MTLPropertyStorageTransitory 的处理，但在 MTLTestModel 中可以找到， MTLTestModel 对 <code>storageBehaviorForPropertyWithKey:</code> 进行了重写，其中它对属性名进行了判断，在对应的头文件里我们也可以找到这个属性的说明：<code>Should not be stored in JSON, has MTLPropertyStorageTransitory.</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (MTLPropertyStorage)storageBehaviorForPropertyWithKey:(NSString *)propertyKey &#123;</span><br><span class="line">  if ([propertyKey isEqual:@&quot;weakModel&quot;]) &#123;</span><br><span class="line">  	return MTLPropertyStorageTransitory;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  	return [super storageBehaviorForPropertyWithKey:propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三类 <code>MTLPropertyStoragePermanen</code> ，属性做永久存储， MTLModel 里判断只要不是 MTLPropertyStorageNone 就是 MTLPropertyStoragePermanen，需要做暂时存储的，就需要在子类里重写了。</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithModelClass:(Class)modelClass &#123;</span><br><span class="line">	...</span><br><span class="line">  	</span><br><span class="line">    _valueTransformersByPropertyKey = [self.class valueTransformersForModelClass:modelClass];</span><br><span class="line">	_JSONAdaptersByModelClass = [NSMapTable strongToStrongObjectsMapTable];</span><br><span class="line"></span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在遍历完之后开始对属性的值进行转换操作，对于转换操作也提供了三种方式，</p>
<p>第一种是自定义方式，在子类里定义实现方法名为 <code>key（属性名）</code> + <code>JSONTransformer</code>  的方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSValueTransformer *)URLJSONTransformer &#123;</span><br><span class="line">    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是重写 MTLJSONSerializing 的 optional 协议，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key &#123;</span><br><span class="line">	return @&#123;</span><br><span class="line">		// Not provided transformer for self.URL</span><br><span class="line">		@&quot;otherURL&quot;: [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName],</span><br><span class="line">	&#125;[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种则是根据属性的类型做相应的转换。</p>
<p>在以上两部转换完成之后剩下的就是赋值了，因为实现了 JSONKeyPathsByPropertyKey 方法，所以从 JSONDictionary 取值时如果碰到以数组形式定义的 key 时，会以<code>.</code>进行拆分，例如 <code>@&quot;name&quot;: @&quot;POI.name&quot;</code> ，则对应的取值处理是 <code>JSONDictionary[@&quot;POI&quot;][@&quot;name”]</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</span><br><span class="line">	...</span><br><span class="line">      </span><br><span class="line">      for (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;</span><br><span class="line">		id JSONKeyPaths = self.JSONKeyPathsByPropertyKey[propertyKey];</span><br><span class="line"></span><br><span class="line">		if (JSONKeyPaths == nil) continue;</span><br><span class="line"></span><br><span class="line">		id value;</span><br><span class="line"></span><br><span class="line">		if ([JSONKeyPaths isKindOfClass:NSArray.class]) &#123;</span><br><span class="line">			NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">			for (NSString *keyPath in JSONKeyPaths) &#123;</span><br><span class="line">				BOOL success = NO;</span><br><span class="line">				id value = [JSONDictionary mtl_valueForJSONKeyPath:keyPath success:&amp;success error:error];</span><br><span class="line"></span><br><span class="line">				if (!success) return nil;</span><br><span class="line"></span><br><span class="line">				if (value != nil) dictionary[keyPath] = value;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			value = dictionary;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			BOOL success = NO;</span><br><span class="line">			value = [JSONDictionary mtl_valueForJSONKeyPath:JSONKeyPaths success:&amp;success error:error];</span><br><span class="line"></span><br><span class="line">			if (!success) return nil;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们在子类里定义的 keyTransform 方法么，在取值之后这些值都会做相应的转换，注意一点就是NSNull对象会先转换成nil，然后将nil转换成NSNull对象插入到新的 dictionaryValue 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</span><br><span class="line">	...</span><br><span class="line">      </span><br><span class="line">      for (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;</span><br><span class="line">		...</span><br><span class="line">          </span><br><span class="line">         @try &#123;</span><br><span class="line">            NSValueTransformer *transformer = self.valueTransformersByPropertyKey[propertyKey];</span><br><span class="line">            if (transformer != nil) &#123;</span><br><span class="line">                // Map NSNull -&gt; nil for the transformer, and then back for the</span><br><span class="line">                // dictionary we&apos;re going to insert into.</span><br><span class="line">                if ([value isEqual:NSNull.null]) value = nil;</span><br><span class="line"></span><br><span class="line">                if ([transformer respondsToSelector:@selector(transformedValue:success:error:)]) &#123;</span><br><span class="line">                    id&lt;MTLTransformerErrorHandling&gt; errorHandlingTransformer = (id)transformer;</span><br><span class="line"></span><br><span class="line">                    BOOL success = YES;</span><br><span class="line">                    value = [errorHandlingTransformer transformedValue:value success:&amp;success error:error];</span><br><span class="line"></span><br><span class="line">                    if (!success) return nil;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    value = [transformer transformedValue:value];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (value == nil) value = NSNull.null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dictionaryValue[propertyKey] = value;</span><br><span class="line">        &#125; @catch (NSException *ex) &#123;</span><br><span class="line">            NSLog(@&quot;*** Caught exception %@ parsing JSON key path \&quot;%@\&quot; from: %@&quot;, ex, JSONKeyPaths, JSONDictionary);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>在生成 dictionaryValue 之后，开始调用 <code>- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error</code> 来对子类进行初始化，并调用 <code>MTLValidateAndSetValue</code> 来赋值，至此从 JSONDictionary 到 model 的解析算是完成了~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;</span><br><span class="line">	self = [self init];</span><br><span class="line">	if (self == nil) return nil;</span><br><span class="line"></span><br><span class="line">	for (NSString *key in dictionary) &#123;</span><br><span class="line">		// Mark this as being autoreleased, because validateValue may return</span><br><span class="line">		// a new object to be stored in this variable (and we don&apos;t want ARC to</span><br><span class="line">		// double-free or leak the old or new values).</span><br><span class="line">		__autoreleasing id value = [dictionary objectForKey:key];</span><br><span class="line"></span><br><span class="line">		if ([value isEqual:NSNull.null]) value = nil;</span><br><span class="line"></span><br><span class="line">		BOOL success = MTLValidateAndSetValue(self, key, value, YES, error);</span><br><span class="line">		if (!success) return nil;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 JSON 解析库目前流行的也是非常的多，&lt;a href=&quot;https://github.com/jsonmodel/jsonmodel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jsonmodel&lt;/a&gt; 、&lt;a href=&quot;https://github.com/Mantle/Mantle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mantle&lt;/a&gt; 、&lt;a href=&quot;https://github.com/ibireme/YYModel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YYModel&lt;/a&gt; 等都是大家常用的，使用这些库的好处就是你无需关心数据解析转换和复杂的类型判断处理，你只需要确定好客户端的数据结构能够与后端数据结构相对应即可，而这些库里面对于解析的处理也都是大同小异，无非是在使用、性能和异常处理上有些差别，这里推荐一下郭曜源大神（ YYModel 的作者）的文章，内容是对&lt;a href=&quot;http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;各大解析库进行了比较&lt;/a&gt;，对于开发者来说，了解其解析过程是最为基础的，这次看完 Mantle 的解析处理，我也做个简单的总结，大家可以互相学习交流。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mantle" scheme="http://yuzeyang.github.io/tags/Mantle/"/>
    
  </entry>
  
  <entry>
    <title>有赞 App 动态化配置中心实践</title>
    <link href="http://yuzeyang.github.io/2017/04/06/Youzan-App-Config-Center/"/>
    <id>http://yuzeyang.github.io/2017/04/06/Youzan-App-Config-Center/</id>
    <published>2017-04-06T12:16:19.000Z</published>
    <updated>2017-04-11T12:06:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>客户端大量的硬编码导致其灵活性大大降低，一些细小的改动只能通过发布版本解决，用户升级更新迭代速度慢，时效性差等原因，催生出了有赞 App 的动态化配置中心，它可以将配置，功能，界面，数据等各种配置数据统一进行管理下发，实时生效，极大地提升了客户端的灵活性。</p>
<p>同时配置中心不仅仅是简单的对配置数据进行修改、读取而已，更需要在容错性、流量优化、带宽节省等各方面的优化上下功夫。本文主要提供了有赞 App 的动态化配置中心解决方案，也总结了版本迭代中所做的优化。</p>
<a id="more"></a>
<h2 id="配置中心设计"><a href="#配置中心设计" class="headerlink" title="配置中心设计"></a>配置中心设计</h2><p>起初有赞各 App 内都散落着一些写死的链接，但随着 WWDC 16 中，Apple 表示将继续在 iOS 10 和 macOS 10.12 里收紧对普通 HTTP 的访问限制，并且无法使用 <code>NSAllowsArbitraryLoads</code> 来绕过 ATS 限制。我们只能很费时费力的把各 App 内所有访问 HTTP 的链接都修改成 HTTPS，这一个小小的改动就如此麻烦，那后续大的改动更难以想象，所以我们开始思考能否将这些重复且动态的工作抽象成一个配置中心，用它来支撑各个业务。</p>
<h4 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h4><p>第一版设计的相对简单，我们只是专门设计了一个 API，通过 API 请求配置数据，并且每个业务单独维护一份配置文件。</p>
<p>具体流程：客户端进入到前台，也就是应用程序被激活的时候，通过配置中心的接口向服务端请求最新的配置数据，如果配置文件有更新，则下发最新的配置给客户端，并且客户端本地存储这份最新的配置，用于应用运行时使用。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AppConfigCenter1.png" alt=""></p>
<p>但随着模块化的推进和应用数量的增加，配置文件的体积和数量会逐渐增大，每一次修改都会全量下发到客户端，这部分的流量累积起来是一个非常庞大的数字。并且使用配置文件去管理配置，只能维护到最新的配置，无法做到下发指定版本的配置。</p>
<p>所以针对这些弊端问题，我们衍生出了第二版配置中心。</p>
<h4 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h4><p>为了解决第一版产生的流量浪费和配置管理弱的问题，我们优化了配置下发和管理流程，我们采取的策略是 <code>增量更新</code> 和 <code>数据库存储配置</code> 。</p>
<p>具体流程改动：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AppConfigCenter2.png" alt=""></p>
<h4 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h4><p>增量更新的优势主要体现在业务增长的过程中。我们的配置文件可能会从几十 KB 增长到几百 KB 甚至更大，如果还继续使用全量更新，这部分流量对用户来说是非常浪费的。而使用增量更新之后，服务端只需要下发不同配置之间的差异补丁包，补丁包的大小相比于原始配置的大小是非常小的，可以节省下90%左右的流量，这是非常可观的。</p>
<p>增量更新我们目前使用的是 Google 出的 <a href="https://code.google.com/p/google-diff-match-patch/" target="_blank" rel="noopener">google-diff-match-patch</a> ，支持 Java,  JavaScript, Dart, C++, C#,  Objective-C, Lua 和 Python，但是官网已经下掉了该 SDK（不明白为什么），需要到 GitHub 上搜索类似于 <code>diff patch language:java</code> 这样的关键词，就能找到对应平台下的 SDK 了，有人已经 fork 出来了，因为只是字符串的比较处理，所以可以放心使用。</p>
<p>该增量更新的原理是先通过比较首部和尾部的相同部分，目的是提升一定的效率，再比较中间差异的部分，差异的部分通过一些字符去表示该改动是  <code>DEL</code>  还是  <code>ADD</code>  还是  <code>EQUAL</code>  ，这样最终形成的补丁包比改动部分要大一点，但是相比于全量更新已经减少很多了。</p>
<p>并且生成补丁包基本是毫秒级的，也不必担心接口请求的耗时问题。</p>
<p>服务端把前后配置的字符串进行比较即可得到一组补丁数据：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$dmp = <span class="keyword">new</span> DiffMatchPatch();</span><br><span class="line">$patches = $dmp-&gt;patch_make($oldConfigString, $latestConfigString);</span><br><span class="line">$patchStrings = [];</span><br><span class="line"><span class="keyword">foreach</span> ($patches <span class="keyword">as</span> $patchObject) &#123;</span><br><span class="line">    array_push($patchStrings, $patchObject-&gt;__toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的补丁以官方为例，补丁内包含两个字符串之间变动部分的 location 和 length，并最终下发给客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@@ -16,21 +16,29 @@</span><br><span class="line"> see </span><br><span class="line">-yonder</span><br><span class="line">+the</span><br><span class="line">  cloud </span><br><span class="line">+over there </span><br><span class="line"> that</span><br><span class="line">@@ -47,18 +47,19 @@</span><br><span class="line">  almost </span><br><span class="line">-in</span><br><span class="line">+the</span><br><span class="line">  shape o</span><br><span class="line">@@ -86,24 +86,18 @@</span><br><span class="line">  By </span><br><span class="line">-the mass, and &apos;t</span><br><span class="line">+golly, it </span><br><span class="line"> is l</span><br><span class="line">@@ -129,21 +129,23 @@</span><br><span class="line"> et: </span><br><span class="line">-Me</span><br><span class="line">+I </span><br><span class="line"> think</span><br><span class="line">-s</span><br><span class="line">  it </span><br><span class="line">-i</span><br><span class="line">+look</span><br><span class="line"> s li</span><br><span class="line">@@ -177,12 +177,12 @@</span><br><span class="line">  is </span><br><span class="line">-back</span><br><span class="line">+shap</span><br><span class="line"> ed l</span><br><span class="line">@@ -234,11 +234,19 @@</span><br><span class="line"> us: </span><br><span class="line">-Ver</span><br><span class="line">+It&apos;s totall</span><br><span class="line"> y li</span><br></pre></td></tr></table></figure>
<p>以 iOS 为例，客户端获取补丁包后，根据补丁包内变动符号以及变动内容对本地配置文件内容进行字符串拼接或删除操作，形成最终的配置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DiffMatchPatch *dmp = [[DiffMatchPatch alloc] init];</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *patchStrings = configDic[<span class="string">@"patches"</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span>&lt;Patch *&gt; *patches = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *patchString <span class="keyword">in</span> patchStrings) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;Patch *&gt; *patch = [dmp patch_fromText:patchString error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        [patches addObjectsFromArray:patch];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSString</span> *newCacheConfig = [[dmp patch_apply:patches toString:cacheConfig] objectAtIndex:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>为了确保客户端最终生成的配置与服务端保持一致，客户端在打好补丁之后，用该配置生成 MD5 值，与我们在服务端下发补丁包时携带的最新配置的 MD5 值进行比较，在一致的情况下才去缓存配置，避免因为补丁造成 App 无法使用的问题。</p>
<h4 id="数据库管理配置"><a href="#数据库管理配置" class="headerlink" title="数据库管理配置"></a>数据库管理配置</h4><p>实现增量更新的前提是我们需要有不同版本的配置记录，而用文件去管理是非常不可控的，取而代之的是我们可以通过数据库来管理，同时利于后期的横向扩展，可以针对不同平台，不同渠道，不同版本等规则下发。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/dbConfig.png" alt=""></p>
<p>目前我们是根据版本和应用来关联到配置，所以表结构设计的很简单，把应用、版本和配置放在一张表里面，后面针对多渠道和多平台等规则之后，表结构上会做一定调整。</p>
<p>由于需要 App 能及时获取到最新配置，我们选择在 App 激活的时机去获取配置，通过数据统计中心我们可以看到 App 当日启动次数的时段分析，再结合配置文件大小，我们可以预估所占带宽的大小，运维是非常担心你把他的带宽跑满，影响到其他业务，所以我们需要做两个优化，一个是压缩配置，一个是本地缓存。</p>
<h5 id="压缩配置"><a href="#压缩配置" class="headerlink" title="压缩配置"></a>压缩配置</h5><p>为了不占用过多的带宽，我们需要在写入之前把配置压缩，读取之后解压配置。</p>
<p>这里我们通过 <code>gzip</code> 来压缩配置：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$data[<span class="string">'config'</span>] = base64_encode(gzcompress(json_encode($config)));</span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>gzip</code> 可以设置压缩等级，范围是0 - 9，默认是6，但是提升压缩等级会占用较多 CPU 时间和内存，我们使用默认等级压缩之后，配置文件体积减少了75%，看来是配置内相同的部分比较多，所以压缩效果还是比较明显的。</p>
<p>这里有人会问，为什么 <code>gzip</code> 之后还要 <code>base64</code> 编码一下，因为二进制数据不能直接写到text字段里面，写进去之后读出来也是解压不了的。进行 <code>base64</code>  编码之后，我们的压缩配置内容会比原来多1/3的长度。</p>
<h5 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h5><p>对于相同的配置，我们可以不用频繁地去请求数据库，而将其缓存到本地，这样后续的请求可以直接从缓存中读取配置，当然请记得设置缓存的过期时间。</p>
<p>我们目前用的是 <code>Redis</code> 缓存，它对于复杂的数据结构和操作支持的相当不错，而且操作简单，对于前期只是key-value存储的话，可以考虑使用 <code>Redis</code> 。</p>
<h4 id="可操作界面"><a href="#可操作界面" class="headerlink" title="可操作界面"></a>可操作界面</h4><p>为了方便业务方修改配置，我们在内部平台上提供了一个简单的可操作界面，通过顶部的Tab栏切换查看不同应用下的配置记录。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/cpAppConfigCenter.png" alt=""></p>
<p>点击 <code>查看详情</code> 可以看到当前版本的配置内容，目前展示的效果并不友好，后面会进行优化。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/cpAppConfigCenterDetail.png" alt=""></p>
<p>在需要修改配置的时候，我们可以通过 <code>新增配置</code> 给指定应用修改配置，新增时会自动在版本上 +1。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/cpAppConfigCenterAdd.png" alt=""></p>
<h2 id="后续优化"><a href="#后续优化" class="headerlink" title="后续优化"></a>后续优化</h2><p>目前有赞 App 已经实现了动态化配置中心整一套流程，但是在一些细节方面还需要不断的改进优化，比如：</p>
<ul>
<li>更加丰富的配置下发规则</li>
<li>可操作界面配置的有效性的校验</li>
<li>可操作界面的视觉优化</li>
<li>等等</li>
</ul>
<p>也欢迎大家提出自己的意见和建议，我们一起探讨学习！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;客户端大量的硬编码导致其灵活性大大降低，一些细小的改动只能通过发布版本解决，用户升级更新迭代速度慢，时效性差等原因，催生出了有赞 App 的动态化配置中心，它可以将配置，功能，界面，数据等各种配置数据统一进行管理下发，实时生效，极大地提升了客户端的灵活性。&lt;/p&gt;
&lt;p&gt;同时配置中心不仅仅是简单的对配置数据进行修改、读取而已，更需要在容错性、流量优化、带宽节省等各方面的优化上下功夫。本文主要提供了有赞 App 的动态化配置中心解决方案，也总结了版本迭代中所做的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="App 配置中心" scheme="http://yuzeyang.github.io/tags/App-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>查看MySQL连接的root密码</title>
    <link href="http://yuzeyang.github.io/2017/01/04/Check-MySQL-Password/"/>
    <id>http://yuzeyang.github.io/2017/01/04/Check-MySQL-Password/</id>
    <published>2017-01-03T16:03:02.000Z</published>
    <updated>2018-06-08T08:20:44.181Z</updated>
    
    <content type="html"><![CDATA[<p>晚上在用<code>Navicat</code>去连本地的MySQL的时候发现我已经忘了密码了，试了网上很多方式都不行…后来发现其实可以自己直接去看当初设置的密码..</p>
<p>来看正文：</p>
<a id="more"></a>
<h5 id="1-首先我们进到MySQL的bin目录下"><a href="#1-首先我们进到MySQL的bin目录下" class="headerlink" title="1.首先我们进到MySQL的bin目录下"></a>1.首先我们进到MySQL的bin目录下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  cd /usr/local/mysql/bin</span><br></pre></td></tr></table></figure>
<h5 id="2-切换成root身份"><a href="#2-切换成root身份" class="headerlink" title="2.切换成root身份"></a>2.切换成root身份</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo su</span><br></pre></td></tr></table></figure>
<h5 id="3-跨过权限的验证"><a href="#3-跨过权限的验证" class="headerlink" title="3.跨过权限的验证"></a>3.跨过权限的验证</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh-3.2# ./mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">[1] 9451</span><br><span class="line">sh-3.2# 2017-01-03T15:40:10.6NZ mysqld_safe Logging to '/usr/local/mysql/data/yzydeMacBook-Pro.local.err'.</span><br><span class="line">2017-01-03T15:40:10.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data</span><br></pre></td></tr></table></figure>
<h5 id="4-以root身份登录MySQL"><a href="#4-以root身份登录MySQL" class="headerlink" title="4.以root身份登录MySQL"></a>4.以root身份登录MySQL</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./mysql -uroot</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.12 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br></pre></td></tr></table></figure>
<h5 id="5-选择mysql数据库"><a href="#5-选择mysql数据库" class="headerlink" title="5.选择mysql数据库"></a>5.选择mysql数据库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> use mysql</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>
<h5 id="6-显示mysql数据库下的表"><a href="#6-显示mysql数据库下的表" class="headerlink" title="6.显示mysql数据库下的表"></a>6.显示mysql数据库下的表</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show tables;</span><br><span class="line">+---------------------------+</span><br><span class="line">| Tables_in_mysql           |</span><br><span class="line">+---------------------------+</span><br><span class="line">| columns_priv              |</span><br><span class="line">| db                        |</span><br><span class="line">| engine_cost               |</span><br><span class="line">| event                     |</span><br><span class="line">| func                      |</span><br><span class="line">| general_log               |</span><br><span class="line">| gtid_executed             |</span><br><span class="line">| help_category             |</span><br><span class="line">| help_keyword              |</span><br><span class="line">| help_relation             |</span><br><span class="line">| help_topic                |</span><br><span class="line">| innodb_index_stats        |</span><br><span class="line">| innodb_table_stats        |</span><br><span class="line">| ndb_binlog_index          |</span><br><span class="line">| plugin                    |</span><br><span class="line">| proc                      |</span><br><span class="line">| procs_priv                |</span><br><span class="line">| proxies_priv              |</span><br><span class="line">| server_cost               |</span><br><span class="line">| servers                   |</span><br><span class="line">| slave_master_info         |</span><br><span class="line">| slave_relay_log_info      |</span><br><span class="line">| slave_worker_info         |</span><br><span class="line">| slow_log                  |</span><br><span class="line">| tables_priv               |</span><br><span class="line">| time_zone                 |</span><br><span class="line">| time_zone_leap_second     |</span><br><span class="line">| time_zone_name            |</span><br><span class="line">| time_zone_transition      |</span><br><span class="line">| time_zone_transition_type |</span><br><span class="line">| user                      |</span><br><span class="line">+---------------------------+</span><br><span class="line">31 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h5 id="7-很明显我们需要的密码是存在user这个表下的，所以我们直接看user的表结构是怎么样的"><a href="#7-很明显我们需要的密码是存在user这个表下的，所以我们直接看user的表结构是怎么样的" class="headerlink" title="7.很明显我们需要的密码是存在user这个表下的，所以我们直接看user的表结构是怎么样的"></a>7.很明显我们需要的密码是存在user这个表下的，所以我们直接看user的表结构是怎么样的</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show columns from user;</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Field                  | Type                              | Null | Key | Default               | Extra |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">| Host                   | char(60)                          | NO   | PRI |                       |       |</span><br><span class="line">| User                   | char(32)                          | NO   | PRI |                       |       |</span><br><span class="line">| Select_priv            | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Insert_priv            | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Update_priv            | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Delete_priv            | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Create_priv            | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Drop_priv              | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Reload_priv            | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Shutdown_priv          | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Process_priv           | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| File_priv              | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Grant_priv             | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| References_priv        | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Index_priv             | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_priv             | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Show_db_priv           | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Super_priv             | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tmp_table_priv  | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Lock_tables_priv       | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Execute_priv           | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_slave_priv        | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Repl_client_priv       | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Create_view_priv       | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Show_view_priv         | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Create_routine_priv    | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Alter_routine_priv     | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Create_user_priv       | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Event_priv             | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Trigger_priv           | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| Create_tablespace_priv | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| ssl_type               | enum('','ANY','X509','SPECIFIED') | NO   |     |                       |       |</span><br><span class="line">| ssl_cipher             | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_issuer            | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| x509_subject           | blob                              | NO   |     | NULL                  |       |</span><br><span class="line">| max_questions          | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_updates            | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_connections        | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| max_user_connections   | int(11) unsigned                  | NO   |     | 0                     |       |</span><br><span class="line">| plugin                 | char(64)                          | NO   |     | mysql_native_password |       |</span><br><span class="line">| authentication_string  | text                              | YES  |     | NULL                  |       |</span><br><span class="line">| password_expired       | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">| password_last_changed  | timestamp                         | YES  |     | NULL                  |       |</span><br><span class="line">| password_lifetime      | smallint(5) unsigned              | YES  |     | NULL                  |       |</span><br><span class="line">| account_locked         | enum('N','Y')                     | NO   |     | N                     |       |</span><br><span class="line">+------------------------+-----------------------------------+------+-----+-----------------------+-------+</span><br><span class="line">45 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>
<h5 id="8-表的内容比较多，但是我们很容易就发现，密码其实是存在authentication-string字段下的，那我们就可以直接读User内容为root的密码了"><a href="#8-表的内容比较多，但是我们很容易就发现，密码其实是存在authentication-string字段下的，那我们就可以直接读User内容为root的密码了" class="headerlink" title="8.表的内容比较多，但是我们很容易就发现，密码其实是存在authentication_string字段下的，那我们就可以直接读User内容为root的密码了"></a>8.表的内容比较多，但是我们很容易就发现，密码其实是存在authentication_string字段下的，那我们就可以直接读User内容为root的密码了</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> select authentication_string from user where User='root';</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| authentication_string                     |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| *781D25322166DB7FF99BA4A1FA5ED30439A60DDE |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>OK，那我们拿着这个密码到<code>Navicat</code>试试看</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/EditConnection.png!400x400" alt=""></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/connectionSuccessful.png!400x400" alt=""></p>
<p>Wonderful~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;晚上在用&lt;code&gt;Navicat&lt;/code&gt;去连本地的MySQL的时候发现我已经忘了密码了，试了网上很多方式都不行…后来发现其实可以自己直接去看当初设置的密码..&lt;/p&gt;
&lt;p&gt;来看正文：&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yuzeyang.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>项目接入使用React Native</title>
    <link href="http://yuzeyang.github.io/2016/10/09/react-native/"/>
    <id>http://yuzeyang.github.io/2016/10/09/react-native/</id>
    <published>2016-10-09T13:53:32.000Z</published>
    <updated>2017-07-11T03:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一段时间没有写东西了，因为最近项目开始尝试使用React Native（以下简称RN）来开发，所以这段时间一直在研究，目前为止开发的内容不多，所以使用过的东西也不算多，这里也只是做个简单的记录</p>
<p>这里我打算从以下几个方面来讲：</p>
<p>1.背景介绍</p>
<p>2.环境的配置</p>
<p>3.RN所需要知道的知识</p>
<p>4.RN与原生的交互</p>
<p>5.本地调试与本地打包调试</p>
<p>6.远程热更新</p>
<p>7.iOS和Android不同样式处理</p>
<p>8.踩坑记录</p>
<p>9.相关资料</p>
<a id="more"></a>
<h2 id="0x00-背景介绍"><a href="#0x00-背景介绍" class="headerlink" title="0x00 背景介绍"></a>0x00 背景介绍</h2><p>RN是Facebook在React.js 2015大会上公布开源的，它是基于开源框架React.js来实现的，它支持了iOS和Android两大平台，解决开发者们编写重复代码的痛点，实现了所谓的跨平台开发，Learn Once , Write Anywhere，这是目前很多开发者所追求的，特别是一些独立开发者或者项目快速迭代的团队，可以尝试使用RN来开发，另外包括方便的npm管理，快速的调试等等</p>
<p>那么既然优点这么明显，为什么大部分的团队还是采用传统的iOS、Android开发呢，踩过坑的同学都知道，首先在支持上还做得不够完善，在使用组件时，RN原有提供的组件往往不能很好的支持，与原生组件多少存在着差异，而且在使用第三方组件时，又会因为长期不更新的原因，存在很多坑，对于新手来说，根本不知道坑在哪，完全无从下手。另外RN的性能也不能和原生的相提并论，特别是列表组件在渲染大量数据时，流畅性方面还是原生更加优越，而且并非所以代码iOS和Android都能公用，如果某个组件只支持某一个平台，那你必须分开编写代码，实际上还是存在重复代码，除此之外学习的成本以及团队RN推广等等原因都需要考量，但是我相信，跨平台开发始终是一个趋势，RN整个社区也在不断的发展，相信未来我们会实现真正意义上的跨平台开发~</p>
<h2 id="0x01-环境配置"><a href="#0x01-环境配置" class="headerlink" title="0x01 环境配置"></a>0x01 环境配置</h2><p>相对于Android的环境配置过程来说，iOS可以说是简单轻松…出现的问题要少很多</p>
<p>首先我们需要安装<strong>Homebrew</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<p>然后安装<strong>node</strong>和<strong>watchman</strong>(用于监测文件系统的变更)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">brew install watchman</span><br></pre></td></tr></table></figure>
<p>RN的命令行工具<strong>react-native-cli</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>如果遇到权限问题，只要前面加个<strong>sudo</strong>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>yeah~that’s all~我在配置的过程中，基本没有报错，如果有出现配置问题的话，请自行Google一下，看看大家的解决方法</p>
<p>如果在原有iOS项目中集成的话，我们需要在package.json文件配置一下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"your project name"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node node_modules/react-native/local-cli/cli.js start"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"15.3.1"</span>,</span><br><span class="line">    <span class="attr">"react-native"</span>: <span class="string">"0.33.0"</span>,</span><br><span class="line">    <span class="attr">"react-native-swipeout"</span>: <span class="string">"^2.0.12"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且Podfile里，导入需要的RN模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [</span><br><span class="line">    &apos;Core&apos;,</span><br><span class="line">    &apos;RCTText&apos;,</span><br><span class="line">    &apos;RCTImage&apos;,</span><br><span class="line">    &apos;RCTNetwork&apos;,</span><br><span class="line">    &apos;RCTWebSocket&apos;, # needed for debugging</span><br><span class="line">    # Add any other subspecs you want to use in your project</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="0x02-RN所需要知道的知识"><a href="#0x02-RN所需要知道的知识" class="headerlink" title="0x02 RN所需要知道的知识"></a>0x02 RN所需要知道的知识</h2><h3 id="RN的运行机制"><a href="#RN的运行机制" class="headerlink" title="RN的运行机制"></a>RN的运行机制</h3><p>在开始写代码之前，我们需要了解RN的运行机制是怎么样的，这样写起来思路会更加清晰</p>
<p>首先，程序需要有个入口，我们可以创建很多的组件，但是有且只有一个组件用来做为程序的入口，RN的入口则类似于iOS的main.m，在iOS里我们会在main函数里设置应用程序类的代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return UIApplicationMain(argc, argv, nil, NSStringFromClass([KDAppDelegate class]));</span><br></pre></td></tr></table></figure>
<p>同样，RN里我们需要注册入口的名称，并且这个名称要和原生的初始化RN界面时的入口名称保持一致</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用navigation使用的组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建navigation类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">navigation</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// set compnent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册navigation为程序的入口</span></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'navigation'</span>, () =&gt; navigation);</span><br></pre></td></tr></table></figure>
<p>在iOS原生这边需要用到RN的地方，我们需要初始化它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSURL *jsCodeLocation =</span><br><span class="line">[[NSBundle mainBundle] URLForResource:@&quot;bundle/index.ios&quot; withExtension:@&quot;jsbundle&quot;];</span><br><span class="line">//        [NSURL URLWithString:@&quot;http://172.17.9.188:8081/index.ios.bundle?platform=ios&quot;];</span><br><span class="line">RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                                    moduleName:@&quot;navigation&quot;</span><br><span class="line">                                            initialProperties:nil</span><br><span class="line">                                                 launchOptions:nil];</span><br><span class="line">self.view = rootView;</span><br></pre></td></tr></table></figure>
<p>Tip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsCodeLocation 是RN资源加载的路径，我们有两种方式去加载，一种是加载本地的js文件及其他资源文件，一种是我们将其打包成bundle文件，前者的优势在于方便调试，后者是用来打包发布上线用</span><br></pre></td></tr></table></figure>
<p><code>moduleName</code>是对应于RN的入口名字，且这个是唯一的，那我们如果原生有多个入口需要初始化不同的RN界面，那该怎么办呢？这就用到了<code>initialProperties</code>，它是字典类型，我们可以将入口作为路由，在<code>initialProperties</code>里传入我们需要初始化的界面名称，入口获取到名称之后，渲染对应的界面即可</p>
<h3 id="RN组件的生命周期"><a href="#RN组件的生命周期" class="headerlink" title="RN组件的生命周期"></a>RN组件的生命周期</h3><p>在RN里面，所谓的界面应该称作类或者组件更为合适</p>
<p>并且组件也有它的生命周期，和iOS里的<code>viewWillAppear</code>、<code>viewDidDisappear</code>等等很像，下面生命周期内容取自于<a href="http://www.race604.com/react-native-component-lifecycle/" target="_blank" rel="noopener">http://www.race604.com/react-native-component-lifecycle/</a></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/RNCycleLife.jpg!700x700" alt=""></p>
<p>我们可以把组件生命周期大致分为三个阶段：</p>
<ul>
<li>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；</li>
<li>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；</li>
<li>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</li>
</ul>
<p>下面来详细介绍生命周期中的各回调函数。</p>
<h4 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h4><p>在组件创建之前，会先调用 <code>getDefaultProps()</code>，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 <code>getInitialState()</code>，来初始化组件的状态。</p>
<h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h4><p>然后，准备加载组件，会调用 <code>componentWillMount()</code>，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentWillMount()</span><br></pre></td></tr></table></figure>
<p>这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 <code>render()</code> 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。</p>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h4><p>在组件第一次绘制之后，会调用 <code>componentDidMount()</code>，通知组件已经加载完成。函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentDidMount()</span><br></pre></td></tr></table></figure>
<p>这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 <code>componentDidMount()</code>，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 <code>setTimeout</code> 或者 <code>setInterval</code>，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发。</p>
<h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>如果组件收到新的属性（props），就会调用 <code>componentWillReceiveProps()</code>，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentWillReceiveProps(  </span><br><span class="line">  object nextProps</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 是即将被设置的属性，旧的属性还是可以通过 <code>this.props</code> 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 <code>this.setState()</code> 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 <code>render()</code> 调用。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps: function(nextProps) &#123;  </span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    likesIncreasing: nextProps.likeCount &gt; this.props.likeCount</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>当组件接收到新的属性和状态改变的话，都会触发调用 <code>shouldComponentUpdate(...)</code>，函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean shouldComponentUpdate(  </span><br><span class="line">  object nextProps, object nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 和上面的 <code>componentWillReceiveProps</code> 函数一样，<code>nextState</code> 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 <code>true</code> 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。</p>
<p>默认情况下，这个函数永远返回 <code>true</code> 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。</p>
<h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>如果组件状态或者属性改变，并且上面的 <code>shouldComponentUpdate(...)</code> 返回为 <code>true</code>，就会开始准更新组件，并调用 <code>componentWillUpdate()</code>，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentWillUpdate(  </span><br><span class="line">  object nextProps, object nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输入参数与 <code>shouldComponentUpdate</code> 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 <code>this.setState</code> 来修改状态。这个函数调用之后，就会把 <code>nextProps</code> 和 <code>nextState</code> 分别设置到 <code>this.props</code>和 <code>this.state</code> 中。紧接着这个函数，就会调用 <code>render()</code> 来更新界面了。</p>
<h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><p>调用了 <code>render()</code> 更新完成界面之后，会调用 <code>componentDidUpdate()</code> 来得到通知，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentDidUpdate(  </span><br><span class="line">  object prevProps, object prevState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 <code>prevProps</code> 和 <code>prevState</code>。</p>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h4><p>当组件要被从界面上移除的时候，就会调用 <code>componentWillUnmount()</code>，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentWillUnmount()</span><br></pre></td></tr></table></figure>
<p>在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等。</p>
<p>下表是生命周期函数的调用次数，以及能否使用 setSate()：</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>调用次数</th>
<th>能否使用 setSate()</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDefaultProps</td>
<td>1(全局调用一次)</td>
<td>否</td>
</tr>
<tr>
<td>getInitialState</td>
<td>1</td>
<td>否</td>
</tr>
<tr>
<td>componentWillMount</td>
<td>1</td>
<td>是</td>
</tr>
<tr>
<td>render</td>
<td>&gt;=1</td>
<td>否</td>
</tr>
<tr>
<td>componentDidMount</td>
<td>1</td>
<td>是</td>
</tr>
<tr>
<td>componentWillReceiveProps</td>
<td>&gt;=0</td>
<td>是</td>
</tr>
<tr>
<td>shouldComponentUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentWillUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentDidUpdate</td>
<td>&gt;=0</td>
<td>否</td>
</tr>
<tr>
<td>componentWillUnmount</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="RN的设计模式"><a href="#RN的设计模式" class="headerlink" title="RN的设计模式"></a>RN的设计模式</h3><p>目前设计模式也非常多，如Flux，Reflux，Redux，Relay，Marty，不过以上都不是很了解，可以参考<a href="https://segmentfault.com/a/1190000004161358" target="_blank" rel="noopener">ReactNative的组件架构设计</a>学习了解一下，由于做客户端的同学接触的最多的是MVC，MVVM、MVCS等等，所以我觉得选用类似MVCS的模式可能更加适合新手的学习，比如写组件时，通常我们会创建一个组件，里面会包含数据的处理，页面的渲染，样式的设置，网络请求，当这些内容过多时，组件就会显得特别臃肿，所以我们需要将其拆分开为数据模型（Model），页面渲染，样式设置，网路请求（Service），这里的页面渲染和样式设置，不能算是称作为iOS里的Controller和View，应该跟前端一样，在html文件里面写布局，css文件里面写样式，感觉像是MVCS和前端的融合</p>
<h2 id="0x03-RN与原生的交互"><a href="#0x03-RN与原生的交互" class="headerlink" title="0x03 RN与原生的交互"></a>0x03 RN与原生的交互</h2><p>在写RN时不免会遇到与原生交互，下面我分JS调用原生、原生调用JS来讲</p>
<h3 id="JS调用原生"><a href="#JS调用原生" class="headerlink" title="JS调用原生"></a>JS调用原生</h3><p>在调用原生时，我们需要实现<code>RCTBridgeModule</code>和<code>RCT_EXPORT_MODULE();</code></p>
<p><code>RCT_EXPORT_MODULE();</code>则是一个宏定义，返回moduleName，并且调用<code>+ load</code>方法注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define RCT_EXPORT_MODULE(js_name) \</span><br><span class="line">RCT_EXTERN void RCTRegisterModule(Class); \</span><br><span class="line">+ (NSString *)moduleName &#123; return @#js_name; &#125; \</span><br><span class="line">+ (void)load &#123; RCTRegisterModule(self); &#125;</span><br></pre></td></tr></table></figure>
<p>例如我们增加一个bridge方法，获取版本号，<code>getVersion</code>为方法名，<code>callback</code>是原生回调给JS的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(getVersion : (RCTResponseSenderBlock)callback) &#123;</span><br><span class="line">    NSString *version =</span><br><span class="line">    [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];</span><br><span class="line">    callback(@[[NSNull null], @[version]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后返回方法的队列为主队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_queue_t)methodQueue &#123;</span><br><span class="line">    return dispatch_get_main_queue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JS文件里，我们可以定义一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ZanIntentModule = NativeModules.ZanIntentModule;</span><br></pre></td></tr></table></figure>
<p>然后在使用的时候调用我们在原生时定义方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZanIntentModule.getVersion(</span><br><span class="line">(callback) =&gt; &#123;</span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="原生调用JS"><a href="#原生调用JS" class="headerlink" title="原生调用JS"></a>原生调用JS</h3><p>老版本的调用方式为，但是接口被标记为deprecated：<code>__deprecated_msg(&quot;Subclass RCTEventEmitter instead&quot;);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.bridge.eventDispatcher sendAppEventWithName:kGiftReloadData body:nil];</span><br></pre></td></tr></table></figure>
<p>新版本的调用方式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZanEventEmitter *emitter = [[ZanEventEmitter alloc] init];</span><br><span class="line">emitter.bridge = self.bridge;</span><br><span class="line">[emitter sendEventWithName:kGiftReloadData body:nil];</span><br></pre></td></tr></table></figure>
<p>但是新版本坑的是，直接这样调用时bridge居然是nil，网上说用单例，但是也不行…所以我还是用老版本的调用方法，有哪个大神知道怎么用新版本接口调用的正确姿势，请留言交流哈</p>
<p>然后在实现<code>RCTBridgeDelegate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge &#123;</span><br><span class="line">    return [[NSBundle mainBundle] URLForResource:@&quot;bundle/index.ios&quot; withExtension:@&quot;jsbundle&quot;];</span><br><span class="line">//    return [NSURL URLWithString:@&quot;http://172.17.9.94:8081/index.ios.bundle?platform=ios&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对应的组件里，需要在<code>componentWillMount</code>增加监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.eventEmitter = NativeAppEventEmitter.addListener(</span><br><span class="line">    <span class="string">'GiftReloadData'</span>,</span><br><span class="line">    () =&gt; <span class="keyword">this</span>._reloadData()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的也需要移除掉监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  subscription.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后原生发送action之后，会触发我们设定好的<code>reloadData()</code>方法</p>
<h2 id="0x04-本地调试与打包调试"><a href="#0x04-本地调试与打包调试" class="headerlink" title="0x04 本地调试与打包调试"></a>0x04 本地调试与打包调试</h2><p>在编写的过程中，也需要进行调试，调试有两种方法：一种是本地调试，一种是打包调试</p>
<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>我们在加载bundle时，需要替换成你的ip地址，端口号不要变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSURL URLWithString:@&quot;http://172.17.9.94:8081/index.ios.bundle?platform=ios&quot;]</span><br></pre></td></tr></table></figure>
<p>如果你是在真机上调试，你需要开启HTTP代理，填写你的ip地址和端口号</p>
<p>在终端上，先进入到你的项目目录（与node_modules目录同级），然后开启服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yzydeMacBook-Pro:shangjiaban-ios yzy$ npm start</span><br></pre></td></tr></table></figure>
<p>你修改了某处之后，在模拟器上点击<code>Shake Gesture</code>或者快捷键，在真机上只要摇一摇就可以</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Shake.png!400x400" alt=""></p>
<p>在模拟器弹出框里选择<code>Roload</code>，这样就会重新加载你本地的JS文件</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/simulation.png!400x400" alt=""></p>
<p>如果你想查看JS里面的log日志，你可以选择<code>Start Remote JS Debugging</code>，在chrome浏览器里就能看到输出的日志了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/chromeDebug.png" alt=""></p>
<h3 id="打包调试"><a href="#打包调试" class="headerlink" title="打包调试"></a>打包调试</h3><p>另外一种就是打包调试，但是比较麻烦，首先我们要讲bundle加载方式改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSBundle mainBundle] URLForResource:@&quot;bundle/index.ios&quot; withExtension:@&quot;jsbundle&quot;];</span><br></pre></td></tr></table></figure>
<p>然后在终端里面，输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yzydeMacBook-Pro:shangjiaban-ios yzy$ react-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output ./xxx/bundle/index.ios.jsbundle --assets-dest ./xxx/bundle</span><br></pre></td></tr></table></figure>
<p><code>--bundle-output ./xxx/bundle/index.ios.jsbundle</code>指的是输出的bundle文件路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[20:54:43] &lt;START&gt; Building Dependency Graph</span><br><span class="line">[20:54:43] &lt;START&gt; Crawling File System</span><br><span class="line">[20:54:43] &lt;START&gt; find dependencies</span><br><span class="line">[20:54:48] &lt;END&gt;   Crawling File System (4712ms)</span><br><span class="line">[20:54:48] &lt;START&gt; Building in-memory fs for JavaScript</span><br><span class="line">[20:54:48] &lt;END&gt;   Building in-memory fs for JavaScript (230ms)</span><br><span class="line">[20:54:48] &lt;START&gt; Building in-memory fs for Assets</span><br><span class="line">[20:54:48] &lt;END&gt;   Building in-memory fs for Assets (154ms)</span><br><span class="line">[20:54:48] &lt;START&gt; Building Haste Map</span><br><span class="line">[20:54:48] &lt;START&gt; Building (deprecated) Asset Map</span><br><span class="line">[20:54:48] &lt;END&gt;   Building (deprecated) Asset Map (66ms)</span><br><span class="line">[20:54:48] &lt;END&gt;   Building Haste Map (154ms)</span><br><span class="line">[20:54:48] &lt;END&gt;   Building Dependency Graph (5261ms)</span><br><span class="line">transformed 372/372 (100%)</span><br><span class="line">[20:54:49] &lt;END&gt;   find dependencies (6402ms)</span><br><span class="line">bundle: start</span><br><span class="line">bundle: finish</span><br><span class="line">bundle: Writing bundle output to: ./Koudaitong/bundle/index.ios.jsbundle</span><br><span class="line">bundle: Copying 5 asset files</span><br><span class="line">bundle: Done writing bundle output</span><br><span class="line">bundle: Done copying assets</span><br></pre></td></tr></table></figure>
<p>当看到这样的信息的时候，说明已经打包成功了，再将生成的bundle文件夹以<code>Create folder references</code>形式加到工程里，然后就可以run了</p>
<p>Tip:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在真机调试时，需要在Edit Scheme里在Run模式里，将Build Configuration改为Release模式</span><br></pre></td></tr></table></figure>
<h2 id="0x05-远程热更新"><a href="#0x05-远程热更新" class="headerlink" title="0x05 远程热更新"></a>0x05 远程热更新</h2><p>这块网上的方案大同小异，因为目前我们还是采取本地打包加载的方式，还未上热更新，所以在这不好多做说明，等上了热更新之后，我再来补充~</p>
<p>2016年11月23日更新：</p>
<p>Tips：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该热更新方法取自于有赞技术团队官方博客里《React Native有赞初探》，欢迎关注我们技术团队的博客~</span><br></pre></td></tr></table></figure>
<h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><p>经过调研和选型，最终选择了微软出品的 <code>CodePush</code> 作为 <code>React Native</code> 热部署方案。</p>
<p><code>CodePush</code> 是提供给 <code>React Native</code> 开发者直接部署移动应用更新给用户设备的云服务。<code>CodePush</code> 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 <code>SDK</code> 里面查询更新。<code>CodePush</code> 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。</p>
<p><code>CodePush</code> 可以进行实时的推送代码更新：</p>
<ul>
<li>直接对用户部署代码更新</li>
<li>管理 <code>Alpha</code> ， <code>Beta</code> 和生产环境应用</li>
<li>支持 <code>JavaScript</code> 文件与图片资源的更新</li>
<li>暂不支持增量更新</li>
</ul>
<p><code>CodePush</code> 开源了 <code>react-native</code> 版本，<a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="noopener">react-native-code-push</a>托管在GitHub上。</p>
<p>具体的教程和用法微软都在 <code>Github上</code> 做了详细说明，接下来简单地梳理一下从配置、编码、部署等具体流程。</p>
<p>(1) 安装 <code>CodePush CLI</code></p>
<p>管理 <code>CodePush</code> 账号需要通过 <code>NodeJS-based CLI</code>。 只需要在终端输入 <code>npm install -g code-push-cli</code> ，就可以安装了。 安装完毕后，输入 <code>code-push -v</code> 查看版本，如看到版本代表成功。</p>
<p>(2) 创建一个 <code>CodePush</code> 账号 在终端输入 <code>code-push register</code> ，会打开如下注册页面让你选择授权账号。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/codepush.png" alt=""></p>
<p>授权通过之后，<code>CodePush</code> 会告诉你“access key”，复制此key到终端即可完成注册。</p>
<p>然后终端输入 <code>code-push login</code> 进行登陆，登陆成功后，你的session文件将会写在 /Users/你的用户名 <code>/.code-push.config</code>。</p>
<p>(3) 在CodePush服务器注册app 为了让 <code>CodePush</code> 服务器知道你的app，我们需要向它注册app： 在终端输入 <code>code-push app add</code> 即可完成注册。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push app add shangjiaban-android</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是iOS平台，命令为 <code>code-push app add shangjiaban-ios</code> ， <code>Android</code> 和 <code>iOS</code> 必须要区分</p>
</blockquote>
<p>还有很多 <code>code-push app</code> 相关的命令，参考如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$: code-push app help</span><br><span class="line">Usage: code-push app &lt;command&gt;</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  add       Add a new app to your account</span><br><span class="line">  remove    Remove an app from your account</span><br><span class="line">  rm        Remove an app from your account</span><br><span class="line">  rename    Rename an existing app</span><br><span class="line">  list      Lists the apps associated with your account</span><br><span class="line">  ls        Lists the apps associated with your account</span><br><span class="line">  transfer  Transfer the ownership of an app to another account</span><br></pre></td></tr></table></figure>
<h3 id="iOS配置"><a href="#iOS配置" class="headerlink" title="iOS配置"></a>iOS配置</h3><p>iOS平台上关于 <code>CodePush</code> 的配置和 <code>Android</code> 平台是类似的，可以参考上文的(1)(2)(3)，iOS平台集成 <code>CodePush</code> 比较简单，官网提供了3种集成方式，这里重点介绍如何通过 <code>cocoapods</code> 来集成。</p>
<p>(1) 引入 <code>CodePush</code></p>
<p>首先在Podfile文件中添加 <code>CodePush</code>，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;CodePush&apos;, :path =&gt; &apos;./node_modules/react-native-code-push&apos;</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>pod install</code> 就可以了。</p>
<p>(2) 声明 <code>bundle</code> 文件来源</p>
<p>引入 <code>CodePush</code> 后还需要在代码中声明 <code>bundle</code> 的加载来源，之前是加载本地的<code>bundle</code>文件，现在需要调用 <code>CodePush</code> 提供的方法指定加载 <code>Bundle</code> 文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CodePush.h&quot;</span><br><span class="line">...</span><br><span class="line">// 原来的bundle加载方法</span><br><span class="line">jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br><span class="line"></span><br><span class="line">// CodePush的bundle加载方法，这里的bundleURL默认加载的是main.jsbundle，</span><br><span class="line">// 如果你的名称不一样，需要调用CodePush提供的其他方法来自定义。</span><br><span class="line">jsCodeLocation = [CodePush bundleURL];</span><br></pre></td></tr></table></figure>
<p>最后还需要在 <code>Info.plist</code> 中添加一个 <code>key</code> 为 <code>CodePushDeploymentKey</code> ,其<code>value</code> 就是 <code>CodePush</code> 提供的唯一 <code>token</code> 值。具体获取方法，可以通过如下命令获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push deployment ls &lt;appName&gt; -k</span><br></pre></td></tr></table></figure>
<h3 id="RN配置"><a href="#RN配置" class="headerlink" title="RN配置"></a>RN配置</h3><p>为了达到更好的体验效果，我们决定采用静默升级的策略，让用户无感知地体验热更新，也可以是具体的升级流程图如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/updateStrategy.png!500x500" alt=""></p>
<p>如果要达成上述热部署效果，那么还需要在 <code>JavaScript</code> 文件中完成更新时机和更新策略的设置。</p>
<p>(1)在js中导入 <code>CodePush</code> 模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import codePush from &apos;react-native-code-push&apos;</span><br></pre></td></tr></table></figure>
<p>(2)在 <code>componentDidMount</code> 中调用 <code>sync</code> 方法，后台请求更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codePush.sync()</span><br></pre></td></tr></table></figure>
<p>如果是非强制并允许更新， <code>CodePush</code> 会在后台静默地将更新下载到本地，等待APP再一次启动或者加载 <code>React Native</code> 页面的时候更新应用。</p>
<p>如果更新是强制性的，更新文件下载好之后会立即进行更新。关于如何配置是否强制更新，会在下文发布更新处重点说明。</p>
<p>如果你期望更及时的获得更新，可以在每次APP从后台进入前台的时候去主动的检查更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AppState.addEventListener(&quot;change&quot;, (newState) =&gt; &#123;  </span><br><span class="line">        newState === &quot;active&quot; &amp;&amp; codePush.sync(&#123;</span><br><span class="line">            installMode:codePush.InstallMode.ON_NEXT_RESUME,</span><br><span class="line">            deploymentKey: DEPLOYMENT_KEY,</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上述流程图提及的三种更新方式，就是通过 <code>installMode</code> 参数控制的，取值方式分别为：</p>
<ol>
<li><code>codePush.InstallMode.ON_NEXT_RESTART</code>即下一次启动的时候安装更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESUME</code>即下一次切后台切换的时候安装更新</li>
<li><code>codePush.InstallMode. IMMEDIATE</code>立即下载安装更新</li>
</ol>
<blockquote>
<p>如果发布更新时 <code>mandatory</code> 参数为true，即强制更新，则上述设置都会无效，只有<code>mandatory</code> 参数为fasle时，设置才会有效。</p>
</blockquote>
<h3 id="打包并发布"><a href="#打包并发布" class="headerlink" title="打包并发布"></a>打包并发布</h3><p>(1) 打包js 发布更新之前，需要先把js打包成 <code>bundle</code> ，以下是Android的做法：</p>
<p>第一步： 在 <code>Android</code> 工程目录里面新增 <code>release</code> 文件： <code>mkdir release</code> ，对于iOS来说，目前 <code>bundle</code> 文件直接放在工程根目录下，所以无需这一步。 第二步： 运行命令打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试。</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<p>Android</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --platform android --entry-file index.android.js --bundle-output ./release/index.android.bundle --assets-dest ./release --dev false</span><br></pre></td></tr></table></figure>
<p>iOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --platform ios --entry-file index.ios.js --bundle-output ./Koudaitong/main.jsbundle --assets-dest ./Koudaitong --dev false</span><br></pre></td></tr></table></figure>
<p>(2) 发布更新</p>
<p>打包 <code>bundle</code> 结束后，就可以通过 <code>CodePush</code> 发布更新了。在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code-push release &lt;应用名称&gt; &lt;Bundles所在目录&gt; &lt;对应的应用版本&gt; --deploymentName： 更新环境  </span><br><span class="line">--description： 更新描述 --mandatory： 是否强制更新</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p>Android</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push release shangjiaban-android ./release 3.12.1 --description &quot;update React Native&quot; --mandatory true</span><br></pre></td></tr></table></figure>
<p>iOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push release shangjiaban-ios ./Koudaitong/main.jsbundle 3.12.0 --description &quot;update React Native&quot; --mandatory false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
</blockquote>
<ol>
<li><code>CodePush</code> 默认是更新 <code>Staging</code> 环境的，如果是 <code>Staging</code> ，则不需要填写<code>deploymentName</code>。</li>
<li>如果有 <code>mandatory</code> 则 <code>Code Push</code> 会根据 <code>mandatory</code> 是 <code>true</code> 或<code>false</code> 来控制应用是否强制更新。默认情况下 <code>mandatory</code> 为 <code>false</code> 即不强制更新。</li>
<li>对应的应用版本 <code>targetBinaryVersion</code> 是指当前app的版本(对应 <code>build.gradle</code> 中设置的versionName “3.12.1”)，也就是说此次更新的 <code>js/images</code> 对应的是app的那个版本。不要将其理解为这次js更新的版本。 如客户端版本是3.12.1，那么我们对3.12.1的客户端更新 <code>js/images</code> ， <code>targetBinaryVersion</code> 填的就是3.12.1。</li>
<li>对于对某个应用版本进行多次更新的情况， <code>CodePush</code> 会检查每次上传的 <code>bundle</code> ，如果在该版本下如3.12.1已经存在与这次上传完全一样的 <code>bundle</code> (对应一个版本有两个 <code>bundle</code> 的 <code>md5</code> 完全一样)，那么 <code>CodePush</code> 会拒绝此次更新。</li>
</ol>
<h2 id="0x06-iOS和Android不同样式处理"><a href="#0x06-iOS和Android不同样式处理" class="headerlink" title="0x06 iOS和Android不同样式处理"></a>0x06 iOS和Android不同样式处理</h2><p>最近看到FB的F8代码里面对于iOS和Android不同平台上样式的处理觉得挺不错的，由于系统原生控件样式设计风格的不一样，导致在写styles的时候会根据不同的platform来写，之前做法是定义不同的styles，然后判断platform去用，这样styles里面的代码会存在冗余，而且对styles的定义也不好</p>
<p>FB的做法是定义一个styles的基类，然后基类里解析平台信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">styles: Object</span>): </span>&#123;[name: string]: number&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> platformStyles = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.keys(styles).forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;ios, android, ...style&#125; = &#123;...styles[name]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ios &amp;&amp; Platform.OS === <span class="string">'ios'</span>) &#123;</span><br><span class="line">      style = &#123;...style, ...ios&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (android &amp;&amp; Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">      style = &#123;...style, ...android&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    platformStyles[name] = style;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> StyleSheet.create(platformStyles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析完之后，在styles里面，会根据不同的platform取不同的样式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">button: &#123;</span><br><span class="line">    borderColor: <span class="string">'transparent'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    justifyContent: <span class="string">'center'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'transparent'</span>,</span><br><span class="line">    ios: &#123;</span><br><span class="line">      height: HEIGHT,</span><br><span class="line">      paddingHorizontal: <span class="number">20</span>,</span><br><span class="line">      borderRadius: HEIGHT / <span class="number">2</span>,</span><br><span class="line">      borderWidth: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    android: &#123;</span><br><span class="line">      paddingBottom: <span class="number">6</span>,</span><br><span class="line">      paddingHorizontal: <span class="number">10</span>,</span><br><span class="line">      borderBottomWidth: <span class="number">3</span>,</span><br><span class="line">      marginRight: <span class="number">10</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="0x07-踩坑记录"><a href="#0x07-踩坑记录" class="headerlink" title="0x07 踩坑记录"></a>0x07 踩坑记录</h2><p>踩坑最多是应该是使用上的</p>
<p>1.RN系统的组件并不是所有都是共用的，比如segment支持iOS，不支持Android，Alert分为iOS和Android等等，所以还是要写重复的代码</p>
<p>2.ListView不支持iOS原生的滑动操作，需要使用第三方库，但是第三方库不能控制只编辑一个Cell</p>
<p>3.由于原先iOS和Android的代码仓库是分开的，所以接入RN时，JS文件也是跟着仓库走的，这样iOS和Android会存在重复代码，并且目前两个人分别接iOS和Android，写JS时，有时并不共享，容易代码写着写着就有差异了，偏离了Write Once , Run Anywhere的初衷</p>
<h2 id="0x08-相关资料"><a href="#0x08-相关资料" class="headerlink" title="0x08 相关资料"></a>0x08 相关资料</h2><p><a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">React Native</a></p>
<p><a href="http://reactnative.cn/" target="_blank" rel="noopener">React Native 中文网</a></p>
<p><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="noopener">汇集了各类react-native学习资源、开源App和组件</a></p>
<p><a href="http://blog.talisk.cn/blog/2016/08/13/RN-Learning-path-for-iOS-developer/" target="_blank" rel="noopener">写给 iOS 开发者的 React Native 学习路线</a></p>
<p><a href="http://www.lcode.org/" target="_blank" rel="noopener">江清清的技术专栏</a></p>
<p><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8" target="_blank" rel="noopener">React/React Native 的ES5 ES6写法对照表</a></p>
<p><a href="http://tech.youzan.com/react-native-zan/" target="_blank" rel="noopener">React Native有赞初探</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一段时间没有写东西了，因为最近项目开始尝试使用React Native（以下简称RN）来开发，所以这段时间一直在研究，目前为止开发的内容不多，所以使用过的东西也不算多，这里也只是做个简单的记录&lt;/p&gt;
&lt;p&gt;这里我打算从以下几个方面来讲：&lt;/p&gt;
&lt;p&gt;1.背景介绍&lt;/p&gt;
&lt;p&gt;2.环境的配置&lt;/p&gt;
&lt;p&gt;3.RN所需要知道的知识&lt;/p&gt;
&lt;p&gt;4.RN与原生的交互&lt;/p&gt;
&lt;p&gt;5.本地调试与本地打包调试&lt;/p&gt;
&lt;p&gt;6.远程热更新&lt;/p&gt;
&lt;p&gt;7.iOS和Android不同样式处理&lt;/p&gt;
&lt;p&gt;8.踩坑记录&lt;/p&gt;
&lt;p&gt;9.相关资料&lt;/p&gt;
    
    </summary>
    
    
      <category term="React Native" scheme="http://yuzeyang.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>iOS 抽屉式效果列表</title>
    <link href="http://yuzeyang.github.io/2016/09/08/iOS-Drawer-Table-View/"/>
    <id>http://yuzeyang.github.io/2016/09/08/iOS-Drawer-Table-View/</id>
    <published>2016-09-08T14:16:43.000Z</published>
    <updated>2016-09-12T11:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前很喜欢收藏<a href="https://dribbble.com/shots" target="_blank" rel="noopener">dribbble</a>里面的一些动效gif，里面不仅是动效还是配色等等都非常的美，作为一个视觉动物，真的想把他们一个一个都实现出来，作为自己的一个作品，那真的是一件赏心悦目的事情，看着G20也快结束了，赶紧趁还闲着，先实现一个，我先挑选了一个比较简单的动效—–<strong>抽屉式效果列表</strong></p>
<p>我们先来看下效果:</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCDrawerTableView.gif!500x500" alt=""></p>
<a id="more"></a>
<p>原来的动效地址找不到了…有知道的请留言给我…</p>
<p>代码地址：<a href="https://github.com/Yuzeyang/GCDrawerTableView" target="_blank" rel="noopener">https://github.com/Yuzeyang/GCDrawerTableView</a></p>
<p>老样子，我们来分析下步骤</p>
<h2 id="0x00-cell的处理"><a href="#0x00-cell的处理" class="headerlink" title="0x00 cell的处理"></a>0x00 cell的处理</h2><p>我们将<code>cell</code>和<code>详情界面</code>分开来处理</p>
<p>我们可以看到，当我们选中其中一个<code>cell</code>的时候，该<code>cell</code>会移动到列表上方的某一个位置，其他<code>cell</code>则不显示，点击<code>x</code>的时候，<code>cell</code>返回为原位，其他<code>cell</code>又重新显示</p>
<p>选中处理：首先是先将其他<code>cell</code>隐藏，我们取出<code>tableview</code>的可见<code>cell</code>，然后将除了选中的<code>cell</code>之外的透明度都设置为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GCTableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">[self.tableView bringSubviewToFront:cell];</span><br><span class="line">for (UIView *subcell in tableView.visibleCells) &#123;</span><br><span class="line">    if (subcell != cell) &#123;</span><br><span class="line">        subcell.alpha = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后改变选中<code>cell</code>的原点值，并且给<code>cell</code>增加阴影，这里我偷懒没有做按钮的动画，只是用文字表示了按钮的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">    CGRect rect = self.frame;</span><br><span class="line">    self.originCellFrame = rect;</span><br><span class="line">    CGPoint origin = CGPointMake(0, contentOffsetY + 30);</span><br><span class="line">    rect.origin = origin;</span><br><span class="line">    self.frame = rect;</span><br><span class="line"></span><br><span class="line">    // 详情页处理</span><br><span class="line"></span><br><span class="line">    [self addShadowWithView:self];</span><br><span class="line">    [self addShadowWithView:self.detailView];</span><br><span class="line">    [self.detailButton setTitle:@&quot;×&quot; forState:UIControlStateNormal];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>由于cell的动画处理是放在自定义cell里面做的，所以在点击关闭的时候，需要在动画结束之后回调给视图控制器，所以这里就用了block来回调关闭的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)deselectCell &#123;</span><br><span class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">        self.frame = self.originCellFrame;</span><br><span class="line">        </span><br><span class="line">        self.layer.shadowColor = [UIColor clearColor].CGColor;</span><br><span class="line">        self.layer.shadowRadius = 0;</span><br><span class="line">        self.layer.shadowOpacity = 0.0;</span><br><span class="line">        </span><br><span class="line">        // 详情页处理</span><br><span class="line">        [self.detailButton setTitle:@&quot;...&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        [self.helperHideView removeFromSuperview];</span><br><span class="line">        [self.detailView removeFromSuperview];</span><br><span class="line">        if (_deselectBlock) &#123;</span><br><span class="line">            _deselectBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在试图控制器里面，将其他的cell透明度改成1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[cell addDeselectBlock:^() &#123;</span><br><span class="line">    for (UIView *subcell in tableView.visibleCells) &#123;</span><br><span class="line">        if (subcell != cell) &#123;</span><br><span class="line">            subcell.alpha = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tableView.allowsSelection = YES;</span><br><span class="line">    tableView.scrollEnabled = YES;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="0x01-详情页"><a href="#0x01-详情页" class="headerlink" title="0x01 详情页"></a>0x01 详情页</h2><p>可以看到<code>详情页</code>是类似于从上掉落的感觉，可能会联想到电商的那些筛选栏，但是筛选栏点击的时候，是上部分开始出现一直到下面，展示的顺序是反过来的，后面想了很久，只能想到利用视觉错误的效果，将详情页添加到cell的下一层，然后<code>cell</code>动画时候，详情页也做相应的动画，但是由于详情页的<code>size</code>比<code>cell</code>肯定是要大的，所以如果加到<code>cell</code>下一层时，是遮挡不住的，所以就需要一个遮挡的view来遮住详情页</p>
<p>首先我们需要将<code>cell</code>移到最前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.tableView bringSubviewToFront:cell];</span><br></pre></td></tr></table></figure>
<p>然后在cell的下一层加上<code>遮挡视图</code>和<code>详情页</code>，并根据cell的origin做frame的变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">UIView *superview = self.superview;</span><br><span class="line">    </span><br><span class="line">CGFloat height = CGRectGetMinY(self.frame) - contentOffsetY + 30;</span><br><span class="line">[self.helperHideView setFrame:CGRectMake(0, contentOffsetY, CGRectGetWidth(self.frame), height)];</span><br><span class="line">[superview insertSubview:self.helperHideView belowSubview:self];</span><br><span class="line"></span><br><span class="line">[self.detailView setFrame:CGRectMake(0, CGRectGetMaxY(self.frame) - (GCDeviceHeight - 100 - 30*2),</span><br><span class="line">                                     CGRectGetWidth(self.frame), GCDeviceHeight - 100 - 30*2)];</span><br><span class="line">[superview insertSubview:self.detailView belowSubview:self.helperHideView];</span><br><span class="line"></span><br><span class="line">[UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">  	// cell处理  </span><br><span class="line">  </span><br><span class="line">  	CGRect rect2 = self.helperHideView.frame;</span><br><span class="line">    self.originHelperViewFrame = rect2;</span><br><span class="line">    CGPoint origin2 = CGPointMake(0, contentOffsetY + 30 - height);</span><br><span class="line">    rect2.origin = origin2;</span><br><span class="line">    self.helperHideView.frame = rect2;</span><br><span class="line"></span><br><span class="line">    CGRect rect1 = self.detailView.frame;</span><br><span class="line">    self.originDetailViewFrame = rect1;</span><br><span class="line">    CGPoint origin1 = CGPointMake(0, 100 + 30 + contentOffsetY);</span><br><span class="line">    rect1.origin = origin1;</span><br><span class="line">    self.detailView.frame = rect1;</span><br><span class="line"></span><br><span class="line">    [self addShadowWithView:self];</span><br><span class="line">    [self addShadowWithView:self.detailView];</span><br><span class="line">    [self.detailButton setTitle:@&quot;×&quot; forState:UIControlStateNormal];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>然后在关闭的时候，移除掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)deselectCell &#123;</span><br><span class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">        // cell处理</span><br><span class="line">        </span><br><span class="line">        self.detailView.layer.shadowColor = [UIColor clearColor].CGColor;</span><br><span class="line">        self.detailView.layer.shadowRadius = 0;</span><br><span class="line">        self.detailView.layer.shadowOpacity = 0.0;</span><br><span class="line">        </span><br><span class="line">        self.detailView.frame = self.originDetailViewFrame;</span><br><span class="line">        self.helperHideView.frame = self.originHelperViewFrame;</span><br><span class="line">        </span><br><span class="line">        [self.detailButton setTitle:@&quot;...&quot; forState:UIControlStateNormal];</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        [self.helperHideView removeFromSuperview];</span><br><span class="line">        [self.detailView removeFromSuperview];</span><br><span class="line">        if (_deselectBlock) &#123;</span><br><span class="line">            _deselectBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就实现了抽屉式的效果，但是总感觉还有更好的办法实现，如果有思路的，欢迎交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前很喜欢收藏&lt;a href=&quot;https://dribbble.com/shots&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dribbble&lt;/a&gt;里面的一些动效gif，里面不仅是动效还是配色等等都非常的美，作为一个视觉动物，真的想把他们一个一个都实现出来，作为自己的一个作品，那真的是一件赏心悦目的事情，看着G20也快结束了，赶紧趁还闲着，先实现一个，我先挑选了一个比较简单的动效—–&lt;strong&gt;抽屉式效果列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来看下效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCDrawerTableView.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="抽屉式 列表" scheme="http://yuzeyang.github.io/tags/%E6%8A%BD%E5%B1%89%E5%BC%8F-%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>果冻效果下拉刷新控件</title>
    <link href="http://yuzeyang.github.io/2016/09/02/loadingAniamtion-0902/"/>
    <id>http://yuzeyang.github.io/2016/09/02/loadingAniamtion-0902/</id>
    <published>2016-09-02T05:23:04.000Z</published>
    <updated>2016-09-02T09:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个下拉控件是在<a href="http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/?sukey=3997c0719f151520e178bb5175f11bfb983f5560c51261103fafb276bac79e1371d16e07ede0cca9f23d826405507a3c" target="_blank" rel="noopener">Elastic view animation using UIBezierPath</a>这篇博客上看到的，觉得效果还不错，自己也就OC简单实现了一下（原作者是用Swift写的），控件效果如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationTwo.gif!700x700" alt=""></p>
<p>这是代码地址：<a href="https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo" target="_blank" rel="noopener">https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo</a></p>
<p>这个控件的动画效果分为两个部分：</p>
<p>1.下拉的果冻效果</p>
<p>2.下拉进度圆圈的显示及旋转</p>
<a id="more"></a>
<h2 id="0x00-下拉果冻状态实现思路"><a href="#0x00-下拉果冻状态实现思路" class="headerlink" title="0x00 下拉果冻状态实现思路"></a>0x00 下拉果冻状态实现思路</h2><p>对于下拉的状态，我将其分为三种，然后在初始化的时候，将状态设置为正常状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, GCLoadingState) &#123;</span><br><span class="line">    GCLoadingStateNormal,	// 正常状态</span><br><span class="line">    GCLoadingStateLoading,	// 加载中状态</span><br><span class="line">    GCLoadingStateCancelled	// 取消加载状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并且在初始化的时候，绘制曲线的初始样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawOriginPath &#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    [path moveToPoint:CGPointMake(0, 0)];</span><br><span class="line">    [path addLineToPoint:CGPointMake(0, kGCLoadingViewMinHeight)];</span><br><span class="line">    [path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), kGCLoadingViewMinHeight)];</span><br><span class="line">    [path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), 0)];</span><br><span class="line">    </span><br><span class="line">    self.loadLayer.path = path.CGPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那在手指拖动的过程中，我们该如果实现果冻拉伸的效果呢？</p>
<p>我们需要一个辅助视图<code>centerHelperView</code>，这个辅助视图是加在下面这条线的中间的，如图的小黑点：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/centerHelperView.png!500x500" alt=""></p>
<p>在下拉时我们就根据这个<code>centerHelperView</code>的变化来不断的绘制我们的曲线，所以我们用到了<code>CADisplayLink</code>，这个应该在写动画的时候用的也是比较多了，是根据屏幕的刷新频率将内容绘制到屏幕的定时器，当我们将定时器加到<code>runLoop</code>里时，我们需要注意在设置<code>mode</code>时，如果将<code>mode</code>设置为<code>NSDefaultRunLoopMode</code>，那么在滑动的时候，定时器会暂停，直到停止滑动才会继续工作，所以我们需要将<code>mode</code>设置为<code>NSRunLoopCommonModes</code>，这样能保证定时器在滑动的过程中也能正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (CADisplayLink *)displayLink &#123;</span><br><span class="line">    if (!_displayLink) &#123;</span><br><span class="line">        _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkAction:)];</span><br><span class="line">        [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">        _displayLink.paused = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return _displayLink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在取出<code>centerHelperView</code>的原点，来不断绘制果冻的曲线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayLinkAction:(CADisplayLink *)displayLink &#123;</span><br><span class="line">    CALayer *centerHelperViewLayer = (CALayer *)[self.centerHelperView.layer presentationLayer];</span><br><span class="line">    CGRect centerHelperViewRect = [[centerHelperViewLayer valueForKey:@&quot;frame&quot;] CGRectValue];</span><br><span class="line">    [self drawLoadLayerWithCenter:centerHelperViewRect.origin];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然我们能够获取到<code>centerHelperView</code>在不同时间里的位置，那么我们就可以根据它来绘制我们的曲线</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/loadingPoint.png!300x300" alt=""></p>
<p>我们可以看到左右两边都是直线，调用<code>- addLineToPoint</code>方法即可，重要的是底下这条线，我们获取到<code>centerHelperView</code>的位置后，暂且用<code>c</code>来表示，我们在绘制曲线时，需要用到<code>controlPoint1</code>和<code>controlPoint2</code>，那我们就把底下的线分为三段，并且以<code>c</code>为中心店，左边取出<code>l3</code>、<code>l2</code>、<code>l1</code>，右边取出<code>r3</code>、<code>r2</code>、<code>r1</code>，曲线分为三条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">[path moveToPoint:CGPointMake(0, 0)];</span><br><span class="line">[path addLineToPoint:l3];</span><br><span class="line">[path addCurveToPoint:l1 controlPoint1:l3 controlPoint2:l2];</span><br><span class="line">[path addCurveToPoint:r1 controlPoint1:l1 controlPoint2:c];</span><br><span class="line">[path addCurveToPoint:r3 controlPoint1:r1 controlPoint2:r2];</span><br><span class="line">[path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), 0)];</span><br></pre></td></tr></table></figure>
<p>果冻的曲线我们就完成了，然后我们就要开始对手势的状态来进行处理</p>
<p>在写控件调试的时候，你可以通过给目标视图添加<code>UIPanGestureRecognizer</code>，调用<code>- translationInView:</code>来获取到手指在屏幕上拖动时位置的变化，但是下拉刷新控件一般都是加在ScrollView上的，ScrollView自己是有一个只读的<code>UIPanGestureRecognizer</code>属性，所以我们不必自己再添加一个，我们只需要观察<code>UIPanGestureRecognizer</code>的<code>state</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.associatedScrollView addObserver:self forKeyPath:@&quot;panGestureRecognizer.state&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure>
<p>在取消拖动时，我们根据<code>ScrollView</code>的<code>contentOffset</code>来判断，是否是取消加载还是加载</p>
<h2 id="0x01-下拉进度圆圈的显示及旋转"><a href="#0x01-下拉进度圆圈的显示及旋转" class="headerlink" title="0x01 下拉进度圆圈的显示及旋转"></a>0x01 下拉进度圆圈的显示及旋转</h2><p>进度圆圈的显示主要是依赖于下拉的进度，然后改变<code>progress</code>，圆圈随之绘制就好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (contentOffset.y &lt; 0) &#123;</span><br><span class="line">    self.progress = MAX(0.0, MIN(fabs(contentOffset.y/kGCPullMaxDistance), 1.0));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    self.progress = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    UIBezierPath *circlePath = [UIBezierPath bezierPath];</span><br><span class="line">    [circlePath moveToPoint:CGPointMake(0, - kGCLoadingCircleRadius)];</span><br><span class="line">    [circlePath addArcWithCenter:CGPointMake(0, 0) radius:kGCLoadingCircleRadius startAngle:-M_PI/2 endAngle:((M_PI*17/9)*self.progess - M_PI/2) clockwise:YES];</span><br><span class="line">    </span><br><span class="line">    self.circleLayer.path = circlePath.CGPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>progress</code>达到1之后，就开始旋转动画了，这个我们使用<code>CABasicAnimation</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</span><br><span class="line">rotationAnimation.toValue = @(M_PI*2);</span><br><span class="line">rotationAnimation.beginTime = CACurrentMediaTime();</span><br><span class="line">rotationAnimation.duration = 1.0;</span><br><span class="line">rotationAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">rotationAnimation.repeatCount = HUGE_VALF;</span><br><span class="line">[self.circleLayer addAnimation:rotationAnimation forKey:nil];</span><br></pre></td></tr></table></figure>
<p>ok，大功告成~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个下拉控件是在&lt;a href=&quot;http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/?sukey=3997c0719f151520e178bb5175f11bfb983f5560c51261103fafb276bac79e1371d16e07ede0cca9f23d826405507a3c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Elastic view animation using UIBezierPath&lt;/a&gt;这篇博客上看到的，觉得效果还不错，自己也就OC简单实现了一下（原作者是用Swift写的），控件效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationTwo.gif!700x700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个控件的动画效果分为两个部分：&lt;/p&gt;
&lt;p&gt;1.下拉的果冻效果&lt;/p&gt;
&lt;p&gt;2.下拉进度圆圈的显示及旋转&lt;/p&gt;
    
    </summary>
    
    
      <category term="下拉刷新" scheme="http://yuzeyang.github.io/tags/%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>根据协议名获取所有代理方法</title>
    <link href="http://yuzeyang.github.io/2016/08/07/get-protocol-methods/"/>
    <id>http://yuzeyang.github.io/2016/08/07/get-protocol-methods/</id>
    <published>2016-08-07T00:34:59.000Z</published>
    <updated>2016-08-10T09:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为一直在用<a href="https://github.com/markohlebar/Peckham" target="_blank" rel="noopener">Peckham</a>这个插件，能够在编辑器的任意位置使用快捷键快速引用头文件，所以后来在想能不能也写一个类似的插件快速引入什么东西，细细一想平时自己在引用代理协议的时候，基本都是要跑到文件顶部添加好之后，再回到原来的位置继续写，如果有必须实现的代理方法没注意实现的话，可能又要回到implementation看warnings或者跳转到协议里面看哪些是必须实现，拷贝过来，粘贴到自己的实现里面，这样的操作实在是太麻烦了，所以我想可以写个插件，使用快捷键将必须实现的代理方法到implementation底部，这样对于开发者来说能避免很多不必要操作，也能快速明白哪些代理方法必须实现，好，接下来我来构思下怎么实现这个插件（但是后面这个实现出来的效果并不是很完美，所以还是放弃了…原因看更多）</p>
<a id="more"></a>
<p>1.在写完协议名之后，双击或者单击拖动选中协议名<br>2.使用快捷键，根据选中的协议名，查找协议里面的所有代理方法<br>3.再筛选出里面require标记的代理方法<br>4.将这些代理方法，添加到当前类的实现文件里面</p>
<p>我接下去讲的都是默认你已经了解了插件的配置以及调试</p>
<h2 id="选中协议名"><a href="#选中协议名" class="headerlink" title="选中协议名"></a>选中协议名</h2><p>首先我们在初始化bundle的时候，注册<code>NSTextViewDidChangeSelectionNotification</code>通知，<code>- selectString :</code>用来接收选中文本改变时通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(selectString:)</span><br><span class="line">name:NSTextViewDidChangeSelectionNotification object:nil];</span><br></pre></td></tr></table></figure>
<p>然后在接收方法里面，我们获取到当前操作的编辑页面<code>NSTextView</code>对象，然后获取到选中的<code>range</code>，取出选中的文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)selectString:(NSNotification *)notification &#123;</span><br><span class="line">    if ([notification.object isKindOfClass:[NSTextView class]]) &#123;</span><br><span class="line">        NSTextView* textView = (NSTextView *)notification.object;</span><br><span class="line">        NSArray* selectedRanges = [textView selectedRanges];</span><br><span class="line">        if (selectedRanges.count == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        NSRange selectedRange = [[selectedRanges objectAtIndex:0] rangeValue];</span><br><span class="line">        NSString* text = textView.textStorage.string;</span><br><span class="line">        self.selectedString = [text substringWithRange:selectedRange];</span><br><span class="line">        NSLog(@&quot;%s %@&quot;,__func__,self.selectedString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用快捷键，查找协议里面的所有代理方法"><a href="#使用快捷键，查找协议里面的所有代理方法" class="headerlink" title="使用快捷键，查找协议里面的所有代理方法"></a>使用快捷键，查找协议里面的所有代理方法</h2><p>快捷键的设置在增加<code>NSMenuItem</code>对象时就已经设置了，并且设置其快捷键为<code>^⎇G</code>，以及对应的<code>- searchProtocol:</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[menuItem submenu] addItem:[NSMenuItem separatorItem]];</span><br><span class="line">        </span><br><span class="line">NSMenuItem *protolMenuItem = [[NSMenuItem alloc] initWithTitle:@&quot;Protol Helper&quot; action:@selector(searchProtocol:) keyEquivalent:@&quot;g&quot;];</span><br><span class="line">[protolMenuItem setKeyEquivalentModifierMask:NSAlternateKeyMask|NSControlKeyMask];</span><br><span class="line">protolMenuItem.target = self;</span><br><span class="line">[[menuItem submenu] addItem:protolMenuItem];</span><br></pre></td></tr></table></figure>
<p>然后我们怎么查找到选中文本对应的协议和里面的代理方法呢？</p>
<p>我们先找怎么获取到代理方法，然后倒推回来，首先我们需要用到<code>runtime</code>，我们进到<code>runtime.h</code>里，通过搜索<code>protocol</code>关键字，我们找了<code>protocol_copyMethodDescriptionList</code>这个方法，<code>p</code>是一个<code>Protocol</code>对象，<code>isRequiredMethod</code>筛选是否是必须的方法，这样的话，我们就可以直接通过这个方法来获取必须实现的代理方法，<code>isInstanceMethod</code>筛选是否是实例方法，<code>outCount</code>这个表示返回方法的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount)</span><br><span class="line">     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);</span><br></pre></td></tr></table></figure>
<p><code>Protocol</code>对象我们可以通过<code>objc_getProtocol</code>方法，通过传入协议名来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *protocolName = self.selectedString.UTF8String;</span><br><span class="line">Protocol *protocol = objc_getProtocol(protocolName);</span><br></pre></td></tr></table></figure>
<p>然后我们开始调用<code>protocol_copyMethodDescriptionList</code>方法，打印出方法信息，这里我就先不管代码简洁性了，我拿<code>NSTextViewDelegate</code>来测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count = 999;</span><br><span class="line">struct objc_method_description *methods1;</span><br><span class="line">struct objc_method_description *methods2;</span><br><span class="line">struct objc_method_description *methods3;</span><br><span class="line">struct objc_method_description *methods4;</span><br><span class="line">methods1 = protocol_copyMethodDescriptionList(protocol, NO, YES, &amp;count);</span><br><span class="line">methods2 = protocol_copyMethodDescriptionList(protocol, NO, NO, &amp;count);</span><br><span class="line">methods3 = protocol_copyMethodDescriptionList(protocol, YES, YES, &amp;count);</span><br><span class="line">methods4 = protocol_copyMethodDescriptionList(protocol, YES, NO, &amp;count);</span><br><span class="line"></span><br><span class="line">if (methods1 != NULL) &#123;</span><br><span class="line">    NSLog(@&quot;---------------------methods1&quot;);</span><br><span class="line">    [self logMethods:methods1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (methods2 != NULL) &#123;</span><br><span class="line">    NSLog(@&quot;---------------------methods2&quot;);</span><br><span class="line">    [self logMethods:methods2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (methods3 != NULL) &#123;</span><br><span class="line">    NSLog(@&quot;---------------------methods3&quot;);</span><br><span class="line">    [self logMethods:methods3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (methods4 != NULL) &#123;</span><br><span class="line">    NSLog(@&quot;---------------------methods4&quot;);</span><br><span class="line">    [self logMethods:methods4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下打印的方法信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] ---------------------methods1</span><br><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:shouldChangeTextInRange:replacementString: c48@0:8@16&#123;_NSRange=QQ&#125;24@40</span><br><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:willChangeSelectionFromCharacterRange:toCharacterRange: &#123;_NSRange=QQ&#125;56@0:8@16&#123;_NSRange=QQ&#125;24&#123;_NSRange=QQ&#125;40</span><br><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textViewDidChangeSelection: v24@0:8@16</span><br><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:completions:forPartialWordRange:indexOfSelectedItem: @56@0:8@16@24&#123;_NSRange=QQ&#125;32^q48</span><br><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doCommandBySelector: c32@0:8@16:24</span><br><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnLink:atIndex: c40@0:8@16@24Q32</span><br><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnCell:inRect:atIndex: v72@0:8@16@24&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;32Q64</span><br><span class="line">2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doubleClickedOnCell:inRect:atIndex: v72@0:8@16@24&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;32Q64</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>what？方法名居然不是完整的，不是我们看到<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>这样的，但是想想也对，方法名应该是这样的，不包含参数名和参数类型，虽然参数类型可以通过<code>objc_method_description</code>结构体里面<code>types</code>拿到，但是参数名怎么办…我总不能用abc来代替吧，虽然做是可以做，但是用起来还是要改参数名，这不是很麻烦…感觉在这里遇到瓶颈了</p>
<p>然后我想看到<code>objc_class</code>结构体里面也有存放协议信息，那他里面是怎么样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_protocol_list &#123;</span><br><span class="line">    struct objc_protocol_list *next;</span><br><span class="line">    long count;</span><br><span class="line">    Protocol *list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Protocol : Object</span><br><span class="line">&#123;</span><br><span class="line">@private</span><br><span class="line">    char *protocol_name OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocol_list OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_description_list *instance_methods OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_description_list *class_methods OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method_description_list &#123;</span><br><span class="line">        int count;</span><br><span class="line">        struct objc_method_description list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method_description &#123;</span><br><span class="line">	SEL name;               /**&lt; The name of the method */</span><br><span class="line">	char *types;            /**&lt; The types of the method arguments */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过一系列的查找，我们又回到了<code>objc_method_description</code>，what？这<code>objc_class</code>最终拿到的数据还是从<code>objc_method_description</code>来的，那就是说明我们没有办法直接获得<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>….这样就不能达到我们所预期的那样了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以通过<code>protocol_copyMethodDescriptionList</code>方法获取到协议里面所有的代理方法，分为方法名和类型，但是不能获取到<code>- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;</code>这样的，如果用a，b，c这样的来填充参数名，这样在使用起来，使用方还要自己再替换参数名，这样会比较麻烦，解决不了我们的需求，gg…..</p>
<p>2016年8月10日补充：</p>
<p>后来西兰花提出说根据协议名称去爬开发文档上相关的代理方法或者找本地开发包里面的相关头文件，不考虑是否可行，但是有个共同的问题是只能获取到官方的，自己创建的不行，而且前者没有require标记</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为一直在用&lt;a href=&quot;https://github.com/markohlebar/Peckham&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Peckham&lt;/a&gt;这个插件，能够在编辑器的任意位置使用快捷键快速引用头文件，所以后来在想能不能也写一个类似的插件快速引入什么东西，细细一想平时自己在引用代理协议的时候，基本都是要跑到文件顶部添加好之后，再回到原来的位置继续写，如果有必须实现的代理方法没注意实现的话，可能又要回到implementation看warnings或者跳转到协议里面看哪些是必须实现，拷贝过来，粘贴到自己的实现里面，这样的操作实在是太麻烦了，所以我想可以写个插件，使用快捷键将必须实现的代理方法到implementation底部，这样对于开发者来说能避免很多不必要操作，也能快速明白哪些代理方法必须实现，好，接下来我来构思下怎么实现这个插件（但是后面这个实现出来的效果并不是很完美，所以还是放弃了…原因看更多）&lt;/p&gt;
    
    </summary>
    
    
      <category term="协议方法" scheme="http://yuzeyang.github.io/tags/%E5%8D%8F%E8%AE%AE%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>加载动画分析</title>
    <link href="http://yuzeyang.github.io/2016/07/27/loadingAnimation-0727/"/>
    <id>http://yuzeyang.github.io/2016/07/27/loadingAnimation-0727/</id>
    <published>2016-07-27T14:49:19.000Z</published>
    <updated>2016-08-15T15:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写动画了…最近扒了下以前没有写的动画效果，想想从最老的开始写吧，之前看到的版本是用Swift写的，没仔细找有没有OC版的，所以干脆自己练习一下吧，我们先来看看效果：</p>
<p>(这里三角形是旋转动画，但是Gif录出来看上去是抖了两下…)</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationOne.gif!500x500" alt=""></p>
<p>可以直接run下代码，看下效果：<a href="https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne" target="_blank" rel="noopener">https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne</a></p>
<p>下面我来分析下过程</p>
<a id="more"></a>
<p>这个动画的实现只用到了<code>UIBezierPath</code>、<code>CABasicAnimation</code>和<code>CALayer</code></p>
<p>从Gif里面可以看到这个动画分为以下几个步骤：</p>
<p>1.从无到圆</p>
<p>2.圆x轴方向拉伸和y轴方向拉伸</p>
<p>3.“长出”三角形的三个角</p>
<p>4.三角形旋转</p>
<p>5.画两条边框</p>
<p>6.水面上涨动画</p>
<p>7.中间矩形放大至全屏</p>
<p>8.中间logo跟着出现</p>
<h2 id="0x00-从无到圆"><a href="#0x00-从无到圆" class="headerlink" title="0x00 从无到圆"></a>0x00 从无到圆</h2><p>这个比较简单，只要设定起始的size为0和设定默认圆半径大小，用<code>+ bezierPathWithOvalInRect:</code>方法画圆<code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *startPath = [self circleStartPath];</span><br><span class="line">UIBezierPath *endPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2, GCCircleRadius*2)];</span><br></pre></td></tr></table></figure>
<p>将最后圆的<code>path</code>设为<code>circleLayer</code>的<code>path</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.circleLayer = [CAShapeLayer layer];</span><br><span class="line">self.circleLayer.path = endPath.CGPath;</span><br><span class="line">self.circleLayer.fillColor = [UIColor orangeColor].CGColor;</span><br><span class="line">[self addSublayer:self.circleLayer];</span><br></pre></td></tr></table></figure>
<p>然后加上动画，因为我们修改的是<code>path</code>，所以我们<code>animation</code>的<code>keyPath</code>是<code>path</code>（后面也是），设定起始值为<code>startPath.CGPath</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *circleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</span><br><span class="line">circleAnimation.fromValue = (__bridge id _Nullable)(startPath.CGPath);</span><br><span class="line">circleAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">circleAnimation.duration = 0.2f;</span><br><span class="line">circleAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">circleAnimation.delegate = self;</span><br><span class="line">circleAnimation.removedOnCompletion = NO;</span><br><span class="line">[circleAnimation setValue:@&quot;circleAnimation&quot; forKey:@&quot;animationName&quot;];</span><br><span class="line">[self.circleLayer addAnimation:circleAnimation forKey:nil];</span><br></pre></td></tr></table></figure>
<h2 id="0x01-圆x轴方向拉伸和y轴方向拉伸"><a href="#0x01-圆x轴方向拉伸和y轴方向拉伸" class="headerlink" title="0x01 圆x轴方向拉伸和y轴方向拉伸"></a>0x01 圆x轴方向拉伸和y轴方向拉伸</h2><p>这里我们的<code>keyPath</code>不用<code>transform.scale.x/y</code>，因为缩放之后，圆心会改变，看上去有偏移，这样动画写起来更复杂，所以我们干脆直接用拉伸后的<code>path</code>来做动画</p>
<p>创建x轴、y轴拉伸后的<code>path</code>，然后加到<code>animation</code>里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *scaleXPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius*1.1, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2.2, GCCircleRadius*2)];</span><br><span class="line">UIBezierPath *scaleYPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius*1.1, GCCircleRadius*2, GCCircleRadius*2.2)];</span><br><span class="line"></span><br><span class="line">CABasicAnimation *circleScaleXOneAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</span><br><span class="line">circleScaleXOneAnimation.fromValue = (__bridge id _Nullable)(self.circleLayer.path);</span><br><span class="line">circleScaleXOneAnimation.toValue = (__bridge id _Nullable)(scaleXPath.CGPath);</span><br><span class="line">circleScaleXOneAnimation.duration = 0.2f;</span><br><span class="line">circleScaleXOneAnimation.beginTime = 0.0;</span><br></pre></td></tr></table></figure>
<p>一共四个<code>CABasicAnimation</code>对象，然后我们将这些动画加到<code>CAAnimationGroup</code>里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CAAnimationGroup *animationGroup = [CAAnimationGroup animation];</span><br><span class="line">animationGroup.animations = @[circleScaleXOneAnimation,circleScaleXTwoAnimation,circleScaleYOneAnimation,circleScaleYTwoAnimation];</span><br><span class="line">animationGroup.duration = circleScaleYTwoAnimation.beginTime + circleScaleYTwoAnimation.duration;</span><br><span class="line">animationGroup.delegate = self;</span><br><span class="line">[animationGroup setValue:@&quot;circleScaleAnimation&quot; forKey:@&quot;animationName&quot;];</span><br><span class="line">[self.circleLayer addAnimation:animationGroup forKey:nil];</span><br></pre></td></tr></table></figure>
<h2 id="0x02-“长出”三角形的三个角"><a href="#0x02-“长出”三角形的三个角" class="headerlink" title="0x02 “长出”三角形的三个角"></a>0x02 “长出”三角形的三个角</h2><p>实际上三角形在等到圆形出现或者圆形拉伸完之后就已经在那了，“长出角”的感觉实际上只是改变了绘制的三个点的位置，首先我们根据圆的半径画出三角形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *originTrianglePath = [UIBezierPath bezierPath];</span><br><span class="line">[originTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.0]];</span><br><span class="line">[originTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];</span><br><span class="line">[originTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];</span><br><span class="line">[originTrianglePath closePath];</span><br><span class="line"></span><br><span class="line">self.triangleLayer = [CAShapeLayer layer];</span><br><span class="line">self.triangleLayer.path = originTrianglePath.CGPath;</span><br><span class="line">self.triangleLayer.fillColor = [UIColor orangeColor].CGColor;</span><br><span class="line">[self addSublayer:self.triangleLayer];</span><br></pre></td></tr></table></figure>
<p>然后改变左边点的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *blowUpLeftTrianglePath = [UIBezierPath bezierPath];</span><br><span class="line">[blowUpLeftTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.2]];</span><br><span class="line">[blowUpLeftTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];</span><br><span class="line">[blowUpLeftTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];</span><br><span class="line">[blowUpLeftTrianglePath closePath];</span><br></pre></td></tr></table></figure>
<p>也加上<code>path</code>的动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *blowUpLeftAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</span><br><span class="line">blowUpLeftAnimation.fromValue = (__bridge id _Nullable)(self.triangleLayer.path);</span><br><span class="line">blowUpLeftAnimation.toValue = (__bridge id _Nullable)(blowUpLeftTrianglePath.CGPath);</span><br><span class="line">blowUpLeftAnimation.duration = 0.2f;</span><br><span class="line">blowUpLeftAnimation.beginTime = 0.0;</span><br></pre></td></tr></table></figure>
<p>右边和上边的点同理，然后也一起加到<code>CAAnimationGroup</code>里</p>
<h2 id="0x03-三角形旋转"><a href="#0x03-三角形旋转" class="headerlink" title="0x03 三角形旋转"></a>0x03 三角形旋转</h2><p>旋转就比较简单了，只要根据z轴旋转设定的角度即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *rotationAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</span><br><span class="line">rotationAniamtion.toValue = @(M_PI*2);</span><br><span class="line">rotationAniamtion.duration = 0.4;</span><br><span class="line">rotationAniamtion.fillMode = kCAFillModeForwards;</span><br><span class="line">rotationAniamtion.delegate = self;</span><br><span class="line">rotationAniamtion.beginTime = CACurrentMediaTime();</span><br><span class="line">[rotationAniamtion setValue:@&quot;rotationAniamtion&quot; forKey:@&quot;animationName&quot;];</span><br><span class="line">[self.triangleLayer addAnimation:rotationAniamtion forKey:nil];</span><br></pre></td></tr></table></figure>
<h2 id="0x04-画两条边框"><a href="#0x04-画两条边框" class="headerlink" title="0x04 画两条边框"></a>0x04 画两条边框</h2><p>这两个边框绘制方法是一模一样的，只是中间有个时间间隔而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (CABasicAnimation *)drawRectWithLineColor:(CGColorRef)color animationValue:(NSString *)animationValue &#123;</span><br><span class="line">    CGPoint startPoint = [self triangleLeftPointWithScale:1.2];</span><br><span class="line">    UIBezierPath *rectPath = [UIBezierPath bezierPath];</span><br><span class="line">    [rectPath moveToPoint:startPoint];</span><br><span class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x, startPoint.y - GCCircleRadius*2.4)];</span><br><span class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - GCCircleRadius*2.4)];</span><br><span class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - 2)];</span><br><span class="line">    [rectPath addLineToPoint:CGPointMake(startPoint.x - 2.5, startPoint.y - 2)];</span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *layer = [CAShapeLayer layer];</span><br><span class="line">    layer.path = rectPath.CGPath;</span><br><span class="line">    layer.lineWidth = 5;</span><br><span class="line">    layer.strokeColor = color;</span><br><span class="line">    layer.fillColor = [UIColor clearColor].CGColor;</span><br><span class="line">    [self addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    CABasicAnimation *rectAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</span><br><span class="line">    rectAniamtion.fromValue = @(0.0);</span><br><span class="line">    rectAniamtion.toValue = @(1.0);</span><br><span class="line">    rectAniamtion.duration = 0.8;</span><br><span class="line">    rectAniamtion.delegate = self;</span><br><span class="line">    if (animationValue.length) &#123;</span><br><span class="line">        [rectAniamtion setValue:@&quot;rectAniamtion&quot; forKey:@&quot;animationName&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    [layer addAnimation:rectAniamtion forKey:nil];</span><br><span class="line">    </span><br><span class="line">    return rectAniamtion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>间隔的话，我们直接调用<code>- performSelector: withObject: afterDelay:</code>来延迟执行第二条边框的绘制就好</p>
<h2 id="0x05-水面上涨动画"><a href="#0x05-水面上涨动画" class="headerlink" title="0x05 水面上涨动画"></a>0x05 水面上涨动画</h2><p>这个动画的关键就是用<code>- addCurveToPoint: controlPoint1: controlPoint2:</code>方法来画出水波的线，这个方法主要是利用<code>controlPoint1</code>和<code>controlPoint2</code>这两个点来控制弧度方向，如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/addCurveToPoint.png" alt=""></p>
<p>然后我们只需要交叉改变<code>controlPoint1</code>和<code>controlPoint2</code>这两个点在上下的位置和<code>startPoint</code>和<code>endPoint</code>的位置，就能感觉水面上涨的感觉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray &lt;UIBezierPath *&gt; *waterPathArray = [NSMutableArray array];</span><br><span class="line">for (NSInteger i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">    UIBezierPath *water = [self water:i % 2 == 0 ? YES : NO withProgress:0.1*i];</span><br><span class="line">    [waterPathArray addObject:water];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完毕<code>path</code>之后，将<code>anmations</code>放到<code>CAAnimationGroup</code>里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)addWaterAnimation:(NSMutableArray &lt;UIBezierPath *&gt; *)waterArray &#123;</span><br><span class="line">    NSMutableArray &lt;CABasicAnimation *&gt; *animationArray = [NSMutableArray array];</span><br><span class="line">    for (NSInteger i = 0; i &lt; waterArray.count - 1; i++) &#123;</span><br><span class="line">        CABasicAnimation *waterAniamtion = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</span><br><span class="line">        waterAniamtion.fromValue = (__bridge id _Nullable)(waterArray[i].CGPath);</span><br><span class="line">        waterAniamtion.toValue = (__bridge id _Nullable)(waterArray[i + 1].CGPath);</span><br><span class="line">        waterAniamtion.duration = 0.2;</span><br><span class="line">        waterAniamtion.beginTime = i == 0 ? 0.0 : animationArray[i - 1].beginTime + animationArray[i - 1].duration;</span><br><span class="line">        [animationArray addObject:waterAniamtion];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line">    group.animations = animationArray;</span><br><span class="line">    group.duration = [animationArray lastObject].beginTime + [animationArray lastObject].duration;</span><br><span class="line">    group.fillMode = kCAFillModeForwards;</span><br><span class="line">    group.removedOnCompletion = NO;</span><br><span class="line">    group.delegate = self;</span><br><span class="line">    [group setValue:@&quot;waterAnimation&quot; forKey:@&quot;animationName&quot;];</span><br><span class="line">    [self.waterLayer addAnimation:group forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x06-中间矩形放大至全屏"><a href="#0x06-中间矩形放大至全屏" class="headerlink" title="0x06 中间矩形放大至全屏"></a>0x06 中间矩形放大至全屏</h2><p>和前面一样，创建好全屏大小的<code>path</code>之后，然后加上动画即可</p>
<h2 id="0x07-中间logo跟着出现"><a href="#0x07-中间logo跟着出现" class="headerlink" title="0x07 中间logo跟着出现"></a>0x07 中间logo跟着出现</h2><p>这个改变<code>bounds</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CALayer *logoLayer = [CALayer layer];</span><br><span class="line">logoLayer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;logo.jpg&quot;].CGImage);</span><br><span class="line"></span><br><span class="line">logoLayer.frame = CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 0, 0);</span><br><span class="line">[self addSublayer:logoLayer];</span><br><span class="line"></span><br><span class="line">CABasicAnimation *logoAnimation = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;];</span><br><span class="line">logoAnimation.toValue = [NSValue valueWithCGRect:CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 100, 120)];</span><br><span class="line">logoAnimation.duration = 0.2;</span><br><span class="line">logoAnimation.beginTime = 0.0;</span><br><span class="line">logoAnimation.removedOnCompletion = NO;</span><br><span class="line">logoAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">[logoLayer addAnimation:logoAnimation forKey:nil];</span><br></pre></td></tr></table></figure>
<p>这个加载动画的缺点就是在加载时没有可定制化的形状，只能修改圆形等的颜色，如果要改变形状，可能会涉及到动效的改动，所以这个动画只能作为学习分析参考</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写动画了…最近扒了下以前没有写的动画效果，想想从最老的开始写吧，之前看到的版本是用Swift写的，没仔细找有没有OC版的，所以干脆自己练习一下吧，我们先来看看效果：&lt;/p&gt;
&lt;p&gt;(这里三角形是旋转动画，但是Gif录出来看上去是抖了两下…)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationOne.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以直接run下代码，看下效果：&lt;a href=&quot;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我来分析下过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="加载动画" scheme="http://yuzeyang.github.io/tags/%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>FMDB初探（二）</title>
    <link href="http://yuzeyang.github.io/2016/07/23/FMDB-two/"/>
    <id>http://yuzeyang.github.io/2016/07/23/FMDB-two/</id>
    <published>2016-07-23T08:38:23.000Z</published>
    <updated>2016-07-23T10:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>FMResultSet</code>用来执行SQL语句结果的查询</p>
<p><code>FMDatabaseQueue</code>用不同的线程来执行若干个查询和更新操作</p>
<p><code>FMDatabasePool</code>和<code>FMDatabaseQueue</code>类似，但是只是用在数据库只读操作上</p>
<a id="more"></a>
<h2 id="FMResultSet"><a href="#FMResultSet" class="headerlink" title="FMResultSet"></a>FMResultSet</h2><p>主要是根据<code>columnName</code>列名/<code>columnIdx</code>列索引获取到相应数据格式的数据，以及使用<code>- next</code>方法，将查询结果逐行输入</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)resultSetWithStatement:(FMStatement *)statement usingParentDatabase:(FMDatabase*)aDB &#123;</span><br><span class="line">    // 初始化FMResultSet对象</span><br><span class="line">    FMResultSet *rs = [[FMResultSet alloc] init];</span><br><span class="line">    // 设置prepared语句和db</span><br><span class="line">    [rs setStatement:statement];</span><br><span class="line">    [rs setParentDB:aDB];</span><br><span class="line">    // 设置prepared语句正在使用</span><br><span class="line">    NSParameterAssert(![statement inUse]);</span><br><span class="line">    [statement setInUse:YES]; // weak reference</span><br><span class="line">    </span><br><span class="line">    return FMDBReturnAutoreleased(rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><p>返回结果的数据类型有很多种：除了基本数据类型之外，还有<code>NSString</code>、<code>NSDate</code>、<code>NSData</code></p>
<p>比如以下两个接口<code>- intForColumn:</code>实际上调用的还是<code>- intForColumnIndex:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (int)intForColumn:(NSString*)columnName &#123;</span><br><span class="line">    return [self intForColumnIndex:[self columnIndexForName:columnName]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)intForColumnIndex:(int)columnIdx &#123;</span><br><span class="line">    return sqlite3_column_int([_statement statement], columnIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>- columnIndexForName:</code>方法，用列名来获得列索引，这层映射关系都是存在<code>_columnNameToIndexMap</code>字典里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (int)columnIndexForName:(NSString*)columnName &#123;</span><br><span class="line">    columnName = [columnName lowercaseString];</span><br><span class="line">    </span><br><span class="line">    NSNumber *n = [[self columnNameToIndexMap] objectForKey:columnName];</span><br><span class="line">    </span><br><span class="line">    if (n) &#123;</span><br><span class="line">        return [n intValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;Warning: I could not find the column named &apos;%@&apos;.&quot;, columnName);</span><br><span class="line">    </span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableDictionary *)columnNameToIndexMap &#123;</span><br><span class="line">    if (!_columnNameToIndexMap) &#123;</span><br><span class="line">        int columnCount = sqlite3_column_count([_statement statement]);</span><br><span class="line">        _columnNameToIndexMap = [[NSMutableDictionary alloc] initWithCapacity:(NSUInteger)columnCount];</span><br><span class="line">        int columnIdx = 0;</span><br><span class="line">        for (columnIdx = 0; columnIdx &lt; columnCount; columnIdx++) &#123;</span><br><span class="line">            // 列名作为key，对应的列号作为value</span><br><span class="line">            [_columnNameToIndexMap setObject:[NSNumber numberWithInt:columnIdx]</span><br><span class="line">                                      forKey:[[NSString stringWithUTF8String:sqlite3_column_name([_statement statement], columnIdx)] lowercaseString]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _columnNameToIndexMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逐行返回结果"><a href="#逐行返回结果" class="headerlink" title="逐行返回结果"></a>逐行返回结果</h4><p><code>- next</code>方法本质是调用<code>- nextWithError</code>，<code>FMDB</code>里面有的注释写的还是挺逗的，连<code>wtf</code>都有…哈哈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)nextWithError:(NSError **)outErr &#123;</span><br><span class="line">    /* Call sqlite3_step() to run the virtual machine. Since the SQL being</span><br><span class="line">     ** executed is not a SELECT statement, we assume no data will be returned.</span><br><span class="line">     */</span><br><span class="line">    // sqlite3_prepare函数将SQL命令字符串解析并转换为一系列的命令字节码，这些字节码最终被传送到SQlite3的虚拟数据库引擎（VDBE: Virtual Database Engine）中执行，完成这项工作的是sqlite3_step函数。比如一个SELECT查询操作，sqlite3_step函数的每次调用都会返回结果集中的其中一行，直到再没有有效数据行了。每次调用sqlite3_step函数如果返回SQLITE_ROW，代表获得了有效数据行，可以通过sqlite3_column函数提取某列的值。如果调用sqlite3_step函数返回SQLITE_DONE，则代表prepared语句已经执行到终点了，没有有效数据了。很多命令第一次调用sqlite3_step函数就会返回SQLITE_DONE，因为这些SQL命令不会返回数据。对于INSERT，UPDATE，DELETE命令，会返回它们所修改的行号——一个单行单列的值。</span><br><span class="line">    /**</span><br><span class="line">     SQLITE_BUSY 数据库文件有锁</span><br><span class="line">     SQLITE_LOCKED 数据库中的某张表有锁</span><br><span class="line">     SQLITE_DONE sqlite3_step()执行完毕</span><br><span class="line">     SQLITE_ROW sqlite3_step()获取到下一行数据</span><br><span class="line">     SQLITE_ERROR 一般用于没有特别指定错误码的错误，就是说函数在执行过程中发生了错误，但无法知道错误发生的原因。</span><br><span class="line">     SQLITE_MISUSE 没有正确使用SQLite接口，比如一条语句在sqlite3_step函数执行之后，没有被重置之前，再次给其绑定参数，这时bind函数就会返回SQLITE_MISUSE。</span><br><span class="line">     **/</span><br><span class="line">    int rc = sqlite3_step([_statement statement]);</span><br><span class="line">    </span><br><span class="line">    if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &#123;</span><br><span class="line">        NSLog(@&quot;%s:%d Database busy (%@)&quot;, __FUNCTION__, __LINE__, [_parentDB databasePath]);</span><br><span class="line">        NSLog(@&quot;Database busy&quot;);</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [_parentDB lastError];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (SQLITE_DONE == rc || SQLITE_ROW == rc) &#123;</span><br><span class="line">        // all is well, let&apos;s return.</span><br><span class="line">    &#125;</span><br><span class="line">    else if (SQLITE_ERROR == rc) &#123;</span><br><span class="line">        NSLog(@&quot;Error calling sqlite3_step (%d: %s) rs&quot;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [_parentDB lastError];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (SQLITE_MISUSE == rc) &#123;</span><br><span class="line">        // uh oh.</span><br><span class="line">        NSLog(@&quot;Error calling sqlite3_step (%d: %s) rs&quot;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            if (_parentDB) &#123;</span><br><span class="line">                *outErr = [_parentDB lastError];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // If &apos;next&apos; or &apos;nextWithError&apos; is called after the result set is closed,</span><br><span class="line">                // we need to return the appropriate error.</span><br><span class="line">                NSDictionary* errorMessage = [NSDictionary dictionaryWithObject:@&quot;parentDB does not exist&quot; forKey:NSLocalizedDescriptionKey];</span><br><span class="line">                *outErr = [NSError errorWithDomain:@&quot;FMDatabase&quot; code:SQLITE_MISUSE userInfo:errorMessage];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // wtf?</span><br><span class="line">        NSLog(@&quot;Unknown error calling sqlite3_step (%d: %s) rs&quot;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [_parentDB lastError];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (rc != SQLITE_ROW) &#123;</span><br><span class="line">        [self close];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (rc == SQLITE_ROW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while ([rs next]) &#123;</span><br><span class="line">    NSString *file = [rs stringForColumn:@&quot;file&quot;];</span><br><span class="line">    NSLog(@&quot;database_list: %@&quot;, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FMDatabaseQueue"><a href="#FMDatabaseQueue" class="headerlink" title="FMDatabaseQueue"></a>FMDatabaseQueue</h2><p>是用来多线程并行执行SQL语句</p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>头文件里提供了很多种初始化方法，但是最终调用的还是<code>(instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags vfs:(NSString *)vfsName</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags vfs:(NSString *)vfsName &#123;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    if (self != nil) &#123;</span><br><span class="line">        // 根据指定路径寻找数据库，如果已存在则返回db，不存在则创建</span><br><span class="line">        _db = [[[self class] databaseClass] databaseWithPath:aPath];</span><br><span class="line">        FMDBRetain(_db);</span><br><span class="line">        </span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3005000</span><br><span class="line">        BOOL success = [_db openWithFlags:openFlags vfs:vfsName];</span><br><span class="line">#else</span><br><span class="line">        BOOL success = [_db open];</span><br><span class="line">#endif</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            NSLog(@&quot;Could not create database queue for path %@&quot;, aPath);</span><br><span class="line">            FMDBRelease(self);</span><br><span class="line">            return 0x00;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _path = FMDBReturnRetained(aPath);</span><br><span class="line">        // 创建串行队列</span><br><span class="line">        _queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);</span><br><span class="line">        // 给_queue队列指定了kDispatchQueueSpecificKey字符串，并和self绑定，后面可以通过kDispatchQueueSpecificKey获取到self，但要保证正在执行的队列是这个_queue</span><br><span class="line">        dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);</span><br><span class="line">        _openFlags = openFlags;</span><br><span class="line">        _vfsName = [vfsName copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:dbPath];</span><br></pre></td></tr></table></figure>
<h4 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h4><p>想要多线程操作数据库时，不是直接使用<code>FMDatabase</code>对象，而是通过<code>FMDatabaseQueue</code>对象，调用<code>- inDatabas:</code>，通过<code>block</code>返回<code>FMDatabase</code>对象来操作，虽然<code>- inDatabas:</code>内是同步操作，但是线程之间是并行的，就相当于马路上有两条单行的路，虽然每条路上的车都是一辆接一辆的，但是两条路之间是互不影响的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)inDatabase:(void (^)(FMDatabase *db))block &#123;</span><br><span class="line">    // 通过kDispatchQueueSpecificKey来获取当前正在执行的队列，并且检查和self做比较，确保没有发生死锁，因为可以创建多个FMDatabaseQueue多个来执行不同的SQL语句</span><br><span class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);</span><br><span class="line">    assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);</span><br><span class="line">    </span><br><span class="line">    FMDBRetain(self);</span><br><span class="line">    // 在当前queue中，同步执行block</span><br><span class="line">    dispatch_sync(_queue, ^() &#123;</span><br><span class="line">        </span><br><span class="line">        FMDatabase *db = [self database];</span><br><span class="line">        block(db);</span><br><span class="line">        </span><br><span class="line">        if ([db hasOpenResultSets]) &#123;</span><br><span class="line">            NSLog(@&quot;Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]&quot;);</span><br><span class="line">            </span><br><span class="line">#if defined(DEBUG) &amp;&amp; DEBUG</span><br><span class="line">            NSSet *openSetCopy = FMDBReturnAutoreleased([[db valueForKey:@&quot;_openResultSets&quot;] copy]);</span><br><span class="line">            for (NSValue *rsInWrappedInATastyValueMeal in openSetCopy) &#123;</span><br><span class="line">                FMResultSet *rs = (FMResultSet *)[rsInWrappedInATastyValueMeal pointerValue];</span><br><span class="line">                NSLog(@&quot;query: &apos;%@&apos;&quot;, [rs query]);</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    FMDBRelease(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[queue inDatabase:^(FMDatabase *adb) &#123;</span><br><span class="line">    [adb executeUpdate:@&quot;create table qfoo (foo text)&quot;];</span><br><span class="line">    [adb executeUpdate:@&quot;insert into qfoo values (&apos;hi&apos;)&quot;];</span><br><span class="line">    [adb executeUpdate:@&quot;insert into qfoo values (&apos;hello&apos;)&quot;];</span><br><span class="line">    [adb executeUpdate:@&quot;insert into qfoo values (&apos;not&apos;)&quot;];</span><br><span class="line"></span><br><span class="line">	int count = 0;</span><br><span class="line">    FMResultSet *rsl = [adb executeQuery:@&quot;select * from qfoo where foo like &apos;h%&apos;&quot;];</span><br><span class="line">    while ([rsl next]) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FMDBQuickCheck(count == 2);</span><br><span class="line"></span><br><span class="line">    count = 0;</span><br><span class="line">    rsl = [adb executeQuery:@&quot;select * from qfoo where foo like ?&quot;, @&quot;h%&quot;];</span><br><span class="line">    while ([rsl next]) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FMDBQuickCheck(count == 2);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h4><p>和<code>FMDatabase</code>一样，也有事务的处理，分为exclusive事务和deferred事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)inDeferredTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block &#123;</span><br><span class="line">    [self beginTransaction:YES withBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)inTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block &#123;</span><br><span class="line">    [self beginTransaction:NO withBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)beginTransaction:(BOOL)useDeferred withBlock:(void (^)(FMDatabase *db, BOOL *rollback))block &#123;</span><br><span class="line">    FMDBRetain(self);</span><br><span class="line">    dispatch_sync(_queue, ^() &#123; </span><br><span class="line">        </span><br><span class="line">        BOOL shouldRollback = NO;</span><br><span class="line">        // 是否使用延迟事务</span><br><span class="line">        if (useDeferred) &#123;</span><br><span class="line">            [[self database] beginDeferredTransaction];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [[self database] beginTransaction];</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果数据库操作出错了，你可以设置是否需要回滚，回滚到操作之前的内容</span><br><span class="line">        block([self database], &amp;shouldRollback);</span><br><span class="line">        </span><br><span class="line">        if (shouldRollback) &#123;</span><br><span class="line">            [[self database] rollback];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果不需要回滚，则commit提交相应的sql操作</span><br><span class="line">            [[self database] commit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    FMDBRelease(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[queue inTransaction:^(FMDatabase *adb, BOOL *rollback) &#123;</span><br><span class="line">    NSLog(@&quot;Starting query  %ld&quot;, nby);</span><br><span class="line"></span><br><span class="line">    FMResultSet *rsl = [adb executeQuery:@&quot;select * from qfoo where foo like &apos;h%&apos;&quot;];</span><br><span class="line">    while ([rsl next]) &#123;</span><br><span class="line">        ;// whatever.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;Ending query    %ld&quot;, nby);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="FMDatabasePool"><a href="#FMDatabasePool" class="headerlink" title="FMDatabasePool"></a>FMDatabasePool</h2><blockquote>
<p>If you really really really know what you’re doing and <code>FMDatabasePool</code> is what  you really really need (ie, you’re using a read only database), OK you can use it.  But just be careful not to deadlock!</p>
</blockquote>
<p>对，这就是<code>FMDatabasePool</code>的描述，只能用于数据库只读操作，如果进行了写操作，很有可能会出现死锁，乱用搞不好就跪了…</p>
<p>里面的方法基本和<code>FMDatabaseQueue</code>差不多，里面有两个特别的属性：<code>_databaseInPool</code>和<code>_databaseOutPool</code>，按我的理解，这两个属性的作用就像是一个用来存放闲置的db，一个是用来存放正在执行操作的db，在<code>- inDatabase:</code>等这些方法最后都调用了<code>- pushDatabaseBackInPool:</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 将db放回InPool里面</span><br><span class="line">- (void)pushDatabaseBackInPool:(FMDatabase*)db &#123;</span><br><span class="line">    </span><br><span class="line">    if (!db) &#123; // db can be null if we set an upper bound on the # of databases to create.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 同步执行</span><br><span class="line">    [self executeLocked:^() &#123;</span><br><span class="line">        // 如果InPool数组里面包含db，说明db已经在InPool里面，不需要再放回InPool里，并且抛出异常，下面的操作就不进行了</span><br><span class="line">        if ([self-&gt;_databaseInPool containsObject:db]) &#123;</span><br><span class="line">            [[NSException exceptionWithName:@&quot;Database already in pool&quot; reason:@&quot;The FMDatabase being put back into the pool is already present in the pool&quot; userInfo:nil] raise];</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果db不在InPool里面，把db加到InPool数组，并且从OutPool中移除</span><br><span class="line">        [self-&gt;_databaseInPool addObject:db];</span><br><span class="line">        [self-&gt;_databaseOutPool removeObject:db];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FMDatabase*)db &#123;</span><br><span class="line">    </span><br><span class="line">    __block FMDatabase *db;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [self executeLocked:^() &#123;</span><br><span class="line">        // 从_databaseInPool里面取出最后一个FMDatabase对象</span><br><span class="line">        db = [self-&gt;_databaseInPool lastObject];</span><br><span class="line">        </span><br><span class="line">        BOOL shouldNotifyDelegate = NO;</span><br><span class="line">        // 如果db存在，则加到_databaseOutPool里，_databaseInPool移除掉，我的理解是_databaseOutPool是用于存放正在执行操作的db池，_databaseInPool则存放闲置的db池</span><br><span class="line">        // 在需要使用的时候，从闲置的池里面取出来放到正在执行的池里面</span><br><span class="line">        if (db) &#123;</span><br><span class="line">            [self-&gt;_databaseOutPool addObject:db];</span><br><span class="line">            [self-&gt;_databaseInPool removeLastObject];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 检查最大创建的db数量，超过了则返回，否则就根据路径，找到db</span><br><span class="line">            if (self-&gt;_maximumNumberOfDatabasesToCreate) &#123;</span><br><span class="line">                NSUInteger currentCount = [self-&gt;_databaseOutPool count] + [self-&gt;_databaseInPool count];</span><br><span class="line">                </span><br><span class="line">                if (currentCount &gt;= self-&gt;_maximumNumberOfDatabasesToCreate) &#123;</span><br><span class="line">                    NSLog(@&quot;Maximum number of databases (%ld) has already been reached!&quot;, (long)currentCount);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            db = [[[self class] databaseClass] databaseWithPath:self-&gt;_path];</span><br><span class="line">            shouldNotifyDelegate = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据_openFlags和_vfsName打开db</span><br><span class="line">        //This ensures that the db is opened before returning</span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3005000</span><br><span class="line">        BOOL success = [db openWithFlags:self-&gt;_openFlags vfs:self-&gt;_vfsName];</span><br><span class="line">#else</span><br><span class="line">        BOOL success = [db open];</span><br><span class="line">#endif</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            // 如果代理方法响应了，但是db不允许被加到pool里面，那么db关闭释放</span><br><span class="line">            if ([self-&gt;_delegate respondsToSelector:@selector(databasePool:shouldAddDatabaseToPool:)] &amp;&amp; ![self-&gt;_delegate databasePool:self shouldAddDatabaseToPool:db]) &#123;</span><br><span class="line">                [db close];</span><br><span class="line">                db = 0x00;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //It should not get added in the pool twice if lastObject was found</span><br><span class="line">                // 对于新创建的db，需要加到_databaseOutPool里，而不需要加到_databaseInPool里</span><br><span class="line">                if (![self-&gt;_databaseOutPool containsObject:db]) &#123;</span><br><span class="line">                    [self-&gt;_databaseOutPool addObject:db];</span><br><span class="line">                    // 新创建的db需要响应delegate</span><br><span class="line">                    if (shouldNotifyDelegate &amp;&amp; [self-&gt;_delegate respondsToSelector:@selector(databasePool:didAddDatabase:)]) &#123;</span><br><span class="line">                        [self-&gt;_delegate databasePool:self didAddDatabase:db];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            NSLog(@&quot;Could not open up the database at path %@&quot;, self-&gt;_path);</span><br><span class="line">            db = 0x00;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    return db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;FMResultSet&lt;/code&gt;用来执行SQL语句结果的查询&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FMDatabaseQueue&lt;/code&gt;用不同的线程来执行若干个查询和更新操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FMDatabasePool&lt;/code&gt;和&lt;code&gt;FMDatabaseQueue&lt;/code&gt;类似，但是只是用在数据库只读操作上&lt;/p&gt;
    
    </summary>
    
    
      <category term="FMDB" scheme="http://yuzeyang.github.io/tags/FMDB/"/>
    
  </entry>
  
  <entry>
    <title>FMDB初探（一）</title>
    <link href="http://yuzeyang.github.io/2016/07/23/FMDB-one/"/>
    <id>http://yuzeyang.github.io/2016/07/23/FMDB-one/</id>
    <published>2016-07-23T04:11:21.000Z</published>
    <updated>2016-07-24T10:49:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的<a href="http://zeeyang.com/2016/06/22/GCDAsyncSocket-socket-optimize/" target="_blank" rel="noopener">iOS Socket重构设计</a>里面我有提到我们使用了FMDB做消息缓存，在数据库选型方面，我们<a href="http://broccoliii.me/" target="_blank" rel="noopener">西兰花</a>也对目前比较流行和成熟的<code>Realm</code>、<code>FMDB</code>和<code>Core Data</code>做了调查，里面包括了安装、使用和性能比较，是个不错的参考例子</p>
<p>在选型时，我们应该多选取几个作为对比，从使用方面评估学习成本，通过测试不同数据库操作来比较性能差异，了解有哪些大型的App使用了该数据库以及评价来侧面说明该数据库的成熟度和在使用过程中出现的问题，最后根据自己实际的业务需求来选型</p>
<p>在选定使用<code>FMDB</code>之后，我也只是简单的了解下<code>FMDB</code>的使用，并未对内部的实现和设计思路做深入了解，但是在阅读了代码之后，<code>FMDB</code>确实像其他博客里面提到的那样，是对原生的SQLite API进行了包装，暴露出相对友好的对外接口，只需传入SQL语句即可(但是对于习惯于使用Model操作的我们来说，直接写SQL语句还是比较麻烦的，所以GitHub上也就库对<code>FMDB</code>进行了封装，省去写SQL语句，直接对Model进行操作)，并且<code>FMDB</code>内部对SQL语句进行了缓存，再配合上多线程并发执行，在提高效率方面做了不少的优化，另外还扩展了内存/文件的IO操作和虚表的操作</p>
<p>下面我会将API使用和源码结合起来讲，方便了解<code>FMDB</code>以及对复习下原生的SQLite API</p>
<a id="more"></a>
<h2 id="FMDatabase"><a href="#FMDatabase" class="headerlink" title="FMDatabase"></a>FMDatabase</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数据库的初始化对外有两种方法<code>+ databaseWithPath:</code>和<code>- initWithPath:</code>，内部实际上<code>+ databaseWithPath:</code>只是对<code>- initWithPath:</code>包装，代码里很多类似<code>FMDBReturnAutoreleased</code>等等这一类宏定义是为了兼容ARC和MRC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)databaseWithPath:(NSString*)aPath &#123;</span><br><span class="line">    return FMDBReturnAutoreleased([[self alloc] initWithPath:aPath]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithPath:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithPath:(NSString*)aPath &#123;</span><br><span class="line">    // SQLite支持三种线程模式，分别为单线程模式、多线程模式和串行模式</span><br><span class="line">    // sqlite3_threadsafe()的返回值可以确定编译时指定的线程模式，其中对于单线程模式，sqlite3_threadsafe()返回false，对于另外两个模式，则返回true。这是因为单线程模式下没有进行互斥，所以多线程下是不安全的</span><br><span class="line">    assert(sqlite3_threadsafe()); // whoa there big boy- gotta make sure sqlite it happy with what we&apos;re going to do.</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _databasePath               = [aPath copy];</span><br><span class="line">        _openResultSets             = [[NSMutableSet alloc] init];</span><br><span class="line">        // 此时并不创建数据库，真正创建是在open的时候</span><br><span class="line">      	_db                         = nil;</span><br><span class="line">        _logsErrors                 = YES;</span><br><span class="line">        _crashOnErrors              = NO;</span><br><span class="line">        _maxBusyRetryTimeInterval   = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 给定database路径</span><br><span class="line">NSString *dbPath = @&quot;/tmp/tmp.db&quot;;</span><br><span class="line">// 调用[+ databaseWithPath:]方法</span><br><span class="line">FMDatabase *db = [FMDatabase databaseWithPath:dbPath];</span><br></pre></td></tr></table></figure>
<h4 id="打开数据连接"><a href="#打开数据连接" class="headerlink" title="打开数据连接"></a>打开数据连接</h4><p>打开连接提供了三种方法，这时候才开始创建数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)open &#123;</span><br><span class="line">    if (_db) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据数据库路径打开数据库，如果数据库不存在就新建一个</span><br><span class="line">    int err = sqlite3_open([self sqlitePath], (sqlite3**)&amp;_db );</span><br><span class="line">    if(err != SQLITE_OK) &#123;</span><br><span class="line">        NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置最大繁忙重试时间间隔，默认为2秒</span><br><span class="line">    if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">        // set the handler</span><br><span class="line">        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 根据标记打开一个新的数据库连接</span><br><span class="line">// flag可以是以下三种值之一：</span><br><span class="line">// SQLITE_OPEN_READONLY，只读模式，如果数据库不存在会报错</span><br><span class="line">// SQLITE_OPEN_READWRITE，读写模式，如果该文件在操作系统中是写保护的，那就是以只读方式打开，如果数据库不存在会报错</span><br><span class="line">// SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE，以读写方式打开，如果数据不存在则新建一个，这个用于open方法里面</span><br><span class="line">// 以上还可以可选组合`SQLITE_OPEN_NOMUTEX`, `SQLITE_OPEN_FULLMUTEX`, `SQLITE_OPEN_SHAREDCACHE`, `SQLITE_OPEN_PRIVATECACHE`, and/or `SQLITE_OPEN_URI`</span><br><span class="line">- (BOOL)openWithFlags:(int)flags &#123;</span><br><span class="line">    return [self openWithFlags:flags vfs:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName &#123;</span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3005000</span><br><span class="line">    if (_db) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    // 比sqlite3_open多传入了flags和vfsName，vfsName为使用的VFS模块的名称</span><br><span class="line">    // sqlite3_open_v2里zVfs参数允许客户应用程序命名一个虚拟文件系统（Virtual File System）模块，用来与数据库连接。VFS作为SQlite library和底层存储系统（如某个文件系统）之间的一个抽象层，通常客户应用程序可以简单的给该参数传递一个NULL指针，以使用默认的VFS模块。</span><br><span class="line">    // sqlite3_open_v2比sqlite3_open和sqlite3_open16强大在它可以指定连接方式</span><br><span class="line">    int err = sqlite3_open_v2([self sqlitePath], (sqlite3**)&amp;_db, flags, [vfsName UTF8String]);</span><br><span class="line">    if(err != SQLITE_OK) &#123;</span><br><span class="line">        NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">        // set the handler</span><br><span class="line">        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">#else</span><br><span class="line">    NSLog(@&quot;openWithFlags requires SQLite 3.5&quot;);</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open时会根据<code>_maxBusyRetryTimeInterval</code>来设置繁忙处理<code>busy handler</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout &#123;</span><br><span class="line">    </span><br><span class="line">    _maxBusyRetryTimeInterval = timeout;</span><br><span class="line">    </span><br><span class="line">    if (!_db) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);</span><br><span class="line">     第二个参数是回调函数（busy handler），如果设置了回调函数，那就需要设置sqlite3_busy_handler的第三个参数，这里传递给它的是一个void*的参数的拷贝；如果回调函数返回０时，将不再尝试再次访问数据库而返回SQLITE_BUSY或者SQLITE_IOERR_BLOCKED。如果回调函数返回非０,将会不断尝试操作数据库。</span><br><span class="line">     也就是说，程序运行过程中，如果有其他进程或者线程在读写数据库，那么sqlite3_busy_handler会不断调用回调函数，直到其他进程或者线程释放锁。获得锁之后，不会再调用回调函数，从而向下执行，进行数据库操作。该函数是在获取不到锁的时候，以执行回调函数的次数来进行延迟，等待其他进程或者线程操作数据库结束，从而获得锁操作数据库。</span><br><span class="line">     */</span><br><span class="line">    if (timeout &gt; 0) &#123;</span><br><span class="line">        // busy handler设置为FMDBDatabaseBusyHandler函数</span><br><span class="line">        sqlite3_busy_handler(_db, &amp;FMDBDatabaseBusyHandler, (__bridge void *)(self));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // turn it off otherwise</span><br><span class="line">        // 关闭busy handler</span><br><span class="line">        sqlite3_busy_handler(_db, nil, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这就是回调函数</span><br><span class="line">static int FMDBDatabaseBusyHandler(void *f, int count) &#123;</span><br><span class="line">    FMDatabase *self = (__bridge FMDatabase*)f;</span><br><span class="line">    </span><br><span class="line">    // 如果是第一次调用，调用[+ timeIntervalSinceReferenceDate]方法，获取当前时间与2001年1月1日00:00:00 UTC的时间间隔，并赋值给startBusyRetryTime</span><br><span class="line">    if (count == 0) &#123;</span><br><span class="line">        self-&gt;_startBusyRetryTime = [NSDate timeIntervalSinceReferenceDate];</span><br><span class="line">        // 返回1，则将不断尝试操作数据库</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算当前时间与2001年1月1日00:00:00 UTC的时间间隔和startBusyRetryTime的间隔</span><br><span class="line">    NSTimeInterval delta = [NSDate timeIntervalSinceReferenceDate] - (self-&gt;_startBusyRetryTime);</span><br><span class="line">    // 如果间隔时间小于最大的重试间隔时间</span><br><span class="line">    if (delta &lt; [self maxBusyRetryTimeInterval]) &#123;</span><br><span class="line">        // 产生一个从50-99的随机整数作为需要挂起毫秒时间</span><br><span class="line">        int requestedSleepInMillseconds = (int) arc4random_uniform(50) + 50;</span><br><span class="line">        // 调用sqlite3_sleep返回实际挂起毫秒时间，如果不一致，可能是因为SQLite构建时没有将HAVE_USLEEP设置为1</span><br><span class="line">        int actualSleepInMilliseconds = sqlite3_sleep(requestedSleepInMillseconds);</span><br><span class="line">        if (actualSleepInMilliseconds != requestedSleepInMillseconds) &#123;</span><br><span class="line">            NSLog(@&quot;WARNING: Requested sleep of %i milliseconds, but SQLite returned %i. Maybe SQLite wasn&apos;t built with HAVE_USLEEP=1?&quot;, requestedSleepInMillseconds, actualSleepInMilliseconds);</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![db open]) &#123;</span><br><span class="line">	// do somthing        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行单个查询SQL语句"><a href="#执行单个查询SQL语句" class="headerlink" title="执行单个查询SQL语句"></a>执行单个查询SQL语句</h4><p>主要执行的是<code>(FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code>方法，<code>sql</code>是执行SELECT语句，<code>dictionaryArgs</code>是对应于<code>sql</code>语句里<code>？</code>的<code>key</code>和<code>value</code>，在将<code>sql</code>语句转换成<code>prepared</code>语句时，这里先从缓存中获取，没有的话再去调用<code>sqlite3_prepare_v2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123;</span><br><span class="line">    // 检查数据库是否存在</span><br><span class="line">    if (![self databaseExists]) &#123;</span><br><span class="line">        return 0x00;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查是否正在执行操作</span><br><span class="line">    if (_isExecutingStatement) &#123;</span><br><span class="line">        [self warnInUse];</span><br><span class="line">        return 0x00;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = YES;</span><br><span class="line">    </span><br><span class="line">    int rc                  = 0x00;</span><br><span class="line">    sqlite3_stmt *pStmt     = 0x00;</span><br><span class="line">    FMStatement *statement  = 0x00;</span><br><span class="line">    FMResultSet *rs         = 0x00;</span><br><span class="line">    </span><br><span class="line">    if (_traceExecution &amp;&amp; sql) &#123;</span><br><span class="line">        NSLog(@&quot;%@ executeQuery: %@&quot;, self, sql);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将sql语句转换成prepared语句</span><br><span class="line">    // 由于使用sqlite3_prepare_v2来生成sql对应的prepared语句代价很大</span><br><span class="line">    // 所以使用缓存机制来减少sqlite3_prepare_v2的使用</span><br><span class="line">    if (_shouldCacheStatements) &#123;</span><br><span class="line">        // 根据sql获取到缓存中的prepared语句</span><br><span class="line">        statement = [self cachedStatementForQuery:sql];</span><br><span class="line">        pStmt = statement ? [statement statement] : 0x00;</span><br><span class="line">        // 重置prepared语句</span><br><span class="line">        [statement reset];</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果缓存中没有sql对应的prepared语句，那么需要用sqlite3_prepare_v2生成对应的prepared语句</span><br><span class="line">    if (!pStmt) &#123;</span><br><span class="line">        </span><br><span class="line">        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;pStmt, 0);</span><br><span class="line">        </span><br><span class="line">        // 如果生成失败，则打印错误日志</span><br><span class="line">        if (SQLITE_OK != rc) &#123;</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">                NSLog(@&quot;DB Path: %@&quot;, _databasePath);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (_crashOnErrors) &#123;</span><br><span class="line">                NSAssert(false, @&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</span><br><span class="line">                // 停止程序</span><br><span class="line">                abort();</span><br><span class="line">            &#125;</span><br><span class="line">            // 释放所有内部资源和FMStatement</span><br><span class="line">            sqlite3_finalize(pStmt);</span><br><span class="line">            _isExecutingStatement = NO;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id obj;</span><br><span class="line">    int idx = 0;</span><br><span class="line">    // sqlite3_bind_parameter_count 返回SQL语句参数的数量</span><br><span class="line">    int queryCount = sqlite3_bind_parameter_count(pStmt); // pointed out by Dominic Yu (thanks!)</span><br><span class="line">    </span><br><span class="line">    // If dictionaryArgs is passed in, that means we are using sqlite&apos;s named parameter support</span><br><span class="line">    if (dictionaryArgs) &#123;</span><br><span class="line">        </span><br><span class="line">        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &#123;</span><br><span class="line">            </span><br><span class="line">            // Prefix the key with a colon.</span><br><span class="line">            NSString *parameterName = [[NSString alloc] initWithFormat:@&quot;:%@&quot;, dictionaryKey];</span><br><span class="line">            </span><br><span class="line">            if (_traceExecution) &#123;</span><br><span class="line">                NSLog(@&quot;%@ = %@&quot;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Get the index for the parameter name.</span><br><span class="line">            // 通过传入参数名来获取该参数的索引</span><br><span class="line">            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);</span><br><span class="line">            </span><br><span class="line">            FMDBRelease(parameterName);</span><br><span class="line">            // 如果索引大于0</span><br><span class="line">            if (namedIdx &gt; 0) &#123;</span><br><span class="line">                // Standard binding from here.</span><br><span class="line">                // 在prepared语句里将值绑定到索引位置</span><br><span class="line">                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];</span><br><span class="line">                // increment the binding count, so our check below works out</span><br><span class="line">                // 绑定数量加一</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                NSLog(@&quot;Could not find index for %@&quot;, dictionaryKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        </span><br><span class="line">        while (idx &lt; queryCount) &#123;</span><br><span class="line">            // 当调用下面三个方法时</span><br><span class="line">            // - (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...</span><br><span class="line">            // - (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments</span><br><span class="line">            // - (FMResultSet *)executeQuery:(NSString *)sql values:(NSArray *)values error:(NSError * __autoreleasing *)error</span><br><span class="line">            // 值是放在NSArray里面，循环取出来绑定</span><br><span class="line">            if (arrayArgs &amp;&amp; idx &lt; (int)[arrayArgs count]) &#123;</span><br><span class="line">                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];</span><br><span class="line">            &#125;</span><br><span class="line">            // 当调用下面两个方法时</span><br><span class="line">            // - (FMResultSet *)executeQuery:(NSString*)sql, ...</span><br><span class="line">            // - (FMResultSet *)executeQuery:(NSString*)sql withVAList:(va_list)args</span><br><span class="line">            // 值是放在va_list里面，循环取出来绑定</span><br><span class="line">            else if (args) &#123;</span><br><span class="line">                obj = va_arg(args, id);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //We ran out of arguments</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (_traceExecution) &#123;</span><br><span class="line">                if ([obj isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">                    NSLog(@&quot;data: %ld bytes&quot;, (unsigned long)[(NSData*)obj length]);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    NSLog(@&quot;obj: %@&quot;, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            idx++;</span><br><span class="line">            // 绑定参数</span><br><span class="line">            [self bindObject:obj toColumn:idx inStatement:pStmt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果绑定数量和参数数量不一致，打印错误，并释放资源</span><br><span class="line">    if (idx != queryCount) &#123;</span><br><span class="line">        NSLog(@&quot;Error: the bind count is not correct for the # of variables (executeQuery)&quot;);</span><br><span class="line">        sqlite3_finalize(pStmt);</span><br><span class="line">        _isExecutingStatement = NO;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FMDBRetain(statement); // to balance the release below</span><br><span class="line">    </span><br><span class="line">    // 如果statement不为空，则缓存</span><br><span class="line">    if (!statement) &#123;</span><br><span class="line">        statement = [[FMStatement alloc] init];</span><br><span class="line">        [statement setStatement:pStmt];</span><br><span class="line">        </span><br><span class="line">        if (_shouldCacheStatements &amp;&amp; sql) &#123;</span><br><span class="line">            // 以sql作为key来缓存statement</span><br><span class="line">            [self setCachedStatement:statement forQuery:sql];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // the statement gets closed in rs&apos;s dealloc or [rs close];</span><br><span class="line">    // 根据statement和FMDataBase对象来初始化FMResultSet对象</span><br><span class="line">    rs = [FMResultSet resultSetWithStatement:statement usingParentDatabase:self];</span><br><span class="line">    [rs setQuery:sql];</span><br><span class="line">    </span><br><span class="line">    // 将FMResultSet对象加到_openResultSets里</span><br><span class="line">    NSValue *openResultSet = [NSValue valueWithNonretainedObject:rs];</span><br><span class="line">    [_openResultSets addObject:openResultSet];</span><br><span class="line">    // useCount+1</span><br><span class="line">    [statement setUseCount:[statement useCount] + 1];</span><br><span class="line">    </span><br><span class="line">    FMDBRelease(statement);</span><br><span class="line">    // 设置_isExecutingStatement操作结束</span><br><span class="line">    _isExecutingStatement = NO;</span><br><span class="line">    </span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rs = [newDb executeQuery:@&quot;select rowid,* from test where a = ?&quot;, @&quot;hi&apos;&quot;];</span><br><span class="line"></span><br><span class="line">rs = [db executeQueryWithFormat:@&quot;select * from t5 where a = %s and a = %@ and b = %d&quot;, &quot;text&quot;, @&quot;text&quot;, 42];</span><br><span class="line"></span><br><span class="line">rs = [db executeQuery:@&quot;select * from testOneHundredTwelvePointTwo where b &gt; ?&quot; withArgumentsInArray:[NSArray arrayWithObject:[NSNumber numberWithInteger:1]]];</span><br><span class="line"></span><br><span class="line">rs = [db executeQuery:@&quot;select * from namedparamcounttest where a = :a&quot; withParameterDictionary:dictionaryArgs];</span><br></pre></td></tr></table></figure>
<h4 id="执行单个更新SQL语句"><a href="#执行单个更新SQL语句" class="headerlink" title="执行单个更新SQL语句"></a>执行单个更新SQL语句</h4><p><code>- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code>是主要函数，但是里面大部分处理和<code>- executeQuery: withArgumentsInArray: orDictionary: orVAList:</code>处理类似，不同处我已经注释说明，可以直接看注释部分代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123;</span><br><span class="line">    </span><br><span class="line">    if (![self databaseExists]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_isExecutingStatement) &#123;</span><br><span class="line">        [self warnInUse];</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = YES;</span><br><span class="line">    </span><br><span class="line">    int rc                   = 0x00;</span><br><span class="line">    sqlite3_stmt *pStmt      = 0x00;</span><br><span class="line">    FMStatement *cachedStmt  = 0x00;</span><br><span class="line">    </span><br><span class="line">    if (_traceExecution &amp;&amp; sql) &#123;</span><br><span class="line">        NSLog(@&quot;%@ executeUpdate: %@&quot;, self, sql);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_shouldCacheStatements) &#123;</span><br><span class="line">        cachedStmt = [self cachedStatementForQuery:sql];</span><br><span class="line">        pStmt = cachedStmt ? [cachedStmt statement] : 0x00;</span><br><span class="line">        [cachedStmt reset];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!pStmt) &#123;</span><br><span class="line">        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;pStmt, 0);</span><br><span class="line">        </span><br><span class="line">        if (SQLITE_OK != rc) &#123;</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">                NSLog(@&quot;DB Path: %@&quot;, _databasePath);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (_crashOnErrors) &#123;</span><br><span class="line">                NSAssert(false, @&quot;DB Error: %d \&quot;%@\&quot;&quot;, [self lastErrorCode], [self lastErrorMessage]);</span><br><span class="line">                abort();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (outErr) &#123;</span><br><span class="line">                *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sqlite3_finalize(pStmt);</span><br><span class="line">            </span><br><span class="line">            _isExecutingStatement = NO;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id obj;</span><br><span class="line">    int idx = 0;</span><br><span class="line">    int queryCount = sqlite3_bind_parameter_count(pStmt);</span><br><span class="line">    </span><br><span class="line">    // If dictionaryArgs is passed in, that means we are using sqlite&apos;s named parameter support</span><br><span class="line">    if (dictionaryArgs) &#123;</span><br><span class="line">        </span><br><span class="line">        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &#123;</span><br><span class="line">            </span><br><span class="line">            // Prefix the key with a colon.</span><br><span class="line">            NSString *parameterName = [[NSString alloc] initWithFormat:@&quot;:%@&quot;, dictionaryKey];</span><br><span class="line">            </span><br><span class="line">            if (_traceExecution) &#123;</span><br><span class="line">                NSLog(@&quot;%@ = %@&quot;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);</span><br><span class="line">            &#125;</span><br><span class="line">            // Get the index for the parameter name.</span><br><span class="line">            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);</span><br><span class="line">            </span><br><span class="line">            FMDBRelease(parameterName);</span><br><span class="line">            </span><br><span class="line">            if (namedIdx &gt; 0) &#123;</span><br><span class="line">                // Standard binding from here.</span><br><span class="line">                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];</span><br><span class="line">                </span><br><span class="line">                // increment the binding count, so our check below works out</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // 由于多了outErr，所以绑定时出错需要将error抛出</span><br><span class="line">                NSString *message = [NSString stringWithFormat:@&quot;Could not find index for %@&quot;, dictionaryKey];</span><br><span class="line">                </span><br><span class="line">                if (_logsErrors) &#123;</span><br><span class="line">                    NSLog(@&quot;%@&quot;, message);</span><br><span class="line">                &#125;</span><br><span class="line">                if (outErr) &#123;</span><br><span class="line">                    *outErr = [self errorWithMessage:message];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        </span><br><span class="line">        while (idx &lt; queryCount) &#123;</span><br><span class="line">            </span><br><span class="line">            if (arrayArgs &amp;&amp; idx &lt; (int)[arrayArgs count]) &#123;</span><br><span class="line">                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (args) &#123;</span><br><span class="line">                obj = va_arg(args, id);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //We ran out of arguments</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (_traceExecution) &#123;</span><br><span class="line">                if ([obj isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">                    NSLog(@&quot;data: %ld bytes&quot;, (unsigned long)[(NSData*)obj length]);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    NSLog(@&quot;obj: %@&quot;, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            idx++;</span><br><span class="line">            </span><br><span class="line">            [self bindObject:obj toColumn:idx inStatement:pStmt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (idx != queryCount) &#123;</span><br><span class="line">        // 同样也是组装error抛出</span><br><span class="line">        NSString *message = [NSString stringWithFormat:@&quot;Error: the bind count (%d) is not correct for the # of variables in the query (%d) (%@) (executeUpdate)&quot;, idx, queryCount, sql];</span><br><span class="line">        if (_logsErrors) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;, message);</span><br><span class="line">        &#125;</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [self errorWithMessage:message];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sqlite3_finalize(pStmt);</span><br><span class="line">        _isExecutingStatement = NO;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Call sqlite3_step() to run the virtual machine. Since the SQL being</span><br><span class="line">     ** executed is not a SELECT statement, we assume no data will be returned.</span><br><span class="line">     */</span><br><span class="line">    // sqlite3_prepare函数将SQL命令字符串解析并转换为一系列的命令字节码，这些字节码最终被传送到SQlite3的虚拟数据库引擎（VDBE: Virtual Database Engine）中执行，完成这项工作的是sqlite3_step函数。比如一个SELECT查询操作，sqlite3_step函数的每次调用都会返回结果集中的其中一行，直到再没有有效数据行了。每次调用sqlite3_step函数如果返回SQLITE_ROW，代表获得了有效数据行，可以通过sqlite3_column函数提取某列的值。如果调用sqlite3_step函数返回SQLITE_DONE，则代表prepared语句已经执行到终点了，没有有效数据了。很多命令第一次调用sqlite3_step函数就会返回SQLITE_DONE，因为这些SQL命令不会返回数据。对于INSERT，UPDATE，DELETE命令，会返回它们所修改的行号——一个单行单列的值。</span><br><span class="line">    /**</span><br><span class="line">     SQLITE_BUSY 数据库文件有锁</span><br><span class="line">     SQLITE_LOCKED 数据库中的某张表有锁</span><br><span class="line">     SQLITE_DONE sqlite3_step()执行完毕</span><br><span class="line">     SQLITE_ROW sqlite3_step()获取到下一行数据</span><br><span class="line">     SQLITE_ERROR 一般用于没有特别指定错误码的错误，就是说函数在执行过程中发生了错误，但无法知道错误发生的原因。</span><br><span class="line">     SQLITE_MISUSE 没有正确使用SQLite接口，比如一条语句在sqlite3_step函数执行之后，没有被重置之前，再次给其绑定参数，这时bind函数就会返回SQLITE_MISUSE。</span><br><span class="line">     **/</span><br><span class="line">    rc      = sqlite3_step(pStmt);</span><br><span class="line">    </span><br><span class="line">    if (SQLITE_DONE == rc) &#123;</span><br><span class="line">        // all is well, let&apos;s return.</span><br><span class="line">    &#125;</span><br><span class="line">    // sql操作被sqlite3_interrupt()函数终止</span><br><span class="line">    else if (SQLITE_INTERRUPT == rc) &#123;</span><br><span class="line">        if (_logsErrors) &#123;</span><br><span class="line">            NSLog(@&quot;Error calling sqlite3_step. Query was interrupted (%d: %s) SQLITE_INTERRUPT&quot;, rc, sqlite3_errmsg(_db));</span><br><span class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (rc == SQLITE_ROW) &#123;</span><br><span class="line">        NSString *message = [NSString stringWithFormat:@&quot;A executeUpdate is being called with a query string &apos;%@&apos;&quot;, sql];</span><br><span class="line">        if (_logsErrors) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;, message);</span><br><span class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">        &#125;</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [self errorWithMessage:message];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (outErr) &#123;</span><br><span class="line">            *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (SQLITE_ERROR == rc) &#123;</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;Error calling sqlite3_step (%d: %s) SQLITE_ERROR&quot;, rc, sqlite3_errmsg(_db));</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (SQLITE_MISUSE == rc) &#123;</span><br><span class="line">            // uh oh.</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;Error calling sqlite3_step (%d: %s) SQLITE_MISUSE&quot;, rc, sqlite3_errmsg(_db));</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // wtf?</span><br><span class="line">            if (_logsErrors) &#123;</span><br><span class="line">                NSLog(@&quot;Unknown error calling sqlite3_step (%d: %s) eu&quot;, rc, sqlite3_errmsg(_db));</span><br><span class="line">                NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_shouldCacheStatements &amp;&amp; !cachedStmt) &#123;</span><br><span class="line">        cachedStmt = [[FMStatement alloc] init];</span><br><span class="line">        </span><br><span class="line">        [cachedStmt setStatement:pStmt];</span><br><span class="line">        </span><br><span class="line">        [self setCachedStatement:cachedStmt forQuery:sql];</span><br><span class="line">        </span><br><span class="line">        FMDBRelease(cachedStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int closeErrorCode;</span><br><span class="line">    </span><br><span class="line">    if (cachedStmt) &#123;</span><br><span class="line">        [cachedStmt setUseCount:[cachedStmt useCount] + 1];</span><br><span class="line">        closeErrorCode = sqlite3_reset(pStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        /* Finalize the virtual machine. This releases all memory and other</span><br><span class="line">         ** resources allocated by the sqlite3_prepare() call above.</span><br><span class="line">         */</span><br><span class="line">        closeErrorCode = sqlite3_finalize(pStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (closeErrorCode != SQLITE_OK) &#123;</span><br><span class="line">        if (_logsErrors) &#123;</span><br><span class="line">            NSLog(@&quot;Unknown error finalizing or resetting statement (%d: %s)&quot;, closeErrorCode, sqlite3_errmsg(_db));</span><br><span class="line">            NSLog(@&quot;DB Query: %@&quot;, sql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = NO;</span><br><span class="line">    return (rc == SQLITE_DONE || rc == SQLITE_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[db executeUpdate:@&quot;insert into t5 values (?, ?, ?, ?, ?)&quot; withErrorAndBindings:&amp;err, @&quot;text&quot;, [NSNumber numberWithInt:42], @&quot;BLOB&quot;, @&quot;d&quot;, [NSNumber numberWithInt:0]];</span><br><span class="line"></span><br><span class="line">[dbB executeUpdate:@&quot;create table attached (a text)&quot;];</span><br><span class="line"></span><br><span class="line">[dbB executeUpdate:@&quot;insert into attached values (?)&quot;, @&quot;test&quot;];</span><br><span class="line"></span><br><span class="line">[db executeUpdateWithFormat:@&quot;insert into t55 values (%c, %hi, %g)&quot;, &apos;a&apos;, testShort, testFloat];</span><br><span class="line"></span><br><span class="line">[db executeUpdate:@&quot;insert into testOneHundredTwelvePointTwo values (?, ?)&quot; withArgumentsInArray:[NSArray arrayWithObjects:@&quot;one&quot;, [NSNumber numberWithInteger:2], nil]];</span><br><span class="line"></span><br><span class="line">[db executeUpdate:@&quot;insert into namedparamtest values (:a, :b, :c, :d)&quot; withParameterDictionary:dictionaryArgs];</span><br></pre></td></tr></table></figure>
<h4 id="执行多个SQL语句"><a href="#执行多个SQL语句" class="headerlink" title="执行多个SQL语句"></a>执行多个SQL语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 使用executeStatements:函数可以将多个SQL执行语句写在一个字符串中，并执行</span><br><span class="line">- (BOOL)executeStatements:(NSString *)sql &#123;</span><br><span class="line">    return [self executeStatements:sql withResultBlock:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)executeStatements:(NSString *)sql withResultBlock:(FMDBExecuteStatementsCallbackBlock)block &#123;</span><br><span class="line">    </span><br><span class="line">    int rc;</span><br><span class="line">    char *errmsg = nil;</span><br><span class="line">    /*</span><br><span class="line">     sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg)</span><br><span class="line">     </span><br><span class="line">     该例程提供了一个执行 SQL 命令的快捷方式，SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。</span><br><span class="line">     </span><br><span class="line">     在这里，第一个参数 sqlite3 是打开的数据库对象，sqlite_callback 是一个回调，data 作为其第一个参数，errmsg 将被返回用来获取程序生成的任何错误。</span><br><span class="line">     </span><br><span class="line">     sqlite3_exec() 程序解析并执行由 sql 参数所给的每个命令，直到字符串结束或者遇到错误为止。</span><br><span class="line">     */</span><br><span class="line">    rc = sqlite3_exec([self sqliteHandle], [sql UTF8String], block ? FMDBExecuteBulkSQLCallback : nil, (__bridge void *)(block), &amp;errmsg);</span><br><span class="line">    </span><br><span class="line">    if (errmsg &amp;&amp; [self logsErrors]) &#123;</span><br><span class="line">        NSLog(@&quot;Error inserting batch: %s&quot;, errmsg);</span><br><span class="line">        sqlite3_free(errmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (rc == SQLITE_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSString *sql = @&quot;create table messages1 (id integer primary key messageId, x text);&quot;</span><br><span class="line">                 &quot;create table messages2 (id integer primary key messageId, y text);&quot;</span><br><span class="line">				 &quot;insert into messages1 (x) values (&apos;X&apos;);&quot;</span><br><span class="line">                 &quot;insert into messages2 (y) values (&apos;Y&apos;);&quot;;</span><br><span class="line"></span><br><span class="line">success = [db executeStatements:sql];</span><br><span class="line"></span><br><span class="line">sql = @&quot;select count(*) as count from messages1;&quot;</span><br><span class="line">       &quot;select count(*) as count from messages2;&quot;;</span><br><span class="line"></span><br><span class="line">success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="获取最后一条插入数据的RowId"><a href="#获取最后一条插入数据的RowId" class="headerlink" title="获取最后一条插入数据的RowId"></a>获取最后一条插入数据的RowId</h4><p>可以根据这个<code>id</code>拿到该数据，并且向上取数据库数据等操作都可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (sqlite_int64)lastInsertRowId &#123;</span><br><span class="line">    // 如果有正在执行语句，返回</span><br><span class="line">    if (_isExecutingStatement) &#123;</span><br><span class="line">        [self warnInUse];</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = YES;</span><br><span class="line">    // sqlite3_last_insert_rowid 获取指定数据库最后一个插入的rowid</span><br><span class="line">    sqlite_int64 ret = sqlite3_last_insert_rowid(_db);</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = NO;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统计上一次SQL语句受影响的行数"><a href="#统计上一次SQL语句受影响的行数" class="headerlink" title="统计上一次SQL语句受影响的行数"></a>统计上一次SQL语句受影响的行数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (int)changes &#123;</span><br><span class="line">    if (_isExecutingStatement) &#123;</span><br><span class="line">        [self warnInUse];</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = YES;</span><br><span class="line">    </span><br><span class="line">    int ret = sqlite3_changes(_db);</span><br><span class="line">    </span><br><span class="line">    _isExecutingStatement = NO;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exclusive事务和deferred事务"><a href="#exclusive事务和deferred事务" class="headerlink" title="exclusive事务和deferred事务"></a>exclusive事务和deferred事务</h4><p>事务可以从<code>DEFERRED</code>，<code>IMMEDIATE</code>或者<code>EXCLUSIVE</code>，一个事务的类型在<code>BEGIN</code>命令中指定：<code>BEGIN [ DEFERRED | IMMEDIATE | EXCLUSIVE ] TRANSACTION</code></p>
<p>一个<code>deferred</code>事务不获取任何锁，直到它需要锁的时候，而且<code>BEGIN</code>语句本身也不会做什么事情——它开始于<code>UNLOCK</code>状态；默认情况下是这样的。如果仅仅用<code>BEGIN</code>开始一个事务，那么事务就是<code>DEFERRED</code>的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取<code>SHARED LOCK</code>；同样，当进行第一次写操作时，它会获取<code>RESERVED LOCK</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 开始延迟事务</span><br><span class="line">- (BOOL)beginDeferredTransaction &#123;</span><br><span class="line">    </span><br><span class="line">    BOOL b = [self executeUpdate:@&quot;begin deferred transaction&quot;];</span><br><span class="line">    if (b) &#123;</span><br><span class="line">        _inTransaction = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Exclusive事务会试着获取对数据库的EXCLUSIVE锁。这与IMMEDIATE类似，但是一旦成功，EXCLUSIVE事务保证没有其它的连接，所以就可对数据库进行读写操作了。</span><br><span class="line"></span><br><span class="line">// 开始事务</span><br><span class="line">- (BOOL)beginTransaction &#123;</span><br><span class="line">    </span><br><span class="line">    BOOL b = [self executeUpdate:@&quot;begin exclusive transaction&quot;];</span><br><span class="line">    if (b) &#123;</span><br><span class="line">        _inTransaction = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回滚事务</span><br><span class="line">- (BOOL)rollback &#123;</span><br><span class="line">    BOOL b = [self executeUpdate:@&quot;rollback transaction&quot;];</span><br><span class="line">    </span><br><span class="line">    if (b) &#123;</span><br><span class="line">        _inTransaction = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">// 提交事务</span><br><span class="line">- (BOOL)commit &#123;</span><br><span class="line">    BOOL b =  [self executeUpdate:@&quot;commit transaction&quot;];</span><br><span class="line">    </span><br><span class="line">    if (b) &#123;</span><br><span class="line">        _inTransaction = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据库加密及重置"><a href="#数据库加密及重置" class="headerlink" title="数据库加密及重置"></a>数据库加密及重置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)setKeyWithData:(NSData *)keyData &#123;</span><br><span class="line">// SQLITE_HAS_CODEC 用来确定是否支持加密</span><br><span class="line">#ifdef SQLITE_HAS_CODEC</span><br><span class="line">    if (!keyData) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // int sqlite3_key( sqlite3 *db, const void *pKey, int nKey)</span><br><span class="line">    // db是指定的数据库，pKey是密钥，nKey是密钥的长度</span><br><span class="line">    // 例如：sqlite3_key(_db, &quot;gongcheng&quot;, 9);</span><br><span class="line">    int rc = sqlite3_key(_db, [keyData bytes], (int)[keyData length]);</span><br><span class="line">    </span><br><span class="line">    return (rc == SQLITE_OK);</span><br><span class="line">#else</span><br><span class="line">#pragma unused(keyData)</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)rekeyWithData:(NSData *)keyData &#123;</span><br><span class="line">#ifdef SQLITE_HAS_CODEC</span><br><span class="line">    if (!keyData) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // int sqlite3_rekey( sqlite3 *db, const void *pKey, int nKey)</span><br><span class="line">    // db是指定的数据库，pKey是密钥，nKey是密钥的长度</span><br><span class="line">    // 例如：sqlite3_rekey(_db, &quot;yzy&quot;, 3);</span><br><span class="line">    int rc = sqlite3_rekey(_db, [keyData bytes], (int)[keyData length]);</span><br><span class="line">    </span><br><span class="line">    if (rc != SQLITE_OK) &#123;</span><br><span class="line">        NSLog(@&quot;error on rekey: %d&quot;, rc);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [self lastErrorMessage]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (rc == SQLITE_OK);</span><br><span class="line">#else</span><br><span class="line">#pragma unused(keyData)</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据库回滚时设置回滚节点"><a href="#数据库回滚时设置回滚节点" class="headerlink" title="数据库回滚时设置回滚节点"></a>数据库回滚时设置回滚节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (NSError*)inSavePoint:(void (^)(BOOL *rollback))block &#123;</span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3007000</span><br><span class="line">    static unsigned long savePointIdx = 0;</span><br><span class="line">    // 设置节点名称</span><br><span class="line">    NSString *name = [NSString stringWithFormat:@&quot;dbSavePoint%ld&quot;, savePointIdx++];</span><br><span class="line">    // 默认不回滚</span><br><span class="line">    BOOL shouldRollback = NO;</span><br><span class="line">    </span><br><span class="line">    NSError *err = 0x00;</span><br><span class="line">    // 先对当前状态进行保存</span><br><span class="line">    if (![self startSavePointWithName:name error:&amp;err]) &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(&amp;shouldRollback);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果需要回滚，则回滚当上一个节点</span><br><span class="line">    if (shouldRollback) &#123;</span><br><span class="line">        // We need to rollback and release this savepoint to remove it</span><br><span class="line">        [self rollbackToSavePointWithName:name error:&amp;err];</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放节点</span><br><span class="line">    [self releaseSavePointWithName:name error:&amp;err];</span><br><span class="line">    </span><br><span class="line">    return err;</span><br><span class="line">#else</span><br><span class="line">    NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil);</span><br><span class="line">    if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage);</span><br><span class="line">    return [NSError errorWithDomain:@&quot;FMDatabase&quot; code:0 userInfo:@&#123;NSLocalizedDescriptionKey : errorMessage&#125;];</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)close &#123;</span><br><span class="line">    // 清除缓存的prepared语句</span><br><span class="line">    [self clearCachedStatements];</span><br><span class="line">    // 关闭所有打开的FMResultSet对象</span><br><span class="line">    [self closeOpenResultSets];</span><br><span class="line">    </span><br><span class="line">    if (!_db) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int  rc;</span><br><span class="line">    BOOL retry;</span><br><span class="line">    BOOL triedFinalizingOpenStatements = NO;</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        retry   = NO;</span><br><span class="line">        // 调用sqlite3_close尝试关闭数据库</span><br><span class="line">        rc      = sqlite3_close(_db);</span><br><span class="line">        // 当返回结果是数据库繁忙或者被锁住了</span><br><span class="line">        if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &#123;</span><br><span class="line">            if (!triedFinalizingOpenStatements) &#123;</span><br><span class="line">                triedFinalizingOpenStatements = YES;</span><br><span class="line">                sqlite3_stmt *pStmt;</span><br><span class="line">                // 从关联的pDb数据里面对应的prepared语句开始往下找相应的prepared语句，</span><br><span class="line">                // 如果pStmt是NULL，则从pDb的第一个prepared语句开始找，</span><br><span class="line">                // 如果没有找到，则返回NULL</span><br><span class="line">                while ((pStmt = sqlite3_next_stmt(_db, nil)) !=0) &#123;</span><br><span class="line">                    // 找到之后，释放资源</span><br><span class="line">                    NSLog(@&quot;Closing leaked statement&quot;);</span><br><span class="line">                    sqlite3_finalize(pStmt);</span><br><span class="line">                    retry = YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (SQLITE_OK != rc) &#123;</span><br><span class="line">            NSLog(@&quot;error closing!: %d&quot;, rc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (retry);</span><br><span class="line">    </span><br><span class="line">    _db = nil;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[newDb close];</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的&lt;a href=&quot;http://zeeyang.com/2016/06/22/GCDAsyncSocket-socket-optimize/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS Socket重构设计&lt;/a&gt;里面我有提到我们使用了FMDB做消息缓存，在数据库选型方面，我们&lt;a href=&quot;http://broccoliii.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;西兰花&lt;/a&gt;也对目前比较流行和成熟的&lt;code&gt;Realm&lt;/code&gt;、&lt;code&gt;FMDB&lt;/code&gt;和&lt;code&gt;Core Data&lt;/code&gt;做了调查，里面包括了安装、使用和性能比较，是个不错的参考例子&lt;/p&gt;
&lt;p&gt;在选型时，我们应该多选取几个作为对比，从使用方面评估学习成本，通过测试不同数据库操作来比较性能差异，了解有哪些大型的App使用了该数据库以及评价来侧面说明该数据库的成熟度和在使用过程中出现的问题，最后根据自己实际的业务需求来选型&lt;/p&gt;
&lt;p&gt;在选定使用&lt;code&gt;FMDB&lt;/code&gt;之后，我也只是简单的了解下&lt;code&gt;FMDB&lt;/code&gt;的使用，并未对内部的实现和设计思路做深入了解，但是在阅读了代码之后，&lt;code&gt;FMDB&lt;/code&gt;确实像其他博客里面提到的那样，是对原生的SQLite API进行了包装，暴露出相对友好的对外接口，只需传入SQL语句即可(但是对于习惯于使用Model操作的我们来说，直接写SQL语句还是比较麻烦的，所以GitHub上也就库对&lt;code&gt;FMDB&lt;/code&gt;进行了封装，省去写SQL语句，直接对Model进行操作)，并且&lt;code&gt;FMDB&lt;/code&gt;内部对SQL语句进行了缓存，再配合上多线程并发执行，在提高效率方面做了不少的优化，另外还扩展了内存/文件的IO操作和虚表的操作&lt;/p&gt;
&lt;p&gt;下面我会将API使用和源码结合起来讲，方便了解&lt;code&gt;FMDB&lt;/code&gt;以及对复习下原生的SQLite API&lt;/p&gt;
    
    </summary>
    
    
      <category term="FMDB" scheme="http://yuzeyang.github.io/tags/FMDB/"/>
    
  </entry>
  
  <entry>
    <title>IM UI性能优化之异步绘制</title>
    <link href="http://yuzeyang.github.io/2016/07/05/IM-UI-optimize/"/>
    <id>http://yuzeyang.github.io/2016/07/05/IM-UI-optimize/</id>
    <published>2016-07-05T14:35:44.000Z</published>
    <updated>2017-04-10T13:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>重构完Socket之后，最近我们也开始针对IM的UI做了优化，这次的优化我们主要是参考了<a href="https://github.com/ibireme/YYKit" target="_blank" rel="noopener">YYKit</a>对于性能方面的优化，前期我的另一个小伙伴<a href="http://broccoliii.me/" target="_blank" rel="noopener">西兰花</a>也对<a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a>做了调研，不过这个库理解起来确实要费一番功夫，由于YYkit的核心思路基本上都是学习AsyncDisplayKit的，相信YYkit这个库大家都已经很熟悉了，不过可能还没有看过这个库，那下面我做一个简单的介绍</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/yykit.png" alt=""></p>
<p>YYKit的作者是<a href="http://blog.ibireme.com/" target="_blank" rel="noopener">郭曜源</a>，YYKit实际上是将它那些单独的iOS组件整合在了一起，类似于集合一样组成功能比较全面的组件，你也可以根据自己业务的需要单独使用其中的某些部分</p>
<h2 id="0x00-前期准备"><a href="#0x00-前期准备" class="headerlink" title="0x00 前期准备"></a>0x00 前期准备</h2><p>我们首先阅读了郭曜源在<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">对界面流畅性方面的见解</a>，里面提到了<code>异步绘制</code>，但是文字表述毕竟是抽象的，然后我们简单看了下他的YYText和YYAsyncLayer组件，看完之后实际上对如何使用他的YYAsyncLayer这个组件来实现异步绘制还是有点模糊的，后来我们直接看他的微博demo，我们逐渐理清了他是如何实现异步绘制以及几个性能优化方面的点</p>
<p>因为YYLabel Async Display里面加了是否异步绘制开关，所以我们直接用这个例子作为对比，首先我们来看下异步绘制的效果，开始的时候我们关闭异步绘制的开关，你会发现FPS瞬间掉到6了，屏幕滚动开始非常卡，但是打开开关之后，滚动时虽然FPS还是会掉到30-40，但是滑动的流畅度比之前要好很多，感觉这异步绘制的效果杠杠的好啊，那我们一定要看看他是怎么做的了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/YYAsyncLayer.gif!500x500" alt=""></p>
<h2 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h2><p>其实整一个性能优化关键的点及流程有三个：</p>
<h5 id="1-数据源的异步处理"><a href="#1-数据源的异步处理" class="headerlink" title="1.数据源的异步处理"></a>1.数据源的异步处理</h5><p>当我们获取到数据源的时候，我们需要对数据源进行计算处理，计算出UI绘制所需要的属性比如宽高、颜色等等，而且这些计算要异步去做，否则会卡住主线程，等这些数据源计算完成之后，再去处理绘制，但是如果数据源过大，计算的耗时还是在的，所以会有较长时间的等待时间，此时我们需要考虑加上等待的友好处理</p>
<h5 id="2-采用更轻量级的绘制"><a href="#2-采用更轻量级的绘制" class="headerlink" title="2.采用更轻量级的绘制"></a>2.采用更轻量级的绘制</h5><p>在绘制时，对于不需要响应触摸事件的控件，我们应该尽量避免创建UIView对象，取而代之的是使用更为轻量的CALayer，并且对于一个layer包含多个subLayer的情况时，我们可以通过图层预合成的方法，将多个subLayer合成渲染成一张图片，通过上述的处理，不仅能减少CPU在创建UIKit对象的消耗，还能减少GPU在合成和渲染上的消耗，内存的占用也会少很多</p>
<h5 id="3-异步绘制"><a href="#3-异步绘制" class="headerlink" title="3.异步绘制"></a>3.异步绘制</h5><p>我们将使用<code>YYAsyncLayer</code>组件实现异步绘制</p>
<h2 id="0x02-YYAsyncLayer介绍"><a href="#0x02-YYAsyncLayer介绍" class="headerlink" title="0x02 YYAsyncLayer介绍"></a>0x02 YYAsyncLayer介绍</h2><p>前面两个优化点，平时在做的时候可能也都会去做，但是异步绘制这个该怎么去实现呢？我们直接来看下<code>YYAsyncLayer</code>的代码</p>
<p><code>YYAsyncLayer</code>组件里面一共包含了三个类：<code>YYAsyncLayer</code>、<code>YYSentinel</code>、<code>YYTransaction</code></p>
<p><code>YYAsyncLayer</code>类是我们主要用的类，它是CALayer的子类，是用来异步渲染layer内容</p>
<p><code>YYSentinel</code>类是用来给线程安全计数的，用于在多线程处理的场景</p>
<p><code>YYTransaction</code>类是利用runloop在休眠前的空闲时间来触发你预设的方法</p>
<p>因为我们没有用到<code>YYTransaction</code>类，所以我们直接将<code>YYAsyncLayer</code>、<code>YYSentinel</code>合成一个类，并做了混淆，这样可以少引用一个库</p>
<p>我们首先来看<code>YYAsyncLayer</code>的头文件</p>
<p><code>YYAsyncLayer</code>类只有一个<code>displaysAsynchronously</code>属性，就是设置渲染是否是异步执行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property BOOL displaysAsynchronously;</span><br></pre></td></tr></table></figure>
<p>然后还有个代理方法，这个代理方法的触发时机是在layer的内容需要更新的时候，此时你有个新的绘制任务，然后返回的是个<code>YYAsyncLayerDisplayTask</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;</span><br></pre></td></tr></table></figure>
<p><code>YYAsyncLayerDisplayTask</code>类只有三个block，即将绘制、绘制中、绘制完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);</span><br><span class="line">@property (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));</span><br><span class="line">@property (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);</span><br></pre></td></tr></table></figure>
<p>看到实现文件里面，触发这个代理的方法是<code>- setNeedsDisplay</code>方法，就是当layer需要更新内容的时候，它会向代理发起一个异步绘制的请求，将内容的渲染放到后台队列去做，所以我们在使用<code>YYAsyncLayer</code>类时，我们需要重写<code>+ layerClass</code>方法，返回<code>YYAsyncLayer</code>类，否则会直接调用<code>CALayer</code>的方法，不会触发代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNeedsDisplay &#123;</span><br><span class="line">    [self _cancelAsyncDisplay];</span><br><span class="line">    [super setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)display &#123;</span><br><span class="line">    super.contents = super.contents;</span><br><span class="line">    [self _displayAsync:_displaysAsynchronously];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Private</span><br><span class="line"></span><br><span class="line">- (void)_displayAsync:(BOOL)async &#123;</span><br><span class="line">    __strong id&lt;YYAsyncLayerDelegate&gt; delegate = self.delegate;</span><br><span class="line">    YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>- _displayAsync</code>方法里面主要分成三部分：</p>
<p>如果没有设置display回调，layer的内容会被清空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!task.display) &#123;</span><br><span class="line">    if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">    self.contents = nil;</span><br><span class="line">    if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据之前<code>displaysAsynchronously</code>属性设置判断，如果是同步绘制的话，实际上的操作就是在调用完<code>display</code>block之后，将sublayer合成一张图作为layer的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self increase];</span><br><span class="line">if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(self.bounds.size,self.opaque,self.contentsScale);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">task.display(context, self.bounds.size, ^&#123;return NO;&#125;);</span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">self.contents = (__bridge id)(image.CGImage);</span><br><span class="line">if (task.didDisplay) task.didDisplay(self, YES);</span><br></pre></td></tr></table></figure>
<p>而异步渲染的处理和同步渲染大同小异，第一，多了一个<code>BOOL (^isCancelled)()</code>block，这个block的好处是，在<code>display</code>block调用绘制前，可以通过判断<code>isCancelled</code>布尔值的值来停止绘制，减少性能上的消耗，以及避免出现线程阻塞的情况，比如TableView快速滑动的时候，就可以通过这样的判断，来避免不必要的绘制，提升滑动的流畅性，第二，将上面同步的绘制处理放到了异步去做，绘制方式是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">if (task.willDisplay) task.willDisplay(self);</span><br><span class="line">int32_t value = self.value;</span><br><span class="line">BOOL (^isCancelled)() = ^BOOL() &#123;</span><br><span class="line">    return value != self.value;</span><br><span class="line">&#125;;</span><br><span class="line">CGSize size = self.bounds.size;</span><br><span class="line">BOOL opaque = self.opaque;</span><br><span class="line">CGFloat scale = self.contentsScale;</span><br><span class="line">if (size.width &lt; 1 || size.height &lt; 1) &#123;</span><br><span class="line">    CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</span><br><span class="line">    self.contents = nil;</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        dispatch_async(FIMAsyncLayerGetReleaseQueue(), ^&#123;</span><br><span class="line">            CFRelease(image);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(FIMAsyncLayerGetDisplayQueue(), ^&#123;</span><br><span class="line">    if (isCancelled()) return;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(size, opaque, scale);</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    task.display(context, size, isCancelled);</span><br><span class="line">    if (isCancelled()) &#123;</span><br><span class="line">        UIGraphicsEndImageContext();</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    if (isCancelled()) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            if (task.didDisplay) task.didDisplay(self, NO);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            self.contents = (__bridge id)(image.CGImage);</span><br><span class="line">            if (task.didDisplay) task.didDisplay(self, YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个异步的队列也是自己创建的，在预设了一个队列最大值之后，通过获取运行该进程的系统处于激活状态的处理器数量来创建队列，使得绘制的效率达到最高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_queue_t FIMAsyncLayerGetDisplayQueue() &#123;</span><br><span class="line">#define MAX_QUEUE_COUNT 16</span><br><span class="line">    static int queueCount;</span><br><span class="line">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static int32_t counter = 0;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.FIMkit.render&quot;, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.FIMkit.render&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int32_t cur = OSAtomicIncrement32(&amp;counter);</span><br><span class="line">    if (cur &lt; 0) cur = -cur;</span><br><span class="line">    return queues[(cur) % queueCount];</span><br><span class="line">#undef MAX_QUEUE_COUNT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-补充"><a href="#0x03-补充" class="headerlink" title="0x03 补充"></a>0x03 补充</h2><p>在<code>文本</code>的实现上，我们更加推荐使用CoreText，CoreText对象占用的内存少，而且适用于文本排版复杂的情况，虽然在实现上较为复杂，但是所带来的好处远远要多</p>
<p>在渲染<code>图片</code>时，我们应该在后台把图片绘制到<code>CGBitmapContext</code>中，然后从<code>Bitmap</code>直接创建图片，因为如果使用原来ImageView读取Image的方式是，在创建Image或者CGImageSource对象时，图片数据并不会立即解码，而是等到设置到ImageView或者layer.contents，layer被提交到GPU之前，才解码，并且这些操作都是在主线程进行，是相当耗性能的，所以我们应该用推荐的方式去绘制，而且AFNetworking在对图片处理的时候也是这么做的</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFURLResponseSerializationImage.png" alt=""></p>
<h2 id="0x04-简单实现demo"><a href="#0x04-简单实现demo" class="headerlink" title="0x04 简单实现demo"></a>0x04 简单实现demo</h2><p>对于上述优化点，我实现了一个简单的<a href="https://github.com/Yuzeyang/GCAsyncDisplayDemo" target="_blank" rel="noopener">CoreText demo</a>，可以看一下这个demo做进一步了解~</p>
<h2 id="0x05-相关推荐阅读"><a href="#0x05-相关推荐阅读" class="headerlink" title="0x05 相关推荐阅读"></a>0x05 相关推荐阅读</h2><p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=27&amp;uin=MjI5NjY4NTU%3D&amp;key=7b81aac53bd2393d5c4f70d3d589ce1750179035ed3e4fc89454779d85881a9acd97a28bef1484ddbcfcd3250861abc7&amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.11.6+build(15G31" target="_blank" rel="noopener">iOS 事件处理机制与图像渲染过程</a>&amp;version=12000110&amp;lang=zh_CN&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=JE1V0DIEopWtscTKwaYEiHN6qmvNRu9O60t4vUkn3Ek%3D)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重构完Socket之后，最近我们也开始针对IM的UI做了优化，这次的优化我们主要是参考了&lt;a href=&quot;https://github.com/ibireme/YYKit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YYKit&lt;/a&gt;对于性能方面的优化，前期我的另一个小伙伴&lt;a href=&quot;http://broccoliii.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;西兰花&lt;/a&gt;也对&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AsyncDisplayKit&lt;/a&gt;做了调研，不过这个库理解起来确实要费一番功夫，由于YYkit的核心思路基本上都是学习AsyncDisplayKit的，相信YYkit这个库大家都已经很熟悉了，不过可能还没有看过这个库，那下面我做一个简单的介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="IM 异步绘制" scheme="http://yuzeyang.github.io/tags/IM-%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS Socket重构设计</title>
    <link href="http://yuzeyang.github.io/2016/06/22/GCDAsyncSocket-socket-optimize/"/>
    <id>http://yuzeyang.github.io/2016/06/22/GCDAsyncSocket-socket-optimize/</id>
    <published>2016-06-22T15:02:22.000Z</published>
    <updated>2016-06-23T08:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前基于GCDAsyncSocket封装了一个Socket Manager类，但是由于业务复杂度的上升，之前设计的业务接口的数量逐渐增加，代理回调也随之增加，代理的使用也越来越麻烦，所以我们针对socket通信这块，进行了一次重构</p>
<p>这里有我们的新童鞋<a href="http://broccoliii.me/" target="_blank" rel="noopener">西兰花</a>很大的功劳哈~</p>
<p>代码地址：<a href="https://github.com/Yuzeyang/GCDAsyncSocketManager" target="_blank" rel="noopener">GCDAsyncSocketManager</a></p>
<a id="more"></a>
<p>之前的设计方案可以看这里：<a href="http://zeeyang.com/2016/01/17/GCDAsyncSocket-socket/" target="_blank" rel="noopener">socket重构前方案</a></p>
<p>针对老的设计，我们做出了以下几点修改方向：</p>
<h2 id="0x00-拆分SocketManager"><a href="#0x00-拆分SocketManager" class="headerlink" title="0x00 拆分SocketManager"></a>0x00 拆分SocketManager</h2><p>首先我们对SocketManager进行开刀，我们将socket相关的操作和业务相关的操作进行拆分，将业务相关的单独放到一个类里面完成，我们命名它为CommunicationManager</p>
<p>现在在SocketManager里面，我们只保留了<code>服务器读写数据</code>、<code>断开连接</code>、<code>心跳</code>、<code>重连</code>、<code>GCDAsyncSocket回调设置</code></p>
<p>在CommunicationManager里面，我们做所有业务的操作</p>
<h2 id="0x01-业务接口改为通用接口"><a href="#0x01-业务接口改为通用接口" class="headerlink" title="0x01 业务接口改为通用接口"></a>0x01 业务接口改为通用接口</h2><p>由于业务请求类型的不断增加，业务接口的数量也在不断增加，这样使得头文件一眼望不到底…自己看起来都很头疼，更别说是使用方了…</p>
<p>首先我们将不同的业务请求以枚举的方式列出来，方便外部调用的时候查看，并且最好在枚举后面加上注释，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  业务类型</span><br><span class="line"> */</span><br><span class="line">typedef NS_ENUM(NSInteger, FIMRequestType) &#123;</span><br><span class="line">    FIMRequestType_Beat = 1,                       //心跳</span><br><span class="line">    FIMRequestType_ConnectionAuthAppraisal,        //连接鉴权</span><br><span class="line">  	FIMRequestType_GetConversationsList,           //获取会话列表</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以将业务接口用下面这一个通用的接口替换掉，只需要传<code>type</code>业务请求类型，<code>body</code>请求体和<code>callback</code>回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  向服务器发送数据</span><br><span class="line"> *</span><br><span class="line"> *  @param type    请求类型</span><br><span class="line"> *  @param body    请求体</span><br><span class="line"> */</span><br><span class="line">- (void)socketWriteDataWithRequestType:(FIMRequestType)type</span><br><span class="line">                           requestBody:(nonnull NSDictionary *)body</span><br><span class="line">                            completion:(nullable SocketDidReadBlock)callback;</span><br></pre></td></tr></table></figure>
<p>比如业务方可以如下使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *requestBody = @&#123; @&quot;limit&quot;: @(10), @&quot;offset&quot;: @(0) &#125;;</span><br><span class="line">[[FIMCommunicationManager sharedInstance]</span><br><span class="line">socketWriteDataWithRequestType:FIMRequestType_GetConversationsList</span><br><span class="line">                   requestBody:requestBody</span><br><span class="line">                    completion:^(NSError *error, id data) &#123;</span><br><span class="line">                        // do something</span><br><span class="line">                    &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="0x02-告别Delegate，使用Blcok"><a href="#0x02-告别Delegate，使用Blcok" class="headerlink" title="0x02 告别Delegate，使用Blcok"></a>0x02 告别Delegate，使用Blcok</h2><p>前面也提到，之前会对不同的业务请求，设定相应的delegate回调，但是数量一多，使用起来那真的是槽糕，所以我们参考<code>AFNetworking</code>的做法，发起请求时将block与一个唯一标识进行绑定，同时将这个唯一标识放到请求里面发给服务器（服务器对该标识不做任何处理），在等到GCDAsyncSocket回调回来的时候，我们通过服务器返回的这个标识，找到对应的block回调出去，这样对业务方来说，这个socket接口用起来其实和HTTP请求接口是一模一样的，将请求的上下文也关联起来了</p>
<p>如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/replaceDelegate.png" alt=""></p>
<p>具体实现：</p>
<p>发起请求时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)socketWriteDataWithRequestType:(FIMRequestType)type</span><br><span class="line">                           requestBody:(nonnull NSDictionary *)body</span><br><span class="line">                            completion:(nullable SocketDidReadBlock)callback &#123;</span><br><span class="line">  // ...                            </span><br><span class="line">   </span><br><span class="line">  // 生成唯一标识</span><br><span class="line">  NSString *blockRequestID = [self createRequestID];</span><br><span class="line">  if (callback) &#123;</span><br><span class="line">      // 将block和标识进行绑定，存到一个全局变量里面</span><br><span class="line">      [self.requestsMap setObject:callback forKey:blockRequestID];</span><br><span class="line">  &#125;</span><br><span class="line">                              </span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收到GCDAsyncSocket回调时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &#123;</span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">  // 根据服务器返回的标识得到相应的block</span><br><span class="line">  SocketDidReadBlock didReadBlock = self.requestsMap[requestID];</span><br><span class="line">  </span><br><span class="line">  switch (requestType) &#123;</span><br><span class="line">        case FIMRequestType_ConnectionAuthAppraisal: &#123;</span><br><span class="line">            if (didReadBlock) &#123;</span><br><span class="line">                didReadBlock(nil, nil);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break;</span><br><span class="line">    	// ...</span><br><span class="line">    	default: &#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125; break;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-使用模拟服务器时间，来解决缓存消息保序问题"><a href="#0x03-使用模拟服务器时间，来解决缓存消息保序问题" class="headerlink" title="0x03 使用模拟服务器时间，来解决缓存消息保序问题"></a>0x03 使用模拟服务器时间，来解决缓存消息保序问题</h2><p>在socket模块里面，我们基于FMDB实现了一套缓存机制，但是聊天页面对数据库读写操作的场景非常复杂，而且我们对发送失败的消息也进行了缓存，如果使用msgID对消息进行保序，你要考虑发送成功和失败消息的排序，以及重发消息之后的排序，等等场景，这样实现起来也会很让人头大</p>
<p>所以我们采用<code>消息的创建时间</code>来进行保序，这样不管消息是怎么操作的，从数据库里面读出来的数据，我们只需要根据创建时间来排下序返回给业务层，如果业务层对数据进行修改的时候，我们更新消息的创建时间，这样下次取出来的顺序和UI展示的顺序也还是一样的</p>
<p>那这个创建时间是由服务器生成的，而且消息发送成功之后，服务器也不会返回给我们这条消息的创建时间，而且失败的消息服务器那边是不会存的，所以就需要我们本地模拟服务器来生成这个时间</p>
<p>因为考虑到本地时间和服务器时间存在偏差，所以我们在socket建立连接成功之后，返回给我们服务器时间，我们拿到服务器时间之后和手机的本地时间做个比较，记录下这个偏差值，然后业务层在调用发送消息的接口时，socket内部模拟出服务器创建时间赋值给该消息，然后存到数据库里面，这样就可以基本保证数据库存储消息的顺序和服务器的顺序是一致的</p>
<p>如图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/serverCreateTime.png" alt=""></p>
<h2 id="0x04-监听网络状态来改变socket连接状态"><a href="#0x04-监听网络状态来改变socket连接状态" class="headerlink" title="0x04 监听网络状态来改变socket连接状态"></a>0x04 监听网络状态来改变socket连接状态</h2><p>我们对socket连接状态也做了微调，我们通过测试微信的连接，发现以下两点：</p>
<p>1、网络断开后，socket直接断开，显示“未连接”</p>
<p>2、有网但是socket连接不上时，socket会一直重连，重连n次后，休眠几秒后，再重连，如此循环</p>
<p>所以我们也对socket连接做了调整，用<code>AFNetWorking</code>库里面监测网络状态类<code>AFNetworkReachabilityManager</code>（<a href="http://zeeyang.com/2016/05/23/AFNetWorking-four/" target="_blank" rel="noopener">AFNetworkReachabilityManager原理</a>），在无网时，判断如果socket正在连接或者已连接时，我们主动调用<code>disconnect</code>断开连接，如果有网，判断如果socket未连接，我们主动建立连接，建立连接不成功的情况时，我们走重连的流程，只是我们依旧保持了重连n次后，n次失败后不再重连了，这个是与微信不同的地方</p>
<h2 id="0x05-使用FIMSocketModel"><a href="#0x05-使用FIMSocketModel" class="headerlink" title="0x05 使用FIMSocketModel"></a>0x05 使用FIMSocketModel</h2><p>因为请求的数据结构基本一样，所以我们定义了FIMSocketModel类来方便对数据的转化，我们定义了几个必传的字段，以及可能请求不同所需的一些非必传字段，由于之前我们body体里面的内容是做了2次JSON转化处理的，所以业务层传入body内容时叫苦连天，FIMSocketModel也增加了<code>- socketModelToJSONString</code>方法，方便Socket内部转化成JSON处理，这样业务层只需要传一个字典进来，Socket内部就会处理好一切，使用起来一下就方便了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前基于GCDAsyncSocket封装了一个Socket Manager类，但是由于业务复杂度的上升，之前设计的业务接口的数量逐渐增加，代理回调也随之增加，代理的使用也越来越麻烦，所以我们针对socket通信这块，进行了一次重构&lt;/p&gt;
&lt;p&gt;这里有我们的新童鞋&lt;a href=&quot;http://broccoliii.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;西兰花&lt;/a&gt;很大的功劳哈~&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCDAsyncSocketManager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GCDAsyncSocketManager&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Socket" scheme="http://yuzeyang.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>客户端生成七牛上传token</title>
    <link href="http://yuzeyang.github.io/2016/06/13/Qiniu-token/"/>
    <id>http://yuzeyang.github.io/2016/06/13/Qiniu-token/</id>
    <published>2016-06-13T15:07:54.000Z</published>
    <updated>2016-06-13T16:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用七牛iOS SDK上传图片时需要用到上传的token，虽然七牛建议token不要在客户端生成，这样做是不安全的，但是我们还是需要了解下客户端是如何生成token的</p>
<a id="more"></a>
<p>我简单地对生成token和上传数据做了封装，这是代码地址：<a href="https://github.com/Yuzeyang/GCQiniuUploadManager" target="_blank" rel="noopener">provide simple interface to create token,upload file and upload files</a></p>
<p>首先我们需要用到三个参数<code>scope</code>、<code>AccessKey</code>和<code>SecretKey</code></p>
<p><code>scope</code>其实就是资源存放的文件夹名字，例如下图的<code>cmxj</code></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Qiniu_scope.png" alt=""></p>
<p><code>AccessKey</code>和<code>SecretKey</code>在个人面板 -&gt; 个人中心 -&gt; 密钥管理里面就能看到</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Qiniu_AK_SK.png" alt=""></p>
<p>接下来就可以创建token了，首先我们将上传策略中的<code>scope</code>和<code>deadline</code>序列化成json格式，里面的<code>liveTime</code>则是token的有效时间，可以以天为单位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *authInfo = [NSMutableDictionary dictionary];</span><br><span class="line">[authInfo setObject:self.scope forKey:@&quot;scope&quot;];</span><br><span class="line">[authInfo</span><br><span class="line">setObject:[NSNumber numberWithLong:[[NSDate date] timeIntervalSince1970] + self.liveTime * 24 * 3600]</span><br><span class="line">   forKey:@&quot;deadline&quot;];</span><br><span class="line"></span><br><span class="line">NSData *jsonData =</span><br><span class="line">[NSJSONSerialization dataWithJSONObject:authInfo options:NSJSONWritingPrettyPrinted error:nil];</span><br></pre></td></tr></table></figure>
<p>再对json序列化后的上传策略进行URL安全的base64编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *encodedString = [self urlSafeBase64Encode:jsonData];</span><br></pre></td></tr></table></figure>
<p><code>QN_GTM_Base64</code>是七牛SDK提供给用户用来处理base64和WebSafeBase64编码的类，然后将里面的<code>+</code>和<code>/</code>替换成<code>_</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)urlSafeBase64Encode:(NSData *)text &#123;</span><br><span class="line">    NSString *base64 =</span><br><span class="line">    [[NSString alloc] initWithData:[QN_GTM_Base64 encodeData:text] encoding:NSUTF8StringEncoding];</span><br><span class="line">    base64 = [base64 stringByReplacingOccurrencesOfString:@&quot;+&quot; withString:@&quot;-&quot;];</span><br><span class="line">    base64 = [base64 stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;_&quot;];</span><br><span class="line">    return base64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用secretKey对编码后的上传策略进行HMAC-SHA1加密，并且做安全的base64编码，得到encoded_signed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *encodedSignedString = [self HMACSHA1:self.secretKey text:encodedString];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)HMACSHA1:(NSString *)key text:(NSString *)text &#123;</span><br><span class="line">    const char *cKey = [key cStringUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    const char *cData = [text cStringUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    char cHMAC[CC_SHA1_DIGEST_LENGTH];</span><br><span class="line"></span><br><span class="line">    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), cData, strlen(cData), cHMAC);</span><br><span class="line"></span><br><span class="line">    NSData *HMAC = [[NSData alloc] initWithBytes:cHMAC length:CC_SHA1_DIGEST_LENGTH];</span><br><span class="line">    NSString *hash = [self urlSafeBase64Encode:HMAC];</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将accessKey、encodedSignedString和encodedString拼接，中间用：分开，得到的就是上传的token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *token =</span><br><span class="line">    [NSString stringWithFormat:@&quot;%@:%@:%@&quot;, self.accessKey, encodedSignedString, encodedString];</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用七牛iOS SDK上传图片时需要用到上传的token，虽然七牛建议token不要在客户端生成，这样做是不安全的，但是我们还是需要了解下客户端是如何生成token的&lt;/p&gt;
    
    </summary>
    
    
      <category term="七牛 token" scheme="http://yuzeyang.github.io/tags/%E4%B8%83%E7%89%9B-token/"/>
    
  </entry>
  
  <entry>
    <title>模仿iOS7 task switcher的卡片动画</title>
    <link href="http://yuzeyang.github.io/2016/06/11/iOS-card-animation/"/>
    <id>http://yuzeyang.github.io/2016/06/11/iOS-card-animation/</id>
    <published>2016-06-11T02:20:29.000Z</published>
    <updated>2016-06-11T09:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一个iOS9的task switcher开源实现，但是没有删除功能，就想着干脆做一个模仿iOS7系统的效果，加上删除和重用卡片功能，效果图如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/GCCardViewController.gif!500x500" alt=""></p>
<p>这是代码地址：<a href="https://github.com/Yuzeyang/GCCardViewController" target="_blank" rel="noopener">https://github.com/Yuzeyang/GCCardViewController</a></p>
<a id="more"></a>
<p>实现上可以使用scrollView或者collectionView去做，这个我是用scrollView去做</p>
<p>功能点上分为三点：</p>
<p>1.卡片滑动的效果</p>
<p>2.卡片重用</p>
<p>3.卡片删除</p>
<h2 id="卡片滑动效果"><a href="#卡片滑动效果" class="headerlink" title="卡片滑动效果"></a>卡片滑动效果</h2><p>通过- [scrollViewDidScroll:]代理获取scrollView滑动时的contentOffset值，计算当前contentOffset和原先contentOffset之间的差值diff，再算出进度值progress，以及根据差值diff是否大于0来获取卡片的滑动方向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</span><br><span class="line">    CGFloat orginContentOffset = self.currentCardIndex*kGCScrollViewWidth;</span><br><span class="line">    CGFloat diff = scrollView.contentOffset.x - orginContentOffset;</span><br><span class="line">    CGFloat progress = fabs(diff)/(kGCViewWidth*0.8);</span><br><span class="line">    CardMoveDirection direction = diff &gt; 0 ? CardMoveDirectionLeft : CardMoveDirectionRight;</span><br><span class="line">    for (UIView *card in self.cards) &#123;</span><br><span class="line">        [self.cardDelegate updateCard:card withProgress:progress direction:direction];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 卡片重用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用自己的cardDelegate方法更新卡片的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateCard:(UIView *)card withProgress:(CGFloat)progress direction:(CardMoveDirection)direction;</span><br></pre></td></tr></table></figure>
<p>当前卡片不管是左移还是右移，只需要根据progress来更新状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">card.layer.transform = CATransform3DMakeScale(1 - 0.1 * progress, 1 - 0.1 * progress, 1.0);</span><br><span class="line">card.layer.opacity = 1 - 0.2*progress;</span><br></pre></td></tr></table></figure>
<p>根据左移还是右移，来决定改变当前卡片下一张还是上一张卡片的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSInteger transCardTag = direction == CardMoveDirectionLeft ? [self.cardScrollView currentCard] + 1 : [self.cardScrollView currentCard] - 1;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">card.layer.transform = CATransform3DMakeScale(0.9 + 0.1*progress, 0.9 + 0.1*progress, 1.0);</span><br><span class="line">card.layer.opacity = 0.8 + 0.2*progress;</span><br></pre></td></tr></table></figure>
<h2 id="卡片重用"><a href="#卡片重用" class="headerlink" title="卡片重用"></a>卡片重用</h2><p>由于页面上只显示三张卡片，所以要重用卡片的话，我们需要初始化四张卡片，类似于tableViewCell的重用处理一样，当第一张卡片离开屏幕显示之后，将第一张卡片移到最后一张卡片的后面，反之，同理</p>
<p>在- [scrollViewDidScroll:]里面，根据contentOffset变化的绝对值大于scrollView宽度的80%时，对卡片进行重用，以及改变当前的index</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (fabs(diff) &gt;= kGCScrollViewWidth*0.8) &#123;</span><br><span class="line">        self.currentCardIndex = direction == CardMoveDirectionLeft ? self.currentCardIndex + 1 : self.currentCardIndex - 1;</span><br><span class="line">        [self reuseCardWithMoveDirection:direction];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在重用之前，并不是所有位置都需要重用，在index（index从0开始计算）小于2或者index大于总卡片数量-3的时候，才需要重用，左移时，取出cards数组里面第一个card，将card移到最后一个card后面，改变它的center就可以，右移时，取出最后一个card，移到第一个card前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)reuseCardWithMoveDirection:(CardMoveDirection)moveDirection &#123;</span><br><span class="line">    BOOL isLeft = moveDirection == CardMoveDirectionLeft;</span><br><span class="line">    UIView *card = nil;</span><br><span class="line">    if (isLeft) &#123;</span><br><span class="line">        if (self.currentCardIndex &gt; self.totalNumberOfCards - 3 || self.currentCardIndex &lt; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        card = [self.cards objectAtIndex:0];</span><br><span class="line">        card.tag+=4;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (self.currentCardIndex &gt; self.totalNumberOfCards - 4 ||</span><br><span class="line">            self.currentCardIndex &lt; 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        card = [self.cards objectAtIndex:3];</span><br><span class="line">        card.tag-=4;</span><br><span class="line">    &#125;</span><br><span class="line">    card.center = [self centerForCardWithIndex:card.tag];</span><br><span class="line">    [self.cardDataSource cardReuseView:card atIndex:card.tag];</span><br><span class="line">    [self ascendingSortCards];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且调用- [cardReuseView:atIndex:]对重用的卡片改变数据源，最后按tag值升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)cardReuseView:(UIView *)reuseView atIndex:(NSInteger)index &#123;</span><br><span class="line">    if (reuseView) &#123;</span><br><span class="line">        // you can set new style</span><br><span class="line">        return reuseView;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UIView *card = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kGCCardWidth * 0.9, kGCCardHeight)];</span><br><span class="line">    card.layer.backgroundColor = [UIColor whiteColor].CGColor;</span><br><span class="line">    card.layer.cornerRadius = 4;</span><br><span class="line">    card.layer.masksToBounds = YES;</span><br><span class="line">    </span><br><span class="line">    return card;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="卡片删除"><a href="#卡片删除" class="headerlink" title="卡片删除"></a>卡片删除</h2><p>卡片删除是一个可选功能，通过设置canDeleteCard来添加手势</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) BOOL canDeleteCard;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (self.canDeleteCard) &#123;</span><br><span class="line">    UIPanGestureRecognizer *deleteGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(deleteCard:)];</span><br><span class="line">    deleteGesture.minimumNumberOfTouches = 1;</span><br><span class="line">    deleteGesture.maximumNumberOfTouches = 1;</span><br><span class="line">    deleteGesture.delegate = self;</span><br><span class="line">    [card addGestureRecognizer:deleteGesture];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于卡片有拖动手势和scrollView也有拖动手势，这两个手势会出现冲突，所以我们需要根据手势的方向来判断到底应该是作用于卡片上还是scrollView上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123;</span><br><span class="line">    if ([gestureRecognizer isKindOfClass:[UIPanGestureRecognizer class]]) &#123;</span><br><span class="line">        CGPoint translatedPoint = [(UIPanGestureRecognizer *)gestureRecognizer translationInView:gestureRecognizer.view];</span><br><span class="line">        if (fabs(translatedPoint.y) &gt; fabs(translatedPoint.x)) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用卡片删除手势时，向下拖动时不做删除，向上拖动屏幕高度的一半后，删除卡片，并且重用删除后的卡片，这部分重用相对比较复杂</p>
<h5 id="当卡片小于等于四张时，我们直接移除当前的卡片"><a href="#当卡片小于等于四张时，我们直接移除当前的卡片" class="headerlink" title="当卡片小于等于四张时，我们直接移除当前的卡片"></a>当卡片小于等于四张时，我们直接移除当前的卡片</h5><p>-&gt; 如果当前卡片index为0时 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>-&gt; 如果当前卡片index为最后一张时 -&gt; 左边的卡片右移 -&gt; 左边卡片的tag不变</p>
<p>-&gt; 如果当前卡片index为中间时 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>最后按升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (self.totalNumberOfCards &lt;= 4) &#123;</span><br><span class="line">    [(UIView *)[self.cards objectAtIndex:index] removeFromSuperview];</span><br><span class="line">    [self resetTagFromIndex:index];</span><br><span class="line">    [self.cards removeObjectAtIndex:index];</span><br><span class="line">    [self ascendingSortCards];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)resetTagFromIndex:(NSInteger)index &#123;</span><br><span class="line">    [self.cards enumerateObjectsUsingBlock:^(UIView *card, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ((NSInteger)idx &gt; index) &#123;</span><br><span class="line">            card.tag-=1;</span><br><span class="line">            [UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">                card.center = [self centerForCardWithIndex:card.tag];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当卡片超过四张时，我们需要重用删除的卡片</p>
<p>-&gt; 如果当前卡片index为0时 -&gt; 卡片的tag值加4 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>-&gt; 如果当前卡片index为最后一张时 -&gt; 卡片的tag值减4 -&gt; 左边的卡片右移 -&gt; 左边卡片的tag不变</p>
<p>-&gt; 如果当前卡片index为中间时 -&gt; 以四个卡片为一组，获取第一个卡片和最后一个卡片的tag值 -&gt; 判读最后一个卡片是否是最后一张卡片 -&gt; 如果是，则将卡片移到第一张卡片的左边，如果不是，则将卡片移到最后一张卡片的右边 -&gt; 右边的卡片左移 -&gt; 右边卡片的tag均减1</p>
<p>最后按升序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">UIView *card = [self.cards objectAtIndex:index];</span><br><span class="line">NSInteger fromIndex = index;</span><br><span class="line">if (index == 0) &#123;</span><br><span class="line">    card.tag+=4;</span><br><span class="line">    fromIndex = index - 1;</span><br><span class="line">&#125; else if (index == 3) &#123;</span><br><span class="line">    card.tag-=4;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSInteger lastTag = ((UIView *)[self.cards lastObject]).tag;</span><br><span class="line">    NSInteger firstTag = ((UIView *)[self.cards firstObject]).tag;</span><br><span class="line">    if (lastTag == self.totalNumberOfCards - 1) &#123;</span><br><span class="line">        card.tag = firstTag - 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        card.tag = lastTag + 1;</span><br><span class="line">        fromIndex = index - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">card.center = [self centerForCardWithIndex:card.tag];</span><br><span class="line">[self ascendingSortCards];</span><br><span class="line">[self resetTagFromIndex:fromIndex];</span><br><span class="line">[self.cardDataSource cardReuseView:card atIndex:card.tag];</span><br></pre></td></tr></table></figure>
<p>最后只要改变scrollView的contentSize和卡片状态即可~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">    [self.scrollView setContentSize:CGSizeMake(kGCScrollViewWidth*self.totalNumberOfCards, kGCViewHeight)];</span><br><span class="line">    for (UIView *card in self.cards) &#123;</span><br><span class="line">        [self.cardDelegate updateCard:card withProgress:1 direction:CardMoveDirectionNone];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到一个iOS9的task switcher开源实现，但是没有删除功能，就想着干脆做一个模仿iOS7系统的效果，加上删除和重用卡片功能，效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCCardViewController.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCCardViewController&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Yuzeyang/GCCardViewController&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="task switcher" scheme="http://yuzeyang.github.io/tags/task-switcher/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（六）</title>
    <link href="http://yuzeyang.github.io/2016/05/27/AFNetWorking-six/"/>
    <id>http://yuzeyang.github.io/2016/05/27/AFNetWorking-six/</id>
    <published>2016-05-27T01:44:43.000Z</published>
    <updated>2016-06-12T15:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFURLResponseSerialization</code>是用来将返回的response处理成相应的格式，它通过协议对特定response的data进行解码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response</span><br><span class="line">                           data:(nullable NSData *)data</span><br><span class="line">                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>AFHTTPResponseSerializer</code>可以通过<code>+ serializer</code>和<code>- init</code>方法进行初始化，实际上<code>+ serializer</code>内只是调用了<code>- init</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)serializer &#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	// 设置字符串编码类型，可接受的状态码，可接受的MIME类型</span><br><span class="line">    self.stringEncoding = NSUTF8StringEncoding;</span><br><span class="line">	self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];</span><br><span class="line">    self.acceptableContentTypes = nil;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acceptableStatusCodes和acceptableContentTypes可以通过外部进行设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy, nullable) NSIndexSet *acceptableStatusCodes;</span><br><span class="line">@property (nonatomic, copy, nullable) NSSet &lt;NSString *&gt; *acceptableContentTypes;</span><br></pre></td></tr></table></figure>
<p>然后可以调用<code>- [validateResponse:data:error:]</code>检查这个response是否包含可接受的状态码和可接受MIME类型来验证response的有效性，子类也可以增加特定域名检查，<code>- [responseObjectForResponse:data:error]</code>也是调用了这个方法，返回data</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 调用- [validateResponse:data:error:]方法，返回data </span><br><span class="line">    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</span><br><span class="line">                    data:(NSData *)data</span><br><span class="line">                   error:(NSError * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 设置初始值</span><br><span class="line">    BOOL responseIsValid = YES;</span><br><span class="line">    NSError *validationError = nil;</span><br><span class="line"></span><br><span class="line">    // 检查这个response是否包含可接受的状态码和可接受MIME类型</span><br><span class="line"></span><br><span class="line">    if (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回response是否有效性</span><br><span class="line">    return responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查这个response是否包含可接受的状态码和可接受MIME类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 检查response是否为空，以及response是否是NSHTTPURLResponse类</span><br><span class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</span><br><span class="line">        // acceptableContentTypes不为空并且response的MIME类型不在可接受的范围里</span><br><span class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]]) &#123;</span><br><span class="line">            </span><br><span class="line">            // 包装错误信息</span><br><span class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</span><br><span class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</span><br><span class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</span><br><span class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                                        &#125; mutableCopy];</span><br><span class="line">                if (data) &#123;</span><br><span class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        // acceptableStatusCodes不为空并且acceptableStatusCodes包含response的状态码，response的URL也存在</span><br><span class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">            // 包装错误信息</span><br><span class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</span><br><span class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</span><br><span class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                       &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line">            if (data) &#123;</span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</span><br><span class="line"></span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是这里有个疑问，假如response为nil或者response不是<code>NSHTTPURLResponse</code>类，那下面的操作均不会对responseIsValid布尔值进行修改，最后返回的是个YES，但是这样的response不应该是NO么？</p>
<hr>
<p><code>AFJSONResponseSerializer</code>是继承于<code>AFHTTPResponseSerializer</code></p>
<p>外部可以设置<code>NSJSONReadingOptions</code>和是否移除空值的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) NSJSONReadingOptions readingOptions;</span><br><span class="line">@property (nonatomic, assign) BOOL removesKeysWithNullValues;</span><br></pre></td></tr></table></figure>
<p>转换object的时候，会检查data是否是空格，这个是Safari的一个bug，具体请看<a href="https://github.com/rails/rails/issues/1742" target="_blank" rel="noopener">Workaround for behavior of Rails to return a single space for <code>head :ok</code> (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</span><br><span class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id responseObject = nil;</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    // 判断是否是空格</span><br><span class="line">    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&quot; &quot; length:1]];</span><br><span class="line">    if (data.length &gt; 0 &amp;&amp; !isSpace) &#123;</span><br><span class="line">        responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用AFJSONObjectByRemovingKeysWithNullValues把空值的key都移除掉，返回object</span><br><span class="line">    if (self.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</span><br><span class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>AFXMLParserResponseSerializer</code>则是直接校验response后，用data初始化NSXMLParser对象并返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSHTTPURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</span><br><span class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [[NSXMLParser alloc] initWithData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>AFPropertyListResponseSerializer</code>也是类似的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</span><br><span class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id responseObject;</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line"></span><br><span class="line">    if (data) &#123;</span><br><span class="line">        responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&amp;serializationError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>AFImageResponseSerializer</code>在验证response之后，会根据设置是否自动解压automaticallyInflatesResponseImage布尔值，来对imageData按图片比例返回UIImage对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) CGFloat imageScale;</span><br><span class="line">@property (nonatomic, assign) BOOL automaticallyInflatesResponseImage;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</span><br><span class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH</span><br><span class="line">    // iOS需要手动解压图片</span><br><span class="line">    if (self.automaticallyInflatesResponseImage) &#123;</span><br><span class="line">        return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return AFImageWithDataAtScale(data, self.imageScale);</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    // MacOS可以直接使用NSBitmapImageRep来解压</span><br><span class="line">    NSBitmapImageRep *bitimage = [[NSBitmapImageRep alloc] initWithData:data];</span><br><span class="line">    NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize([bitimage pixelsWide], [bitimage pixelsHigh])];</span><br><span class="line">    [image addRepresentation:bitimage];</span><br><span class="line"></span><br><span class="line">    return image;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不解压的话，就直接根据imageData和scale来创建Image，但是这有个疑问是，AF为什么要创建两次image，我觉得可以直接使用- [imageWithData:scale:]方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) &#123;</span><br><span class="line">    UIImage *image = [UIImage af_safeImageWithData:data];</span><br><span class="line">    if (image.images) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果用imageWithData转成UIImage对象后，由于网络图片PNG和JPG都是压缩格式，需要解压成bitmap后才能渲染到屏幕，这时会在主线程对图片进行解压操作，这是比较耗时的，可能还会对主线程造成阻塞，所以AF还提供了<code>AFInflatedImageFromResponseWithDataAtScale</code>方法，对PNG和JPG解压后，返回UIImage对象，这样避免了在主线程的解压操作，不会对主线程造成卡顿</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) &#123;</span><br><span class="line">    if (!data || [data length] == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">	// 创建CGImageRef</span><br><span class="line">    CGImageRef imageRef = NULL;</span><br><span class="line">    // 用data创建CGDataProviderRef</span><br><span class="line">    CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);</span><br><span class="line"></span><br><span class="line">    if ([response.MIMEType isEqualToString:@&quot;image/png&quot;]) &#123;</span><br><span class="line">        imageRef = CGImageCreateWithPNGDataProvider(dataProvider,  NULL, true, kCGRenderingIntentDefault);</span><br><span class="line">    &#125; else if ([response.MIMEType isEqualToString:@&quot;image/jpeg&quot;]) &#123;</span><br><span class="line">        imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);</span><br><span class="line"></span><br><span class="line">        if (imageRef) &#123;</span><br><span class="line">            CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);</span><br><span class="line">            CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);</span><br><span class="line"></span><br><span class="line">            // 如果色彩空间是CMKY，CGImageCreateWithJPEGDataProvider是不会进行处理的，也就是不进行解压，将调用AFImageWithDataAtScale返回image</span><br><span class="line">            if (imageColorSpaceModel == kCGColorSpaceModelCMYK) &#123;</span><br><span class="line">                CGImageRelease(imageRef);</span><br><span class="line">                imageRef = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CGDataProviderRelease(dataProvider);</span><br><span class="line">	// 不符合解压条件的，将调用AFImageWithDataAtScale返回image，但是这里如果符合解压条件的也会调用，以及下面会对超出大小的，直接返回image，这里我觉得应该统一对不符合条件的返回image，符合条件的就不需要调用AFImageWithDataAtScale</span><br><span class="line">    UIImage *image = AFImageWithDataAtScale(data, scale);</span><br><span class="line">    if (!imageRef) &#123;</span><br><span class="line">        if (image.images || !image) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">		// 这里调用CGImageCreateCopy，只会对图形本身结构进行拷贝，底层的数据是不会拷贝的</span><br><span class="line">        imageRef = CGImageCreateCopy([image CGImage]);</span><br><span class="line">        if (!imageRef) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	// 设置图片的宽和高和存储一个像素所需要用到的字节</span><br><span class="line">    size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">    size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">    size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);</span><br><span class="line">	// 如果图片大小宽高乘积超过1024*1024或者bitsPerComponent大于8都不解压了，因为bitmap是一直存在UIImage对象里的，可能会把内存爆了</span><br><span class="line">    if (width * height &gt; 1024 * 1024 || bitsPerComponent &gt; 8) &#123;</span><br><span class="line">        CGImageRelease(imageRef);</span><br><span class="line"></span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 画布参数</span><br><span class="line">    size_t bytesPerRow = 0;</span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);</span><br><span class="line">    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);</span><br><span class="line"></span><br><span class="line">    if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;</span><br><span class="line">        uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;</span><br><span class="line">        if (alpha == kCGImageAlphaNone) &#123;</span><br><span class="line">            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">            bitmapInfo |= kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        &#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;</span><br><span class="line">            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">            bitmapInfo |= kCGImageAlphaPremultipliedFirst;</span><br><span class="line">        &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;</span><br><span class="line">	// 创建画布</span><br><span class="line">    CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);</span><br><span class="line"></span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line"></span><br><span class="line">    if (!context) &#123;</span><br><span class="line">        CGImageRelease(imageRef);</span><br><span class="line"></span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">	// 在画布上画出图片</span><br><span class="line">    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);</span><br><span class="line">    // 保存成CGImageRef</span><br><span class="line">  	CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);</span><br><span class="line"></span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">	// 再转成UIImage对象</span><br><span class="line">    UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];</span><br><span class="line"></span><br><span class="line">    CGImageRelease(inflatedImageRef);</span><br><span class="line">    CGImageRelease(imageRef);</span><br><span class="line"></span><br><span class="line">    return inflatedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>AFCompoundResponseSerializer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 遍历responseSerializers                    </span><br><span class="line">    for (id &lt;AFURLResponseSerialization&gt; serializer in self.responseSerializers) &#123;</span><br><span class="line">        // 如果serializer不是AFHTTPResponseSerializer类，则继续</span><br><span class="line">      	if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSError *serializerError = nil;</span><br><span class="line">        // 一层一层的调用自己的- [responseObjectForResponse:data:error:]，直到返回responseObject</span><br><span class="line">        id responseObject = [serializer responseObjectForResponse:response data:data error:&amp;serializerError];</span><br><span class="line">        if (responseObject) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                *error = AFErrorWithUnderlyingError(serializerError, *error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return responseObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [super responseObjectForResponse:response data:data error:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFURLResponseSerialization&lt;/code&gt;是用来将返回的response处理成相应的格式，它通过协议对特定response的data进行解码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                           data:(nullable NSData *)data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（五）</title>
    <link href="http://yuzeyang.github.io/2016/05/25/AFNetWorking-five/"/>
    <id>http://yuzeyang.github.io/2016/05/25/AFNetWorking-five/</id>
    <published>2016-05-25T12:49:32.000Z</published>
    <updated>2016-06-12T15:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFURLRequestSerialization</code>是用来对发出的请求进行一些处理</p>
<a id="more"></a>
<p><code>AFPercentEscapedStringFromString</code>方法将string里面的:#[]@!$&amp;’()*+,;=字符替换成%</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">NSString * AFPercentEscapedStringFromString(NSString *string) &#123;</span><br><span class="line">  	static NSString * const kAFCharactersGeneralDelimitersToEncode = @&quot;:#[]@&quot;; // does not include &quot;?&quot; or &quot;/&quot; due to RFC 3986 - Section 3.4</span><br><span class="line">    static NSString * const kAFCharactersSubDelimitersToEncode = @&quot;!$&amp;&apos;()*+,;=&quot;;</span><br><span class="line">	</span><br><span class="line">  	// 从可用字符替换删除掉:#[]@!$&amp;&apos;()*+,;=这些字符</span><br><span class="line">    NSMutableCharacterSet * allowedCharacterSet = [[NSCharacterSet URLQueryAllowedCharacterSet] mutableCopy];</span><br><span class="line">    [allowedCharacterSet removeCharactersInString:[kAFCharactersGeneralDelimitersToEncode stringByAppendingString:kAFCharactersSubDelimitersToEncode]];</span><br><span class="line"></span><br><span class="line">	// FIXME: https://github.com/AFNetworking/AFNetworking/pull/3028</span><br><span class="line">    // return [string stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet];</span><br><span class="line">	</span><br><span class="line">  	// 声明批量处理的大小为50</span><br><span class="line">    static NSUInteger const batchSize = 50;</span><br><span class="line"></span><br><span class="line">    NSUInteger index = 0;</span><br><span class="line">    NSMutableString *escaped = @&quot;&quot;.mutableCopy;</span><br><span class="line">	</span><br><span class="line">  	// 循环将string里面:#[]@!$&amp;&apos;()*+,;=的字符替换成%</span><br><span class="line">    while (index &lt; string.length) &#123;</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">        NSUInteger length = MIN(string.length - index, batchSize);</span><br><span class="line">#pragma GCC diagnostic pop</span><br><span class="line">        NSRange range = NSMakeRange(index, length);</span><br><span class="line"></span><br><span class="line">        // To avoid breaking up character sequences such as 👴🏻👮🏽</span><br><span class="line">        range = [string rangeOfComposedCharacterSequencesForRange:range];</span><br><span class="line"></span><br><span class="line">        NSString *substring = [string substringWithRange:range];</span><br><span class="line">        NSString *encoded = [substring stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet];</span><br><span class="line">        [escaped appendString:encoded];</span><br><span class="line"></span><br><span class="line">        index += range.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return escaped;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>AFQueryStringPair</code>类里面有个<code>- URLEncodedStringValue</code>方法，将请求里面的URL参数转成field=value形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)URLEncodedStringValue &#123;</span><br><span class="line">    if (!self.value || [self.value isEqual:[NSNull null]]) &#123;</span><br><span class="line">        return AFPercentEscapedStringFromString([self.field description]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [NSString stringWithFormat:@&quot;%@=%@&quot;, AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字典里面是我们查询的key和value，我们通过将字典内容转成<code>AFQueryStringPair</code>对象，调用<code>- URLEncodedStringValue</code>方法，转成key=value，放到mutablePairs数组里，最后用&amp;符拼接起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123;</span><br><span class="line">    NSMutableArray *mutablePairs = [NSMutableArray array];</span><br><span class="line">    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123;</span><br><span class="line">    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];</span><br><span class="line">	</span><br><span class="line">  	// 如果是字典，遍历后返回key[nestedKey]=nestedValue</span><br><span class="line">    if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        NSDictionary *dictionary = value;</span><br><span class="line">        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span><br><span class="line">        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            id nestedValue = dictionary[nestedKey];</span><br><span class="line">            if (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // 如果是数组，遍历后返回key[]=nestedValue</span><br><span class="line">  	else if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSArray *array = value;</span><br><span class="line">        for (id nestedValue in array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // 如果是集合，遍历后返回key=obj</span><br><span class="line">  	else if ([value isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">        NSSet *set = value;</span><br><span class="line">        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // 其他返回key=value </span><br><span class="line">  	else &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设传入的是，我将key,value放到数组里面，再放到mutableQueryStringComponents里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSSet *afSet = [NSSet setWithObjects:@(1),@(2), nil];</span><br><span class="line">NSDictionary *afDic = @&#123;@&quot;dickey&quot;: @&#123;@&quot;nestKey&quot;: @&quot;nestValue&quot;&#125;,</span><br><span class="line">                        @&quot;arrayKey&quot;: @[@[@(1)]],</span><br><span class="line">                        @&quot;setKey&quot;: afSet,</span><br><span class="line">                        @&quot;generalKey&quot;: @&quot;generalValue&quot;&#125;;</span><br><span class="line">NSArray *resultArray = AFQueryStringPairsFromKeyAndValue(nil, afDic);</span><br></pre></td></tr></table></figure>
<p>打印得到的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[arrayKey, 1],</span><br><span class="line"> [dickey[nestKey], nestValue],</span><br><span class="line"> [generalKey, generalValue],</span><br><span class="line"> [setKey, 1]，</span><br><span class="line"> [setKey,2]]</span><br></pre></td></tr></table></figure>
<p>我们使用<code>AFHTTPRequestSerializer</code>对HTTP请求的头部进行处理</p>
<p>首先调用<code>+ serializer</code>进行初始化，里面调用了自己init方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)serializer &#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init里面先将Accept-Language存到mutableHTTPRequestHeaders里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将mainBundle里面根据使用语言的优先顺序放到acceptLanguagesComponents里面，再用&quot;,&quot;分隔，存到mutableHTTPRequestHeaders字典里面</span><br><span class="line">  	NSMutableArray *acceptLanguagesComponents = [NSMutableArray array];</span><br><span class="line">    [[NSLocale preferredLanguages] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">        float q = 1.0f - (idx * 0.1f);</span><br><span class="line">        [acceptLanguagesComponents addObject:[NSString stringWithFormat:@&quot;%@;q=%0.1g&quot;, obj, q]];</span><br><span class="line">        *stop = q &lt;= 0.5f;</span><br><span class="line">    &#125;];</span><br><span class="line">    [self setValue:[acceptLanguagesComponents componentsJoinedByString:@&quot;, &quot;] forHTTPHeaderField:@&quot;Accept-Language&quot;];</span><br></pre></td></tr></table></figure>
<p>然后拼接User-Agent，格式为”%@/%@ (%@; iOS %@; Scale/%0.2f)”，里面需要5个参数，第一个参数先获取项目名，如果没有，就用BundleIdentifier，第二个参数先获取短版本号，如果没有就用版本号，第三个参数是当前设备的类型，第四个参数是当前设备的版本号，第五个参数是屏幕的比例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSString *userAgent = nil;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">#if TARGET_OS_IOS</span><br><span class="line">    userAgent = [NSString stringWithFormat:@&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleShortVersionString&quot;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];</span><br><span class="line">#elif TARGET_OS_WATCH</span><br><span class="line">    // ... </span><br><span class="line">#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)</span><br><span class="line">    // ...</span><br><span class="line">#endif</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">if (userAgent) &#123;</span><br><span class="line">        if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &#123;</span><br><span class="line">            NSMutableString *mutableUserAgent = [userAgent mutableCopy];</span><br><span class="line">            if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@&quot;Any-Latin; Latin-ASCII; [:^ASCII:] Remove&quot;, false)) &#123;</span><br><span class="line">                userAgent = mutableUserAgent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [self setValue:userAgent forHTTPHeaderField:@&quot;User-Agent&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后设置属性的监听，这些属性在头文件里面都可以找到，实现文件里面也实现了set方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.mutableObservedChangedKeyPaths = [NSMutableSet set];</span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123;</span><br><span class="line">            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过KVO判断是否是新值，如果是的话，就加到mutableObservedChangedKeyPaths里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(__unused id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    if (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123;</span><br><span class="line">            [self.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置验证字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username</span><br><span class="line">                                       password:(NSString *)password</span><br><span class="line">&#123;</span><br><span class="line">    NSData *basicAuthCredentials = [[NSString stringWithFormat:@&quot;%@:%@&quot;, username, password] dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];</span><br><span class="line">    [self setValue:[NSString stringWithFormat:@&quot;Basic %@&quot;, base64AuthCredentials] forHTTPHeaderField:@&quot;Authorization&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化之后，需要调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 断言                                     </span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line">    NSParameterAssert(URLString);</span><br><span class="line">	</span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    NSParameterAssert(url);</span><br><span class="line">	// 根据url初始化request</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    // 设置HTTP方法                                   </span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line">	// 根据mutableObservedChangedKeyPaths存储的属性，设置到mutableRequest</span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	// 调用- [requestBySerializingRequest:withParameters:error]方法</span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">	return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 断言                                      </span><br><span class="line">    NSParameterAssert(request);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line">    // 根据HTTPRequestHeaders来设置mutableRequest的头部字段</span><br><span class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</span><br><span class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">	</span><br><span class="line">    NSString *query = nil;</span><br><span class="line">    if (parameters) &#123;</span><br><span class="line">        if (self.queryStringSerialization) &#123;</span><br><span class="line">          	// 如果设置了queryStringSerialization这个block的话，就需要设置一个自定义的查询语句序列化方法，转成query查询参数</span><br><span class="line">            NSError *serializationError;</span><br><span class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                if (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          	// 如果没有设置，则调用AFQueryStringFromParameters方法，转成query查询参数</span><br><span class="line">            switch (self.queryStringSerializationStyle) &#123;</span><br><span class="line">                case AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 将拼接好的query语句放到 mutableRequest.URL或者放到                                    mutableRequest的HTTPBody里</span><br><span class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        if (query) &#123;</span><br><span class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">        if (!query) &#123;</span><br><span class="line">            query = @&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的话，基本都是对多部分数据进行组装</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFURLRequestSerialization&lt;/code&gt;是用来对发出的请求进行一些处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（四）</title>
    <link href="http://yuzeyang.github.io/2016/05/23/AFNetWorking-four/"/>
    <id>http://yuzeyang.github.io/2016/05/23/AFNetWorking-four/</id>
    <published>2016-05-23T15:24:24.000Z</published>
    <updated>2016-06-21T08:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFNetworkReachabilityManager</code>是用来监测网络状态的类，可以通过设置状态改变回调来获得当前网络状态</p>
<a id="more"></a>
<p>网络的状态值有以下四种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;</span><br><span class="line">    AFNetworkReachabilityStatusUnknown          = -1,// 未知</span><br><span class="line">    AFNetworkReachabilityStatusNotReachable     = 0, // 不可用</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWWAN = 1, // 无线广域网连接</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWiFi = 2, // WiFi连接</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>AFNetworkReachabilityManager</code>提供了五种初始化的方法</p>
<p>可以通过单例方法初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedManager &#123;</span><br><span class="line">    static AFNetworkReachabilityManager *_sharedManager = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        // 调用+ manager初始化方法</span><br><span class="line">        _sharedManager = [self manager];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return _sharedManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例里面调用了第二种通过默认的socket地址初始化方法，返回一个manager对象，sin_family表示协议族，AF_INET表示TCP/IP协议族的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)manager</span><br><span class="line">&#123;</span><br><span class="line">#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</span><br><span class="line">    struct sockaddr_in6 address;</span><br><span class="line">    bzero(&amp;address, sizeof(address));</span><br><span class="line">    address.sin6_len = sizeof(address);</span><br><span class="line">    address.sin6_family = AF_INET6;</span><br><span class="line">#else</span><br><span class="line">    // 声明sockaddr_in结构体</span><br><span class="line">    struct sockaddr_in address;</span><br><span class="line">    // address清零</span><br><span class="line">    bzero(&amp;address, sizeof(address));</span><br><span class="line">    // address赋值</span><br><span class="line">    address.sin_len = sizeof(address);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">#endif</span><br><span class="line">    // 调用+ [managerForAddress:]方法 </span><br><span class="line">    return [self managerForAddress:&amp;address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里又调用了第三种通过传入一个socket地址来初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)managerForAddress:(const void *)address &#123;</span><br><span class="line">    // 生成SCNetworkReachabilityRef</span><br><span class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);</span><br><span class="line">    // 调用- [initWithReachability:]方法</span><br><span class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</span><br><span class="line"></span><br><span class="line">    CFRelease(reachability);</span><br><span class="line">    </span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面又调用了第五种初始化方法，因为该方法的后缀里面有<code>NS_DESIGNATED_INITIALIZER</code>，所以最终都会调到它，这里就是做了初始化的工作，将起始的网络状态定为Unknown</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _networkReachability = CFRetain(reachability);</span><br><span class="line">    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后剩下一种方法就是可以根据特定的域来初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)managerForDomain:(NSString *)domain &#123;</span><br><span class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);</span><br><span class="line"></span><br><span class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</span><br><span class="line">    </span><br><span class="line">    CFRelease(reachability);</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在初始化结束之后，我们需要设置网络状态改变的回调，在开启监听之后，会将网络状态回调给外部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setReachabilityStatusChangeBlock:(void (^)(AFNetworkReachabilityStatus status))block &#123;</span><br><span class="line">    self.networkReachabilityStatusBlock = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是开启监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)startMonitoring &#123;</span><br><span class="line">    // 停止监听</span><br><span class="line">    [self stopMonitoring];</span><br><span class="line"></span><br><span class="line">    if (!self.networkReachability) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 收到callback调用后，将status通过networkReachabilityStatusBlock回调出去</span><br><span class="line">    __weak __typeof(self)weakSelf = self;</span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  	// 声明SCNetworkReachabilityContext结构体</span><br><span class="line">    SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;;</span><br><span class="line">    // 设置回调</span><br><span class="line">  	SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    // 加到Main runloop里面对其进行监测</span><br><span class="line">  	SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</span><br><span class="line">	</span><br><span class="line">  	// 获取当前的网络状态，调用callback</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123;</span><br><span class="line">        SCNetworkReachabilityFlags flags;</span><br><span class="line">        if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有设置回调的话，也可以通过注册通知的方式，收到网络状态的变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class="line">    // 获取当前的status</span><br><span class="line">  	AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 返回status值</span><br><span class="line">      	if (block) &#123;</span><br><span class="line">            block(status);</span><br><span class="line">        &#125;</span><br><span class="line">      	// 同时会发送一个通知</span><br><span class="line">        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];</span><br><span class="line">        NSDictionary *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>停止监听的话，就是取消在Main Runloop里面的监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)stopMonitoring &#123;</span><br><span class="line">    if (!self.networkReachability) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>使用方式例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AFNetworkReachabilityManager *networkManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">[networkManager startMonitoring];</span><br><span class="line">[networkManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case AFNetworkReachabilityStatusNotReachable:</span><br><span class="line">      		// do something</span><br><span class="line">            break;</span><br><span class="line">        case AFNetworkReachabilityStatusReachableViaWWAN:</span><br><span class="line">      		// do something</span><br><span class="line">      		break;</span><br><span class="line">        case AFNetworkReachabilityStatusReachableViaWiFi:</span><br><span class="line">      		// do something</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt;是用来监测网络状态的类，可以通过设置状态改变回调来获得当前网络状态&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（三）</title>
    <link href="http://yuzeyang.github.io/2016/05/22/AFNetWorking-three/"/>
    <id>http://yuzeyang.github.io/2016/05/22/AFNetWorking-three/</id>
    <published>2016-05-22T13:35:11.000Z</published>
    <updated>2016-06-12T15:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS9之后，在默认情况下是不能发送HTTP请求，推荐使用HTTPS，当然你可以在plist里面设置<code>NSAppTransportSecurity</code>的NSAllowsArbitraryLoads为true，App就依然支持HTTP请求</p>
<p>而AFSecurityPolicy主要的作用就是验证HTTPS请求的证书的有效性</p>
<a id="more"></a>
<p>AFSecurityPolicy是安全策略类，有三种SSL Pinning模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123;</span><br><span class="line">    AFSSLPinningModeNone,// 在证书列表中校验服务端返回的证书</span><br><span class="line">    AFSSLPinningModePublicKey,// 客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥</span><br><span class="line">    AFSSLPinningModeCertificate,// 客户端要有服务端的证书拷贝，第一步先验证证书域名/有效期等信息，第二步对服务端返回的证书和客户端返回的是否一致</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个是证书集合，泛型里面表示了集合里面是NSData类型，表明这个是用来存证书数据的集合，这些证书根据SSL Pinning模式来和服务器进行校验，默认是没有证书的，我们需要调用+ certificatesInBundle:方法将bundle里面的证书文件转成里面是data类型的集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong, nullable) NSSet &lt;NSData *&gt; *pinnedCertificates;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123;</span><br><span class="line">    // 获取证书</span><br><span class="line">  	NSArray *paths = [bundle pathsForResourcesOfType:@&quot;cer&quot; inDirectory:@&quot;.&quot;];</span><br><span class="line"></span><br><span class="line">    NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]];</span><br><span class="line">    // 将证书文件转成data</span><br><span class="line">  	for (NSString *path in paths) &#123;</span><br><span class="line">        NSData *certificateData = [NSData dataWithContentsOfFile:path];</span><br><span class="line">        [certificates addObject:certificateData];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [NSSet setWithSet:certificates];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有三种初始化的方法，一种是默认策略，AFSSLPinningModeNone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)defaultPolicy &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</span><br><span class="line"></span><br><span class="line">    return securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是自定义一个安全策略，然后读取cer文件放到集合里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class="line">    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet *)defaultPinnedCertificates &#123;</span><br><span class="line">    static NSSet *_defaultPinnedCertificates = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        NSBundle *bundle = [NSBundle bundleForClass:[self class]];</span><br><span class="line">        _defaultPinnedCertificates = [self certificatesInBundle:bundle];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return _defaultPinnedCertificates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种则是需要我们多传入一个证书集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[self alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = pinningMode;</span><br><span class="line"></span><br><span class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class="line"></span><br><span class="line">    return securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置证书的时候，就是把上面初始化时传入的证书取出公钥，再把公钥保存到mutablePinnedPublicKeys集合中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123;</span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    if (self.pinnedCertificates) &#123;</span><br><span class="line">        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];</span><br><span class="line">        for (NSData *certificate in self.pinnedCertificates) &#123;</span><br><span class="line">            // 取出公钥</span><br><span class="line">          	id publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            if (!publicKey) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 将公钥存到集合</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.pinnedPublicKeys = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>AFPublicKeyForCertificate</code>方法里面，做了一系列操作后返回公钥，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static id AFPublicKeyForCertificate(NSData *certificate) &#123;</span><br><span class="line">    id allowedPublicKey = nil;</span><br><span class="line">    SecCertificateRef allowedCertificate;</span><br><span class="line">    SecCertificateRef allowedCertificates[1];</span><br><span class="line">    CFArrayRef tempCertificates = nil;</span><br><span class="line">    SecPolicyRef policy = nil;</span><br><span class="line">    SecTrustRef allowedTrust = nil;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line"></span><br><span class="line">  	// 取出证书SecCertificateRef</span><br><span class="line">    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);</span><br><span class="line">    __Require_Quiet(allowedCertificate != NULL, _out);</span><br><span class="line">	</span><br><span class="line">  	// 生成证书数组</span><br><span class="line">    allowedCertificates[0] = allowedCertificate;</span><br><span class="line">    tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);</span><br><span class="line"></span><br><span class="line">  	// 生成SecPolicyRef</span><br><span class="line">    policy = SecPolicyCreateBasicX509();</span><br><span class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust), _out);</span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out);</span><br><span class="line">	</span><br><span class="line">  	// 从SecPolicyRef中取出公钥</span><br><span class="line">    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);</span><br><span class="line"></span><br><span class="line">_out:</span><br><span class="line">    // 一些资源的释放</span><br><span class="line"></span><br><span class="line">    return allowedPublicKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>-[evaluateServerTrust:forDomain:]</code>方法是<code>AFSecurityPolicy</code>类最长也是最重要的方法，它用来验证服务端是否是受信的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(NSString *)domain</span><br><span class="line">&#123;</span><br><span class="line">    // 苹果文档中表示不要隐式地信任自己签名的证书，取而代之的是应该增加自己的CA证书到受信列表里</span><br><span class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</span><br><span class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // policies增加SecPolicyRef</span><br><span class="line">    NSMutableArray *policies = [NSMutableArray array];</span><br><span class="line">    if (self.validatesDomainName) &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 设置信任的policies应当被验证</span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</span><br><span class="line">	</span><br><span class="line">    // 向系统内置的根证书验证服务端返回的证书是否合法</span><br><span class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 根据SSLPinningMode对服务端是否受信进行校验</span><br><span class="line">    switch (self.SSLPinningMode) &#123;</span><br><span class="line">        case AFSSLPinningModeNone:</span><br><span class="line">        default:</span><br><span class="line">            return NO;</span><br><span class="line">        case AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</span><br><span class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA)</span><br><span class="line">            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    return YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        case AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            NSUInteger trustedPublicKeyCount = 0;</span><br><span class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            for (id trustChainPublicKey in publicKeys) &#123;</span><br><span class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</span><br><span class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return trustedPublicKeyCount &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS9之后，在默认情况下是不能发送HTTP请求，推荐使用HTTPS，当然你可以在plist里面设置&lt;code&gt;NSAppTransportSecurity&lt;/code&gt;的NSAllowsArbitraryLoads为true，App就依然支持HTTP请求&lt;/p&gt;
&lt;p&gt;而AFSecurityPolicy主要的作用就是验证HTTPS请求的证书的有效性&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建GitHub blog</title>
    <link href="http://yuzeyang.github.io/2016/04/29/hexo_build_github_blog/"/>
    <id>http://yuzeyang.github.io/2016/04/29/hexo_build_github_blog/</id>
    <published>2016-04-28T16:00:00.000Z</published>
    <updated>2016-07-06T08:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你厌倦了使用了第三方的博客平台，你可以考虑一下用hexo和github来搭建自己的博客</p>
<hr>
<p>用hexo来搭建github blog很简单，只需要五步~</p>
<h2 id="1-在github上面新建一个仓库"><a href="#1-在github上面新建一个仓库" class="headerlink" title="1.在github上面新建一个仓库"></a>1.在github上面新建一个仓库</h2><p>首先我们需要在自己的github上新建一个仓库，将仓库的命名为xxx.github.io，一定要按该格式命名，否则不能搭建成功</p>
<a id="more"></a>
<h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2.配置环境"></a>2.配置环境</h2><p>在使用搭建之前，我们需要配置好下面环境</p>
<h4 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure>
<h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p>node.js集成带有了npm</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew install node</span><br></pre></td></tr></table></figure>
<h4 id="安装hexo-cli"><a href="#安装hexo-cli" class="headerlink" title="安装hexo-cli"></a>安装hexo-cli</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="3-在blog目录下，初始化hexo"><a href="#3-在blog目录下，初始化hexo" class="headerlink" title="3.在blog目录下，初始化hexo"></a>3.在blog目录下，初始化hexo</h2><p>接下来我们需要新建一个文件夹来存放blog内容，假设我新建了一个blog文件夹，然后我cd到该路径下面，然后我们需要对该目录进行初始化，运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init $&#123;blog路径&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/hexoinit.png" alt=""></p>
<p>（图中中间出现的报错不要在意，因为我使用了插件，提示未找到该插件）</p>
<h2 id="4-生成静态页面"><a href="#4-生成静态页面" class="headerlink" title="4.生成静态页面"></a>4.生成静态页面</h2><p>初始化好之后，我们先来看看页面是不是能正常显示打开了，运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo g</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo generate</span><br></pre></td></tr></table></figure>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>第一次部署的时候会因为找不到git而报错，需要安装下，再提交一次</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/hexog.png" alt=""></p>
<h2 id="5-初始化依赖"><a href="#5-初始化依赖" class="headerlink" title="5.初始化依赖"></a>5.初始化依赖</h2><p>在第一次安装运行时，我们需要初始化依赖，否则后面启动服务或者生成静态界面会出错…</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure>
<h2 id="6-启动服务"><a href="#6-启动服务" class="headerlink" title="6.启动服务"></a>6.启动服务</h2><p>然后我们启动一下服务看看，我们的博客是不是能打开了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo server</span><br></pre></td></tr></table></figure>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/hexoserver.png" alt=""></p>
<p>我们打开<a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>看看，如果前面一切顺利的话，你就能看到你搭建成功的博客了~（注意此时打开的还不是自己的github博客地址哦，只是hexo默认配置的地址）</p>
<h2 id="7-修改blog目录下的-config-yml配置文件"><a href="#7-修改blog目录下的-config-yml配置文件" class="headerlink" title="7.修改blog目录下的_config.yml配置文件"></a>7.修改blog目录下的_config.yml配置文件</h2><p>接下来我们需要将hexo打开的博客地址改成自己的地址，打开blog目录下面的_config.yml文件，找到deploy，将部署类型改成git或者GItHub，仓库改成自己的github blog地址格式，分支改成master，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span>    <span class="comment">#部署类型</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/Yuzeyang/yuzeyang.github.io.git</span>   <span class="comment">#部署的仓库的SSH</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span>   <span class="comment">#部署分支,一般使用master主分支</span></span><br></pre></td></tr></table></figure>
<p>注意：type/repository/branch:和内容之间是有空格的，而且是一定要有的，否则在重新生成静态页面的时候，会找不到仓库路径</p>
<h2 id="8-选取喜欢的主题"><a href="#8-选取喜欢的主题" class="headerlink" title="8.选取喜欢的主题"></a>8.选取喜欢的主题</h2><p>作为爱装逼的程序员怎么能用默认的主题呢，我们可以先在hexo主题网赚挑选一个自己喜欢的主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>，当然你有一定的前端基础可以自己写一套主题玩玩，分享给大家</p>
<h2 id="9-重新部署你的静态网页"><a href="#9-重新部署你的静态网页" class="headerlink" title="9.重新部署你的静态网页"></a>9.重新部署你的静态网页</h2><p>修改完配置之后，我们重新部署一下，看看效果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo d -g</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo deploy -generate</span><br></pre></td></tr></table></figure>
<h2 id="10-再刷新一下你的网页，Duang"><a href="#10-再刷新一下你的网页，Duang" class="headerlink" title="10.再刷新一下你的网页，Duang~"></a>10.再刷新一下你的网页，Duang~</h2><p>因为首页图片加载太慢了…我换了个主题…</p>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/blog.jpg" alt=""></p>
<h2 id="11-上传文章"><a href="#11-上传文章" class="headerlink" title="11.上传文章"></a>11.上传文章</h2><p>你可以运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;新的文章标题&quot;</span><br></pre></td></tr></table></figure>
<p>这样会自动生成好</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo搭建GitHub blog</span><br><span class="line">date: 2016-4-29 17:00:00</span><br><span class="line">tags: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>或者， 把文章放到blog/source/._posts目录下面</p>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/upload.jpg" alt=""></p>
<p>在文章的内容前面需要加上标题、时间和标签，这样才能在首页显示出你的标题，你也可以添加文章的时间和文章的tag，例如：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo搭建GitHub blog</span><br><span class="line">date: 2016-4-29</span><br><span class="line">tags: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>再起一下服务，看看有没有修改成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo server</span><br></pre></td></tr></table></figure>
<p>修改成功后，再重新部署一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo d -g</span><br></pre></td></tr></table></figure>
<p>最后再确认一下</p>
<p><img src="http://7xtit4.com2.z0.glb.clouddn.com/update.jpg" alt=""></p>
<p>上传成功~！</p>
<h2 id="12-申请个人域名"><a href="#12-申请个人域名" class="headerlink" title="12.申请个人域名"></a>12.申请个人域名</h2><p>使用xxx.github.io，其实还不是很方便，也没有xxx.com或者xxx.me这样的域名好（zhuang）记（bi），所以一般都会自己去申请一个个人域名</p>
<p>我们打开google，搜索一下<code>个人域名</code></p>
<p>恩，跳出<a href="https://wanwang.aliyun.com/?utm_content=se_97054&amp;gclid=CITQ0ce8vs0CFQqkvQodNFUPrA" target="_blank" rel="noopener">万网</a>和<a href="https://sg.godaddy.com/zh/offers/default.aspx?tmskey=1dom_23&amp;isc=gennlcn10&amp;countrview=1&amp;currencytype=CNY&amp;cvosrc=ppc.google.+%C3%A4%C2%B8%C2%AA%C3%A4%C2%BA%C2%BA%C3%A5%C2%9F%C2%9F%C3%A5%C2%90%C2%8D&amp;cvo_crid=103919011486&amp;matchtype=b" target="_blank" rel="noopener">GoDaddy</a>，不过好像GoDaddy续费比较贵，万网好像能查到你的个人信息资料…</p>
<p>所以我咨询了下同事，他们推荐了我<a href="https://www.namesilo.com/" target="_blank" rel="noopener">namesilo</a>，续费便宜，还能开启隐私保护~</p>
<p>进到首页之后我们在箭头位置搜索下我们想要的域名</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/namesilo.png" alt=""></p>
<p>然后我们就能看到哪些是已经注册，哪些是可以使用的</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/namesiloRes.png" alt=""></p>
<p>在支付前看下价格，这上面显示的价格只是低价，类似于起拍价，实际价格在支付页可以看到，购买前请仔细看下数字…别付了好几万…（可以支持支付宝哦~）</p>
<p>然后我们到<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSPOD</a>里，对我们的xxx.github.io进行DNS转移到xxx.com</p>
<p>登录后，在域名解析里面，添加我们的个人域名，然后将默认的NS类型的记录值拷贝出来，回到我们的namesilo里面，将nameserver修改成NS类型的记录值，保存，然后过一会儿才会生效</p>
<p>在Github的xxx.github.io仓库的目录下面，新建一个CNAME文件，写上你的个人域名</p>
<p>在web导航栏里面输出你的个人域名，就可以正常访问了~</p>
<h2 id="13-增加评论功能"><a href="#13-增加评论功能" class="headerlink" title="13.增加评论功能"></a>13.增加评论功能</h2><p>目前用的比较多的评论插件有<a href="https://disqus.com/" target="_blank" rel="noopener">disqus</a>、<a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a>、<a href="http://www.uyan.cc/" target="_blank" rel="noopener">友言</a></p>
<p>但是多说和友言界面有点丑…相比之下disqus还是比较符合我的口味的~</p>
<p>那我就来介绍怎么加disqus</p>
<p>首先注册登录，然后点击右上角的设置按钮</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/SettingsDisqus.png!400x400" alt=""></p>
<p>选择左侧的<code>Account</code>，在Username里面填上你的域名名称，例如我的域名是<code>zeeyang.com</code>，那么我就填<code>zeeyang</code></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/SettingsDisqusUsername.png" alt=""></p>
<p>然后打开你的hexo配置文件，在最后加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disqus_shortname: 域名名称(例如：zeeyang)</span><br></pre></td></tr></table></figure>
<p>然后打开主题配置文件，也同样加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disqus: 域名名称(例如：zeeyang)</span><br></pre></td></tr></table></figure>
<p>然后提交修改，再刷新下网页</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/disqusComplete.png" alt=""></p>
<p>这下子别人可以在你的文章下面留言啦~（我后来更换了apollo主题，比较清爽）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你厌倦了使用了第三方的博客平台，你可以考虑一下用hexo和github来搭建自己的博客&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;用hexo来搭建github blog很简单，只需要五步~&lt;/p&gt;
&lt;h2 id=&quot;1-在github上面新建一个仓库&quot;&gt;&lt;a href=&quot;#1-在github上面新建一个仓库&quot; class=&quot;headerlink&quot; title=&quot;1.在github上面新建一个仓库&quot;&gt;&lt;/a&gt;1.在github上面新建一个仓库&lt;/h2&gt;&lt;p&gt;首先我们需要在自己的github上新建一个仓库，将仓库的命名为xxx.github.io，一定要按该格式命名，否则不能搭建成功&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yuzeyang.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>iOS 同时修改button位置和文字问题</title>
    <link href="http://yuzeyang.github.io/2016/04/09/button-location-title-bug/"/>
    <id>http://yuzeyang.github.io/2016/04/09/button-location-title-bug/</id>
    <published>2016-04-09T03:27:16.000Z</published>
    <updated>2016-05-21T03:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在写App的登录注册界面，其中登录和注册之间的切换和印象笔记一样<br><img src="http://7xtit4.com1.z0.glb.clouddn.com/Evernote.gif!500x500" alt="印象笔记登录界面"></p>
<hr>
<p>中间的登录按钮会有一个下移以及更改文字的操作，但是我在加了下移动画之后，再修改按钮的文字，就出现了很奇怪的现象，按钮会先下移然后修改文字之后，又跳回到最初的位置</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/Evernote%20bug.gif!500x500" alt="问题操作"><br>这就奇怪了，看逻辑上一点错误也没有，那怎么会这样呢？</p>
<p>检查了下按钮的类型也是自定义的，那会不会是动画影响的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);</span><br></pre></td></tr></table></figure></p>
<p>在block里面，我在setTitle:forState的方法外面，去掉动画的影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[UIView setAnimationsEnabled:NO];</span><br><span class="line">[self.loginButton setTitle:@&quot;注   册&quot; forState:UIControlStateNormal];</span><br><span class="line">[self.loginButton layoutIfNeeded];</span><br><span class="line">[UIView setAnimationsEnabled:YES];</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[UIView performWithoutAnimation:^&#123;</span><br><span class="line">        [self.loginButton setTitle:@&quot;注   册&quot; forState:UIControlStateNormal];</span><br><span class="line">        [self.loginButton layoutIfNeeded];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>都还是不行。。。</p>
<p>干脆把动画方法去掉，直接改变按钮的位置再试试。。结果还是一样，那就纳闷了。。</p>
<p>后来找了很久的资料发现，原来是受到了autolayout的影响，因为在广泛开始使用autolayout之后，在storyboard，nib和实现文件里面，我们可能不像以前那样去繁琐的计算坐标了，我们通过自适应的方式，去确定控件的位置</p>
<p>因为我的登录按钮是自适应的，所以在修改了按钮位置后，再修改文字，就会出现这样的问题，但是我打印了很多方法，都没有发现调用，所以不知道系统在设置文字的时候，又调用了哪个方法</p>
<p>我试着调用了修改其他的属性的方法，比如背景色，setImage：forState，这些都没事，凡是调用了title相关的三个设置都会这样。。我就满脸黑线了。。</p>
<p>所以目前能找到的解决办法就是，该按钮<strong>用坐标计算的方式添加</strong></p>
<p>如果哪位大神找到更好的解决办法，欢迎留言~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在写App的登录注册界面，其中登录和注册之间的切换和印象笔记一样&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Evernote.gif!500x500&quot; alt=&quot;印象笔记登录界面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;中
    
    </summary>
    
    
      <category term="button" scheme="http://yuzeyang.github.io/tags/button/"/>
    
  </entry>
  
  <entry>
    <title>iOS 简单下载动画</title>
    <link href="http://yuzeyang.github.io/2016/03/27/simple-download-animation/"/>
    <id>http://yuzeyang.github.io/2016/03/27/simple-download-animation/</id>
    <published>2016-03-27T03:22:17.000Z</published>
    <updated>2016-05-21T03:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个动画比较简单基础，首先我们来看一下这个动画模拟的动图<br><img src="http://7xtit4.com1.z0.glb.clouddn.com/downloadAnimation.gif!500x500" alt="下载动画"></p>
<hr>
<p>动画一共有四个状态，<strong>开始下载</strong>、<strong>下载结束</strong>、<strong>下载成功</strong>和<strong>下载失败</strong></p>
<p>为什么会分有<strong>下载结束</strong>这样的状态呢？因为考虑到实际场景，可能会有在加载过程中，用户返回上级界面，我们需要结束下载动画</p>
<hr>
<p>我们按状态来实现，首先先看开始加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *rotationZAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</span><br><span class="line">rotationZAnimation.fromValue = @(0);</span><br><span class="line">rotationZAnimation.toValue = @(M_PI*2);</span><br><span class="line">rotationZAnimation.repeatDuration = HUGE_VAL;</span><br><span class="line">rotationZAnimation.duration = 1.0;</span><br><span class="line">rotationZAnimation.cumulative = YES;</span><br><span class="line">rotationZAnimation.beginTime = CACurrentMediaTime();</span><br><span class="line">[self.loadingLayer addAnimation:rotationZAnimation forKey:@&quot;rotationZAnimation&quot;];</span><br><span class="line">        </span><br><span class="line">NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth];</span><br><span class="line">CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];</span><br><span class="line">[self.loadingLayer addAnimation:boundsAnimation forKey:nil];</span><br></pre></td></tr></table></figure></p>
<p>这里分为两个动画，一个是<strong>旋转动画</strong>，一个是<strong>放大缩小的动画</strong><br><strong>旋转动画</strong>，我们只有一个初始值和末值，所以我们只需要使用CABasicAnimation就可以了，不需要使用CAKeyframeAnimation，CAKeyframeAnimation是用来处理关键帧动画的，它的values属性用来存储关键帧的值，这就是我们用来做处理<strong>放大缩小动画</strong>，上面代码可以看到我将它抽成了一个方法来用，因为在下载成功和失败的时候，成功和失败也是有放大缩小的动画，这三个其实是一个动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)valueArrayWithWidth:(CGFloat)width &#123;</span><br><span class="line">    return @[[NSValue valueWithCGRect:CGRectMake(0, 0, width * 0.7, width * 0.7)],</span><br><span class="line">             [NSValue valueWithCGRect:CGRectMake(0, 0, width, width)],</span><br><span class="line">             [NSValue valueWithCGRect:CGRectMake(0, 0, width * 0.9, width * 0.9)]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CAKeyframeAnimation *)bounsAnimationWithValues:(NSArray *)values &#123;</span><br><span class="line">    CAKeyframeAnimation *boundsAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;bounds&quot;];</span><br><span class="line">    boundsAnimation.duration = 0.6;</span><br><span class="line">    boundsAnimation.beginTime = CACurrentMediaTime();</span><br><span class="line">    boundsAnimation.values = values;</span><br><span class="line">    boundsAnimation.keyTimes = @[@(0),@(0.3),@(0.6)];</span><br><span class="line">    boundsAnimation.timingFunctions = @[[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],</span><br><span class="line">                                        [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut],</span><br><span class="line">                                        [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];</span><br><span class="line">    boundsAnimation.removedOnCompletion = NO;</span><br><span class="line">    boundsAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">    return boundsAnimation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们统一设置动画的values值，这里传入的width值是下载的背景大小，因为下载圆圈有个放大的过程，所以我们需要圆圈的原始大小要比背景的大小小，所以我默认设置圆圈的大小是背景大小的0.9倍，所以动画的效果是圆圈从背景大小的0.7倍-&gt;背景大小-&gt;背景大小的0.9倍（圆圈的原始大小）<br>在设置这个动画的时候，因为动画的值不止是初始值和末值，还是中间值，所以我使用CAKeyframeAnimation来做，每个关键帧之间的动画时间设置为0.3秒，这是最适合的动画时间，当然这是时间还是由自己反复调试动画决定的</p>
<hr>
<p>下载结束我们只要将转圈的动画移除掉即可，这样转圈就恢复到原来的状态了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.loadingLayer removeAllAnimations];</span><br></pre></td></tr></table></figure></p>
<hr>
<p>下载成功我们也需要将转圈动画移除，然后出现成功的动画，并且将成功图层的透明度从0变到1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self.loadingLayer removeAllAnimations];</span><br><span class="line">self.failLayer.opacity = 0.0;</span><br><span class="line">NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth * 0.5];</span><br><span class="line">CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];</span><br><span class="line">[self.doneLayer addAnimation:boundsAnimation forKey:nil];</span><br><span class="line">        </span><br><span class="line">[UIView animateWithDuration:1.0 animations:^&#123;</span><br><span class="line">    self.doneLayer.opacity = 1.0;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<hr>
<p>下载失败也是同理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self.loadingLayer removeAllAnimations];</span><br><span class="line">self.doneLayer.opacity = 0.0;</span><br><span class="line">NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth * 0.5];</span><br><span class="line">CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];</span><br><span class="line">[self.failLayer addAnimation:boundsAnimation forKey:nil];</span><br><span class="line">        </span><br><span class="line">[UIView animateWithDuration:1.0 animations:^&#123;</span><br><span class="line">     self.failLayer.opacity = 1.0;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>好了，动画主要的原理就是这样，具体的代码实现可以看这里：<a href="https://github.com/Yuzeyang/DownloadingAnimation" target="_blank" rel="noopener">https://github.com/Yuzeyang/DownloadingAnimation</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个动画比较简单基础，首先我们来看一下这个动画模拟的动图&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/downloadAnimation.gif!500x500&quot; alt=&quot;下载动画&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;动画
    
    </summary>
    
    
      <category term="下载动画" scheme="http://yuzeyang.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（二）</title>
    <link href="http://yuzeyang.github.io/2016/03/15/AFNetWorking-two/"/>
    <id>http://yuzeyang.github.io/2016/03/15/AFNetWorking-two/</id>
    <published>2016-03-15T07:34:30.000Z</published>
    <updated>2016-06-12T15:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>AFHTTPSessionManager</code>继承于<code>AFURLSessionManager</code>，提供了更方便的HTTP请求方法，包括了GET、POST、PUT、PATCH、DELETE这五种方式，并且AF鼓励我们在<code>AFHTTPSessionManager</code>再进行一次封装来满足我们自己的业务需求</p>
<a id="more"></a>
<hr>
<p>在开始的地方，AF一直提醒到一个属性<code>baseURL</code>，这个变量你可以在进一步封装的时候，将<code>baseURL</code>写成你自己的HTTP请求原始地址，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURL *)baseURL &#123;</span><br><span class="line">    return [NSURL URLWithString:kBaseURLString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对<code>baseURL</code>进行拼接的时候，也需要注意一下几点，防止出现请求的URL出现问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSURL *baseURL = [NSURL URLWithString:@&quot;http://example.com/v1/&quot;];</span><br><span class="line">    [NSURL URLWithString:@&quot;foo&quot; relativeToURL:baseURL];                  // http://example.com/v1/foo</span><br><span class="line">    [NSURL URLWithString:@&quot;foo?bar=baz&quot; relativeToURL:baseURL];          // http://example.com/v1/foo?bar=baz</span><br><span class="line">    [NSURL URLWithString:@&quot;/foo&quot; relativeToURL:baseURL];                 // http://example.com/foo</span><br><span class="line">    [NSURL URLWithString:@&quot;foo/&quot; relativeToURL:baseURL];                 // http://example.com/v1/foo</span><br><span class="line">    [NSURL URLWithString:@&quot;/foo/&quot; relativeToURL:baseURL];                // http://example.com/foo/</span><br><span class="line">    [NSURL URLWithString:@&quot;http://example2.com/&quot; relativeToURL:baseURL]; // http://example2.com/</span><br></pre></td></tr></table></figure>
<p>在初始化的方法里面，我们看到这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</span><br><span class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p><code>NS_DESIGNATED_INITIALIZER</code>的作用是什么呢？<br>指定的构造器通过发送初始化消息到父类来保证object被完全初始化，指定构造器有以下几个规则：</p>
<p>1.指定构造器必须调用父类的指定构造器</p>
<p>2.任何一个便利构造器必须调用最终指向指定构造器的其他构造器</p>
<p>3.具有指定构造器的类必须实现父类的所有指定构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    // 指向- [initWithBaseURL:]</span><br><span class="line">  	return [self initWithBaseURL:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url &#123;</span><br><span class="line">    // 指向- [initWithBaseURL:sessionConfiguration:]</span><br><span class="line">    return [self initWithBaseURL:url sessionConfiguration:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    // 指向- [initWithBaseURL:sessionConfiguration:]</span><br><span class="line">    return [self initWithBaseURL:nil sessionConfiguration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url</span><br><span class="line">           sessionConfiguration:(NSURLSessionConfiguration *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    // 调用父类的- [initWithSessionConfiguration:]</span><br><span class="line">    self = [super initWithSessionConfiguration:configuration];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // baseURL赋值，AFHTTPRequestSerializer和AFJSONResponseSerializer序列化</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DEPRECATED_ATTRIBUTE</code>这个相信大家见得比较多了，字面意思就是这个API不建议开发者再使用了，再使用时，会出现编译警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</span><br><span class="line">                   parameters:(nullable id)parameters</span><br><span class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</span><br></pre></td></tr></table></figure>
<hr>
<p>下面POST、GET、PUT、PATCH、DELETE方法传参基本都是大同小异</p>
<p><code>URLString</code>表示请求的URL，<code>parameters</code>表示客户端请求内容的存储器，<code>progress</code>表示请求的进度，<code>constructingBodyWithBlock</code>里面只有一个formData用来拼接到HTTP的请求体，<code>success</code>表示请求成功后的block回调，<code>failure</code>表示请求失败的block回调</p>
<p>那么这几个请求有什么区别呢？</p>
<p>1、POST请求是向服务端发送数据的，用来更新资源信息，它可以改变数据的种类等资源</p>
<p>2、GET请求是向服务端发起请求数据，用来获取或查询资源信息</p>
<p>3、PUT请求和POST请求很像，都是发送数据的，但是PUT请求不能改变数据的种类等资源，它只能修改内容</p>
<p>4、DELETE请求就是用来删除某个资源的</p>
<p>5、PATCH请求和PUT请求一样，也是用来进行数据更新的，它是HTTP verb推荐用于更新的</p>
<p>在实际开发过程中，我们还是使用POST和GET请求是最多的</p>
<hr>
<p>在请求实现的部分，都是调用了<code>-[dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure]</code>方法创建<code>NSURLSessionDataTask</code>对象</p>
<p>传参的内容基本都是和上一层方法一样，<code>method</code>指的就是请求的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">        // 失败成功处理</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;继承于&lt;code&gt;AFURLSessionManager&lt;/code&gt;，提供了更方便的HTTP请求方法，包括了GET、POST、PUT、PATCH、DELETE这五种方式，并且AF鼓励我们在&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;再进行一次封装来满足我们自己的业务需求&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（一）</title>
    <link href="http://yuzeyang.github.io/2016/02/21/AFNetWorking-one/"/>
    <id>http://yuzeyang.github.io/2016/02/21/AFNetWorking-one/</id>
    <published>2016-02-21T03:47:48.000Z</published>
    <updated>2017-03-21T14:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先来介绍下AFNetWorking，官方介绍如下：</p>
<blockquote>
<p>AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="noopener">Foundation URL Loading System</a>, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p>
<p>Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.</p>
<p>Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did!</p>
</blockquote>
<p>翻译过来简单来说就是</p>
<p>AFNetworking是一个适用于iOS和Mac OS X两个平台的网络库，它是基于<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="noopener">Foundation URL Loading System</a>上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking.png" alt=""></p>
<p>相信从star数和fork数来看，大家都能明白这个库是多么的受欢迎了，所以了解这个库对于一个iOS开发来说是极为重要的！</p>
<p>这个是AFNetworking的github地址：<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">GitHub - AFNetworking/AFNetworking: A delightful networking framework for iOS</a></p>
<p>在使用前阅读README是非常重要的，里面往往包括了这个库的介绍、安装和使用等等，对于快速了解一个库来说，这是非常有帮助的</p>
<hr>
<p>首先我们在<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetWorking源码地址</a>里download下来，打开工程文件，可以看到里面内容分为两个部分，一个是AFNetworking，另一个是UIKit+AFNetworking</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking_file.png" alt=""></p>
<p>很明显，第一个是用来做网络请求相关的，第二个则是和UI使用相关的，我们先看第一个</p>
<p>在看完头文件和README之后，你会发现<code>AFURLSessionManager</code>和<code>AFHTTPSessionManager</code>是里面比较重要的两个类</p>
<p>这里我先讲<code>AFURLSessionManager</code>这个类</p>
<p>首先浏览完这个类从API，发现其主要提供了数据的请求、上传和下载功能</p>
<p>在属性方面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property(readonly,nonatomic,strong)NSArray *tasks;</span><br><span class="line"></span><br><span class="line">@property(readonly,nonatomic,strong)NSArray *dataTasks;</span><br><span class="line"></span><br><span class="line">@property(readonly,nonatomic,strong)NSArray *uploadTasks;</span><br><span class="line"></span><br><span class="line">@property(readonly,nonatomic,strong)NSArray *downloadTasks;</span><br></pre></td></tr></table></figure>
<p>通过这四个属性，我们分别可以拿到总的任务集合、数据任务集合、上传任务集合和下载任务集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,assign)BOOL attemptsToRecreateUploadTasksForBackgroundSessions;</span><br></pre></td></tr></table></figure>
<p>这个属性非常重要，注释里面写到，在iOS7中存在一个bug，在创建后台上传任务时，有时候会返回nil，所以为了解决这个问题，AFNetworking遵照了苹果的建议，在创建失败的时候，会重新尝试创建，次数默认为3次，所以你的应用如果有场景会有在后台上传的情况的话，记得将该值设为YES，避免出现上传失败的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;</span><br></pre></td></tr></table></figure>
<p>在对外提供的notification key里面，使用了<code>FOUNDATION_EXPORT</code>来定义常量，使用<code>FOUNDATION_EXPORT</code>和<code>extern</code>或者<code>define</code>有什么区别呢？</p>
<p><code>FOUNDATION_EXPORT</code>在c文件编译下是和extern等同，在c++文件编译下是和extern “C”等同，在32位机的环境下又是另外编译情况，在兼容性方面，<code>FOUNDATION_EXPORT</code>做的会更好。</p>
<p>这里还提到了效率方面的问题：<a href="http://www.jianshu.com/p/f547eb0368c4" target="_blank" rel="noopener">iOS开发的一些奇巧淫技3</a></p>
<hr>
<p>进入到实现文件里面，我们可以看到在外部API调用dataTask、uploadTask、downloadTask方法实际上都是completionHanlder block返回出来的，但是我们知道网络请求是delegate返回结果的，AF内部做了巧妙的操作，他对每个task都增加代理设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line">	__block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">	// 每个task里面都会调用addDelegate方法</span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在设置里面，每个task会在内部创建<code>AFURLSessionManagerTaskDelegate</code>对象，并设置completionHandler、uploadProgressBlock、downloadProgressBlock回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化delegate对象</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    // 将task的completionHandler赋给delegate，系统网络请求delegate 调用该block，返回结果</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    // 对task进行delegate</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line">	// 设置上传和下载进度回调</span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后delegate对象利用kvo将task对一些方法进行监听，并且监听到变化时，通过block返回，将delegate转成block出去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    // 断言</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    // task使用kvo对一些方法监听，返回上传或者下载的进度</span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    // sessionManager对暂停task和恢复task进行注册通知</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在原先IM的设计时，因为接口的数量并不多，所以在AsyncSocket的delegate回调后，我们依旧是采用delegate回调给业务层，但是随着接口数量的增加，业务层对于回调的处理更加困难和不可控，在重构IM的时候，我们也参考学习了AF的做法，我们通过对唯一标识和每个请求做一一绑定，将请求的上下文关联起来，这样让socket长连接的请求的也想http请求一样，都由block回去，对于业务层的处理也方便更多</p>
<p><code>setupProgressForTask</code>方法主要是对task和progress设置监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    __weak __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line">    // 设置上传和下载的大小</span><br><span class="line">    </span><br><span class="line">    // 设置上传和下载中允许取消和暂停</span><br><span class="line">  </span><br><span class="line">  	// 设置上传和下载响应恢复处理方法后恢复上传或下载</span><br><span class="line">    </span><br><span class="line">    // task对接收到的字节数、期望接收到的字节数、发送的字节数、期望发送的字节数设置监听</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">    [task addObserver:self</span><br><span class="line">          forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line"></span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">    [task addObserver:self</span><br><span class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</span><br><span class="line">              options:NSKeyValueObservingOptionNew</span><br><span class="line">              context:NULL];</span><br><span class="line">	// 上传和下载设置完成的分数监听</span><br><span class="line">    [self.downloadProgress addObserver:self</span><br><span class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                               options:NSKeyValueObservingOptionNew</span><br><span class="line">                               context:NULL];</span><br><span class="line">    [self.uploadProgress addObserver:self</span><br><span class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                             options:NSKeyValueObservingOptionNew</span><br><span class="line">                             context:NULL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</span><br><span class="line">        // 设置上传和下载的新值</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</span><br><span class="line">        if (self.downloadProgressBlock) &#123;</span><br><span class="line">            self.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</span><br><span class="line">        if (self.uploadProgressBlock) &#123;</span><br><span class="line">            self.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个if判断里面，object判断是否是<code>NSURLSessionTask</code>类或者是否是<code>NSURLSessionDownloadTask</code>类，但是进到<code>NSURLSessionDownloadTask</code>的时候，我们可以看到<code>NSURLSessionDownloadTask</code>是<code>NSURLSessionTask</code>的子类，那为什么还要判断这个呢？</p>
<p><code>NSURLSessionTask</code>实际上是<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ClassCluster.html" target="_blank" rel="noopener">Class cluster</a>，通过<code>NSURLSession</code>生成的task返回的并不一定是指定的task类型。因此kindOfClass并不总会生效，具体可以参见<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L382~L414" target="_blank" rel="noopener">AFURLSessionManager.m在load方法中的说明</a>。<br>特定于当前问题，是由于iOS 7上<strong>NSCFURLSessionDownloadTask的基类并不是</strong><code>NSCFURLSessionTask</code>，因此isKindOfClass会出错。查看对应的<a href="https://github.com/AFNetworking/AFNetworking/commit/a745be4fcd75de75b560dce1d689b6bcc11f42ba#diff-dd81ac1f455a60ac8065ade41f06881f" target="_blank" rel="noopener">commit</a>就可以知道了。</p>
<p>在<code>NSURLSessionTaskDelegate</code>的代理里面，只是做了两件事情，第一个是获取数据，将responseSerializer和downloadFileURL或data存到userInfo里面，第二个是根据error是否为空值，做下一步处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - NSURLSessionTaskDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">    // 获取数据，将responseSerializer和downloadFileURL或data存到userInfo里面</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    //Performance Improvement from #2672</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy];</span><br><span class="line">        //We no longer need the reference, so nil it out to gain back some memory.</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">      // 有error时处理</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 无error时正常处理</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有error时，userInfo先存储error，然后检查manager是否有completionGroup和completionQueue，没有的话，就创建一个dispatch_group_t和在主线程上做completionHandler的操作，并在主线程中发送一个AFNetworkingTaskDidCompleteNotification通知，这个通知在UIKit+AFNetworking里UIRefreshControl +AFNetworking里也会接收到，用来停止刷新，如果你不使用AF的UI部分，你可以通过接收这个通知来做操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>在没有error时，会先对数据进行一次序列化操作，然后下面的处理就和有error的那部分一样了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>一开始我们就看到了clang命令，这个的作用是用来消除特定区域的clang的编译警告，-Wgnu则是消除?:警告，这个是clang的警告message列表<a href="http://fuckingclangwarnings.com/" target="_blank" rel="noopener">Which Clang Warning Is Generating This Message?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line"></span><br><span class="line">// some codes</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再下面两个则是收到数据和下载文件的回调处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - NSURLSessionDataTaskDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    [self.mutableData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSURLSessionDownloadTaskDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSError *fileManagerError = nil;</span><br><span class="line">    self.downloadFileURL = nil;</span><br><span class="line"></span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (self.downloadFileURL) &#123;</span><br><span class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            if (fileManagerError) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在刚才说到的load方法里面，对系统的resume和suspend方法进行了替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换之后，只是增加了通知处理而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)af_resume &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state = [self state];</span><br><span class="line">    [self af_resume];</span><br><span class="line">    </span><br><span class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)af_suspend &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state = [self state];</span><br><span class="line">    [self af_suspend];</span><br><span class="line">    </span><br><span class="line">    if (state != NSURLSessionTaskStateSuspended) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用替换和增加方法时候，用到了关键字inline，inline是为了防止反汇编之后，在符号表里面看不到你所调用的该方法，否则别人可以通过篡改你的返回值来造成攻击，<a href="http://www.blogfshare.com/ioss-static-inline.html" target="_blank" rel="noopener">iOS安全–使用static inline方式编译函数，防止静态分析</a>，特别是在使用swizzling的时候，那除了使用swizzling动态替换函数方法之外，还有别的方法么？有，修改IMP指针指向的方法，<a href="http://www.cocoachina.com/ios/20150717/12623.html" target="_blank" rel="noopener">轻松学习之 IMP指针的作用 - CocoaChina_让移动开发更简单</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在+ load方法中，我们又看到了GCC命令，那clang和GCC在使用的时机有没有什么区别？<a href="http://stackoverflow.com/questions/11838379/should-i-use-pragma-gcc-or-pragma-clang-in-xcode" target="_blank" rel="noopener">通常情况下，在GCC特有的处理或者是在GCC，clang和其他兼容GCC的编译器时，尽量使用<strong>#pragma GCC</strong>，clang特有的处理时，使用<strong>#pragma clang</strong></a>，这个是<a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html" target="_blank" rel="noopener">GCC的message表</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    // ...</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</span><br><span class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>看完之后，有个疑问，查了资料也没有找到：</p>
<p>在NSURLSessionDelegate的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L974~L979" target="_blank" rel="noopener">URLSession:didReceiveChallenge:completionHandler:方法里面disposition会对credential对象做非空判断然后再赋值校验类型</a>，但是NSURLSessionTaskDelegate的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L1025~L1026" target="_blank" rel="noopener">-  [URLSession:task:didReceiveChallenge:completionHandler:]方法里面disposition并不对credential对象做判断，而是直接就赋值校验类型</a>，有知道的，欢迎留言交流</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先来介绍下AFNetWorking，官方介绍如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Foundation URL Loading System&lt;/a&gt;, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.&lt;/p&gt;
&lt;p&gt;Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.&lt;/p&gt;
&lt;p&gt;Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来简单来说就是&lt;/p&gt;
&lt;p&gt;AFNetworking是一个适用于iOS和Mac OS X两个平台的网络库，它是基于&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Foundation URL Loading System&lt;/a&gt;上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS 不付费看微信红包照片</title>
    <link href="http://yuzeyang.github.io/2016/01/26/red-packet/"/>
    <id>http://yuzeyang.github.io/2016/01/26/red-packet/</id>
    <published>2016-01-26T15:11:50.000Z</published>
    <updated>2016-05-18T15:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信今天微信红包照片已经席卷了朋友圈，微信这次创意是非常好的，对发布的照片进行了模糊处理，打开一看，是要发红包才能看到照片的，那怎么办呢？</p>
<p>这怎么能难倒我们这些技术男，一招破解！</p>
<a id="more"></a>
<p>第一种方法Charles</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/hongbaozhaopian.png!600x600" alt=""></p>
<p>来我们一起来抓包看看~</p>
<p>首先设置好自己的WiFi的http代理，绑定好自己的Mac ip地址，打开Charles，选择allow</p>
<p>然后打开你的微信朋友圈，你在Charles里面可以看到</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/zhuabaojieguo.jpg!500x500" alt=""></p>
<p>然后在overview的URL里面，你就可以看到图片的URL地址了，将其拷贝出来，放到浏览器里面打开</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/yuanshitu.png!600x600" alt=""></p>
<p>ok~就这么简单~</p>
<hr>
<p><strong>下面讲下第二种方法</strong></p>
<p>用另一个iOS工具，叫做Replica</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/replica.png!600x600" alt=""></p>
<p>打开Replica之后，启动Start，然后会打开VPN，按操作一步一步即可</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/replica_start.png!600x600" alt=""></p>
<p>然后打开微信朋友圈，再返回到Replica，进到Analytics，点击最新的session，里面会有最新的POST/GET的数据</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/post_get_data.png!600x600" alt=""></p>
<p>然后找到180.163开头的GET请求，点进去，切到Response，可以看到这个GET请求到的数据类型是image，然后打开Image Viewer</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/180.163.png!600x600" alt=""></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/yuanshitu2.png!600x600" alt=""></p>
<p>也是可以将图片显示出来的</p>
<p>我们可以发现照片的模糊处理是在本地做的</p>
<p>当然这个我们只是娱乐为主，这次的产品设计还是非常不错的，点个赞喔~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信今天微信红包照片已经席卷了朋友圈，微信这次创意是非常好的，对发布的照片进行了模糊处理，打开一看，是要发红包才能看到照片的，那怎么办呢？&lt;/p&gt;
&lt;p&gt;这怎么能难倒我们这些技术男，一招破解！&lt;/p&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="http://yuzeyang.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS 给App添加TouchID验证</title>
    <link href="http://yuzeyang.github.io/2016/01/19/TouchID/"/>
    <id>http://yuzeyang.github.io/2016/01/19/TouchID/</id>
    <published>2016-01-19T14:47:27.000Z</published>
    <updated>2016-05-18T15:04:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>TouchID验证这个在iOS8中已经对开发者开放使用了，而且需在5s以上真机才能使用，这个出来已经比较早了，相信很多人都应该已经知道怎么使用TouchID了，但是就目前我使用的App来说，看到使用TouchID验证的占得数量并不多，对于一些涉及到安全性的App来说，很有可能你的解锁验证、App登录以及支付验证都是用的TouchID使用TouchID验证还是有风险的，但是有些App增加使用TouchID作为一种验证还是不错的选择，既快捷又方便，对于开发者来说增加的成本也很低</p>
<a id="more"></a>
<p>这个是我所讲的demo的源码<a href="https://github.com/Yuzeyang/TouchIDDemo" target="_blank" rel="noopener">TouchID demo</a>，代码量非常少</p>
<hr>
<p>下面我就来介绍下怎么给App增加TouchID验证吧</p>
<p>首先，要使用TouchID，得先引入LocalAuthentication.framework这个库，这里面只有四个头文件，但实际使用到的只有LAContext.h和LAError.h这两个头文件</p>
<p>在做验证时，我们只需要使用到LAContext中的两个方法</p>
<p>我们先初始化一个LAContext对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LAContext *ctx = [[LAContext alloc] init];</span><br></pre></td></tr></table></figure>
<p>然后调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError*__autoreleasing*)error;</span><br></pre></td></tr></table></figure>
<p>方法来确定当前指定的验证方法能否使用，LAPolicy是个枚举，里面只有两个值，一个是LAPolicyDeviceOwnerAuthenticationWithBiometrics（使用该设备的TouchID验证），LAPolicyDeviceOwnerAuthentication（使用该设备的TouchID和设备密码验证）</p>
<p>这里返回的是一个布尔值，错误处理我等下一起说明，当返回可以使用当前指定的验证法方法时，我们调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)evaluatePolicy:(LAPolicy)policy localizedReason:(NSString*)localizedReason reply:(void(^)(BOOLsuccess,NSError*__nullableerror))reply;</span><br></pre></td></tr></table></figure>
<p>方法开始使用TouchID验证，localizedReason指的是在弹出TouchID验证框时提示的文字，reply指的是在做指纹验证或者密码验证后的结果返回，我将localizedReason用@”通过Home键验证已有手机指纹”作为提示，下图比较直观</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/TouchID1.png!600x600" alt=""></p>
<p>刚才布尔值的错误对应的是哪些呢？</p>
<p>这就用到了LAError.h这个类，这个类定义了目前所有的验证失败的错误code，我直接将它copy过来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">typedefNS_ENUM(NSInteger, LAError)</span><br><span class="line">&#123;</span><br><span class="line">	/// 校验失败</span><br><span class="line">	LAErrorAuthenticationFailed =kLAErrorAuthenticationFailed,</span><br><span class="line"></span><br><span class="line">    /// 用户取消验证</span><br><span class="line">	LAErrorUserCancel=kLAErrorUserCancel,</span><br><span class="line"></span><br><span class="line">	/// 用户回退（返回密码校验）</span><br><span class="line">	LAErrorUserFallback=kLAErrorUserFallback,</span><br><span class="line"></span><br><span class="line">	/// 系统取消校验</span><br><span class="line">	LAErrorSystemCancel=kLAErrorSystemCancel,</span><br><span class="line"></span><br><span class="line">	/// 密码未设置</span><br><span class="line">	LAErrorPasscodeNotSet=kLAErrorPasscodeNotSet,</span><br><span class="line"></span><br><span class="line">	/// 指纹不正确</span><br><span class="line">	LAErrorTouchIDNotAvailable=kLAErrorTouchIDNotAvailable,</span><br><span class="line"></span><br><span class="line">	/// 没有录入指纹</span><br><span class="line">	LAErrorTouchIDNotEnrolled=kLAErrorTouchIDNotEnrolled,</span><br><span class="line"></span><br><span class="line">	/// TouchID被锁定</span><br><span class="line">	LAErrorTouchIDLockoutNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorTouchIDLockout,</span><br><span class="line"></span><br><span class="line">	/// App取消验证</span><br><span class="line">	LAErrorAppCancelNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorAppCancel,</span><br><span class="line"></span><br><span class="line">	/// 无效的上下文环境</span><br><span class="line">	LAErrorInvalidContextNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorInvalidContext</span><br><span class="line">&#125;NS_ENUM_AVAILABLE(10_10,8_0);</span><br></pre></td></tr></table></figure>
<p>而前四种error是针对于能确定使用验证后，在验证后返回的错误</p>
<p>后六种error是针对于不能使用验证的原因</p>
<p>你可以针对这些原因做一些相应的操作，比如弹窗等等</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TouchID验证这个在iOS8中已经对开发者开放使用了，而且需在5s以上真机才能使用，这个出来已经比较早了，相信很多人都应该已经知道怎么使用TouchID了，但是就目前我使用的App来说，看到使用TouchID验证的占得数量并不多，对于一些涉及到安全性的App来说，很有可能你的解锁验证、App登录以及支付验证都是用的TouchID使用TouchID验证还是有风险的，但是有些App增加使用TouchID作为一种验证还是不错的选择，既快捷又方便，对于开发者来说增加的成本也很低&lt;/p&gt;
    
    </summary>
    
    
      <category term="TouchID" scheme="http://yuzeyang.github.io/tags/TouchID/"/>
    
  </entry>
  
  <entry>
    <title>iOS 基于GCDAsyncSocket快速开发Socket通信</title>
    <link href="http://yuzeyang.github.io/2016/01/17/GCDAsyncSocket-socket/"/>
    <id>http://yuzeyang.github.io/2016/01/17/GCDAsyncSocket-socket/</id>
    <published>2016-01-17T14:10:53.000Z</published>
    <updated>2016-08-05T03:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>GCDAsyncSocket是CocoaAsyncSocket第三方库中的其中一个类，本文介绍的就是基于这一个类来做快速的socket通信开发，而且该库已经支持IPv4和IPv6</p>
<p>我们对GCDAsyncSocket做了一层封装调用，它包含了建连、断开、重连、心跳、自定义请求</p>
<a id="more"></a>
<hr>
<p>首先，介绍一下CocoaAsyncSocket第三方库的用途</p>
<blockquote>
<p>CocoaAsyncSocket provides easy-to-use and powerful asynchronous socket libraries for Mac and iOS. </p>
</blockquote>
<p>翻译成：</p>
<blockquote>
<p>CocoaAsyncSocket为Mac和iOS提供了易于使用且强大的异步通信库</p>
</blockquote>
<p>在Podfile文件中，只要加上这句话就可以使用了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;CocoaAsyncSocket&apos;, &apos;7.4.1&apos;</span><br></pre></td></tr></table></figure>
<hr>
<p>简单的Socket通信包括了建连、断开连接、发送socket业务请求、重连这四个基本功能</p>
<p>下面，我就按照这个四个基本功能来讲一下，怎么来使用CocoaAsyncSocket中GCDAsyncSocket这个类来开发Socket通信</p>
<p>首先，Socket在第一步时，需要建连才能开始通信</p>
<p>在GCDAsyncSocket中提供了四种初始化的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init;</span><br><span class="line">- (id)initWithSocketQueue:(dispatch_queue_t)sq;</span><br><span class="line">- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq;</span><br><span class="line">- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq;</span><br><span class="line"></span><br><span class="line">@property (atomic, weak, readwrite) id delegate;</span><br><span class="line">#if OS_OBJECT_USE_OBJC</span><br><span class="line">@property (atomic, strong, readwrite) dispatch_queue_t delegateQueue;</span><br><span class="line">#else</span><br><span class="line">@property (atomic, assign, readwrite) dispatch_queue_t delegateQueue;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>sq是socket的线程，这个是可选的设置，如果你写null，GCDAsyncSocket内部会帮你创建一个它自己的socket线程，如果你要自己提供一个socket线程的话，千万不要提供一个并发线程，在频繁socket通信过程中，可能会阻塞掉，个人建议是不用创建</p>
<p>aDelegate就是socket的代理</p>
<p>dq是delegate的线程</p>
<p>必须要需要设置socket的代理以及代理的线程，否则socket的回调你压根儿就不知道了，</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.socket =[[GCDAsyncSocket alloc] initWithDelegate:delegate delegateQueue:dispatch_get_main_queue()];</span><br></pre></td></tr></table></figure>
<p>接着，在设置代理之后，你需要尝试连接到相应的地址来确定你的socket是否能连通了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)connectToHost:(NSString *)host</span><br><span class="line">               onPort:(uint16_t)port</span><br><span class="line">          withTimeout:(NSTimeInterval)timeout</span><br><span class="line">                error:(NSError **)errPtr;</span><br></pre></td></tr></table></figure>
<p>host是主机地址，port是端口号</p>
<p>如果建连成功之后，会收到socket成功的回调，在成功里面你可以做你需要做的一些事情，我这边的话，是做了心跳的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port;</span><br></pre></td></tr></table></figure>
<p>如果建连失败了，会收到失败的回调，我这边在失败里面做了重连的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err;</span><br></pre></td></tr></table></figure>
<p>重连操作其实比较简单，只需要再调用一次建连请求，我这边设置的重连规则是重连次数为5次，每次的时间间隔为2的n次方，超过次数之后，就不再去重连了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)socketDidDisconnect:(GCDAsyncSocket*)sock withError:(NSError*)err &#123;</span><br><span class="line"></span><br><span class="line">	self.status= -1;</span><br><span class="line"></span><br><span class="line">	if(self.reconnection_time&gt;=0 &amp;&amp; self.reconnection_time &lt;= kMaxReconnection_time) &#123;</span><br><span class="line"></span><br><span class="line">		[self.timer invalidate];</span><br><span class="line"></span><br><span class="line">		self.timer=nil;</span><br><span class="line"></span><br><span class="line">		int time =pow(2,self.reconnection_time);</span><br><span class="line"></span><br><span class="line">		self.timer= [NSTimer scheduledTimerWithTimeInterval:time target:selfselector:@selector(reconnection) userInfo:nil repeats:NO];</span><br><span class="line"></span><br><span class="line">		self.reconnection_time++;</span><br><span class="line"></span><br><span class="line">		NSLog(@&quot;socket did reconnection,after %ds try again&quot;,time);</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line"></span><br><span class="line">		self.reconnection_time=0;</span><br><span class="line"></span><br><span class="line">		NSLog(@&quot;socketDidDisconnect:%p withError: %@&quot;, sock, err);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我用status来标记socket的连接状态</p>
<p>那么socket已经建连了，该怎么发起socket通信呢？</p>
<p>你需要和后端开发人员商定好socket协议格式，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSString stringWithFormat:@&quot;&#123;\&quot;version\&quot;:%d,\&quot;reqType\&quot;:%d,\&quot;body\&quot;:\&quot;%@\&quot;&#125;\r\n&quot;,PROTOCOL_VERSION,reqType,reqBody];</span><br></pre></td></tr></table></figure>
<p>中间应该大家都能看得懂，那为什么后面需要加上\r\n呢？</p>
<p>这个\r\n是socket消息的边界符，是为了防止发生消息黏连，没有\r\n的话，可能由于某种原因，后端会收到两条socket请求，但是后端不知道怎么拆分这两个请求</p>
<p>同理，在收到socket请求回调时，也会根据这个边界符去拆分</p>
<p>那为什么要用\r\n呢？</p>
<p>而且GCDAsyncSocket不支持自定义边界符，它提供了四种边界符供你使用\r\n、\r、\n、空字符串</p>
<p>在拼装好socket请求之后，你需要调用GCDAsyncSocket的写方法，来发送请求，然后在写完成之后你会收到写的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.socket writeData:requestData withTimeout:-1 tag:0];</span><br></pre></td></tr></table></figure>
<p>timeout是超时时间，这个根据实际的需要去设置</p>
<p>这个是写的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)socket:(GCDAsyncSocket*)sock didWriteDataWithTag:(long)tag；</span><br></pre></td></tr></table></figure>
<p>在写之后，需要再调用读方法，这样才能收到你发出请求后从服务器那边收到的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.socketreadDataToData:[GCDAsyncSocket CRLFData] withTimeout:10 maxLength:50000 tag:0];</span><br></pre></td></tr></table></figure>
<p>[GCDAsyncSocket CRLFData]这里是设置边界符，maxLength是设置你收到的请求数据内容的最大值</p>
<p>在读回调里面，你可以根据不同业务来执行不同的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)socket:(GCDAsyncSocket*)sock didReadData:(NSData*)data withTag:(long)tag;</span><br></pre></td></tr></table></figure>
<p>最后一个则是断开连接，这个只需要调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.socket disconnect];</span><br></pre></td></tr></table></figure>
<p>ok，这样的话，最简单基础的socket通信，你已经大致能完成了~</p>
<hr>
<p>2016.4.26更新</p>
<p>在网络环境以及其他因素下，很有可能会造成客户端或者后端没有接收到回调或者请求，那该怎么办？</p>
<p>我们需要加上消息回执的处理</p>
<p>客户端发出请求的时候，可以将该请求放到存到数组里面，等到后端的相应回调在移除掉，如果该请求超时或者在一段时间内没有收到确认返回，说明后端没有接收到我们的请求，我们可以将该请求重新发送</p>
<p>客户端接收请求的时候，后端将数据发给客户端，客户端需要增加回执处理，告诉后端，客户端接收到数据了，如果后端没接收到，也重新推一遍数据，客户端和后端双向保护来解决丢失问题</p>
<p>2016.8.5更新</p>
<p>有些时候，不能定位是否是后端问题还是客户端/SDK问题的时候，可以用命令行抓一下socket包看看（用Charles只能抓http和https包）</p>
<p>命令行如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i any -n -X port 7070</span><br></pre></td></tr></table></figure>
<p>Tip：7070端口号请根据实际的调试端口号修改</p>
<p>效果如下：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/socketPacket.png" alt=""></p>
<p>红色部分就是socket包的内容了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCDAsyncSocket是CocoaAsyncSocket第三方库中的其中一个类，本文介绍的就是基于这一个类来做快速的socket通信开发，而且该库已经支持IPv4和IPv6&lt;/p&gt;
&lt;p&gt;我们对GCDAsyncSocket做了一层封装调用，它包含了建连、断开、重连、心跳、自定义请求&lt;/p&gt;
    
    </summary>
    
    
      <category term="GCDAsyncSocket,Socket" scheme="http://yuzeyang.github.io/tags/GCDAsyncSocket-Socket/"/>
    
  </entry>
  
  <entry>
    <title>零下三十度的哈尔滨之行</title>
    <link href="http://yuzeyang.github.io/2016/01/12/Harbin-travel/"/>
    <id>http://yuzeyang.github.io/2016/01/12/Harbin-travel/</id>
    <published>2016-01-12T11:37:10.000Z</published>
    <updated>2016-05-18T15:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在年假过期之前，我和同事们想着用这个年假去哪儿浪，后来商量之后，决定去一趟哈尔滨看看，当然对于一直从未感受过零下十度以下的南方汉子们，特别是IT宅男们来说，那里的冷是根本想象不到的。（多图预警！！！）</p>
<a id="more"></a>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/afraid.jpg" alt=""></p>
<p>我们定在1月7日出发，刚好和元旦错开了，但是没办法，冰雪节在元旦之后才开始..哎，不然玩的时间就更长了。</p>
<p>前期的准备还是很重要的！</p>
<p><strong>1.帽子-防风防寒</strong></p>
<p><strong>2.口罩-棉/厚（戴眼镜的人极其痛苦…根本不能带口罩）</strong></p>
<p><strong>3.围巾-厚</strong></p>
<p><strong>4.耳套</strong></p>
<p><strong>5.保暖内衣.羊毛衫.抓绒外套.羽绒服 至少四层</strong></p>
<p><strong>6.棉毛裤.棉裤.冲锋裤 至少穿三层</strong></p>
<p><strong>7.厚袜子 至少两双</strong></p>
<p><strong>8.手套</strong></p>
<p><strong>9.棉鞋.雪地靴</strong></p>
<p><strong>10.雪套（这个好像我带去都没有用到）</strong></p>
<p><strong>11.保温杯</strong></p>
<p><strong>12、暖宝宝（这个用到的时间不是很多，不过站在雪地的时候，可以贴一个在脚底抵挡一些寒冷）</strong></p>
<p>千等万等，终于等到出发的日子了，我们一行人也是高高兴兴的粗发啦，坐的是四川航空，空姐和空少都有点胖胖的…好桑心…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/INeedAV.jpg" alt=""></p>
<p>从杭州到哈尔滨的飞机需要三个小时左右的行程，快到哈尔滨的时候，从飞机上往下看，地都是雪白雪白的，这叫尔等南方来的汉子们很是激动啊，白茫茫的一片~</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/snow.jpeg!600x600" alt="飞机上俯瞰的雪景"></p>
<p>飞机降落之后，我们打车到中央大街，在打车的时候要注意一点，有些司机会向你收取<strong>高速路的过路费</strong>，并且让你取消订单，用现金支付。现金支付是可以的，因为听说最近某滴已经开始向司机收取好像20%的服务费了，但<strong>你千万不要给司机高速路的过路费</strong>，因为高速路的过路费，在从哈尔滨到机场的路上，有其他乘客已经帮你付了，这个是没有办法的，但是返程从机场到哈尔滨是不用付的，这个是司机想多赚你的钱！</p>
<p>在进过的路上，我也不知道什么路…有用冰砖搭的一座城，很是漂亮，从没有近距离的看过…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/snow2.jpeg!600x600" alt="冰城"></p>
<p>经过快一个小时的车程（还是有点堵的），到了中央大街，据说这个一条非常热闹而且有名的街（因为之前吃住全是另外一个同事订好的..所以我都没有提前去了解..），下了飞机之后感觉瞬间变冷，得赶紧去旅馆加上衣服，基本按照上面必备的那么穿就不冷了，哈尔滨的天气衣服穿够了，身上不冷，但是风打在脸上还是很冷的，时间一长，鼻子就受不了了。</p>
<p>逛中央大街的时候，门口就有个烤肠，非常好吃！但是不要买多…吃了一两根之后我感觉就有点吃不下了…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/xiangchang.jpeg!600x600" alt="烤肠"></p>
<p>在旅馆门口还有一个用冰砖搭起来的滑梯，要收费，10元滑一次，因为想到晚上要去冰雪大世界了，也就没上去玩了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/binghuati.jpeg!600x600" alt="冰滑梯"></p>
<p>中央大街上面有很多非常有特色店：马迭尔冰棍（这个冰棍买的人特别多），华梅西餐厅（据说连哈尔滨人也都排队还吃不上，最后一天我们想去吃，但是排队的人实在太多了，就没吃了，好可惜），老厨家（这个很有历史也很好吃）等等，那里的店大多都很有特色</p>
<p>沿着中央大街走就可以走到防洪纪念塔，在纪念塔后面就是松花江，江面全部都结冰了，看得我都傻了..上面都是游人在滑冰，玩耍，冰面还是比较滑的，要小心，里面的娱乐项目看情况选择玩吧，出来玩，开心还是最重要的（我一般都是这么想的，飞机票、吃住都花了这么多了，不差这点娱乐的钱了…）</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/songhuajiang.jpeg!600x600" alt="松花江"></p>
<p>晚上就出发去了冰雪大世界玩，在那里鞋一定要穿暖，因为有些项目是需要排队的，站那脚特别冷..而且可以考虑先去排队玩大滑梯，据说很刺激，但是因为排队的人太多了，我们就很遗憾的没有去玩了，里面玩的都是滑梯，看冰雕，感受下冰的魅力，对于南方来的我们玩的还是非常开心的~但是很遗憾我没有找到冰雪大世界的照片，不过同事那里有，之后我会更新上来</p>
<p>在冰雪大世界这么疯狂的消耗体力之后，肯定会饿了，我们用美团搜到了一家非常好吃的烧烤店叫1981烧烤（好像是这个名字），价格也不贵，烤的非常好吃，以致于有个同事一连三天拉着我吃烧烤，别说，北方的烧烤还真的比南方要好吃一点，哈哈</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/1981shaokao.jpeg!600x600" alt="1981烧烤"></p>
<p>第二天，我们选择去了雪乡，听说那里是因为拍了爸爸去哪了之后，才火起来的，但是因为客服的原因，把我们的名单弄错了，导致没坐上大巴车，结果搞了辆小面包，后面的事情就更凄惨了…雪乡的路上有个坡，路面滑，怎么都上不去，装防滑条，断了，装防滑链，装不上…啊…真的是日了够了，搞了一两个小时，本来出发时间就耽搁了，这么一搞就更晚了，结果一辆路过的大巴车救了我们，达到雪乡花了我们12个小时…醉了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/zhuangfanghualian.jpeg!600x600" alt="装防滑链"></p>
<p>但是雪乡沿途的风景还是很漂亮的，厚厚的雪，还有雾凇</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/xuejing.jpeg!600x600" alt="雪景"></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/wusong.jpeg!600x600" alt="雾凇"></p>
<p>到雪乡之后，就是夜晚了，虽然还是5点多钟，但天黑的特别早，雪乡一进来就给人的感觉是商业化比较严重，已经很难看出原来的风土人情了。雪乡里面能看到雪橇犬，还是马拉车，车还是有牌照的…</p>
<p>我们因为路途的劳累也没出去逛，雪乡之行还是意外的可惜，草草的就结束了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/xuexiangyejing.jpeg!600x600" alt="雪乡夜景"></p>
<p>我们一行人睡的是五人炕，但是后来听北方的同事说，那个好像是电子炕，不是火烧那种了</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/wurenkang.jpeg!600x600" alt="五人炕"></p>
<p>在那里我们买了冰柿子，冰草莓，冰梨，发现太硬了太冷了…后来放那软了就扔了…后来听说那个是要放冷水里化开了再吃的…吃的..的，我们就忧伤了…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/bingcaomei.jpeg!600x600" alt="冰草莓"></p>
<p>第三天我们就从雪乡出发，去往亚布力滑雪，第一次滑雪的我来说可兴奋了ヾ(o◕∀◕)ﾉヾ，同事说去30°坡的滑雪场，我说太平了是不是不好玩，我说要45°的，后来少数服从多数，我们还是去了30°的滑雪场，到那里存好东西之后，有条件的可以请个教练带一带你，没有的，可以让会的同事带你，不然就像我一样，从坡上面一直摔到了坡下面….因为不懂怎么刹车…就一直摔…好疼…而且穿着滑雪鞋，容易崴脚，最后我去了儿童区，还是摔/(ㄒoㄒ)/~~</p>
<p>回来的晚上我们好好的逛了下中央大街，在老厨家吃了顿放，和北方的同事聚了一下，总结了一下北方的菜有点咸，但是量特足，5个人基本点3个菜就差不多了</p>
<p>中央大街的夜景也非常漂亮，街道两旁都有大型的冰雕，品牌赞助…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/shengdanshu.jpeg!600x600" alt="圣诞树"></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/beijixiong.jpeg!600x600" alt="北极熊小屋"></p>
<p>最后一天我们就去了圣索菲亚大教堂，据说教堂里面是没有什么好看的，都是买纪念品，只要外面参观下就可以了，而且有鸽子的区域没有我想象中的那么大，就那一小块地方…</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/jiaotang.jpeg!600x600" alt="教堂正面"></p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/gezi.jpeg!600x600" alt="教堂旁的鸽子"></p>
<p>匆匆的哈尔滨之行就愉快的结束了，好期待下一次的旅行~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在年假过期之前，我和同事们想着用这个年假去哪儿浪，后来商量之后，决定去一趟哈尔滨看看，当然对于一直从未感受过零下十度以下的南方汉子们，特别是IT宅男们来说，那里的冷是根本想象不到的。（多图预警！！！）&lt;/p&gt;
    
    </summary>
    
    
      <category term="哈尔滨" scheme="http://yuzeyang.github.io/tags/%E5%93%88%E5%B0%94%E6%BB%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS TableView上拉下拉刷新控件（二）</title>
    <link href="http://yuzeyang.github.io/2016/01/06/iOS_TableView_refresh_controller-two/"/>
    <id>http://yuzeyang.github.io/2016/01/06/iOS_TableView_refresh_controller-two/</id>
    <published>2016-01-06T14:59:44.000Z</published>
    <updated>2016-05-17T15:22:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇我们来讲如何将loading圆圈动画和TableView结合起来一起使用。</p>
<a id="more"></a>
<p>首先，我们需要将loading圆圈和提示label加到一个view上去显示，实现的主要点有两点：第一，在上拉或者下拉的过程中，我们通过progress值去控制loading圆圈的动画和label的alpha值，第二，通过设置拉动的方向来设置label提示的内容</p>
<p>然后，我们该怎么去获得这个progress值呢？</p>
<p>首先，我们在初始化的时候需要监听所关联的scrollView的contentOffset值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.scrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br></pre></td></tr></table></figure>
<p>然后在observeValueForKeyPath里面，我们获取contentOffset的最新值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGPoint contentOffset = [[change valueForKey:NSKeyValueChangeNewKey] CGPointValue];</span><br></pre></td></tr></table></figure>
<p>然后再通过计算来改变progress值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.progress = MAX(0.0, MIN(fabs((self.originOffset + contentOffset.y)/kMaxPullDownDistance), 1.0));</span><br></pre></td></tr></table></figure>
<p>（注：在这里有个originOffset值，这个是我用来处理是否有导航栏的情况，有则该值为64.0，没有则为0.0）</p>
<p>计算的思路是我们通过所关联的scrollView的contentOffset与我们所设置的最大的拉动距离值相除作比较，得到的就是拉动的一个范围比例，因为contentOffset会超出我们设置的最大拉动距离，所以我们需要再取最小最大值，来获取到最后的progress值。</p>
<hr>
<p>在这里插一个小的知识点，因为这个是在写上拉时，所必须知道的一个点，contentOffset是怎么算的？</p>
<p>contentOffset是scrollview当前显示区域顶点相对于frame顶点的偏移量</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/contentOffset.png" alt=""></p>
<p>但当上拉刷新之后，此时scrollview的contentSize变化了，（contentSize指的是可显示区域），在计算contentOffset时，需要将contentSize减去scrollView的高度，来和contentOffset作比较。</p>
<p>拿到progress之后，此时我们离完成这个控件的任务就差不多了。</p>
<p>首先，我们需要将progress赋值给loading圆圈和提示label，</p>
<p>然后如果我们拉动的距离超过了设置最大值的时候，我们做loading，并且通过block让外部做一些网络请求或者其他的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self startLoading:self.refreshView];</span><br><span class="line">                </span><br><span class="line">// 0.3s animation time is the best experience</span><br><span class="line">[UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">    self.scrollView.contentInset = UIEdgeInsetsMake(kMaxPullDownDistance + self.originOffset, 0, 0, 0);</span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line">    if (self.refreshingBlock) &#123;</span><br><span class="line">        self.refreshingBlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在上拉时，有一点不同，scrollView的contentSize可能是会变化的，而我们的控件是要始终显示在它的最下方的，所以我们在上拉时，需要对contentSize也加监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.scrollView addObserver:self forKeyPath:@&quot;contentSize&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br></pre></td></tr></table></figure>
<p>并且在observeValueForKeyPath里面，需要设置控件的center来改变我们的显示位置，以及progress值，其他操作都和下拉刷新一样。</p>
<p>ok，我们的上拉下拉刷新控件完成喽~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇我们来讲如何将loading圆圈动画和TableView结合起来一起使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TableView" scheme="http://yuzeyang.github.io/tags/TableView/"/>
    
  </entry>
  
  <entry>
    <title>iOS TableView上拉下拉刷新控件（一）</title>
    <link href="http://yuzeyang.github.io/2016/01/05/iOS_TableView_refresh_controller_one/"/>
    <id>http://yuzeyang.github.io/2016/01/05/iOS_TableView_refresh_controller_one/</id>
    <published>2016-01-05T14:29:07.000Z</published>
    <updated>2016-05-17T15:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>注：此刷新控件的效果是来自KittenYang的一个GIF图，他有很多动画分析和写得都不错，大家可以关注一下~</p>
<p>推荐一个非常好的动画效果网站：<a href="http://uimovement.com/" target="_blank" rel="noopener">UI Movement</a>，里面很多设计出的动画效果都非常好，都可以一一实现看看哦</p>
<a id="more"></a>
<hr>
<p>话不多说，先看下我要讲的刷新控件效果：</p>
<p>1.无导航栏的刷新控件效果图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/TableRefreshAnimation1.gif" alt=""></p>
<p>2.有导航栏的刷新控件效果图：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/TableRefreshAnimation2.gif" alt="">            </p>
<hr>
<p>好了，进入正题。</p>
<p>首先看到这个控件的时候，我们要去分析，这个控件是由哪几部分组成的，可以看到这个控件是只是由一个loading圆圈和label提示文字组成的，而label比较简单，在这里我就不具体说怎么实现了，大家可以直接看源码，这篇文章，我主要讲怎么实现这个loading圆圈的转圈效果。</p>
<p>首先这个转圈分成两部分，我们将它分成0.0-0.5和0.5-1.0这两个阶段。</p>
<p>在0.0-0.5这个过程的动画是这样的：</p>
<p>​    <img src="http://7xtit4.com1.z0.glb.clouddn.com/refresh0-0.5.gif" alt=""></p>
<p>以左边的线为例，上顶点为B点，下顶点为A点，实际上这个过程只是，A，B两点的y值在随着progress的变化而变化，x是不变的，所以我们可以得到A，B两点的坐标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGPoint leftA = CGPointMake(kCenterX - kLineLength, kCenterY + 2*kLineLength - self.progress/0.5*kLineLength);</span><br><span class="line">CGPoint leftB = CGPointMake(leftA.x, leftA.y - kLineLength);</span><br></pre></td></tr></table></figure>
<p>然后我们用贝塞尔曲线，将两点连起来，从A点到B点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[leftPath moveToPoint:leftA];</span><br><span class="line">[leftPath addLineToPoint:leftB];</span><br></pre></td></tr></table></figure>
<p>那这个尖角怎么办呢？我们利用以前学过的数学知识，假设尖角的角度是30°，那x值就是leftB.x-kArrowLength<em>sin(kArrowAngle)，y值就是leftB.y+kArrowLength</em>cos(kArrowAngle)，假设这个点是C点，最后就是将C点和B点相连</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[arrowPath moveToPoint:leftB];</span><br><span class="line">[arrowPath addLineToPoint:CGPointMake(leftB.x - kArrowLength*sin(kArrowAngle), leftB.y + kArrowLength*cos(kArrowAngle))];</span><br><span class="line">[leftPath appendPath:arrowPath];</span><br></pre></td></tr></table></figure>
<p>这样我们就完成了0.0-0.5的动画，这个一部分还是比较简单的。</p>
<p>下面是0.5-1.0的动画过程：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/refresh0.5-1.gif" alt=""></p>
<p>当到达0.5的时候，原先的B点开始保持不动，它的位置始终是CGPointMake(kCenterX-kLineLength,kCenterY)，而A点也渐渐向B点靠近，CGPointMake(kCenterX-kLineLength,kCenterY+kLineLength- (self.progress-0.5)/0.5*kLineLength)，那这个圆弧是怎么出来的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);</span><br></pre></td></tr></table></figure>
<p>在绘制贝塞尔曲线里面，有一个绘制圆弧的方法，center是以某一个点为圆心绘制圆弧，</p>
<p>radius是半径，startAngle是开始角度，endAngle是结束角度，clockwise是是否以顺时针绘制，ok，我们就用这个来绘制我们的圆弧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[leftPath moveToPoint:leftA];</span><br><span class="line">[leftPath addLineToPoint:leftB];</span><br><span class="line">[leftPath addArcWithCenter:CGPointMake(kCenterX, kCenterY) radius:kLineLength startAngle:M_PI endAngle:M_PI+M_PI*(self.progress - 0.5)/0.5*9/10 clockwise:YES];</span><br></pre></td></tr></table></figure>
<p>恩，圆弧也画好了，那我们的尖角是不是也按照刚才的那样写就可以了？恩，差不多哦，只是我们在原有尖角30°的基础上，需要加上我们圆弧旋转的角度，才是真正尖角与圆弧顶点的切线角度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGPointMake(leftPath.currentPoint.x - kArrowLength*sin(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10),leftPath.currentPoint.y + kArrowLength*cos(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10))</span><br></pre></td></tr></table></figure>
<p>好了，尖角顶点也知道了，那连接只要和原来一样就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[arrowPath moveToPoint:leftPath.currentPoint];</span><br><span class="line">[arrowPath addLineToPoint:CGPointMake(leftPath.currentPoint.x - kArrowLength*sin(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10),</span><br><span class="line">                                              leftPath.currentPoint.y + kArrowLength*cos(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10))];</span><br><span class="line">[leftPath appendPath:arrowPath];</span><br></pre></td></tr></table></figure>
<p>好了，左边的动画是这样，右边的只要对称即可~</p>
<p>是不是看上去比较复杂的动画，将它分解开来，就变得简单了呢？</p>
<p>下一篇，我会讲怎么将这个动画和tableview结合起来使用~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：此刷新控件的效果是来自KittenYang的一个GIF图，他有很多动画分析和写得都不错，大家可以关注一下~&lt;/p&gt;
&lt;p&gt;推荐一个非常好的动画效果网站：&lt;a href=&quot;http://uimovement.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UI Movement&lt;/a&gt;，里面很多设计出的动画效果都非常好，都可以一一实现看看哦&lt;/p&gt;
    
    </summary>
    
    
      <category term="TableView" scheme="http://yuzeyang.github.io/tags/TableView/"/>
    
  </entry>
  
  <entry>
    <title>TextField字数限制处理</title>
    <link href="http://yuzeyang.github.io/2015/09/17/TextField_count_limit_handle/"/>
    <id>http://yuzeyang.github.io/2015/09/17/TextField_count_limit_handle/</id>
    <published>2015-09-17T14:40:44.000Z</published>
    <updated>2016-05-16T15:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在第三方键盘加入之后，对于字数限制的处理不再像之前那么简单了</p>
<a id="more"></a>
<p>纯数字、字符输入（不包括粘贴）这样的字数限制还是相对比较简单的，你可以用两种方法进行处理</p>
<p>第一种是<strong>textfield的delegate</strong>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123;</span><br><span class="line">    if (range.length + range.location &gt; textField.text.length) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    NSUInteger newLength = textField.text.length + string.length - range.length;</span><br><span class="line">    return newLength&lt;=kMaxCharacterCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种<strong>是注册一个通知</strong>，在textfield编辑时做处理：</p>
<p>首先你在viewDidLoad中注册通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFiledEditChanged:) name:UITextFieldTextDidChangeNotification object:self.shopName];</span><br></pre></td></tr></table></figure>
<p>再实现通知里面的方法，在超过最大值时，取最大的字数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (self.shopName.text.length &gt; kMaxCharacterCount) &#123;</span><br><span class="line">        self.shopName.text = [self.shopName.text substringToIndex:kMaxCharacterCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，在中文的限制上面情况就复杂了，当时在调试的时候，因为使用的是第三方键盘，所以当时没有发现问题，但是在使用系统键盘的时候，一下子就蛋疼了….</p>
<p>下面我开始分析一下，两者的区别：</p>
<p>1、第三方键盘在输入字符时，一般是不会将字符直接输入到textfield中，而是将字符显示在它自己的view上方，但是系统键盘会直接输入到textfield中，而且它会占2个字符长度，比如你输入”abcd”，在textfield中显示的是”a b c d”，并且”a b c d”是处在高亮中的，并不算是真正输入到textfield中，所以我们不应把高亮的字符计算在内，我们应该计算真正输入的字符</p>
<p>2、如果我们使用的是delegate做处理的时候，系统中文输入的时候会有联想，但是联想的那个字并不会调用delegate，比如你输入一个”你”，在系统的联想里面可能会出现”的”,”们”这样的联想，但是你选择”的”的时候，delegate并不会调用，（尼玛….），我猜想联想输入应该不算做keyboard所触发的事件，所以他并不会触发delegate，但是如果你注册的是通知，他倒是会调用，（还好有救）</p>
<p>另外提醒一下，有时候在自测输入的时候，要考虑全面，比如粘贴这也是一种输入，当时没考虑，我也是跪了</p>
<p>好了，分析了主要的区别下面我们就来看看具体怎么实现吧~</p>
<p>在实现注册通知方法里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - UITextViewDelegate</span><br><span class="line">- (void)textViewDidChange:(UITextView *)textView &#123;</span><br><span class="line">    if (textView.text.length == 0) &#123;</span><br><span class="line">        self.recommendTips.hidden = NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        self.recommendTips.hidden = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *toBeString = textView.text;</span><br><span class="line">    NSString *lang = self.textInputMode.primaryLanguage; // 键盘输入模式</span><br><span class="line">    if ([lang isEqualToString:@&quot;zh-Hans&quot;]) &#123; // 简体中文输入，包括简体拼音，健体五笔，简体手写</span><br><span class="line">        UITextRange *selectedRange = [textView markedTextRange];</span><br><span class="line">        //获取高亮部分</span><br><span class="line">        UITextPosition *position = [textView positionFromPosition:selectedRange.start offset:0];</span><br><span class="line">        // 没有高亮选择的字，则对已输入的文字进行字数统计和限制</span><br><span class="line">        if (!position || !selectedRange) &#123;</span><br><span class="line">            if (toBeString.length &gt; 200) &#123;</span><br><span class="line">                textView.text = [toBeString substringToIndex:200];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 有高亮选择的字符串，则暂不对文字进行统计和限制</span><br><span class="line">        else&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况</span><br><span class="line">    else&#123;</span><br><span class="line">        if (toBeString.length &gt; 200) &#123;</span><br><span class="line">            textView.text = [toBeString substringToIndex:200];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们根据键盘的输入模式进行区分，英文的比较简单就和上面一样，直接取最大的字符数就好了，在中文输入的时候，我们用markedTextRange方法获取到当前的光标位置，再用textField positionFromPosition:selectedRange.start offset:0获取到高亮部分，然后判断是否有高亮，这个时候系统会调用两次通知方法，第一次是将高亮的字符输入，第二次是将高亮的字符转换成中文输入（这个时候就没有高亮了，然后再取最大的字符数），但是在iOS7的设备上测试时发现，position都不会为nil，在iOS8以上都正常，但是获取到光标的range，却是正常的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE_IOS(3_2) @interface UITextRange : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly, getter=isEmpty) BOOL empty;     //  Whether the range is zero-length.</span><br><span class="line">@property (nonatomic, readonly) UITextPosition *start;</span><br><span class="line">@property (nonatomic, readonly) UITextPosition *end;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>我们可以看到系统的UITextRange，有两个变量，一个是start，一个是end，这正是对于的高亮区域！</p>
<p>所以既然position不能使用，那我们干脆就使用range，通过判断range的存在，来对文字进行限制处理。（粘贴也适用）</p>
<p>结果也是棒棒的！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第三方键盘加入之后，对于字数限制的处理不再像之前那么简单了&lt;/p&gt;
    
    </summary>
    
    
      <category term="TextField" scheme="http://yuzeyang.github.io/tags/TextField/"/>
    
  </entry>
  
</feed>
