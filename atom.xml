<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宫城</title>
  <subtitle>Talk is cheap,show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuzeyang.github.io/"/>
  <updated>2016-09-02T09:48:25.000Z</updated>
  <id>http://yuzeyang.github.io/</id>
  
  <author>
    <name>宫城</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>果冻效果下拉刷新控件</title>
    <link href="http://yuzeyang.github.io/2016/09/02/loadingAniamtion-0902/"/>
    <id>http://yuzeyang.github.io/2016/09/02/loadingAniamtion-0902/</id>
    <published>2016-09-02T05:23:04.000Z</published>
    <updated>2016-09-02T09:48:25.000Z</updated>
    
    <content type="html">&lt;p&gt;这个下拉控件是在&lt;a href=&quot;http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/?sukey=3997c0719f151520e178bb5175f11bfb983f5560c51261103fafb276bac79e1371d16e07ede0cca9f23d826405507a3c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Elastic view animation using UIBezierPath&lt;/a&gt;这篇博客上看到的，觉得效果还不错，自己也就OC简单实现了一下（原作者是用Swift写的），控件效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationTwo.gif!700x700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个控件的动画效果分为两个部分：&lt;/p&gt;
&lt;p&gt;1.下拉的果冻效果&lt;/p&gt;
&lt;p&gt;2.下拉进度圆圈的显示及旋转&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x00__u4E0B_u62C9_u679C_u51BB_u72B6_u6001_u5B9E_u73B0_u601D_u8DEF&quot;&gt;&lt;a href=&quot;#0x00__u4E0B_u62C9_u679C_u51BB_u72B6_u6001_u5B9E_u73B0_u601D_u8DEF&quot; class=&quot;headerlink&quot; title=&quot;0x00 下拉果冻状态实现思路&quot;&gt;&lt;/a&gt;0x00 下拉果冻状态实现思路&lt;/h2&gt;&lt;p&gt;对于下拉的状态，我将其分为三种，然后在初始化的时候，将状态设置为正常状态&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, GCLoadingState) &amp;#123;&amp;#10;    GCLoadingStateNormal,&amp;#9;// &amp;#27491;&amp;#24120;&amp;#29366;&amp;#24577;&amp;#10;    GCLoadingStateLoading,&amp;#9;// &amp;#21152;&amp;#36733;&amp;#20013;&amp;#29366;&amp;#24577;&amp;#10;    GCLoadingStateCancelled&amp;#9;// &amp;#21462;&amp;#28040;&amp;#21152;&amp;#36733;&amp;#29366;&amp;#24577;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并且在初始化的时候，绘制曲线的初始样式&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)drawOriginPath &amp;#123;&amp;#10;    UIBezierPath *path = [UIBezierPath bezierPath];&amp;#10;    [path moveToPoint:CGPointMake(0, 0)];&amp;#10;    [path addLineToPoint:CGPointMake(0, kGCLoadingViewMinHeight)];&amp;#10;    [path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), kGCLoadingViewMinHeight)];&amp;#10;    [path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), 0)];&amp;#10;    &amp;#10;    self.loadLayer.path = path.CGPath;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那在手指拖动的过程中，我们该如果实现果冻拉伸的效果呢？&lt;/p&gt;
&lt;p&gt;我们需要一个辅助视图&lt;code&gt;centerHelperView&lt;/code&gt;，这个辅助视图是加在下面这条线的中间的，如图的小黑点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/centerHelperView.png!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在下拉时我们就根据这个&lt;code&gt;centerHelperView&lt;/code&gt;的变化来不断的绘制我们的曲线，所以我们用到了&lt;code&gt;CADisplayLink&lt;/code&gt;，这个应该在写动画的时候用的也是比较多了，是根据屏幕的刷新频率将内容绘制到屏幕的定时器，当我们将定时器加到&lt;code&gt;runLoop&lt;/code&gt;里时，我们需要注意在设置&lt;code&gt;mode&lt;/code&gt;时，如果将&lt;code&gt;mode&lt;/code&gt;设置为&lt;code&gt;NSDefaultRunLoopMode&lt;/code&gt;，那么在滑动的时候，定时器会暂停，直到停止滑动才会继续工作，所以我们需要将&lt;code&gt;mode&lt;/code&gt;设置为&lt;code&gt;NSRunLoopCommonModes&lt;/code&gt;，这样能保证定时器在滑动的过程中也能正常工作&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (CADisplayLink *)displayLink &amp;#123;&amp;#10;    if (!_displayLink) &amp;#123;&amp;#10;        _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkAction:)];&amp;#10;        [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];&amp;#10;        _displayLink.paused = YES;&amp;#10;    &amp;#125;&amp;#10;    return _displayLink;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在取出&lt;code&gt;centerHelperView&lt;/code&gt;的原点，来不断绘制果冻的曲线&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)displayLinkAction:(CADisplayLink *)displayLink &amp;#123;&amp;#10;    CALayer *centerHelperViewLayer = (CALayer *)[self.centerHelperView.layer presentationLayer];&amp;#10;    CGRect centerHelperViewRect = [[centerHelperViewLayer valueForKey:@&amp;#34;frame&amp;#34;] CGRectValue];&amp;#10;    [self drawLoadLayerWithCenter:centerHelperViewRect.origin];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然我们能够获取到&lt;code&gt;centerHelperView&lt;/code&gt;在不同时间里的位置，那么我们就可以根据它来绘制我们的曲线&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/loadingPoint.png!300x300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到左右两边都是直线，调用&lt;code&gt;- addLineToPoint&lt;/code&gt;方法即可，重要的是底下这条线，我们获取到&lt;code&gt;centerHelperView&lt;/code&gt;的位置后，暂且用&lt;code&gt;c&lt;/code&gt;来表示，我们在绘制曲线时，需要用到&lt;code&gt;controlPoint1&lt;/code&gt;和&lt;code&gt;controlPoint2&lt;/code&gt;，那我们就把底下的线分为三段，并且以&lt;code&gt;c&lt;/code&gt;为中心店，左边取出&lt;code&gt;l3&lt;/code&gt;、&lt;code&gt;l2&lt;/code&gt;、&lt;code&gt;l1&lt;/code&gt;，右边取出&lt;code&gt;r3&lt;/code&gt;、&lt;code&gt;r2&lt;/code&gt;、&lt;code&gt;r1&lt;/code&gt;，曲线分为三条：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIBezierPath *path = [UIBezierPath bezierPath];&amp;#10;[path moveToPoint:CGPointMake(0, 0)];&amp;#10;[path addLineToPoint:l3];&amp;#10;[path addCurveToPoint:l1 controlPoint1:l3 controlPoint2:l2];&amp;#10;[path addCurveToPoint:r1 controlPoint1:l1 controlPoint2:c];&amp;#10;[path addCurveToPoint:r3 controlPoint1:r1 controlPoint2:r2];&amp;#10;[path addLineToPoint:CGPointMake(CGRectGetWidth(self.associatedScrollView.frame), 0)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;果冻的曲线我们就完成了，然后我们就要开始对手势的状态来进行处理&lt;/p&gt;
&lt;p&gt;在写控件调试的时候，你可以通过给目标视图添加&lt;code&gt;UIPanGestureRecognizer&lt;/code&gt;，调用&lt;code&gt;- translationInView:&lt;/code&gt;来获取到手指在屏幕上拖动时位置的变化，但是下拉刷新控件一般都是加在ScrollView上的，ScrollView自己是有一个只读的&lt;code&gt;UIPanGestureRecognizer&lt;/code&gt;属性，所以我们不必自己再添加一个，我们只需要观察&lt;code&gt;UIPanGestureRecognizer&lt;/code&gt;的&lt;code&gt;state&lt;/code&gt;即可&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.associatedScrollView addObserver:self forKeyPath:@&amp;#34;panGestureRecognizer.state&amp;#34; options:NSKeyValueObservingOptionNew context:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在取消拖动时，我们根据&lt;code&gt;ScrollView&lt;/code&gt;的&lt;code&gt;contentOffset&lt;/code&gt;来判断，是否是取消加载还是加载&lt;/p&gt;
&lt;h2 id=&quot;0x01__u4E0B_u62C9_u8FDB_u5EA6_u5706_u5708_u7684_u663E_u793A_u53CA_u65CB_u8F6C&quot;&gt;&lt;a href=&quot;#0x01__u4E0B_u62C9_u8FDB_u5EA6_u5706_u5708_u7684_u663E_u793A_u53CA_u65CB_u8F6C&quot; class=&quot;headerlink&quot; title=&quot;0x01 下拉进度圆圈的显示及旋转&quot;&gt;&lt;/a&gt;0x01 下拉进度圆圈的显示及旋转&lt;/h2&gt;&lt;p&gt;进度圆圈的显示主要是依赖于下拉的进度，然后改变&lt;code&gt;progress&lt;/code&gt;，圆圈随之绘制就好&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (contentOffset.y &amp;#60; 0) &amp;#123;&amp;#10;    self.progress = MAX(0.0, MIN(fabs(contentOffset.y/kGCPullMaxDistance), 1.0));&amp;#10;&amp;#125; else &amp;#123;&amp;#10;    self.progress = 0;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)drawRect:(CGRect)rect &amp;#123;&amp;#10;    UIBezierPath *circlePath = [UIBezierPath bezierPath];&amp;#10;    [circlePath moveToPoint:CGPointMake(0, - kGCLoadingCircleRadius)];&amp;#10;    [circlePath addArcWithCenter:CGPointMake(0, 0) radius:kGCLoadingCircleRadius startAngle:-M_PI/2 endAngle:((M_PI*17/9)*self.progess - M_PI/2) clockwise:YES];&amp;#10;    &amp;#10;    self.circleLayer.path = circlePath.CGPath;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当&lt;code&gt;progress&lt;/code&gt;达到1之后，就开始旋转动画了，这个我们使用&lt;code&gt;CABasicAnimation&lt;/code&gt;即可&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@&amp;#34;transform.rotation.z&amp;#34;];&amp;#10;rotationAnimation.toValue = @(M_PI*2);&amp;#10;rotationAnimation.beginTime = CACurrentMediaTime();&amp;#10;rotationAnimation.duration = 1.0;&amp;#10;rotationAnimation.fillMode = kCAFillModeForwards;&amp;#10;rotationAnimation.repeatCount = HUGE_VALF;&amp;#10;[self.circleLayer addAnimation:rotationAnimation forKey:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ok，大功告成~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个下拉控件是在&lt;a href=&quot;http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/?sukey=3997c0719f151520e178bb5175f11bfb983f5560c51261103fafb276bac79e1371d16e07ede0cca9f23d826405507a3c&quot;&gt;Elastic view animation using UIBezierPath&lt;/a&gt;这篇博客上看到的，觉得效果还不错，自己也就OC简单实现了一下（原作者是用Swift写的），控件效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationTwo.gif!700x700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo&quot;&gt;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationTwo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个控件的动画效果分为两个部分：&lt;/p&gt;
&lt;p&gt;1.下拉的果冻效果&lt;/p&gt;
&lt;p&gt;2.下拉进度圆圈的显示及旋转&lt;/p&gt;
    
    </summary>
    
    
      <category term="下拉刷新" scheme="http://yuzeyang.github.io/tags/%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>根据协议名获取所有代理方法</title>
    <link href="http://yuzeyang.github.io/2016/08/07/get-protocol-methods/"/>
    <id>http://yuzeyang.github.io/2016/08/07/get-protocol-methods/</id>
    <published>2016-08-07T00:34:59.000Z</published>
    <updated>2016-08-10T09:44:36.000Z</updated>
    
    <content type="html">&lt;p&gt;因为一直在用&lt;a href=&quot;https://github.com/markohlebar/Peckham&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Peckham&lt;/a&gt;这个插件，能够在编辑器的任意位置使用快捷键快速引用头文件，所以后来在想能不能也写一个类似的插件快速引入什么东西，细细一想平时自己在引用代理协议的时候，基本都是要跑到文件顶部添加好之后，再回到原来的位置继续写，如果有必须实现的代理方法没注意实现的话，可能又要回到implementation看warnings或者跳转到协议里面看哪些是必须实现，拷贝过来，粘贴到自己的实现里面，这样的操作实在是太麻烦了，所以我想可以写个插件，使用快捷键将必须实现的代理方法到implementation底部，这样对于开发者来说能避免很多不必要操作，也能快速明白哪些代理方法必须实现，好，接下来我来构思下怎么实现这个插件（但是后面这个实现出来的效果并不是很完美，所以还是放弃了…原因看更多）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1.在写完协议名之后，双击或者单击拖动选中协议名&lt;br&gt;2.使用快捷键，根据选中的协议名，查找协议里面的所有代理方法&lt;br&gt;3.再筛选出里面require标记的代理方法&lt;br&gt;4.将这些代理方法，添加到当前类的实现文件里面&lt;/p&gt;
&lt;p&gt;我接下去讲的都是默认你已经了解了插件的配置以及调试&lt;/p&gt;
&lt;h2 id=&quot;u9009_u4E2D_u534F_u8BAE_u540D&quot;&gt;&lt;a href=&quot;#u9009_u4E2D_u534F_u8BAE_u540D&quot; class=&quot;headerlink&quot; title=&quot;选中协议名&quot;&gt;&lt;/a&gt;选中协议名&lt;/h2&gt;&lt;p&gt;首先我们在初始化bundle的时候，注册&lt;code&gt;NSTextViewDidChangeSelectionNotification&lt;/code&gt;通知，&lt;code&gt;- selectString :&lt;/code&gt;用来接收选中文本改变时通知&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(selectString:)&amp;#10;name:NSTextViewDidChangeSelectionNotification object:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在接收方法里面，我们获取到当前操作的编辑页面&lt;code&gt;NSTextView&lt;/code&gt;对象，然后获取到选中的&lt;code&gt;range&lt;/code&gt;，取出选中的文本&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)selectString:(NSNotification *)notification &amp;#123;&amp;#10;    if ([notification.object isKindOfClass:[NSTextView class]]) &amp;#123;&amp;#10;        NSTextView* textView = (NSTextView *)notification.object;&amp;#10;        NSArray* selectedRanges = [textView selectedRanges];&amp;#10;        if (selectedRanges.count == 0) &amp;#123;&amp;#10;            return;&amp;#10;        &amp;#125;&amp;#10;        NSRange selectedRange = [[selectedRanges objectAtIndex:0] rangeValue];&amp;#10;        NSString* text = textView.textStorage.string;&amp;#10;        self.selectedString = [text substringWithRange:selectedRange];&amp;#10;        NSLog(@&amp;#34;%s %@&amp;#34;,__func__,self.selectedString);&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;u4F7F_u7528_u5FEB_u6377_u952E_uFF0C_u67E5_u627E_u534F_u8BAE_u91CC_u9762_u7684_u6240_u6709_u4EE3_u7406_u65B9_u6CD5&quot;&gt;&lt;a href=&quot;#u4F7F_u7528_u5FEB_u6377_u952E_uFF0C_u67E5_u627E_u534F_u8BAE_u91CC_u9762_u7684_u6240_u6709_u4EE3_u7406_u65B9_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;使用快捷键，查找协议里面的所有代理方法&quot;&gt;&lt;/a&gt;使用快捷键，查找协议里面的所有代理方法&lt;/h2&gt;&lt;p&gt;快捷键的设置在增加&lt;code&gt;NSMenuItem&lt;/code&gt;对象时就已经设置了，并且设置其快捷键为&lt;code&gt;^⎇G&lt;/code&gt;，以及对应的&lt;code&gt;- searchProtocol:&lt;/code&gt;方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[menuItem submenu] addItem:[NSMenuItem separatorItem]];&amp;#10;        &amp;#10;NSMenuItem *protolMenuItem = [[NSMenuItem alloc] initWithTitle:@&amp;#34;Protol Helper&amp;#34; action:@selector(searchProtocol:) keyEquivalent:@&amp;#34;g&amp;#34;];&amp;#10;[protolMenuItem setKeyEquivalentModifierMask:NSAlternateKeyMask|NSControlKeyMask];&amp;#10;protolMenuItem.target = self;&amp;#10;[[menuItem submenu] addItem:protolMenuItem];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我们怎么查找到选中文本对应的协议和里面的代理方法呢？&lt;/p&gt;
&lt;p&gt;我们先找怎么获取到代理方法，然后倒推回来，首先我们需要用到&lt;code&gt;runtime&lt;/code&gt;，我们进到&lt;code&gt;runtime.h&lt;/code&gt;里，通过搜索&lt;code&gt;protocol&lt;/code&gt;关键字，我们找了&lt;code&gt;protocol_copyMethodDescriptionList&lt;/code&gt;这个方法，&lt;code&gt;p&lt;/code&gt;是一个&lt;code&gt;Protocol&lt;/code&gt;对象，&lt;code&gt;isRequiredMethod&lt;/code&gt;筛选是否是必须的方法，这样的话，我们就可以直接通过这个方法来获取必须实现的代理方法，&lt;code&gt;isInstanceMethod&lt;/code&gt;筛选是否是实例方法，&lt;code&gt;outCount&lt;/code&gt;这个表示返回方法的数量&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OBJC_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount)&amp;#10;     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Protocol&lt;/code&gt;对象我们可以通过&lt;code&gt;objc_getProtocol&lt;/code&gt;方法，通过传入协议名来创建&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const char *protocolName = self.selectedString.UTF8String;&amp;#10;Protocol *protocol = objc_getProtocol(protocolName);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我们开始调用&lt;code&gt;protocol_copyMethodDescriptionList&lt;/code&gt;方法，打印出方法信息，这里我就先不管代码简洁性了，我拿&lt;code&gt;NSTextViewDelegate&lt;/code&gt;来测试&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;unsigned int count = 999;&amp;#10;struct objc_method_description *methods1;&amp;#10;struct objc_method_description *methods2;&amp;#10;struct objc_method_description *methods3;&amp;#10;struct objc_method_description *methods4;&amp;#10;methods1 = protocol_copyMethodDescriptionList(protocol, NO, YES, &amp;#38;count);&amp;#10;methods2 = protocol_copyMethodDescriptionList(protocol, NO, NO, &amp;#38;count);&amp;#10;methods3 = protocol_copyMethodDescriptionList(protocol, YES, YES, &amp;#38;count);&amp;#10;methods4 = protocol_copyMethodDescriptionList(protocol, YES, NO, &amp;#38;count);&amp;#10;&amp;#10;if (methods1 != NULL) &amp;#123;&amp;#10;    NSLog(@&amp;#34;---------------------methods1&amp;#34;);&amp;#10;    [self logMethods:methods1];&amp;#10;&amp;#125;&amp;#10;&amp;#10;if (methods2 != NULL) &amp;#123;&amp;#10;    NSLog(@&amp;#34;---------------------methods2&amp;#34;);&amp;#10;    [self logMethods:methods2];&amp;#10;&amp;#125;&amp;#10;&amp;#10;if (methods3 != NULL) &amp;#123;&amp;#10;    NSLog(@&amp;#34;---------------------methods3&amp;#34;);&amp;#10;    [self logMethods:methods3];&amp;#10;&amp;#125;&amp;#10;&amp;#10;if (methods4 != NULL) &amp;#123;&amp;#10;    NSLog(@&amp;#34;---------------------methods4&amp;#34;);&amp;#10;    [self logMethods:methods4];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们看下打印的方法信息&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2016-08-07 15:13:39.242 Xcode[1218:86590] ---------------------methods1&amp;#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:shouldChangeTextInRange:replacementString: c48@0:8@16&amp;#123;_NSRange=QQ&amp;#125;24@40&amp;#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:willChangeSelectionFromCharacterRange:toCharacterRange: &amp;#123;_NSRange=QQ&amp;#125;56@0:8@16&amp;#123;_NSRange=QQ&amp;#125;24&amp;#123;_NSRange=QQ&amp;#125;40&amp;#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textViewDidChangeSelection: v24@0:8@16&amp;#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:completions:forPartialWordRange:indexOfSelectedItem: @56@0:8@16@24&amp;#123;_NSRange=QQ&amp;#125;32^q48&amp;#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doCommandBySelector: c32@0:8@16:24&amp;#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnLink:atIndex: c40@0:8@16@24Q32&amp;#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:clickedOnCell:inRect:atIndex: v72@0:8@16@24&amp;#123;CGRect=&amp;#123;CGPoint=dd&amp;#125;&amp;#123;CGSize=dd&amp;#125;&amp;#125;32Q64&amp;#10;2016-08-07 15:13:39.242 Xcode[1218:86590] methods name textView:doubleClickedOnCell:inRect:atIndex: v72@0:8@16@24&amp;#123;CGRect=&amp;#123;CGPoint=dd&amp;#125;&amp;#123;CGSize=dd&amp;#125;&amp;#125;32Q64&amp;#10;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;what？方法名居然不是完整的，不是我们看到&lt;code&gt;- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;&lt;/code&gt;这样的，但是想想也对，方法名应该是这样的，不包含参数名和参数类型，虽然参数类型可以通过&lt;code&gt;objc_method_description&lt;/code&gt;结构体里面&lt;code&gt;types&lt;/code&gt;拿到，但是参数名怎么办…我总不能用abc来代替吧，虽然做是可以做，但是用起来还是要改参数名，这不是很麻烦…感觉在这里遇到瓶颈了&lt;/p&gt;
&lt;p&gt;然后我想看到&lt;code&gt;objc_class&lt;/code&gt;结构体里面也有存放协议信息，那他里面是怎么样的&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct objc_class &amp;#123;&amp;#10;    Class isa  OBJC_ISA_AVAILABILITY;&amp;#10;&amp;#10;#if !__OBJC2__&amp;#10;    Class super_class                                        OBJC2_UNAVAILABLE;&amp;#10;    const char *name                                         OBJC2_UNAVAILABLE;&amp;#10;    long version                                             OBJC2_UNAVAILABLE;&amp;#10;    long info                                                OBJC2_UNAVAILABLE;&amp;#10;    long instance_size                                       OBJC2_UNAVAILABLE;&amp;#10;    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;&amp;#10;    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;&amp;#10;    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;&amp;#10;    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;&amp;#10;#endif&amp;#10;&amp;#10;&amp;#125; OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct objc_protocol_list &amp;#123;&amp;#10;    struct objc_protocol_list *next;&amp;#10;    long count;&amp;#10;    Protocol *list[1];&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Protocol : Object&amp;#10;&amp;#123;&amp;#10;@private&amp;#10;    char *protocol_name OBJC2_UNAVAILABLE;&amp;#10;    struct objc_protocol_list *protocol_list OBJC2_UNAVAILABLE;&amp;#10;    struct objc_method_description_list *instance_methods OBJC2_UNAVAILABLE;&amp;#10;    struct objc_method_description_list *class_methods OBJC2_UNAVAILABLE;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct objc_method_description_list &amp;#123;&amp;#10;        int count;&amp;#10;        struct objc_method_description list[1];&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct objc_method_description &amp;#123;&amp;#10;&amp;#9;SEL name;               /**&amp;#60; The name of the method */&amp;#10;&amp;#9;char *types;            /**&amp;#60; The types of the method arguments */&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过一系列的查找，我们又回到了&lt;code&gt;objc_method_description&lt;/code&gt;，what？这&lt;code&gt;objc_class&lt;/code&gt;最终拿到的数据还是从&lt;code&gt;objc_method_description&lt;/code&gt;来的，那就是说明我们没有办法直接获得&lt;code&gt;- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;&lt;/code&gt;….这样就不能达到我们所预期的那样了&lt;/p&gt;
&lt;h2 id=&quot;u603B_u7ED3&quot;&gt;&lt;a href=&quot;#u603B_u7ED3&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;我们可以通过&lt;code&gt;protocol_copyMethodDescriptionList&lt;/code&gt;方法获取到协议里面所有的代理方法，分为方法名和类型，但是不能获取到&lt;code&gt;- (BOOL)textView:(NSTextView *)textView clickedOnLink:(id)link atIndex:(NSUInteger)charIndex;&lt;/code&gt;这样的，如果用a，b，c这样的来填充参数名，这样在使用起来，使用方还要自己再替换参数名，这样会比较麻烦，解决不了我们的需求，gg…..&lt;/p&gt;
&lt;p&gt;2016年8月10日补充：&lt;/p&gt;
&lt;p&gt;后来西兰花提出说根据协议名称去爬开发文档上相关的代理方法或者找本地开发包里面的相关头文件，不考虑是否可行，但是有个共同的问题是只能获取到官方的，自己创建的不行，而且前者没有require标记&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;因为一直在用&lt;a href=&quot;https://github.com/markohlebar/Peckham&quot;&gt;Peckham&lt;/a&gt;这个插件，能够在编辑器的任意位置使用快捷键快速引用头文件，所以后来在想能不能也写一个类似的插件快速引入什么东西，细细一想平时自己在引用代理协议的时候，基本都是要跑到文件顶部添加好之后，再回到原来的位置继续写，如果有必须实现的代理方法没注意实现的话，可能又要回到implementation看warnings或者跳转到协议里面看哪些是必须实现，拷贝过来，粘贴到自己的实现里面，这样的操作实在是太麻烦了，所以我想可以写个插件，使用快捷键将必须实现的代理方法到implementation底部，这样对于开发者来说能避免很多不必要操作，也能快速明白哪些代理方法必须实现，好，接下来我来构思下怎么实现这个插件（但是后面这个实现出来的效果并不是很完美，所以还是放弃了…原因看更多）&lt;/p&gt;
    
    </summary>
    
    
      <category term="协议方法" scheme="http://yuzeyang.github.io/tags/%E5%8D%8F%E8%AE%AE%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>加载动画分析</title>
    <link href="http://yuzeyang.github.io/2016/07/27/loadingAnimation-0727/"/>
    <id>http://yuzeyang.github.io/2016/07/27/loadingAnimation-0727/</id>
    <published>2016-07-27T14:49:19.000Z</published>
    <updated>2016-08-15T15:03:40.000Z</updated>
    
    <content type="html">&lt;p&gt;好久没写动画了…最近扒了下以前没有写的动画效果，想想从最老的开始写吧，之前看到的版本是用Swift写的，没仔细找有没有OC版的，所以干脆自己练习一下吧，我们先来看看效果：&lt;/p&gt;
&lt;p&gt;(这里三角形是旋转动画，但是Gif录出来看上去是抖了两下…)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationOne.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以直接run下代码，看下效果：&lt;a href=&quot;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我来分析下过程&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这个动画的实现只用到了&lt;code&gt;UIBezierPath&lt;/code&gt;、&lt;code&gt;CABasicAnimation&lt;/code&gt;和&lt;code&gt;CALayer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从Gif里面可以看到这个动画分为以下几个步骤：&lt;/p&gt;
&lt;p&gt;1.从无到圆&lt;/p&gt;
&lt;p&gt;2.圆x轴方向拉伸和y轴方向拉伸&lt;/p&gt;
&lt;p&gt;3.“长出”三角形的三个角&lt;/p&gt;
&lt;p&gt;4.三角形旋转&lt;/p&gt;
&lt;p&gt;5.画两条边框&lt;/p&gt;
&lt;p&gt;6.水面上涨动画&lt;/p&gt;
&lt;p&gt;7.中间矩形放大至全屏&lt;/p&gt;
&lt;p&gt;8.中间logo跟着出现&lt;/p&gt;
&lt;h2 id=&quot;0x00__u4ECE_u65E0_u5230_u5706&quot;&gt;&lt;a href=&quot;#0x00__u4ECE_u65E0_u5230_u5706&quot; class=&quot;headerlink&quot; title=&quot;0x00 从无到圆&quot;&gt;&lt;/a&gt;0x00 从无到圆&lt;/h2&gt;&lt;p&gt;这个比较简单，只要设定起始的size为0和设定默认圆半径大小，用&lt;code&gt;+ bezierPathWithOvalInRect:&lt;/code&gt;方法画圆&lt;code&gt;+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIBezierPath *startPath = [self circleStartPath];&amp;#10;UIBezierPath *endPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2, GCCircleRadius*2)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将最后圆的&lt;code&gt;path&lt;/code&gt;设为&lt;code&gt;circleLayer&lt;/code&gt;的&lt;code&gt;path&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.circleLayer = [CAShapeLayer layer];&amp;#10;self.circleLayer.path = endPath.CGPath;&amp;#10;self.circleLayer.fillColor = [UIColor orangeColor].CGColor;&amp;#10;[self addSublayer:self.circleLayer];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后加上动画，因为我们修改的是&lt;code&gt;path&lt;/code&gt;，所以我们&lt;code&gt;animation&lt;/code&gt;的&lt;code&gt;keyPath&lt;/code&gt;是&lt;code&gt;path&lt;/code&gt;（后面也是），设定起始值为&lt;code&gt;startPath.CGPath&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *circleAnimation = [CABasicAnimation animationWithKeyPath:@&amp;#34;path&amp;#34;];&amp;#10;circleAnimation.fromValue = (__bridge id _Nullable)(startPath.CGPath);&amp;#10;circleAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];&amp;#10;circleAnimation.duration = 0.2f;&amp;#10;circleAnimation.fillMode = kCAFillModeForwards;&amp;#10;circleAnimation.delegate = self;&amp;#10;circleAnimation.removedOnCompletion = NO;&amp;#10;[circleAnimation setValue:@&amp;#34;circleAnimation&amp;#34; forKey:@&amp;#34;animationName&amp;#34;];&amp;#10;[self.circleLayer addAnimation:circleAnimation forKey:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;0x01__u5706x_u8F74_u65B9_u5411_u62C9_u4F38_u548Cy_u8F74_u65B9_u5411_u62C9_u4F38&quot;&gt;&lt;a href=&quot;#0x01__u5706x_u8F74_u65B9_u5411_u62C9_u4F38_u548Cy_u8F74_u65B9_u5411_u62C9_u4F38&quot; class=&quot;headerlink&quot; title=&quot;0x01 圆x轴方向拉伸和y轴方向拉伸&quot;&gt;&lt;/a&gt;0x01 圆x轴方向拉伸和y轴方向拉伸&lt;/h2&gt;&lt;p&gt;这里我们的&lt;code&gt;keyPath&lt;/code&gt;不用&lt;code&gt;transform.scale.x/y&lt;/code&gt;，因为缩放之后，圆心会改变，看上去有偏移，这样动画写起来更复杂，所以我们干脆直接用拉伸后的&lt;code&gt;path&lt;/code&gt;来做动画&lt;/p&gt;
&lt;p&gt;创建x轴、y轴拉伸后的&lt;code&gt;path&lt;/code&gt;，然后加到&lt;code&gt;animation&lt;/code&gt;里面&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIBezierPath *scaleXPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius*1.1, GCLoadingLayerCenterY - GCCircleRadius, GCCircleRadius*2.2, GCCircleRadius*2)];&amp;#10;UIBezierPath *scaleYPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(GCLoadingLayerCenterX - GCCircleRadius, GCLoadingLayerCenterY - GCCircleRadius*1.1, GCCircleRadius*2, GCCircleRadius*2.2)];&amp;#10;&amp;#10;CABasicAnimation *circleScaleXOneAnimation = [CABasicAnimation animationWithKeyPath:@&amp;#34;path&amp;#34;];&amp;#10;circleScaleXOneAnimation.fromValue = (__bridge id _Nullable)(self.circleLayer.path);&amp;#10;circleScaleXOneAnimation.toValue = (__bridge id _Nullable)(scaleXPath.CGPath);&amp;#10;circleScaleXOneAnimation.duration = 0.2f;&amp;#10;circleScaleXOneAnimation.beginTime = 0.0;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一共四个&lt;code&gt;CABasicAnimation&lt;/code&gt;对象，然后我们将这些动画加到&lt;code&gt;CAAnimationGroup&lt;/code&gt;里&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CAAnimationGroup *animationGroup = [CAAnimationGroup animation];&amp;#10;animationGroup.animations = @[circleScaleXOneAnimation,circleScaleXTwoAnimation,circleScaleYOneAnimation,circleScaleYTwoAnimation];&amp;#10;animationGroup.duration = circleScaleYTwoAnimation.beginTime + circleScaleYTwoAnimation.duration;&amp;#10;animationGroup.delegate = self;&amp;#10;[animationGroup setValue:@&amp;#34;circleScaleAnimation&amp;#34; forKey:@&amp;#34;animationName&amp;#34;];&amp;#10;[self.circleLayer addAnimation:animationGroup forKey:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;0x02__u201C_u957F_u51FA_u201D_u4E09_u89D2_u5F62_u7684_u4E09_u4E2A_u89D2&quot;&gt;&lt;a href=&quot;#0x02__u201C_u957F_u51FA_u201D_u4E09_u89D2_u5F62_u7684_u4E09_u4E2A_u89D2&quot; class=&quot;headerlink&quot; title=&quot;0x02 “长出”三角形的三个角&quot;&gt;&lt;/a&gt;0x02 “长出”三角形的三个角&lt;/h2&gt;&lt;p&gt;实际上三角形在等到圆形出现或者圆形拉伸完之后就已经在那了，“长出角”的感觉实际上只是改变了绘制的三个点的位置，首先我们根据圆的半径画出三角形&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIBezierPath *originTrianglePath = [UIBezierPath bezierPath];&amp;#10;[originTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.0]];&amp;#10;[originTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];&amp;#10;[originTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];&amp;#10;[originTrianglePath closePath];&amp;#10;&amp;#10;self.triangleLayer = [CAShapeLayer layer];&amp;#10;self.triangleLayer.path = originTrianglePath.CGPath;&amp;#10;self.triangleLayer.fillColor = [UIColor orangeColor].CGColor;&amp;#10;[self addSublayer:self.triangleLayer];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后改变左边点的位置&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIBezierPath *blowUpLeftTrianglePath = [UIBezierPath bezierPath];&amp;#10;[blowUpLeftTrianglePath moveToPoint:[self triangleLeftPointWithScale:1.2]];&amp;#10;[blowUpLeftTrianglePath addLineToPoint:[self triangleRightPointWithScale:1.0]];&amp;#10;[blowUpLeftTrianglePath addLineToPoint:[self triangleTopPointWithScale:1.0]];&amp;#10;[blowUpLeftTrianglePath closePath];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也加上&lt;code&gt;path&lt;/code&gt;的动画&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *blowUpLeftAnimation = [CABasicAnimation animationWithKeyPath:@&amp;#34;path&amp;#34;];&amp;#10;blowUpLeftAnimation.fromValue = (__bridge id _Nullable)(self.triangleLayer.path);&amp;#10;blowUpLeftAnimation.toValue = (__bridge id _Nullable)(blowUpLeftTrianglePath.CGPath);&amp;#10;blowUpLeftAnimation.duration = 0.2f;&amp;#10;blowUpLeftAnimation.beginTime = 0.0;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;右边和上边的点同理，然后也一起加到&lt;code&gt;CAAnimationGroup&lt;/code&gt;里&lt;/p&gt;
&lt;h2 id=&quot;0x03__u4E09_u89D2_u5F62_u65CB_u8F6C&quot;&gt;&lt;a href=&quot;#0x03__u4E09_u89D2_u5F62_u65CB_u8F6C&quot; class=&quot;headerlink&quot; title=&quot;0x03 三角形旋转&quot;&gt;&lt;/a&gt;0x03 三角形旋转&lt;/h2&gt;&lt;p&gt;旋转就比较简单了，只要根据z轴旋转设定的角度即可&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *rotationAniamtion = [CABasicAnimation animationWithKeyPath:@&amp;#34;transform.rotation.z&amp;#34;];&amp;#10;rotationAniamtion.toValue = @(M_PI*2);&amp;#10;rotationAniamtion.duration = 0.4;&amp;#10;rotationAniamtion.fillMode = kCAFillModeForwards;&amp;#10;rotationAniamtion.delegate = self;&amp;#10;rotationAniamtion.beginTime = CACurrentMediaTime();&amp;#10;[rotationAniamtion setValue:@&amp;#34;rotationAniamtion&amp;#34; forKey:@&amp;#34;animationName&amp;#34;];&amp;#10;[self.triangleLayer addAnimation:rotationAniamtion forKey:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;0x04__u753B_u4E24_u6761_u8FB9_u6846&quot;&gt;&lt;a href=&quot;#0x04__u753B_u4E24_u6761_u8FB9_u6846&quot; class=&quot;headerlink&quot; title=&quot;0x04 画两条边框&quot;&gt;&lt;/a&gt;0x04 画两条边框&lt;/h2&gt;&lt;p&gt;这两个边框绘制方法是一模一样的，只是中间有个时间间隔而已&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (CABasicAnimation *)drawRectWithLineColor:(CGColorRef)color animationValue:(NSString *)animationValue &amp;#123;&amp;#10;    CGPoint startPoint = [self triangleLeftPointWithScale:1.2];&amp;#10;    UIBezierPath *rectPath = [UIBezierPath bezierPath];&amp;#10;    [rectPath moveToPoint:startPoint];&amp;#10;    [rectPath addLineToPoint:CGPointMake(startPoint.x, startPoint.y - GCCircleRadius*2.4)];&amp;#10;    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - GCCircleRadius*2.4)];&amp;#10;    [rectPath addLineToPoint:CGPointMake(startPoint.x + powf(3, 0.5)*GCCircleRadius*1.2, startPoint.y - 2)];&amp;#10;    [rectPath addLineToPoint:CGPointMake(startPoint.x - 2.5, startPoint.y - 2)];&amp;#10;    &amp;#10;    CAShapeLayer *layer = [CAShapeLayer layer];&amp;#10;    layer.path = rectPath.CGPath;&amp;#10;    layer.lineWidth = 5;&amp;#10;    layer.strokeColor = color;&amp;#10;    layer.fillColor = [UIColor clearColor].CGColor;&amp;#10;    [self addSublayer:layer];&amp;#10;    &amp;#10;    CABasicAnimation *rectAniamtion = [CABasicAnimation animationWithKeyPath:@&amp;#34;strokeEnd&amp;#34;];&amp;#10;    rectAniamtion.fromValue = @(0.0);&amp;#10;    rectAniamtion.toValue = @(1.0);&amp;#10;    rectAniamtion.duration = 0.8;&amp;#10;    rectAniamtion.delegate = self;&amp;#10;    if (animationValue.length) &amp;#123;&amp;#10;        [rectAniamtion setValue:@&amp;#34;rectAniamtion&amp;#34; forKey:@&amp;#34;animationName&amp;#34;];&amp;#10;    &amp;#125;&amp;#10;    [layer addAnimation:rectAniamtion forKey:nil];&amp;#10;    &amp;#10;    return rectAniamtion;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;间隔的话，我们直接调用&lt;code&gt;- performSelector: withObject: afterDelay:&lt;/code&gt;来延迟执行第二条边框的绘制就好&lt;/p&gt;
&lt;h2 id=&quot;0x05__u6C34_u9762_u4E0A_u6DA8_u52A8_u753B&quot;&gt;&lt;a href=&quot;#0x05__u6C34_u9762_u4E0A_u6DA8_u52A8_u753B&quot; class=&quot;headerlink&quot; title=&quot;0x05 水面上涨动画&quot;&gt;&lt;/a&gt;0x05 水面上涨动画&lt;/h2&gt;&lt;p&gt;这个动画的关键就是用&lt;code&gt;- addCurveToPoint: controlPoint1: controlPoint2:&lt;/code&gt;方法来画出水波的线，这个方法主要是利用&lt;code&gt;controlPoint1&lt;/code&gt;和&lt;code&gt;controlPoint2&lt;/code&gt;这两个点来控制弧度方向，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/addCurveToPoint.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后我们只需要交叉改变&lt;code&gt;controlPoint1&lt;/code&gt;和&lt;code&gt;controlPoint2&lt;/code&gt;这两个点在上下的位置和&lt;code&gt;startPoint&lt;/code&gt;和&lt;code&gt;endPoint&lt;/code&gt;的位置，就能感觉水面上涨的感觉&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray &amp;#60;UIBezierPath *&amp;#62; *waterPathArray = [NSMutableArray array];&amp;#10;for (NSInteger i = 0; i &amp;#60; 11; i++) &amp;#123;&amp;#10;    UIBezierPath *water = [self water:i % 2 == 0 ? YES : NO withProgress:0.1*i];&amp;#10;    [waterPathArray addObject:water];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;创建完毕&lt;code&gt;path&lt;/code&gt;之后，将&lt;code&gt;anmations&lt;/code&gt;放到&lt;code&gt;CAAnimationGroup&lt;/code&gt;里面&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)addWaterAnimation:(NSMutableArray &amp;#60;UIBezierPath *&amp;#62; *)waterArray &amp;#123;&amp;#10;    NSMutableArray &amp;#60;CABasicAnimation *&amp;#62; *animationArray = [NSMutableArray array];&amp;#10;    for (NSInteger i = 0; i &amp;#60; waterArray.count - 1; i++) &amp;#123;&amp;#10;        CABasicAnimation *waterAniamtion = [CABasicAnimation animationWithKeyPath:@&amp;#34;path&amp;#34;];&amp;#10;        waterAniamtion.fromValue = (__bridge id _Nullable)(waterArray[i].CGPath);&amp;#10;        waterAniamtion.toValue = (__bridge id _Nullable)(waterArray[i + 1].CGPath);&amp;#10;        waterAniamtion.duration = 0.2;&amp;#10;        waterAniamtion.beginTime = i == 0 ? 0.0 : animationArray[i - 1].beginTime + animationArray[i - 1].duration;&amp;#10;        [animationArray addObject:waterAniamtion];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    CAAnimationGroup *group = [CAAnimationGroup animation];&amp;#10;    group.animations = animationArray;&amp;#10;    group.duration = [animationArray lastObject].beginTime + [animationArray lastObject].duration;&amp;#10;    group.fillMode = kCAFillModeForwards;&amp;#10;    group.removedOnCompletion = NO;&amp;#10;    group.delegate = self;&amp;#10;    [group setValue:@&amp;#34;waterAnimation&amp;#34; forKey:@&amp;#34;animationName&amp;#34;];&amp;#10;    [self.waterLayer addAnimation:group forKey:nil];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;0x06__u4E2D_u95F4_u77E9_u5F62_u653E_u5927_u81F3_u5168_u5C4F&quot;&gt;&lt;a href=&quot;#0x06__u4E2D_u95F4_u77E9_u5F62_u653E_u5927_u81F3_u5168_u5C4F&quot; class=&quot;headerlink&quot; title=&quot;0x06 中间矩形放大至全屏&quot;&gt;&lt;/a&gt;0x06 中间矩形放大至全屏&lt;/h2&gt;&lt;p&gt;和前面一样，创建好全屏大小的&lt;code&gt;path&lt;/code&gt;之后，然后加上动画即可&lt;/p&gt;
&lt;h2 id=&quot;0x07__u4E2D_u95F4logo_u8DDF_u7740_u51FA_u73B0&quot;&gt;&lt;a href=&quot;#0x07__u4E2D_u95F4logo_u8DDF_u7740_u51FA_u73B0&quot; class=&quot;headerlink&quot; title=&quot;0x07 中间logo跟着出现&quot;&gt;&lt;/a&gt;0x07 中间logo跟着出现&lt;/h2&gt;&lt;p&gt;这个改变&lt;code&gt;bounds&lt;/code&gt;即可&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CALayer *logoLayer = [CALayer layer];&amp;#10;logoLayer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&amp;#34;logo.jpg&amp;#34;].CGImage);&amp;#10;&amp;#10;logoLayer.frame = CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 0, 0);&amp;#10;[self addSublayer:logoLayer];&amp;#10;&amp;#10;CABasicAnimation *logoAnimation = [CABasicAnimation animationWithKeyPath:@&amp;#34;bounds&amp;#34;];&amp;#10;logoAnimation.toValue = [NSValue valueWithCGRect:CGRectMake(GCLoadingLayerCenterX, GCLoadingLayerCenterY, 100, 120)];&amp;#10;logoAnimation.duration = 0.2;&amp;#10;logoAnimation.beginTime = 0.0;&amp;#10;logoAnimation.removedOnCompletion = NO;&amp;#10;logoAnimation.fillMode = kCAFillModeForwards;&amp;#10;[logoLayer addAnimation:logoAnimation forKey:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个加载动画的缺点就是在加载时没有可定制化的形状，只能修改圆形等的颜色，如果要改变形状，可能会涉及到动效的改动，所以这个动画只能作为学习分析参考&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写动画了…最近扒了下以前没有写的动画效果，想想从最老的开始写吧，之前看到的版本是用Swift写的，没仔细找有没有OC版的，所以干脆自己练习一下吧，我们先来看看效果：&lt;/p&gt;
&lt;p&gt;(这里三角形是旋转动画，但是Gif录出来看上去是抖了两下…)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCLoadingAnimationOne.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以直接run下代码，看下效果：&lt;a href=&quot;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne&quot;&gt;https://github.com/Yuzeyang/GCLoadingAnimation/tree/master/GCLoadingAnimationOne&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我来分析下过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="加载动画" scheme="http://yuzeyang.github.io/tags/%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>FMDB初探（二）</title>
    <link href="http://yuzeyang.github.io/2016/07/23/FMDB-two/"/>
    <id>http://yuzeyang.github.io/2016/07/23/FMDB-two/</id>
    <published>2016-07-23T08:38:23.000Z</published>
    <updated>2016-07-23T10:31:17.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;FMResultSet&lt;/code&gt;用来执行SQL语句结果的查询&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FMDatabaseQueue&lt;/code&gt;用不同的线程来执行若干个查询和更新操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FMDatabasePool&lt;/code&gt;和&lt;code&gt;FMDatabaseQueue&lt;/code&gt;类似，但是只是用在数据库只读操作上&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;FMResultSet&quot;&gt;&lt;a href=&quot;#FMResultSet&quot; class=&quot;headerlink&quot; title=&quot;FMResultSet&quot;&gt;&lt;/a&gt;FMResultSet&lt;/h2&gt;&lt;p&gt;主要是根据&lt;code&gt;columnName&lt;/code&gt;列名/&lt;code&gt;columnIdx&lt;/code&gt;列索引获取到相应数据格式的数据，以及使用&lt;code&gt;- next&lt;/code&gt;方法，将查询结果逐行输入&lt;/p&gt;
&lt;h4 id=&quot;u521D_u59CB_u5316&quot;&gt;&lt;a href=&quot;#u521D_u59CB_u5316&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)resultSetWithStatement:(FMStatement *)statement usingParentDatabase:(FMDatabase*)aDB &amp;#123;&amp;#10;    // &amp;#21021;&amp;#22987;&amp;#21270;FMResultSet&amp;#23545;&amp;#35937;&amp;#10;    FMResultSet *rs = [[FMResultSet alloc] init];&amp;#10;    // &amp;#35774;&amp;#32622;prepared&amp;#35821;&amp;#21477;&amp;#21644;db&amp;#10;    [rs setStatement:statement];&amp;#10;    [rs setParentDB:aDB];&amp;#10;    // &amp;#35774;&amp;#32622;prepared&amp;#35821;&amp;#21477;&amp;#27491;&amp;#22312;&amp;#20351;&amp;#29992;&amp;#10;    NSParameterAssert(![statement inUse]);&amp;#10;    [statement setInUse:YES]; // weak reference&amp;#10;    &amp;#10;    return FMDBReturnAutoreleased(rs);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u83B7_u53D6_u7ED3_u679C&quot;&gt;&lt;a href=&quot;#u83B7_u53D6_u7ED3_u679C&quot; class=&quot;headerlink&quot; title=&quot;获取结果&quot;&gt;&lt;/a&gt;获取结果&lt;/h4&gt;&lt;p&gt;返回结果的数据类型有很多种：除了基本数据类型之外，还有&lt;code&gt;NSString&lt;/code&gt;、&lt;code&gt;NSDate&lt;/code&gt;、&lt;code&gt;NSData&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比如以下两个接口&lt;code&gt;- intForColumn:&lt;/code&gt;实际上调用的还是&lt;code&gt;- intForColumnIndex:&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (int)intForColumn:(NSString*)columnName &amp;#123;&amp;#10;    return [self intForColumnIndex:[self columnIndexForName:columnName]];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (int)intForColumnIndex:(int)columnIdx &amp;#123;&amp;#10;    return sqlite3_column_int([_statement statement], columnIdx);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过调用&lt;code&gt;- columnIndexForName:&lt;/code&gt;方法，用列名来获得列索引，这层映射关系都是存在&lt;code&gt;_columnNameToIndexMap&lt;/code&gt;字典里&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (int)columnIndexForName:(NSString*)columnName &amp;#123;&amp;#10;    columnName = [columnName lowercaseString];&amp;#10;    &amp;#10;    NSNumber *n = [[self columnNameToIndexMap] objectForKey:columnName];&amp;#10;    &amp;#10;    if (n) &amp;#123;&amp;#10;        return [n intValue];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    NSLog(@&amp;#34;Warning: I could not find the column named &amp;#39;%@&amp;#39;.&amp;#34;, columnName);&amp;#10;    &amp;#10;    return -1;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (NSMutableDictionary *)columnNameToIndexMap &amp;#123;&amp;#10;    if (!_columnNameToIndexMap) &amp;#123;&amp;#10;        int columnCount = sqlite3_column_count([_statement statement]);&amp;#10;        _columnNameToIndexMap = [[NSMutableDictionary alloc] initWithCapacity:(NSUInteger)columnCount];&amp;#10;        int columnIdx = 0;&amp;#10;        for (columnIdx = 0; columnIdx &amp;#60; columnCount; columnIdx++) &amp;#123;&amp;#10;            // &amp;#21015;&amp;#21517;&amp;#20316;&amp;#20026;key&amp;#65292;&amp;#23545;&amp;#24212;&amp;#30340;&amp;#21015;&amp;#21495;&amp;#20316;&amp;#20026;value&amp;#10;            [_columnNameToIndexMap setObject:[NSNumber numberWithInt:columnIdx]&amp;#10;                                      forKey:[[NSString stringWithUTF8String:sqlite3_column_name([_statement statement], columnIdx)] lowercaseString]];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    return _columnNameToIndexMap;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u9010_u884C_u8FD4_u56DE_u7ED3_u679C&quot;&gt;&lt;a href=&quot;#u9010_u884C_u8FD4_u56DE_u7ED3_u679C&quot; class=&quot;headerlink&quot; title=&quot;逐行返回结果&quot;&gt;&lt;/a&gt;逐行返回结果&lt;/h4&gt;&lt;p&gt;&lt;code&gt;- next&lt;/code&gt;方法本质是调用&lt;code&gt;- nextWithError&lt;/code&gt;，&lt;code&gt;FMDB&lt;/code&gt;里面有的注释写的还是挺逗的，连&lt;code&gt;wtf&lt;/code&gt;都有…哈哈&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)nextWithError:(NSError **)outErr &amp;#123;&amp;#10;    /* Call sqlite3_step() to run the virtual machine. Since the SQL being&amp;#10;     ** executed is not a SELECT statement, we assume no data will be returned.&amp;#10;     */&amp;#10;    // sqlite3_prepare&amp;#20989;&amp;#25968;&amp;#23558;SQL&amp;#21629;&amp;#20196;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#35299;&amp;#26512;&amp;#24182;&amp;#36716;&amp;#25442;&amp;#20026;&amp;#19968;&amp;#31995;&amp;#21015;&amp;#30340;&amp;#21629;&amp;#20196;&amp;#23383;&amp;#33410;&amp;#30721;&amp;#65292;&amp;#36825;&amp;#20123;&amp;#23383;&amp;#33410;&amp;#30721;&amp;#26368;&amp;#32456;&amp;#34987;&amp;#20256;&amp;#36865;&amp;#21040;SQlite3&amp;#30340;&amp;#34394;&amp;#25311;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#24341;&amp;#25806;&amp;#65288;VDBE: Virtual Database Engine&amp;#65289;&amp;#20013;&amp;#25191;&amp;#34892;&amp;#65292;&amp;#23436;&amp;#25104;&amp;#36825;&amp;#39033;&amp;#24037;&amp;#20316;&amp;#30340;&amp;#26159;sqlite3_step&amp;#20989;&amp;#25968;&amp;#12290;&amp;#27604;&amp;#22914;&amp;#19968;&amp;#20010;SELECT&amp;#26597;&amp;#35810;&amp;#25805;&amp;#20316;&amp;#65292;sqlite3_step&amp;#20989;&amp;#25968;&amp;#30340;&amp;#27599;&amp;#27425;&amp;#35843;&amp;#29992;&amp;#37117;&amp;#20250;&amp;#36820;&amp;#22238;&amp;#32467;&amp;#26524;&amp;#38598;&amp;#20013;&amp;#30340;&amp;#20854;&amp;#20013;&amp;#19968;&amp;#34892;&amp;#65292;&amp;#30452;&amp;#21040;&amp;#20877;&amp;#27809;&amp;#26377;&amp;#26377;&amp;#25928;&amp;#25968;&amp;#25454;&amp;#34892;&amp;#20102;&amp;#12290;&amp;#27599;&amp;#27425;&amp;#35843;&amp;#29992;sqlite3_step&amp;#20989;&amp;#25968;&amp;#22914;&amp;#26524;&amp;#36820;&amp;#22238;SQLITE_ROW&amp;#65292;&amp;#20195;&amp;#34920;&amp;#33719;&amp;#24471;&amp;#20102;&amp;#26377;&amp;#25928;&amp;#25968;&amp;#25454;&amp;#34892;&amp;#65292;&amp;#21487;&amp;#20197;&amp;#36890;&amp;#36807;sqlite3_column&amp;#20989;&amp;#25968;&amp;#25552;&amp;#21462;&amp;#26576;&amp;#21015;&amp;#30340;&amp;#20540;&amp;#12290;&amp;#22914;&amp;#26524;&amp;#35843;&amp;#29992;sqlite3_step&amp;#20989;&amp;#25968;&amp;#36820;&amp;#22238;SQLITE_DONE&amp;#65292;&amp;#21017;&amp;#20195;&amp;#34920;prepared&amp;#35821;&amp;#21477;&amp;#24050;&amp;#32463;&amp;#25191;&amp;#34892;&amp;#21040;&amp;#32456;&amp;#28857;&amp;#20102;&amp;#65292;&amp;#27809;&amp;#26377;&amp;#26377;&amp;#25928;&amp;#25968;&amp;#25454;&amp;#20102;&amp;#12290;&amp;#24456;&amp;#22810;&amp;#21629;&amp;#20196;&amp;#31532;&amp;#19968;&amp;#27425;&amp;#35843;&amp;#29992;sqlite3_step&amp;#20989;&amp;#25968;&amp;#23601;&amp;#20250;&amp;#36820;&amp;#22238;SQLITE_DONE&amp;#65292;&amp;#22240;&amp;#20026;&amp;#36825;&amp;#20123;SQL&amp;#21629;&amp;#20196;&amp;#19981;&amp;#20250;&amp;#36820;&amp;#22238;&amp;#25968;&amp;#25454;&amp;#12290;&amp;#23545;&amp;#20110;INSERT&amp;#65292;UPDATE&amp;#65292;DELETE&amp;#21629;&amp;#20196;&amp;#65292;&amp;#20250;&amp;#36820;&amp;#22238;&amp;#23427;&amp;#20204;&amp;#25152;&amp;#20462;&amp;#25913;&amp;#30340;&amp;#34892;&amp;#21495;&amp;#8212;&amp;#8212;&amp;#19968;&amp;#20010;&amp;#21333;&amp;#34892;&amp;#21333;&amp;#21015;&amp;#30340;&amp;#20540;&amp;#12290;&amp;#10;    /**&amp;#10;     SQLITE_BUSY &amp;#25968;&amp;#25454;&amp;#24211;&amp;#25991;&amp;#20214;&amp;#26377;&amp;#38145;&amp;#10;     SQLITE_LOCKED &amp;#25968;&amp;#25454;&amp;#24211;&amp;#20013;&amp;#30340;&amp;#26576;&amp;#24352;&amp;#34920;&amp;#26377;&amp;#38145;&amp;#10;     SQLITE_DONE sqlite3_step()&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#10;     SQLITE_ROW sqlite3_step()&amp;#33719;&amp;#21462;&amp;#21040;&amp;#19979;&amp;#19968;&amp;#34892;&amp;#25968;&amp;#25454;&amp;#10;     SQLITE_ERROR &amp;#19968;&amp;#33324;&amp;#29992;&amp;#20110;&amp;#27809;&amp;#26377;&amp;#29305;&amp;#21035;&amp;#25351;&amp;#23450;&amp;#38169;&amp;#35823;&amp;#30721;&amp;#30340;&amp;#38169;&amp;#35823;&amp;#65292;&amp;#23601;&amp;#26159;&amp;#35828;&amp;#20989;&amp;#25968;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#36807;&amp;#31243;&amp;#20013;&amp;#21457;&amp;#29983;&amp;#20102;&amp;#38169;&amp;#35823;&amp;#65292;&amp;#20294;&amp;#26080;&amp;#27861;&amp;#30693;&amp;#36947;&amp;#38169;&amp;#35823;&amp;#21457;&amp;#29983;&amp;#30340;&amp;#21407;&amp;#22240;&amp;#12290;&amp;#10;     SQLITE_MISUSE &amp;#27809;&amp;#26377;&amp;#27491;&amp;#30830;&amp;#20351;&amp;#29992;SQLite&amp;#25509;&amp;#21475;&amp;#65292;&amp;#27604;&amp;#22914;&amp;#19968;&amp;#26465;&amp;#35821;&amp;#21477;&amp;#22312;sqlite3_step&amp;#20989;&amp;#25968;&amp;#25191;&amp;#34892;&amp;#20043;&amp;#21518;&amp;#65292;&amp;#27809;&amp;#26377;&amp;#34987;&amp;#37325;&amp;#32622;&amp;#20043;&amp;#21069;&amp;#65292;&amp;#20877;&amp;#27425;&amp;#32473;&amp;#20854;&amp;#32465;&amp;#23450;&amp;#21442;&amp;#25968;&amp;#65292;&amp;#36825;&amp;#26102;bind&amp;#20989;&amp;#25968;&amp;#23601;&amp;#20250;&amp;#36820;&amp;#22238;SQLITE_MISUSE&amp;#12290;&amp;#10;     **/&amp;#10;    int rc = sqlite3_step([_statement statement]);&amp;#10;    &amp;#10;    if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &amp;#123;&amp;#10;        NSLog(@&amp;#34;%s:%d Database busy (%@)&amp;#34;, __FUNCTION__, __LINE__, [_parentDB databasePath]);&amp;#10;        NSLog(@&amp;#34;Database busy&amp;#34;);&amp;#10;        if (outErr) &amp;#123;&amp;#10;            *outErr = [_parentDB lastError];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else if (SQLITE_DONE == rc || SQLITE_ROW == rc) &amp;#123;&amp;#10;        // all is well, let&amp;#39;s return.&amp;#10;    &amp;#125;&amp;#10;    else if (SQLITE_ERROR == rc) &amp;#123;&amp;#10;        NSLog(@&amp;#34;Error calling sqlite3_step (%d: %s) rs&amp;#34;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));&amp;#10;        if (outErr) &amp;#123;&amp;#10;            *outErr = [_parentDB lastError];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else if (SQLITE_MISUSE == rc) &amp;#123;&amp;#10;        // uh oh.&amp;#10;        NSLog(@&amp;#34;Error calling sqlite3_step (%d: %s) rs&amp;#34;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));&amp;#10;        if (outErr) &amp;#123;&amp;#10;            if (_parentDB) &amp;#123;&amp;#10;                *outErr = [_parentDB lastError];&amp;#10;            &amp;#125;&amp;#10;            else &amp;#123;&amp;#10;                // If &amp;#39;next&amp;#39; or &amp;#39;nextWithError&amp;#39; is called after the result set is closed,&amp;#10;                // we need to return the appropriate error.&amp;#10;                NSDictionary* errorMessage = [NSDictionary dictionaryWithObject:@&amp;#34;parentDB does not exist&amp;#34; forKey:NSLocalizedDescriptionKey];&amp;#10;                *outErr = [NSError errorWithDomain:@&amp;#34;FMDatabase&amp;#34; code:SQLITE_MISUSE userInfo:errorMessage];&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else &amp;#123;&amp;#10;        // wtf?&amp;#10;        NSLog(@&amp;#34;Unknown error calling sqlite3_step (%d: %s) rs&amp;#34;, rc, sqlite3_errmsg([_parentDB sqliteHandle]));&amp;#10;        if (outErr) &amp;#123;&amp;#10;            *outErr = [_parentDB lastError];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    &amp;#10;    if (rc != SQLITE_ROW) &amp;#123;&amp;#10;        [self close];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return (rc == SQLITE_ROW);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;while ([rs next]) &amp;#123;&amp;#10;    NSString *file = [rs stringForColumn:@&amp;#34;file&amp;#34;];&amp;#10;    NSLog(@&amp;#34;database_list: %@&amp;#34;, file);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;FMDatabaseQueue&quot;&gt;&lt;a href=&quot;#FMDatabaseQueue&quot; class=&quot;headerlink&quot; title=&quot;FMDatabaseQueue&quot;&gt;&lt;/a&gt;FMDatabaseQueue&lt;/h2&gt;&lt;p&gt;是用来多线程并行执行SQL语句&lt;/p&gt;
&lt;h4 id=&quot;u521D_u59CB_u5316-1&quot;&gt;&lt;a href=&quot;#u521D_u59CB_u5316-1&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h4&gt;&lt;p&gt;头文件里提供了很多种初始化方法，但是最终调用的还是&lt;code&gt;(instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags vfs:(NSString *)vfsName&lt;/code&gt;方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags vfs:(NSString *)vfsName &amp;#123;&amp;#10;    &amp;#10;    self = [super init];&amp;#10;    &amp;#10;    if (self != nil) &amp;#123;&amp;#10;        // &amp;#26681;&amp;#25454;&amp;#25351;&amp;#23450;&amp;#36335;&amp;#24452;&amp;#23547;&amp;#25214;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#24050;&amp;#23384;&amp;#22312;&amp;#21017;&amp;#36820;&amp;#22238;db&amp;#65292;&amp;#19981;&amp;#23384;&amp;#22312;&amp;#21017;&amp;#21019;&amp;#24314;&amp;#10;        _db = [[[self class] databaseClass] databaseWithPath:aPath];&amp;#10;        FMDBRetain(_db);&amp;#10;        &amp;#10;#if SQLITE_VERSION_NUMBER &amp;#62;= 3005000&amp;#10;        BOOL success = [_db openWithFlags:openFlags vfs:vfsName];&amp;#10;#else&amp;#10;        BOOL success = [_db open];&amp;#10;#endif&amp;#10;        if (!success) &amp;#123;&amp;#10;            NSLog(@&amp;#34;Could not create database queue for path %@&amp;#34;, aPath);&amp;#10;            FMDBRelease(self);&amp;#10;            return 0x00;&amp;#10;        &amp;#125;&amp;#10;        &amp;#10;        _path = FMDBReturnRetained(aPath);&amp;#10;        // &amp;#21019;&amp;#24314;&amp;#20018;&amp;#34892;&amp;#38431;&amp;#21015;&amp;#10;        _queue = dispatch_queue_create([[NSString stringWithFormat:@&amp;#34;fmdb.%@&amp;#34;, self] UTF8String], NULL);&amp;#10;        // &amp;#32473;_queue&amp;#38431;&amp;#21015;&amp;#25351;&amp;#23450;&amp;#20102;kDispatchQueueSpecificKey&amp;#23383;&amp;#31526;&amp;#20018;&amp;#65292;&amp;#24182;&amp;#21644;self&amp;#32465;&amp;#23450;&amp;#65292;&amp;#21518;&amp;#38754;&amp;#21487;&amp;#20197;&amp;#36890;&amp;#36807;kDispatchQueueSpecificKey&amp;#33719;&amp;#21462;&amp;#21040;self&amp;#65292;&amp;#20294;&amp;#35201;&amp;#20445;&amp;#35777;&amp;#27491;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#30340;&amp;#38431;&amp;#21015;&amp;#26159;&amp;#36825;&amp;#20010;_queue&amp;#10;        dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);&amp;#10;        _openFlags = openFlags;&amp;#10;        _vfsName = [vfsName copy];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return self;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:dbPath];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u64CD_u4F5C_u6570_u636E_u5E93&quot;&gt;&lt;a href=&quot;#u64CD_u4F5C_u6570_u636E_u5E93&quot; class=&quot;headerlink&quot; title=&quot;操作数据库&quot;&gt;&lt;/a&gt;操作数据库&lt;/h4&gt;&lt;p&gt;想要多线程操作数据库时，不是直接使用&lt;code&gt;FMDatabase&lt;/code&gt;对象，而是通过&lt;code&gt;FMDatabaseQueue&lt;/code&gt;对象，调用&lt;code&gt;- inDatabas:&lt;/code&gt;，通过&lt;code&gt;block&lt;/code&gt;返回&lt;code&gt;FMDatabase&lt;/code&gt;对象来操作，虽然&lt;code&gt;- inDatabas:&lt;/code&gt;内是同步操作，但是线程之间是并行的，就相当于马路上有两条单行的路，虽然每条路上的车都是一辆接一辆的，但是两条路之间是互不影响的&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)inDatabase:(void (^)(FMDatabase *db))block &amp;#123;&amp;#10;    // &amp;#36890;&amp;#36807;kDispatchQueueSpecificKey&amp;#26469;&amp;#33719;&amp;#21462;&amp;#24403;&amp;#21069;&amp;#27491;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#30340;&amp;#38431;&amp;#21015;&amp;#65292;&amp;#24182;&amp;#19988;&amp;#26816;&amp;#26597;&amp;#21644;self&amp;#20570;&amp;#27604;&amp;#36739;&amp;#65292;&amp;#30830;&amp;#20445;&amp;#27809;&amp;#26377;&amp;#21457;&amp;#29983;&amp;#27515;&amp;#38145;&amp;#65292;&amp;#22240;&amp;#20026;&amp;#21487;&amp;#20197;&amp;#21019;&amp;#24314;&amp;#22810;&amp;#20010;FMDatabaseQueue&amp;#22810;&amp;#20010;&amp;#26469;&amp;#25191;&amp;#34892;&amp;#19981;&amp;#21516;&amp;#30340;SQL&amp;#35821;&amp;#21477;&amp;#10;    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);&amp;#10;    assert(currentSyncQueue != self &amp;#38;&amp;#38; &amp;#34;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&amp;#34;);&amp;#10;    &amp;#10;    FMDBRetain(self);&amp;#10;    // &amp;#22312;&amp;#24403;&amp;#21069;queue&amp;#20013;&amp;#65292;&amp;#21516;&amp;#27493;&amp;#25191;&amp;#34892;block&amp;#10;    dispatch_sync(_queue, ^() &amp;#123;&amp;#10;        &amp;#10;        FMDatabase *db = [self database];&amp;#10;        block(db);&amp;#10;        &amp;#10;        if ([db hasOpenResultSets]) &amp;#123;&amp;#10;            NSLog(@&amp;#34;Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]&amp;#34;);&amp;#10;            &amp;#10;#if defined(DEBUG) &amp;#38;&amp;#38; DEBUG&amp;#10;            NSSet *openSetCopy = FMDBReturnAutoreleased([[db valueForKey:@&amp;#34;_openResultSets&amp;#34;] copy]);&amp;#10;            for (NSValue *rsInWrappedInATastyValueMeal in openSetCopy) &amp;#123;&amp;#10;                FMResultSet *rs = (FMResultSet *)[rsInWrappedInATastyValueMeal pointerValue];&amp;#10;                NSLog(@&amp;#34;query: &amp;#39;%@&amp;#39;&amp;#34;, [rs query]);&amp;#10;            &amp;#125;&amp;#10;#endif&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;);&amp;#10;    &amp;#10;    FMDBRelease(self);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[queue inDatabase:^(FMDatabase *adb) &amp;#123;&amp;#10;    [adb executeUpdate:@&amp;#34;create table qfoo (foo text)&amp;#34;];&amp;#10;    [adb executeUpdate:@&amp;#34;insert into qfoo values (&amp;#39;hi&amp;#39;)&amp;#34;];&amp;#10;    [adb executeUpdate:@&amp;#34;insert into qfoo values (&amp;#39;hello&amp;#39;)&amp;#34;];&amp;#10;    [adb executeUpdate:@&amp;#34;insert into qfoo values (&amp;#39;not&amp;#39;)&amp;#34;];&amp;#10;&amp;#10;&amp;#9;int count = 0;&amp;#10;    FMResultSet *rsl = [adb executeQuery:@&amp;#34;select * from qfoo where foo like &amp;#39;h%&amp;#39;&amp;#34;];&amp;#10;    while ([rsl next]) &amp;#123;&amp;#10;        count++;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    FMDBQuickCheck(count == 2);&amp;#10;&amp;#10;    count = 0;&amp;#10;    rsl = [adb executeQuery:@&amp;#34;select * from qfoo where foo like ?&amp;#34;, @&amp;#34;h%&amp;#34;];&amp;#10;    while ([rsl next]) &amp;#123;&amp;#10;        count++;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    FMDBQuickCheck(count == 2);&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u4E8B_u52A1_u5904_u7406&quot;&gt;&lt;a href=&quot;#u4E8B_u52A1_u5904_u7406&quot; class=&quot;headerlink&quot; title=&quot;事务处理&quot;&gt;&lt;/a&gt;事务处理&lt;/h4&gt;&lt;p&gt;和&lt;code&gt;FMDatabase&lt;/code&gt;一样，也有事务的处理，分为exclusive事务和deferred事务&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)inDeferredTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block &amp;#123;&amp;#10;    [self beginTransaction:YES withBlock:block];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)inTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block &amp;#123;&amp;#10;    [self beginTransaction:NO withBlock:block];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)beginTransaction:(BOOL)useDeferred withBlock:(void (^)(FMDatabase *db, BOOL *rollback))block &amp;#123;&amp;#10;    FMDBRetain(self);&amp;#10;    dispatch_sync(_queue, ^() &amp;#123; &amp;#10;        &amp;#10;        BOOL shouldRollback = NO;&amp;#10;        // &amp;#26159;&amp;#21542;&amp;#20351;&amp;#29992;&amp;#24310;&amp;#36831;&amp;#20107;&amp;#21153;&amp;#10;        if (useDeferred) &amp;#123;&amp;#10;            [[self database] beginDeferredTransaction];&amp;#10;        &amp;#125;&amp;#10;        else &amp;#123;&amp;#10;            [[self database] beginTransaction];&amp;#10;        &amp;#125;&amp;#10;        // &amp;#22914;&amp;#26524;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#25805;&amp;#20316;&amp;#20986;&amp;#38169;&amp;#20102;&amp;#65292;&amp;#20320;&amp;#21487;&amp;#20197;&amp;#35774;&amp;#32622;&amp;#26159;&amp;#21542;&amp;#38656;&amp;#35201;&amp;#22238;&amp;#28378;&amp;#65292;&amp;#22238;&amp;#28378;&amp;#21040;&amp;#25805;&amp;#20316;&amp;#20043;&amp;#21069;&amp;#30340;&amp;#20869;&amp;#23481;&amp;#10;        block([self database], &amp;#38;shouldRollback);&amp;#10;        &amp;#10;        if (shouldRollback) &amp;#123;&amp;#10;            [[self database] rollback];&amp;#10;        &amp;#125;&amp;#10;        else &amp;#123;&amp;#10;            // &amp;#22914;&amp;#26524;&amp;#19981;&amp;#38656;&amp;#35201;&amp;#22238;&amp;#28378;&amp;#65292;&amp;#21017;commit&amp;#25552;&amp;#20132;&amp;#30456;&amp;#24212;&amp;#30340;sql&amp;#25805;&amp;#20316;&amp;#10;            [[self database] commit];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;);&amp;#10;    &amp;#10;    FMDBRelease(self);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[queue inTransaction:^(FMDatabase *adb, BOOL *rollback) &amp;#123;&amp;#10;    NSLog(@&amp;#34;Starting query  %ld&amp;#34;, nby);&amp;#10;&amp;#10;    FMResultSet *rsl = [adb executeQuery:@&amp;#34;select * from qfoo where foo like &amp;#39;h%&amp;#39;&amp;#34;];&amp;#10;    while ([rsl next]) &amp;#123;&amp;#10;        ;// whatever.&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    NSLog(@&amp;#34;Ending query    %ld&amp;#34;, nby);&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;FMDatabasePool&quot;&gt;&lt;a href=&quot;#FMDatabasePool&quot; class=&quot;headerlink&quot; title=&quot;FMDatabasePool&quot;&gt;&lt;/a&gt;FMDatabasePool&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;If you really really really know what you’re doing and &lt;code&gt;FMDatabasePool&lt;/code&gt; is what  you really really need (ie, you’re using a read only database), OK you can use it.  But just be careful not to deadlock!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对，这就是&lt;code&gt;FMDatabasePool&lt;/code&gt;的描述，只能用于数据库只读操作，如果进行了写操作，很有可能会出现死锁，乱用搞不好就跪了…&lt;/p&gt;
&lt;p&gt;里面的方法基本和&lt;code&gt;FMDatabaseQueue&lt;/code&gt;差不多，里面有两个特别的属性：&lt;code&gt;_databaseInPool&lt;/code&gt;和&lt;code&gt;_databaseOutPool&lt;/code&gt;，按我的理解，这两个属性的作用就像是一个用来存放闲置的db，一个是用来存放正在执行操作的db，在&lt;code&gt;- inDatabase:&lt;/code&gt;等这些方法最后都调用了&lt;code&gt;- pushDatabaseBackInPool:&lt;/code&gt;方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#23558;db&amp;#25918;&amp;#22238;InPool&amp;#37324;&amp;#38754;&amp;#10;- (void)pushDatabaseBackInPool:(FMDatabase*)db &amp;#123;&amp;#10;    &amp;#10;    if (!db) &amp;#123; // db can be null if we set an upper bound on the # of databases to create.&amp;#10;        return;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#21516;&amp;#27493;&amp;#25191;&amp;#34892;&amp;#10;    [self executeLocked:^() &amp;#123;&amp;#10;        // &amp;#22914;&amp;#26524;InPool&amp;#25968;&amp;#32452;&amp;#37324;&amp;#38754;&amp;#21253;&amp;#21547;db&amp;#65292;&amp;#35828;&amp;#26126;db&amp;#24050;&amp;#32463;&amp;#22312;InPool&amp;#37324;&amp;#38754;&amp;#65292;&amp;#19981;&amp;#38656;&amp;#35201;&amp;#20877;&amp;#25918;&amp;#22238;InPool&amp;#37324;&amp;#65292;&amp;#24182;&amp;#19988;&amp;#25243;&amp;#20986;&amp;#24322;&amp;#24120;&amp;#65292;&amp;#19979;&amp;#38754;&amp;#30340;&amp;#25805;&amp;#20316;&amp;#23601;&amp;#19981;&amp;#36827;&amp;#34892;&amp;#20102;&amp;#10;        if ([self-&amp;#62;_databaseInPool containsObject:db]) &amp;#123;&amp;#10;            [[NSException exceptionWithName:@&amp;#34;Database already in pool&amp;#34; reason:@&amp;#34;The FMDatabase being put back into the pool is already present in the pool&amp;#34; userInfo:nil] raise];&amp;#10;        &amp;#125;&amp;#10;        // &amp;#22914;&amp;#26524;db&amp;#19981;&amp;#22312;InPool&amp;#37324;&amp;#38754;&amp;#65292;&amp;#25226;db&amp;#21152;&amp;#21040;InPool&amp;#25968;&amp;#32452;&amp;#65292;&amp;#24182;&amp;#19988;&amp;#20174;OutPool&amp;#20013;&amp;#31227;&amp;#38500;&amp;#10;        [self-&amp;#62;_databaseInPool addObject:db];&amp;#10;        [self-&amp;#62;_databaseOutPool removeObject:db];&amp;#10;        &amp;#10;    &amp;#125;];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (FMDatabase*)db &amp;#123;&amp;#10;    &amp;#10;    __block FMDatabase *db;&amp;#10;    &amp;#10;    &amp;#10;    [self executeLocked:^() &amp;#123;&amp;#10;        // &amp;#20174;_databaseInPool&amp;#37324;&amp;#38754;&amp;#21462;&amp;#20986;&amp;#26368;&amp;#21518;&amp;#19968;&amp;#20010;FMDatabase&amp;#23545;&amp;#35937;&amp;#10;        db = [self-&amp;#62;_databaseInPool lastObject];&amp;#10;        &amp;#10;        BOOL shouldNotifyDelegate = NO;&amp;#10;        // &amp;#22914;&amp;#26524;db&amp;#23384;&amp;#22312;&amp;#65292;&amp;#21017;&amp;#21152;&amp;#21040;_databaseOutPool&amp;#37324;&amp;#65292;_databaseInPool&amp;#31227;&amp;#38500;&amp;#25481;&amp;#65292;&amp;#25105;&amp;#30340;&amp;#29702;&amp;#35299;&amp;#26159;_databaseOutPool&amp;#26159;&amp;#29992;&amp;#20110;&amp;#23384;&amp;#25918;&amp;#27491;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#25805;&amp;#20316;&amp;#30340;db&amp;#27744;&amp;#65292;_databaseInPool&amp;#21017;&amp;#23384;&amp;#25918;&amp;#38386;&amp;#32622;&amp;#30340;db&amp;#27744;&amp;#10;        // &amp;#22312;&amp;#38656;&amp;#35201;&amp;#20351;&amp;#29992;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#65292;&amp;#20174;&amp;#38386;&amp;#32622;&amp;#30340;&amp;#27744;&amp;#37324;&amp;#38754;&amp;#21462;&amp;#20986;&amp;#26469;&amp;#25918;&amp;#21040;&amp;#27491;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#30340;&amp;#27744;&amp;#37324;&amp;#38754;&amp;#10;        if (db) &amp;#123;&amp;#10;            [self-&amp;#62;_databaseOutPool addObject:db];&amp;#10;            [self-&amp;#62;_databaseInPool removeLastObject];&amp;#10;        &amp;#125;&amp;#10;        else &amp;#123;&amp;#10;            // &amp;#26816;&amp;#26597;&amp;#26368;&amp;#22823;&amp;#21019;&amp;#24314;&amp;#30340;db&amp;#25968;&amp;#37327;&amp;#65292;&amp;#36229;&amp;#36807;&amp;#20102;&amp;#21017;&amp;#36820;&amp;#22238;&amp;#65292;&amp;#21542;&amp;#21017;&amp;#23601;&amp;#26681;&amp;#25454;&amp;#36335;&amp;#24452;&amp;#65292;&amp;#25214;&amp;#21040;db&amp;#10;            if (self-&amp;#62;_maximumNumberOfDatabasesToCreate) &amp;#123;&amp;#10;                NSUInteger currentCount = [self-&amp;#62;_databaseOutPool count] + [self-&amp;#62;_databaseInPool count];&amp;#10;                &amp;#10;                if (currentCount &amp;#62;= self-&amp;#62;_maximumNumberOfDatabasesToCreate) &amp;#123;&amp;#10;                    NSLog(@&amp;#34;Maximum number of databases (%ld) has already been reached!&amp;#34;, (long)currentCount);&amp;#10;                    return;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            db = [[[self class] databaseClass] databaseWithPath:self-&amp;#62;_path];&amp;#10;            shouldNotifyDelegate = YES;&amp;#10;        &amp;#125;&amp;#10;        // &amp;#26681;&amp;#25454;_openFlags&amp;#21644;_vfsName&amp;#25171;&amp;#24320;db&amp;#10;        //This ensures that the db is opened before returning&amp;#10;#if SQLITE_VERSION_NUMBER &amp;#62;= 3005000&amp;#10;        BOOL success = [db openWithFlags:self-&amp;#62;_openFlags vfs:self-&amp;#62;_vfsName];&amp;#10;#else&amp;#10;        BOOL success = [db open];&amp;#10;#endif&amp;#10;        if (success) &amp;#123;&amp;#10;            // &amp;#22914;&amp;#26524;&amp;#20195;&amp;#29702;&amp;#26041;&amp;#27861;&amp;#21709;&amp;#24212;&amp;#20102;&amp;#65292;&amp;#20294;&amp;#26159;db&amp;#19981;&amp;#20801;&amp;#35768;&amp;#34987;&amp;#21152;&amp;#21040;pool&amp;#37324;&amp;#38754;&amp;#65292;&amp;#37027;&amp;#20040;db&amp;#20851;&amp;#38381;&amp;#37322;&amp;#25918;&amp;#10;            if ([self-&amp;#62;_delegate respondsToSelector:@selector(databasePool:shouldAddDatabaseToPool:)] &amp;#38;&amp;#38; ![self-&amp;#62;_delegate databasePool:self shouldAddDatabaseToPool:db]) &amp;#123;&amp;#10;                [db close];&amp;#10;                db = 0x00;&amp;#10;            &amp;#125;&amp;#10;            else &amp;#123;&amp;#10;                //It should not get added in the pool twice if lastObject was found&amp;#10;                // &amp;#23545;&amp;#20110;&amp;#26032;&amp;#21019;&amp;#24314;&amp;#30340;db&amp;#65292;&amp;#38656;&amp;#35201;&amp;#21152;&amp;#21040;_databaseOutPool&amp;#37324;&amp;#65292;&amp;#32780;&amp;#19981;&amp;#38656;&amp;#35201;&amp;#21152;&amp;#21040;_databaseInPool&amp;#37324;&amp;#10;                if (![self-&amp;#62;_databaseOutPool containsObject:db]) &amp;#123;&amp;#10;                    [self-&amp;#62;_databaseOutPool addObject:db];&amp;#10;                    // &amp;#26032;&amp;#21019;&amp;#24314;&amp;#30340;db&amp;#38656;&amp;#35201;&amp;#21709;&amp;#24212;delegate&amp;#10;                    if (shouldNotifyDelegate &amp;#38;&amp;#38; [self-&amp;#62;_delegate respondsToSelector:@selector(databasePool:didAddDatabase:)]) &amp;#123;&amp;#10;                        [self-&amp;#62;_delegate databasePool:self didAddDatabase:db];&amp;#10;                    &amp;#125;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        else &amp;#123;&amp;#10;            NSLog(@&amp;#34;Could not open up the database at path %@&amp;#34;, self-&amp;#62;_path);&amp;#10;            db = 0x00;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;];&amp;#10;    &amp;#10;    return db;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;FMResultSet&lt;/code&gt;用来执行SQL语句结果的查询&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FMDatabaseQueue&lt;/code&gt;用不同的线程来执行若干个查询和更新操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FMDatabasePool&lt;/code&gt;和&lt;code&gt;FMDatabaseQueue&lt;/code&gt;类似，但是只是用在数据库只读操作上&lt;/p&gt;
    
    </summary>
    
    
      <category term="FMDB" scheme="http://yuzeyang.github.io/tags/FMDB/"/>
    
  </entry>
  
  <entry>
    <title>FMDB初探（一）</title>
    <link href="http://yuzeyang.github.io/2016/07/23/FMDB-one/"/>
    <id>http://yuzeyang.github.io/2016/07/23/FMDB-one/</id>
    <published>2016-07-23T04:11:21.000Z</published>
    <updated>2016-07-24T10:49:53.000Z</updated>
    
    <content type="html">&lt;p&gt;在之前的&lt;a href=&quot;http://zeeyang.com/2016/06/22/GCDAsyncSocket-socket-optimize/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS Socket重构设计&lt;/a&gt;里面我有提到我们使用了FMDB做消息缓存，在数据库选型方面，我们&lt;a href=&quot;http://broccoliii.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;西兰花&lt;/a&gt;也对目前比较流行和成熟的&lt;code&gt;Realm&lt;/code&gt;、&lt;code&gt;FMDB&lt;/code&gt;和&lt;code&gt;Core Data&lt;/code&gt;做了调查，里面包括了安装、使用和性能比较，是个不错的参考例子&lt;/p&gt;
&lt;p&gt;在选型时，我们应该多选取几个作为对比，从使用方面评估学习成本，通过测试不同数据库操作来比较性能差异，了解有哪些大型的App使用了该数据库以及评价来侧面说明该数据库的成熟度和在使用过程中出现的问题，最后根据自己实际的业务需求来选型&lt;/p&gt;
&lt;p&gt;在选定使用&lt;code&gt;FMDB&lt;/code&gt;之后，我也只是简单的了解下&lt;code&gt;FMDB&lt;/code&gt;的使用，并未对内部的实现和设计思路做深入了解，但是在阅读了代码之后，&lt;code&gt;FMDB&lt;/code&gt;确实像其他博客里面提到的那样，是对原生的SQLite API进行了包装，暴露出相对友好的对外接口，只需传入SQL语句即可(但是对于习惯于使用Model操作的我们来说，直接写SQL语句还是比较麻烦的，所以GitHub上也就库对&lt;code&gt;FMDB&lt;/code&gt;进行了封装，省去写SQL语句，直接对Model进行操作)，并且&lt;code&gt;FMDB&lt;/code&gt;内部对SQL语句进行了缓存，再配合上多线程并发执行，在提高效率方面做了不少的优化，另外还扩展了内存/文件的IO操作和虚表的操作&lt;/p&gt;
&lt;p&gt;下面我会将API使用和源码结合起来讲，方便了解&lt;code&gt;FMDB&lt;/code&gt;以及对复习下原生的SQLite API&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;FMDatabase&quot;&gt;&lt;a href=&quot;#FMDatabase&quot; class=&quot;headerlink&quot; title=&quot;FMDatabase&quot;&gt;&lt;/a&gt;FMDatabase&lt;/h2&gt;&lt;h4 id=&quot;u521D_u59CB_u5316&quot;&gt;&lt;a href=&quot;#u521D_u59CB_u5316&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h4&gt;&lt;p&gt;数据库的初始化对外有两种方法&lt;code&gt;+ databaseWithPath:&lt;/code&gt;和&lt;code&gt;- initWithPath:&lt;/code&gt;，内部实际上&lt;code&gt;+ databaseWithPath:&lt;/code&gt;只是对&lt;code&gt;- initWithPath:&lt;/code&gt;包装，代码里很多类似&lt;code&gt;FMDBReturnAutoreleased&lt;/code&gt;等等这一类宏定义是为了兼容ARC和MRC&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)databaseWithPath:(NSString*)aPath &amp;#123;&amp;#10;    return FMDBReturnAutoreleased([[self alloc] initWithPath:aPath]);&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (instancetype)init &amp;#123;&amp;#10;    return [self initWithPath:nil];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (instancetype)initWithPath:(NSString*)aPath &amp;#123;&amp;#10;    // SQLite&amp;#25903;&amp;#25345;&amp;#19977;&amp;#31181;&amp;#32447;&amp;#31243;&amp;#27169;&amp;#24335;&amp;#65292;&amp;#20998;&amp;#21035;&amp;#20026;&amp;#21333;&amp;#32447;&amp;#31243;&amp;#27169;&amp;#24335;&amp;#12289;&amp;#22810;&amp;#32447;&amp;#31243;&amp;#27169;&amp;#24335;&amp;#21644;&amp;#20018;&amp;#34892;&amp;#27169;&amp;#24335;&amp;#10;    // sqlite3_threadsafe()&amp;#30340;&amp;#36820;&amp;#22238;&amp;#20540;&amp;#21487;&amp;#20197;&amp;#30830;&amp;#23450;&amp;#32534;&amp;#35793;&amp;#26102;&amp;#25351;&amp;#23450;&amp;#30340;&amp;#32447;&amp;#31243;&amp;#27169;&amp;#24335;&amp;#65292;&amp;#20854;&amp;#20013;&amp;#23545;&amp;#20110;&amp;#21333;&amp;#32447;&amp;#31243;&amp;#27169;&amp;#24335;&amp;#65292;sqlite3_threadsafe()&amp;#36820;&amp;#22238;false&amp;#65292;&amp;#23545;&amp;#20110;&amp;#21478;&amp;#22806;&amp;#20004;&amp;#20010;&amp;#27169;&amp;#24335;&amp;#65292;&amp;#21017;&amp;#36820;&amp;#22238;true&amp;#12290;&amp;#36825;&amp;#26159;&amp;#22240;&amp;#20026;&amp;#21333;&amp;#32447;&amp;#31243;&amp;#27169;&amp;#24335;&amp;#19979;&amp;#27809;&amp;#26377;&amp;#36827;&amp;#34892;&amp;#20114;&amp;#26021;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#22810;&amp;#32447;&amp;#31243;&amp;#19979;&amp;#26159;&amp;#19981;&amp;#23433;&amp;#20840;&amp;#30340;&amp;#10;    assert(sqlite3_threadsafe()); // whoa there big boy- gotta make sure sqlite it happy with what we&amp;#39;re going to do.&amp;#10;    &amp;#10;    self = [super init];&amp;#10;    &amp;#10;    if (self) &amp;#123;&amp;#10;        _databasePath               = [aPath copy];&amp;#10;        _openResultSets             = [[NSMutableSet alloc] init];&amp;#10;        // &amp;#27492;&amp;#26102;&amp;#24182;&amp;#19981;&amp;#21019;&amp;#24314;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#65292;&amp;#30495;&amp;#27491;&amp;#21019;&amp;#24314;&amp;#26159;&amp;#22312;open&amp;#30340;&amp;#26102;&amp;#20505;&amp;#10;      &amp;#9;_db                         = nil;&amp;#10;        _logsErrors                 = YES;&amp;#10;        _crashOnErrors              = NO;&amp;#10;        _maxBusyRetryTimeInterval   = 2;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return self;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#32473;&amp;#23450;database&amp;#36335;&amp;#24452;&amp;#10;NSString *dbPath = @&amp;#34;/tmp/tmp.db&amp;#34;;&amp;#10;// &amp;#35843;&amp;#29992;[+ databaseWithPath:]&amp;#26041;&amp;#27861;&amp;#10;FMDatabase *db = [FMDatabase databaseWithPath:dbPath];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u6253_u5F00_u6570_u636E_u8FDE_u63A5&quot;&gt;&lt;a href=&quot;#u6253_u5F00_u6570_u636E_u8FDE_u63A5&quot; class=&quot;headerlink&quot; title=&quot;打开数据连接&quot;&gt;&lt;/a&gt;打开数据连接&lt;/h4&gt;&lt;p&gt;打开连接提供了三种方法，这时候才开始创建数据库&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)open &amp;#123;&amp;#10;    if (_db) &amp;#123;&amp;#10;        return YES;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#26681;&amp;#25454;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#36335;&amp;#24452;&amp;#25171;&amp;#24320;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#19981;&amp;#23384;&amp;#22312;&amp;#23601;&amp;#26032;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#10;    int err = sqlite3_open([self sqlitePath], (sqlite3**)&amp;#38;_db );&amp;#10;    if(err != SQLITE_OK) &amp;#123;&amp;#10;        NSLog(@&amp;#34;error opening!: %d&amp;#34;, err);&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#35774;&amp;#32622;&amp;#26368;&amp;#22823;&amp;#32321;&amp;#24537;&amp;#37325;&amp;#35797;&amp;#26102;&amp;#38388;&amp;#38388;&amp;#38548;&amp;#65292;&amp;#40664;&amp;#35748;&amp;#20026;2&amp;#31186;&amp;#10;    if (_maxBusyRetryTimeInterval &amp;#62; 0.0) &amp;#123;&amp;#10;        // set the handler&amp;#10;        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;  &amp;#9;return YES;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#26681;&amp;#25454;&amp;#26631;&amp;#35760;&amp;#25171;&amp;#24320;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#36830;&amp;#25509;&amp;#10;// flag&amp;#21487;&amp;#20197;&amp;#26159;&amp;#20197;&amp;#19979;&amp;#19977;&amp;#31181;&amp;#20540;&amp;#20043;&amp;#19968;&amp;#65306;&amp;#10;// SQLITE_OPEN_READONLY&amp;#65292;&amp;#21482;&amp;#35835;&amp;#27169;&amp;#24335;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#19981;&amp;#23384;&amp;#22312;&amp;#20250;&amp;#25253;&amp;#38169;&amp;#10;// SQLITE_OPEN_READWRITE&amp;#65292;&amp;#35835;&amp;#20889;&amp;#27169;&amp;#24335;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#35813;&amp;#25991;&amp;#20214;&amp;#22312;&amp;#25805;&amp;#20316;&amp;#31995;&amp;#32479;&amp;#20013;&amp;#26159;&amp;#20889;&amp;#20445;&amp;#25252;&amp;#30340;&amp;#65292;&amp;#37027;&amp;#23601;&amp;#26159;&amp;#20197;&amp;#21482;&amp;#35835;&amp;#26041;&amp;#24335;&amp;#25171;&amp;#24320;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#19981;&amp;#23384;&amp;#22312;&amp;#20250;&amp;#25253;&amp;#38169;&amp;#10;// SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE&amp;#65292;&amp;#20197;&amp;#35835;&amp;#20889;&amp;#26041;&amp;#24335;&amp;#25171;&amp;#24320;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#25968;&amp;#25454;&amp;#19981;&amp;#23384;&amp;#22312;&amp;#21017;&amp;#26032;&amp;#24314;&amp;#19968;&amp;#20010;&amp;#65292;&amp;#36825;&amp;#20010;&amp;#29992;&amp;#20110;open&amp;#26041;&amp;#27861;&amp;#37324;&amp;#38754;&amp;#10;// &amp;#20197;&amp;#19978;&amp;#36824;&amp;#21487;&amp;#20197;&amp;#21487;&amp;#36873;&amp;#32452;&amp;#21512;`SQLITE_OPEN_NOMUTEX`, `SQLITE_OPEN_FULLMUTEX`, `SQLITE_OPEN_SHAREDCACHE`, `SQLITE_OPEN_PRIVATECACHE`, and/or `SQLITE_OPEN_URI`&amp;#10;- (BOOL)openWithFlags:(int)flags &amp;#123;&amp;#10;    return [self openWithFlags:flags vfs:nil];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName &amp;#123;&amp;#10;#if SQLITE_VERSION_NUMBER &amp;#62;= 3005000&amp;#10;    if (_db) &amp;#123;&amp;#10;        return YES;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#27604;sqlite3_open&amp;#22810;&amp;#20256;&amp;#20837;&amp;#20102;flags&amp;#21644;vfsName&amp;#65292;vfsName&amp;#20026;&amp;#20351;&amp;#29992;&amp;#30340;VFS&amp;#27169;&amp;#22359;&amp;#30340;&amp;#21517;&amp;#31216;&amp;#10;    // sqlite3_open_v2&amp;#37324;zVfs&amp;#21442;&amp;#25968;&amp;#20801;&amp;#35768;&amp;#23458;&amp;#25143;&amp;#24212;&amp;#29992;&amp;#31243;&amp;#24207;&amp;#21629;&amp;#21517;&amp;#19968;&amp;#20010;&amp;#34394;&amp;#25311;&amp;#25991;&amp;#20214;&amp;#31995;&amp;#32479;&amp;#65288;Virtual File System&amp;#65289;&amp;#27169;&amp;#22359;&amp;#65292;&amp;#29992;&amp;#26469;&amp;#19982;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#36830;&amp;#25509;&amp;#12290;VFS&amp;#20316;&amp;#20026;SQlite library&amp;#21644;&amp;#24213;&amp;#23618;&amp;#23384;&amp;#20648;&amp;#31995;&amp;#32479;&amp;#65288;&amp;#22914;&amp;#26576;&amp;#20010;&amp;#25991;&amp;#20214;&amp;#31995;&amp;#32479;&amp;#65289;&amp;#20043;&amp;#38388;&amp;#30340;&amp;#19968;&amp;#20010;&amp;#25277;&amp;#35937;&amp;#23618;&amp;#65292;&amp;#36890;&amp;#24120;&amp;#23458;&amp;#25143;&amp;#24212;&amp;#29992;&amp;#31243;&amp;#24207;&amp;#21487;&amp;#20197;&amp;#31616;&amp;#21333;&amp;#30340;&amp;#32473;&amp;#35813;&amp;#21442;&amp;#25968;&amp;#20256;&amp;#36882;&amp;#19968;&amp;#20010;NULL&amp;#25351;&amp;#38024;&amp;#65292;&amp;#20197;&amp;#20351;&amp;#29992;&amp;#40664;&amp;#35748;&amp;#30340;VFS&amp;#27169;&amp;#22359;&amp;#12290;&amp;#10;    // sqlite3_open_v2&amp;#27604;sqlite3_open&amp;#21644;sqlite3_open16&amp;#24378;&amp;#22823;&amp;#22312;&amp;#23427;&amp;#21487;&amp;#20197;&amp;#25351;&amp;#23450;&amp;#36830;&amp;#25509;&amp;#26041;&amp;#24335;&amp;#10;    int err = sqlite3_open_v2([self sqlitePath], (sqlite3**)&amp;#38;_db, flags, [vfsName UTF8String]);&amp;#10;    if(err != SQLITE_OK) &amp;#123;&amp;#10;        NSLog(@&amp;#34;error opening!: %d&amp;#34;, err);&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    if (_maxBusyRetryTimeInterval &amp;#62; 0.0) &amp;#123;&amp;#10;        // set the handler&amp;#10;        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return YES;&amp;#10;#else&amp;#10;    NSLog(@&amp;#34;openWithFlags requires SQLite 3.5&amp;#34;);&amp;#10;    return NO;&amp;#10;#endif&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;open时会根据&lt;code&gt;_maxBusyRetryTimeInterval&lt;/code&gt;来设置繁忙处理&lt;code&gt;busy handler&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout &amp;#123;&amp;#10;    &amp;#10;    _maxBusyRetryTimeInterval = timeout;&amp;#10;    &amp;#10;    if (!_db) &amp;#123;&amp;#10;        return;&amp;#10;    &amp;#125;&amp;#10;    /*&amp;#10;     int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);&amp;#10;     &amp;#31532;&amp;#20108;&amp;#20010;&amp;#21442;&amp;#25968;&amp;#26159;&amp;#22238;&amp;#35843;&amp;#20989;&amp;#25968;&amp;#65288;busy handler&amp;#65289;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#35774;&amp;#32622;&amp;#20102;&amp;#22238;&amp;#35843;&amp;#20989;&amp;#25968;&amp;#65292;&amp;#37027;&amp;#23601;&amp;#38656;&amp;#35201;&amp;#35774;&amp;#32622;sqlite3_busy_handler&amp;#30340;&amp;#31532;&amp;#19977;&amp;#20010;&amp;#21442;&amp;#25968;&amp;#65292;&amp;#36825;&amp;#37324;&amp;#20256;&amp;#36882;&amp;#32473;&amp;#23427;&amp;#30340;&amp;#26159;&amp;#19968;&amp;#20010;void*&amp;#30340;&amp;#21442;&amp;#25968;&amp;#30340;&amp;#25335;&amp;#36125;&amp;#65307;&amp;#22914;&amp;#26524;&amp;#22238;&amp;#35843;&amp;#20989;&amp;#25968;&amp;#36820;&amp;#22238;&amp;#65296;&amp;#26102;&amp;#65292;&amp;#23558;&amp;#19981;&amp;#20877;&amp;#23581;&amp;#35797;&amp;#20877;&amp;#27425;&amp;#35775;&amp;#38382;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#32780;&amp;#36820;&amp;#22238;SQLITE_BUSY&amp;#25110;&amp;#32773;SQLITE_IOERR_BLOCKED&amp;#12290;&amp;#22914;&amp;#26524;&amp;#22238;&amp;#35843;&amp;#20989;&amp;#25968;&amp;#36820;&amp;#22238;&amp;#38750;&amp;#65296;,&amp;#23558;&amp;#20250;&amp;#19981;&amp;#26029;&amp;#23581;&amp;#35797;&amp;#25805;&amp;#20316;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#12290;&amp;#10;     &amp;#20063;&amp;#23601;&amp;#26159;&amp;#35828;&amp;#65292;&amp;#31243;&amp;#24207;&amp;#36816;&amp;#34892;&amp;#36807;&amp;#31243;&amp;#20013;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#26377;&amp;#20854;&amp;#20182;&amp;#36827;&amp;#31243;&amp;#25110;&amp;#32773;&amp;#32447;&amp;#31243;&amp;#22312;&amp;#35835;&amp;#20889;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#65292;&amp;#37027;&amp;#20040;sqlite3_busy_handler&amp;#20250;&amp;#19981;&amp;#26029;&amp;#35843;&amp;#29992;&amp;#22238;&amp;#35843;&amp;#20989;&amp;#25968;&amp;#65292;&amp;#30452;&amp;#21040;&amp;#20854;&amp;#20182;&amp;#36827;&amp;#31243;&amp;#25110;&amp;#32773;&amp;#32447;&amp;#31243;&amp;#37322;&amp;#25918;&amp;#38145;&amp;#12290;&amp;#33719;&amp;#24471;&amp;#38145;&amp;#20043;&amp;#21518;&amp;#65292;&amp;#19981;&amp;#20250;&amp;#20877;&amp;#35843;&amp;#29992;&amp;#22238;&amp;#35843;&amp;#20989;&amp;#25968;&amp;#65292;&amp;#20174;&amp;#32780;&amp;#21521;&amp;#19979;&amp;#25191;&amp;#34892;&amp;#65292;&amp;#36827;&amp;#34892;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#25805;&amp;#20316;&amp;#12290;&amp;#35813;&amp;#20989;&amp;#25968;&amp;#26159;&amp;#22312;&amp;#33719;&amp;#21462;&amp;#19981;&amp;#21040;&amp;#38145;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#65292;&amp;#20197;&amp;#25191;&amp;#34892;&amp;#22238;&amp;#35843;&amp;#20989;&amp;#25968;&amp;#30340;&amp;#27425;&amp;#25968;&amp;#26469;&amp;#36827;&amp;#34892;&amp;#24310;&amp;#36831;&amp;#65292;&amp;#31561;&amp;#24453;&amp;#20854;&amp;#20182;&amp;#36827;&amp;#31243;&amp;#25110;&amp;#32773;&amp;#32447;&amp;#31243;&amp;#25805;&amp;#20316;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#32467;&amp;#26463;&amp;#65292;&amp;#20174;&amp;#32780;&amp;#33719;&amp;#24471;&amp;#38145;&amp;#25805;&amp;#20316;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#12290;&amp;#10;     */&amp;#10;    if (timeout &amp;#62; 0) &amp;#123;&amp;#10;        // busy handler&amp;#35774;&amp;#32622;&amp;#20026;FMDBDatabaseBusyHandler&amp;#20989;&amp;#25968;&amp;#10;        sqlite3_busy_handler(_db, &amp;#38;FMDBDatabaseBusyHandler, (__bridge void *)(self));&amp;#10;    &amp;#125;&amp;#10;    else &amp;#123;&amp;#10;        // turn it off otherwise&amp;#10;        // &amp;#20851;&amp;#38381;busy handler&amp;#10;        sqlite3_busy_handler(_db, nil, nil);&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&amp;#10;&amp;#10;// &amp;#36825;&amp;#23601;&amp;#26159;&amp;#22238;&amp;#35843;&amp;#20989;&amp;#25968;&amp;#10;static int FMDBDatabaseBusyHandler(void *f, int count) &amp;#123;&amp;#10;    FMDatabase *self = (__bridge FMDatabase*)f;&amp;#10;    &amp;#10;    // &amp;#22914;&amp;#26524;&amp;#26159;&amp;#31532;&amp;#19968;&amp;#27425;&amp;#35843;&amp;#29992;&amp;#65292;&amp;#35843;&amp;#29992;[+ timeIntervalSinceReferenceDate]&amp;#26041;&amp;#27861;&amp;#65292;&amp;#33719;&amp;#21462;&amp;#24403;&amp;#21069;&amp;#26102;&amp;#38388;&amp;#19982;2001&amp;#24180;1&amp;#26376;1&amp;#26085;00:00:00 UTC&amp;#30340;&amp;#26102;&amp;#38388;&amp;#38388;&amp;#38548;&amp;#65292;&amp;#24182;&amp;#36171;&amp;#20540;&amp;#32473;startBusyRetryTime&amp;#10;    if (count == 0) &amp;#123;&amp;#10;        self-&amp;#62;_startBusyRetryTime = [NSDate timeIntervalSinceReferenceDate];&amp;#10;        // &amp;#36820;&amp;#22238;1&amp;#65292;&amp;#21017;&amp;#23558;&amp;#19981;&amp;#26029;&amp;#23581;&amp;#35797;&amp;#25805;&amp;#20316;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#10;        return 1;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#35745;&amp;#31639;&amp;#24403;&amp;#21069;&amp;#26102;&amp;#38388;&amp;#19982;2001&amp;#24180;1&amp;#26376;1&amp;#26085;00:00:00 UTC&amp;#30340;&amp;#26102;&amp;#38388;&amp;#38388;&amp;#38548;&amp;#21644;startBusyRetryTime&amp;#30340;&amp;#38388;&amp;#38548;&amp;#10;    NSTimeInterval delta = [NSDate timeIntervalSinceReferenceDate] - (self-&amp;#62;_startBusyRetryTime);&amp;#10;    // &amp;#22914;&amp;#26524;&amp;#38388;&amp;#38548;&amp;#26102;&amp;#38388;&amp;#23567;&amp;#20110;&amp;#26368;&amp;#22823;&amp;#30340;&amp;#37325;&amp;#35797;&amp;#38388;&amp;#38548;&amp;#26102;&amp;#38388;&amp;#10;    if (delta &amp;#60; [self maxBusyRetryTimeInterval]) &amp;#123;&amp;#10;        // &amp;#20135;&amp;#29983;&amp;#19968;&amp;#20010;&amp;#20174;50-99&amp;#30340;&amp;#38543;&amp;#26426;&amp;#25972;&amp;#25968;&amp;#20316;&amp;#20026;&amp;#38656;&amp;#35201;&amp;#25346;&amp;#36215;&amp;#27627;&amp;#31186;&amp;#26102;&amp;#38388;&amp;#10;        int requestedSleepInMillseconds = (int) arc4random_uniform(50) + 50;&amp;#10;        // &amp;#35843;&amp;#29992;sqlite3_sleep&amp;#36820;&amp;#22238;&amp;#23454;&amp;#38469;&amp;#25346;&amp;#36215;&amp;#27627;&amp;#31186;&amp;#26102;&amp;#38388;&amp;#65292;&amp;#22914;&amp;#26524;&amp;#19981;&amp;#19968;&amp;#33268;&amp;#65292;&amp;#21487;&amp;#33021;&amp;#26159;&amp;#22240;&amp;#20026;SQLite&amp;#26500;&amp;#24314;&amp;#26102;&amp;#27809;&amp;#26377;&amp;#23558;HAVE_USLEEP&amp;#35774;&amp;#32622;&amp;#20026;1&amp;#10;        int actualSleepInMilliseconds = sqlite3_sleep(requestedSleepInMillseconds);&amp;#10;        if (actualSleepInMilliseconds != requestedSleepInMillseconds) &amp;#123;&amp;#10;            NSLog(@&amp;#34;WARNING: Requested sleep of %i milliseconds, but SQLite returned %i. Maybe SQLite wasn&amp;#39;t built with HAVE_USLEEP=1?&amp;#34;, requestedSleepInMillseconds, actualSleepInMilliseconds);&amp;#10;        &amp;#125;&amp;#10;        return 1;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return 0;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (![db open]) &amp;#123;&amp;#10;&amp;#9;// do somthing        &amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u6267_u884C_u5355_u4E2A_u67E5_u8BE2SQL_u8BED_u53E5&quot;&gt;&lt;a href=&quot;#u6267_u884C_u5355_u4E2A_u67E5_u8BE2SQL_u8BED_u53E5&quot; class=&quot;headerlink&quot; title=&quot;执行单个查询SQL语句&quot;&gt;&lt;/a&gt;执行单个查询SQL语句&lt;/h4&gt;&lt;p&gt;主要执行的是&lt;code&gt;(FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args&lt;/code&gt;方法，&lt;code&gt;sql&lt;/code&gt;是执行SELECT语句，&lt;code&gt;dictionaryArgs&lt;/code&gt;是对应于&lt;code&gt;sql&lt;/code&gt;语句里&lt;code&gt;？&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;，在将&lt;code&gt;sql&lt;/code&gt;语句转换成&lt;code&gt;prepared&lt;/code&gt;语句时，这里先从缓存中获取，没有的话再去调用&lt;code&gt;sqlite3_prepare_v2&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &amp;#123;&amp;#10;    // &amp;#26816;&amp;#26597;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#26159;&amp;#21542;&amp;#23384;&amp;#22312;&amp;#10;    if (![self databaseExists]) &amp;#123;&amp;#10;        return 0x00;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#26816;&amp;#26597;&amp;#26159;&amp;#21542;&amp;#27491;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#25805;&amp;#20316;&amp;#10;    if (_isExecutingStatement) &amp;#123;&amp;#10;        [self warnInUse];&amp;#10;        return 0x00;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    _isExecutingStatement = YES;&amp;#10;    &amp;#10;    int rc                  = 0x00;&amp;#10;    sqlite3_stmt *pStmt     = 0x00;&amp;#10;    FMStatement *statement  = 0x00;&amp;#10;    FMResultSet *rs         = 0x00;&amp;#10;    &amp;#10;    if (_traceExecution &amp;#38;&amp;#38; sql) &amp;#123;&amp;#10;        NSLog(@&amp;#34;%@ executeQuery: %@&amp;#34;, self, sql);&amp;#10;    &amp;#125;&amp;#10;    // &amp;#23558;sql&amp;#35821;&amp;#21477;&amp;#36716;&amp;#25442;&amp;#25104;prepared&amp;#35821;&amp;#21477;&amp;#10;    // &amp;#30001;&amp;#20110;&amp;#20351;&amp;#29992;sqlite3_prepare_v2&amp;#26469;&amp;#29983;&amp;#25104;sql&amp;#23545;&amp;#24212;&amp;#30340;prepared&amp;#35821;&amp;#21477;&amp;#20195;&amp;#20215;&amp;#24456;&amp;#22823;&amp;#10;    // &amp;#25152;&amp;#20197;&amp;#20351;&amp;#29992;&amp;#32531;&amp;#23384;&amp;#26426;&amp;#21046;&amp;#26469;&amp;#20943;&amp;#23569;sqlite3_prepare_v2&amp;#30340;&amp;#20351;&amp;#29992;&amp;#10;    if (_shouldCacheStatements) &amp;#123;&amp;#10;        // &amp;#26681;&amp;#25454;sql&amp;#33719;&amp;#21462;&amp;#21040;&amp;#32531;&amp;#23384;&amp;#20013;&amp;#30340;prepared&amp;#35821;&amp;#21477;&amp;#10;        statement = [self cachedStatementForQuery:sql];&amp;#10;        pStmt = statement ? [statement statement] : 0x00;&amp;#10;        // &amp;#37325;&amp;#32622;prepared&amp;#35821;&amp;#21477;&amp;#10;        [statement reset];&amp;#10;    &amp;#125;&amp;#10;    // &amp;#22914;&amp;#26524;&amp;#32531;&amp;#23384;&amp;#20013;&amp;#27809;&amp;#26377;sql&amp;#23545;&amp;#24212;&amp;#30340;prepared&amp;#35821;&amp;#21477;&amp;#65292;&amp;#37027;&amp;#20040;&amp;#38656;&amp;#35201;&amp;#29992;sqlite3_prepare_v2&amp;#29983;&amp;#25104;&amp;#23545;&amp;#24212;&amp;#30340;prepared&amp;#35821;&amp;#21477;&amp;#10;    if (!pStmt) &amp;#123;&amp;#10;        &amp;#10;        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;#38;pStmt, 0);&amp;#10;        &amp;#10;        // &amp;#22914;&amp;#26524;&amp;#29983;&amp;#25104;&amp;#22833;&amp;#36133;&amp;#65292;&amp;#21017;&amp;#25171;&amp;#21360;&amp;#38169;&amp;#35823;&amp;#26085;&amp;#24535;&amp;#10;        if (SQLITE_OK != rc) &amp;#123;&amp;#10;            if (_logsErrors) &amp;#123;&amp;#10;                NSLog(@&amp;#34;DB Error: %d \&amp;#34;%@\&amp;#34;&amp;#34;, [self lastErrorCode], [self lastErrorMessage]);&amp;#10;                NSLog(@&amp;#34;DB Query: %@&amp;#34;, sql);&amp;#10;                NSLog(@&amp;#34;DB Path: %@&amp;#34;, _databasePath);&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            if (_crashOnErrors) &amp;#123;&amp;#10;                NSAssert(false, @&amp;#34;DB Error: %d \&amp;#34;%@\&amp;#34;&amp;#34;, [self lastErrorCode], [self lastErrorMessage]);&amp;#10;                // &amp;#20572;&amp;#27490;&amp;#31243;&amp;#24207;&amp;#10;                abort();&amp;#10;            &amp;#125;&amp;#10;            // &amp;#37322;&amp;#25918;&amp;#25152;&amp;#26377;&amp;#20869;&amp;#37096;&amp;#36164;&amp;#28304;&amp;#21644;FMStatement&amp;#10;            sqlite3_finalize(pStmt);&amp;#10;            _isExecutingStatement = NO;&amp;#10;            return nil;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    id obj;&amp;#10;    int idx = 0;&amp;#10;    // sqlite3_bind_parameter_count &amp;#36820;&amp;#22238;SQL&amp;#35821;&amp;#21477;&amp;#21442;&amp;#25968;&amp;#30340;&amp;#25968;&amp;#37327;&amp;#10;    int queryCount = sqlite3_bind_parameter_count(pStmt); // pointed out by Dominic Yu (thanks!)&amp;#10;    &amp;#10;    // If dictionaryArgs is passed in, that means we are using sqlite&amp;#39;s named parameter support&amp;#10;    if (dictionaryArgs) &amp;#123;&amp;#10;        &amp;#10;        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &amp;#123;&amp;#10;            &amp;#10;            // Prefix the key with a colon.&amp;#10;            NSString *parameterName = [[NSString alloc] initWithFormat:@&amp;#34;:%@&amp;#34;, dictionaryKey];&amp;#10;            &amp;#10;            if (_traceExecution) &amp;#123;&amp;#10;                NSLog(@&amp;#34;%@ = %@&amp;#34;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            // Get the index for the parameter name.&amp;#10;            // &amp;#36890;&amp;#36807;&amp;#20256;&amp;#20837;&amp;#21442;&amp;#25968;&amp;#21517;&amp;#26469;&amp;#33719;&amp;#21462;&amp;#35813;&amp;#21442;&amp;#25968;&amp;#30340;&amp;#32034;&amp;#24341;&amp;#10;            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);&amp;#10;            &amp;#10;            FMDBRelease(parameterName);&amp;#10;            // &amp;#22914;&amp;#26524;&amp;#32034;&amp;#24341;&amp;#22823;&amp;#20110;0&amp;#10;            if (namedIdx &amp;#62; 0) &amp;#123;&amp;#10;                // Standard binding from here.&amp;#10;                // &amp;#22312;prepared&amp;#35821;&amp;#21477;&amp;#37324;&amp;#23558;&amp;#20540;&amp;#32465;&amp;#23450;&amp;#21040;&amp;#32034;&amp;#24341;&amp;#20301;&amp;#32622;&amp;#10;                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];&amp;#10;                // increment the binding count, so our check below works out&amp;#10;                // &amp;#32465;&amp;#23450;&amp;#25968;&amp;#37327;&amp;#21152;&amp;#19968;&amp;#10;                idx++;&amp;#10;            &amp;#125;&amp;#10;            else &amp;#123;&amp;#10;                NSLog(@&amp;#34;Could not find index for %@&amp;#34;, dictionaryKey);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else &amp;#123;&amp;#10;        &amp;#10;        while (idx &amp;#60; queryCount) &amp;#123;&amp;#10;            // &amp;#24403;&amp;#35843;&amp;#29992;&amp;#19979;&amp;#38754;&amp;#19977;&amp;#20010;&amp;#26041;&amp;#27861;&amp;#26102;&amp;#10;            // - (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...&amp;#10;            // - (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments&amp;#10;            // - (FMResultSet *)executeQuery:(NSString *)sql values:(NSArray *)values error:(NSError * __autoreleasing *)error&amp;#10;            // &amp;#20540;&amp;#26159;&amp;#25918;&amp;#22312;NSArray&amp;#37324;&amp;#38754;&amp;#65292;&amp;#24490;&amp;#29615;&amp;#21462;&amp;#20986;&amp;#26469;&amp;#32465;&amp;#23450;&amp;#10;            if (arrayArgs &amp;#38;&amp;#38; idx &amp;#60; (int)[arrayArgs count]) &amp;#123;&amp;#10;                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];&amp;#10;            &amp;#125;&amp;#10;            // &amp;#24403;&amp;#35843;&amp;#29992;&amp;#19979;&amp;#38754;&amp;#20004;&amp;#20010;&amp;#26041;&amp;#27861;&amp;#26102;&amp;#10;            // - (FMResultSet *)executeQuery:(NSString*)sql, ...&amp;#10;            // - (FMResultSet *)executeQuery:(NSString*)sql withVAList:(va_list)args&amp;#10;            // &amp;#20540;&amp;#26159;&amp;#25918;&amp;#22312;va_list&amp;#37324;&amp;#38754;&amp;#65292;&amp;#24490;&amp;#29615;&amp;#21462;&amp;#20986;&amp;#26469;&amp;#32465;&amp;#23450;&amp;#10;            else if (args) &amp;#123;&amp;#10;                obj = va_arg(args, id);&amp;#10;            &amp;#125;&amp;#10;            else &amp;#123;&amp;#10;                //We ran out of arguments&amp;#10;                break;&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            if (_traceExecution) &amp;#123;&amp;#10;                if ([obj isKindOfClass:[NSData class]]) &amp;#123;&amp;#10;                    NSLog(@&amp;#34;data: %ld bytes&amp;#34;, (unsigned long)[(NSData*)obj length]);&amp;#10;                &amp;#125;&amp;#10;                else &amp;#123;&amp;#10;                    NSLog(@&amp;#34;obj: %@&amp;#34;, obj);&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            idx++;&amp;#10;            // &amp;#32465;&amp;#23450;&amp;#21442;&amp;#25968;&amp;#10;            [self bindObject:obj toColumn:idx inStatement:pStmt];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#22914;&amp;#26524;&amp;#32465;&amp;#23450;&amp;#25968;&amp;#37327;&amp;#21644;&amp;#21442;&amp;#25968;&amp;#25968;&amp;#37327;&amp;#19981;&amp;#19968;&amp;#33268;&amp;#65292;&amp;#25171;&amp;#21360;&amp;#38169;&amp;#35823;&amp;#65292;&amp;#24182;&amp;#37322;&amp;#25918;&amp;#36164;&amp;#28304;&amp;#10;    if (idx != queryCount) &amp;#123;&amp;#10;        NSLog(@&amp;#34;Error: the bind count is not correct for the # of variables (executeQuery)&amp;#34;);&amp;#10;        sqlite3_finalize(pStmt);&amp;#10;        _isExecutingStatement = NO;&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    FMDBRetain(statement); // to balance the release below&amp;#10;    &amp;#10;    // &amp;#22914;&amp;#26524;statement&amp;#19981;&amp;#20026;&amp;#31354;&amp;#65292;&amp;#21017;&amp;#32531;&amp;#23384;&amp;#10;    if (!statement) &amp;#123;&amp;#10;        statement = [[FMStatement alloc] init];&amp;#10;        [statement setStatement:pStmt];&amp;#10;        &amp;#10;        if (_shouldCacheStatements &amp;#38;&amp;#38; sql) &amp;#123;&amp;#10;            // &amp;#20197;sql&amp;#20316;&amp;#20026;key&amp;#26469;&amp;#32531;&amp;#23384;statement&amp;#10;            [self setCachedStatement:statement forQuery:sql];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    // the statement gets closed in rs&amp;#39;s dealloc or [rs close];&amp;#10;    // &amp;#26681;&amp;#25454;statement&amp;#21644;FMDataBase&amp;#23545;&amp;#35937;&amp;#26469;&amp;#21021;&amp;#22987;&amp;#21270;FMResultSet&amp;#23545;&amp;#35937;&amp;#10;    rs = [FMResultSet resultSetWithStatement:statement usingParentDatabase:self];&amp;#10;    [rs setQuery:sql];&amp;#10;    &amp;#10;    // &amp;#23558;FMResultSet&amp;#23545;&amp;#35937;&amp;#21152;&amp;#21040;_openResultSets&amp;#37324;&amp;#10;    NSValue *openResultSet = [NSValue valueWithNonretainedObject:rs];&amp;#10;    [_openResultSets addObject:openResultSet];&amp;#10;    // useCount+1&amp;#10;    [statement setUseCount:[statement useCount] + 1];&amp;#10;    &amp;#10;    FMDBRelease(statement);&amp;#10;    // &amp;#35774;&amp;#32622;_isExecutingStatement&amp;#25805;&amp;#20316;&amp;#32467;&amp;#26463;&amp;#10;    _isExecutingStatement = NO;&amp;#10;    &amp;#10;    return rs;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rs = [newDb executeQuery:@&amp;#34;select rowid,* from test where a = ?&amp;#34;, @&amp;#34;hi&amp;#39;&amp;#34;];&amp;#10;&amp;#10;rs = [db executeQueryWithFormat:@&amp;#34;select * from t5 where a = %s and a = %@ and b = %d&amp;#34;, &amp;#34;text&amp;#34;, @&amp;#34;text&amp;#34;, 42];&amp;#10;&amp;#10;rs = [db executeQuery:@&amp;#34;select * from testOneHundredTwelvePointTwo where b &amp;#62; ?&amp;#34; withArgumentsInArray:[NSArray arrayWithObject:[NSNumber numberWithInteger:1]]];&amp;#10;&amp;#10;rs = [db executeQuery:@&amp;#34;select * from namedparamcounttest where a = :a&amp;#34; withParameterDictionary:dictionaryArgs];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u6267_u884C_u5355_u4E2A_u66F4_u65B0SQL_u8BED_u53E5&quot;&gt;&lt;a href=&quot;#u6267_u884C_u5355_u4E2A_u66F4_u65B0SQL_u8BED_u53E5&quot; class=&quot;headerlink&quot; title=&quot;执行单个更新SQL语句&quot;&gt;&lt;/a&gt;执行单个更新SQL语句&lt;/h4&gt;&lt;p&gt;&lt;code&gt;- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args&lt;/code&gt;是主要函数，但是里面大部分处理和&lt;code&gt;- executeQuery: withArgumentsInArray: orDictionary: orVAList:&lt;/code&gt;处理类似，不同处我已经注释说明，可以直接看注释部分代码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)executeUpdate:(NSString*)sql error:(NSError**)outErr withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &amp;#123;&amp;#10;    &amp;#10;    if (![self databaseExists]) &amp;#123;&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    if (_isExecutingStatement) &amp;#123;&amp;#10;        [self warnInUse];&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    _isExecutingStatement = YES;&amp;#10;    &amp;#10;    int rc                   = 0x00;&amp;#10;    sqlite3_stmt *pStmt      = 0x00;&amp;#10;    FMStatement *cachedStmt  = 0x00;&amp;#10;    &amp;#10;    if (_traceExecution &amp;#38;&amp;#38; sql) &amp;#123;&amp;#10;        NSLog(@&amp;#34;%@ executeUpdate: %@&amp;#34;, self, sql);&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    if (_shouldCacheStatements) &amp;#123;&amp;#10;        cachedStmt = [self cachedStatementForQuery:sql];&amp;#10;        pStmt = cachedStmt ? [cachedStmt statement] : 0x00;&amp;#10;        [cachedStmt reset];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    if (!pStmt) &amp;#123;&amp;#10;        rc = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;#38;pStmt, 0);&amp;#10;        &amp;#10;        if (SQLITE_OK != rc) &amp;#123;&amp;#10;            if (_logsErrors) &amp;#123;&amp;#10;                NSLog(@&amp;#34;DB Error: %d \&amp;#34;%@\&amp;#34;&amp;#34;, [self lastErrorCode], [self lastErrorMessage]);&amp;#10;                NSLog(@&amp;#34;DB Query: %@&amp;#34;, sql);&amp;#10;                NSLog(@&amp;#34;DB Path: %@&amp;#34;, _databasePath);&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            if (_crashOnErrors) &amp;#123;&amp;#10;                NSAssert(false, @&amp;#34;DB Error: %d \&amp;#34;%@\&amp;#34;&amp;#34;, [self lastErrorCode], [self lastErrorMessage]);&amp;#10;                abort();&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            if (outErr) &amp;#123;&amp;#10;                *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            sqlite3_finalize(pStmt);&amp;#10;            &amp;#10;            _isExecutingStatement = NO;&amp;#10;            return NO;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    id obj;&amp;#10;    int idx = 0;&amp;#10;    int queryCount = sqlite3_bind_parameter_count(pStmt);&amp;#10;    &amp;#10;    // If dictionaryArgs is passed in, that means we are using sqlite&amp;#39;s named parameter support&amp;#10;    if (dictionaryArgs) &amp;#123;&amp;#10;        &amp;#10;        for (NSString *dictionaryKey in [dictionaryArgs allKeys]) &amp;#123;&amp;#10;            &amp;#10;            // Prefix the key with a colon.&amp;#10;            NSString *parameterName = [[NSString alloc] initWithFormat:@&amp;#34;:%@&amp;#34;, dictionaryKey];&amp;#10;            &amp;#10;            if (_traceExecution) &amp;#123;&amp;#10;                NSLog(@&amp;#34;%@ = %@&amp;#34;, parameterName, [dictionaryArgs objectForKey:dictionaryKey]);&amp;#10;            &amp;#125;&amp;#10;            // Get the index for the parameter name.&amp;#10;            int namedIdx = sqlite3_bind_parameter_index(pStmt, [parameterName UTF8String]);&amp;#10;            &amp;#10;            FMDBRelease(parameterName);&amp;#10;            &amp;#10;            if (namedIdx &amp;#62; 0) &amp;#123;&amp;#10;                // Standard binding from here.&amp;#10;                [self bindObject:[dictionaryArgs objectForKey:dictionaryKey] toColumn:namedIdx inStatement:pStmt];&amp;#10;                &amp;#10;                // increment the binding count, so our check below works out&amp;#10;                idx++;&amp;#10;            &amp;#125;&amp;#10;            else &amp;#123;&amp;#10;                // &amp;#30001;&amp;#20110;&amp;#22810;&amp;#20102;outErr&amp;#65292;&amp;#25152;&amp;#20197;&amp;#32465;&amp;#23450;&amp;#26102;&amp;#20986;&amp;#38169;&amp;#38656;&amp;#35201;&amp;#23558;error&amp;#25243;&amp;#20986;&amp;#10;                NSString *message = [NSString stringWithFormat:@&amp;#34;Could not find index for %@&amp;#34;, dictionaryKey];&amp;#10;                &amp;#10;                if (_logsErrors) &amp;#123;&amp;#10;                    NSLog(@&amp;#34;%@&amp;#34;, message);&amp;#10;                &amp;#125;&amp;#10;                if (outErr) &amp;#123;&amp;#10;                    *outErr = [self errorWithMessage:message];&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else &amp;#123;&amp;#10;        &amp;#10;        while (idx &amp;#60; queryCount) &amp;#123;&amp;#10;            &amp;#10;            if (arrayArgs &amp;#38;&amp;#38; idx &amp;#60; (int)[arrayArgs count]) &amp;#123;&amp;#10;                obj = [arrayArgs objectAtIndex:(NSUInteger)idx];&amp;#10;            &amp;#125;&amp;#10;            else if (args) &amp;#123;&amp;#10;                obj = va_arg(args, id);&amp;#10;            &amp;#125;&amp;#10;            else &amp;#123;&amp;#10;                //We ran out of arguments&amp;#10;                break;&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            if (_traceExecution) &amp;#123;&amp;#10;                if ([obj isKindOfClass:[NSData class]]) &amp;#123;&amp;#10;                    NSLog(@&amp;#34;data: %ld bytes&amp;#34;, (unsigned long)[(NSData*)obj length]);&amp;#10;                &amp;#125;&amp;#10;                else &amp;#123;&amp;#10;                    NSLog(@&amp;#34;obj: %@&amp;#34;, obj);&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            idx++;&amp;#10;            &amp;#10;            [self bindObject:obj toColumn:idx inStatement:pStmt];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    &amp;#10;    if (idx != queryCount) &amp;#123;&amp;#10;        // &amp;#21516;&amp;#26679;&amp;#20063;&amp;#26159;&amp;#32452;&amp;#35013;error&amp;#25243;&amp;#20986;&amp;#10;        NSString *message = [NSString stringWithFormat:@&amp;#34;Error: the bind count (%d) is not correct for the # of variables in the query (%d) (%@) (executeUpdate)&amp;#34;, idx, queryCount, sql];&amp;#10;        if (_logsErrors) &amp;#123;&amp;#10;            NSLog(@&amp;#34;%@&amp;#34;, message);&amp;#10;        &amp;#125;&amp;#10;        if (outErr) &amp;#123;&amp;#10;            *outErr = [self errorWithMessage:message];&amp;#10;        &amp;#125;&amp;#10;        &amp;#10;        sqlite3_finalize(pStmt);&amp;#10;        _isExecutingStatement = NO;&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    /* Call sqlite3_step() to run the virtual machine. Since the SQL being&amp;#10;     ** executed is not a SELECT statement, we assume no data will be returned.&amp;#10;     */&amp;#10;    // sqlite3_prepare&amp;#20989;&amp;#25968;&amp;#23558;SQL&amp;#21629;&amp;#20196;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#35299;&amp;#26512;&amp;#24182;&amp;#36716;&amp;#25442;&amp;#20026;&amp;#19968;&amp;#31995;&amp;#21015;&amp;#30340;&amp;#21629;&amp;#20196;&amp;#23383;&amp;#33410;&amp;#30721;&amp;#65292;&amp;#36825;&amp;#20123;&amp;#23383;&amp;#33410;&amp;#30721;&amp;#26368;&amp;#32456;&amp;#34987;&amp;#20256;&amp;#36865;&amp;#21040;SQlite3&amp;#30340;&amp;#34394;&amp;#25311;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#24341;&amp;#25806;&amp;#65288;VDBE: Virtual Database Engine&amp;#65289;&amp;#20013;&amp;#25191;&amp;#34892;&amp;#65292;&amp;#23436;&amp;#25104;&amp;#36825;&amp;#39033;&amp;#24037;&amp;#20316;&amp;#30340;&amp;#26159;sqlite3_step&amp;#20989;&amp;#25968;&amp;#12290;&amp;#27604;&amp;#22914;&amp;#19968;&amp;#20010;SELECT&amp;#26597;&amp;#35810;&amp;#25805;&amp;#20316;&amp;#65292;sqlite3_step&amp;#20989;&amp;#25968;&amp;#30340;&amp;#27599;&amp;#27425;&amp;#35843;&amp;#29992;&amp;#37117;&amp;#20250;&amp;#36820;&amp;#22238;&amp;#32467;&amp;#26524;&amp;#38598;&amp;#20013;&amp;#30340;&amp;#20854;&amp;#20013;&amp;#19968;&amp;#34892;&amp;#65292;&amp;#30452;&amp;#21040;&amp;#20877;&amp;#27809;&amp;#26377;&amp;#26377;&amp;#25928;&amp;#25968;&amp;#25454;&amp;#34892;&amp;#20102;&amp;#12290;&amp;#27599;&amp;#27425;&amp;#35843;&amp;#29992;sqlite3_step&amp;#20989;&amp;#25968;&amp;#22914;&amp;#26524;&amp;#36820;&amp;#22238;SQLITE_ROW&amp;#65292;&amp;#20195;&amp;#34920;&amp;#33719;&amp;#24471;&amp;#20102;&amp;#26377;&amp;#25928;&amp;#25968;&amp;#25454;&amp;#34892;&amp;#65292;&amp;#21487;&amp;#20197;&amp;#36890;&amp;#36807;sqlite3_column&amp;#20989;&amp;#25968;&amp;#25552;&amp;#21462;&amp;#26576;&amp;#21015;&amp;#30340;&amp;#20540;&amp;#12290;&amp;#22914;&amp;#26524;&amp;#35843;&amp;#29992;sqlite3_step&amp;#20989;&amp;#25968;&amp;#36820;&amp;#22238;SQLITE_DONE&amp;#65292;&amp;#21017;&amp;#20195;&amp;#34920;prepared&amp;#35821;&amp;#21477;&amp;#24050;&amp;#32463;&amp;#25191;&amp;#34892;&amp;#21040;&amp;#32456;&amp;#28857;&amp;#20102;&amp;#65292;&amp;#27809;&amp;#26377;&amp;#26377;&amp;#25928;&amp;#25968;&amp;#25454;&amp;#20102;&amp;#12290;&amp;#24456;&amp;#22810;&amp;#21629;&amp;#20196;&amp;#31532;&amp;#19968;&amp;#27425;&amp;#35843;&amp;#29992;sqlite3_step&amp;#20989;&amp;#25968;&amp;#23601;&amp;#20250;&amp;#36820;&amp;#22238;SQLITE_DONE&amp;#65292;&amp;#22240;&amp;#20026;&amp;#36825;&amp;#20123;SQL&amp;#21629;&amp;#20196;&amp;#19981;&amp;#20250;&amp;#36820;&amp;#22238;&amp;#25968;&amp;#25454;&amp;#12290;&amp;#23545;&amp;#20110;INSERT&amp;#65292;UPDATE&amp;#65292;DELETE&amp;#21629;&amp;#20196;&amp;#65292;&amp;#20250;&amp;#36820;&amp;#22238;&amp;#23427;&amp;#20204;&amp;#25152;&amp;#20462;&amp;#25913;&amp;#30340;&amp;#34892;&amp;#21495;&amp;#8212;&amp;#8212;&amp;#19968;&amp;#20010;&amp;#21333;&amp;#34892;&amp;#21333;&amp;#21015;&amp;#30340;&amp;#20540;&amp;#12290;&amp;#10;    /**&amp;#10;     SQLITE_BUSY &amp;#25968;&amp;#25454;&amp;#24211;&amp;#25991;&amp;#20214;&amp;#26377;&amp;#38145;&amp;#10;     SQLITE_LOCKED &amp;#25968;&amp;#25454;&amp;#24211;&amp;#20013;&amp;#30340;&amp;#26576;&amp;#24352;&amp;#34920;&amp;#26377;&amp;#38145;&amp;#10;     SQLITE_DONE sqlite3_step()&amp;#25191;&amp;#34892;&amp;#23436;&amp;#27605;&amp;#10;     SQLITE_ROW sqlite3_step()&amp;#33719;&amp;#21462;&amp;#21040;&amp;#19979;&amp;#19968;&amp;#34892;&amp;#25968;&amp;#25454;&amp;#10;     SQLITE_ERROR &amp;#19968;&amp;#33324;&amp;#29992;&amp;#20110;&amp;#27809;&amp;#26377;&amp;#29305;&amp;#21035;&amp;#25351;&amp;#23450;&amp;#38169;&amp;#35823;&amp;#30721;&amp;#30340;&amp;#38169;&amp;#35823;&amp;#65292;&amp;#23601;&amp;#26159;&amp;#35828;&amp;#20989;&amp;#25968;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#36807;&amp;#31243;&amp;#20013;&amp;#21457;&amp;#29983;&amp;#20102;&amp;#38169;&amp;#35823;&amp;#65292;&amp;#20294;&amp;#26080;&amp;#27861;&amp;#30693;&amp;#36947;&amp;#38169;&amp;#35823;&amp;#21457;&amp;#29983;&amp;#30340;&amp;#21407;&amp;#22240;&amp;#12290;&amp;#10;     SQLITE_MISUSE &amp;#27809;&amp;#26377;&amp;#27491;&amp;#30830;&amp;#20351;&amp;#29992;SQLite&amp;#25509;&amp;#21475;&amp;#65292;&amp;#27604;&amp;#22914;&amp;#19968;&amp;#26465;&amp;#35821;&amp;#21477;&amp;#22312;sqlite3_step&amp;#20989;&amp;#25968;&amp;#25191;&amp;#34892;&amp;#20043;&amp;#21518;&amp;#65292;&amp;#27809;&amp;#26377;&amp;#34987;&amp;#37325;&amp;#32622;&amp;#20043;&amp;#21069;&amp;#65292;&amp;#20877;&amp;#27425;&amp;#32473;&amp;#20854;&amp;#32465;&amp;#23450;&amp;#21442;&amp;#25968;&amp;#65292;&amp;#36825;&amp;#26102;bind&amp;#20989;&amp;#25968;&amp;#23601;&amp;#20250;&amp;#36820;&amp;#22238;SQLITE_MISUSE&amp;#12290;&amp;#10;     **/&amp;#10;    rc      = sqlite3_step(pStmt);&amp;#10;    &amp;#10;    if (SQLITE_DONE == rc) &amp;#123;&amp;#10;        // all is well, let&amp;#39;s return.&amp;#10;    &amp;#125;&amp;#10;    // sql&amp;#25805;&amp;#20316;&amp;#34987;sqlite3_interrupt()&amp;#20989;&amp;#25968;&amp;#32456;&amp;#27490;&amp;#10;    else if (SQLITE_INTERRUPT == rc) &amp;#123;&amp;#10;        if (_logsErrors) &amp;#123;&amp;#10;            NSLog(@&amp;#34;Error calling sqlite3_step. Query was interrupted (%d: %s) SQLITE_INTERRUPT&amp;#34;, rc, sqlite3_errmsg(_db));&amp;#10;            NSLog(@&amp;#34;DB Query: %@&amp;#34;, sql);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else if (rc == SQLITE_ROW) &amp;#123;&amp;#10;        NSString *message = [NSString stringWithFormat:@&amp;#34;A executeUpdate is being called with a query string &amp;#39;%@&amp;#39;&amp;#34;, sql];&amp;#10;        if (_logsErrors) &amp;#123;&amp;#10;            NSLog(@&amp;#34;%@&amp;#34;, message);&amp;#10;            NSLog(@&amp;#34;DB Query: %@&amp;#34;, sql);&amp;#10;        &amp;#125;&amp;#10;        if (outErr) &amp;#123;&amp;#10;            *outErr = [self errorWithMessage:message];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else &amp;#123;&amp;#10;        if (outErr) &amp;#123;&amp;#10;            *outErr = [self errorWithMessage:[NSString stringWithUTF8String:sqlite3_errmsg(_db)]];&amp;#10;        &amp;#125;&amp;#10;        &amp;#10;        if (SQLITE_ERROR == rc) &amp;#123;&amp;#10;            if (_logsErrors) &amp;#123;&amp;#10;                NSLog(@&amp;#34;Error calling sqlite3_step (%d: %s) SQLITE_ERROR&amp;#34;, rc, sqlite3_errmsg(_db));&amp;#10;                NSLog(@&amp;#34;DB Query: %@&amp;#34;, sql);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        else if (SQLITE_MISUSE == rc) &amp;#123;&amp;#10;            // uh oh.&amp;#10;            if (_logsErrors) &amp;#123;&amp;#10;                NSLog(@&amp;#34;Error calling sqlite3_step (%d: %s) SQLITE_MISUSE&amp;#34;, rc, sqlite3_errmsg(_db));&amp;#10;                NSLog(@&amp;#34;DB Query: %@&amp;#34;, sql);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        else &amp;#123;&amp;#10;            // wtf?&amp;#10;            if (_logsErrors) &amp;#123;&amp;#10;                NSLog(@&amp;#34;Unknown error calling sqlite3_step (%d: %s) eu&amp;#34;, rc, sqlite3_errmsg(_db));&amp;#10;                NSLog(@&amp;#34;DB Query: %@&amp;#34;, sql);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    if (_shouldCacheStatements &amp;#38;&amp;#38; !cachedStmt) &amp;#123;&amp;#10;        cachedStmt = [[FMStatement alloc] init];&amp;#10;        &amp;#10;        [cachedStmt setStatement:pStmt];&amp;#10;        &amp;#10;        [self setCachedStatement:cachedStmt forQuery:sql];&amp;#10;        &amp;#10;        FMDBRelease(cachedStmt);&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    int closeErrorCode;&amp;#10;    &amp;#10;    if (cachedStmt) &amp;#123;&amp;#10;        [cachedStmt setUseCount:[cachedStmt useCount] + 1];&amp;#10;        closeErrorCode = sqlite3_reset(pStmt);&amp;#10;    &amp;#125;&amp;#10;    else &amp;#123;&amp;#10;        /* Finalize the virtual machine. This releases all memory and other&amp;#10;         ** resources allocated by the sqlite3_prepare() call above.&amp;#10;         */&amp;#10;        closeErrorCode = sqlite3_finalize(pStmt);&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    if (closeErrorCode != SQLITE_OK) &amp;#123;&amp;#10;        if (_logsErrors) &amp;#123;&amp;#10;            NSLog(@&amp;#34;Unknown error finalizing or resetting statement (%d: %s)&amp;#34;, closeErrorCode, sqlite3_errmsg(_db));&amp;#10;            NSLog(@&amp;#34;DB Query: %@&amp;#34;, sql);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    _isExecutingStatement = NO;&amp;#10;    return (rc == SQLITE_DONE || rc == SQLITE_OK);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[db executeUpdate:@&amp;#34;insert into t5 values (?, ?, ?, ?, ?)&amp;#34; withErrorAndBindings:&amp;#38;err, @&amp;#34;text&amp;#34;, [NSNumber numberWithInt:42], @&amp;#34;BLOB&amp;#34;, @&amp;#34;d&amp;#34;, [NSNumber numberWithInt:0]];&amp;#10;&amp;#10;[dbB executeUpdate:@&amp;#34;create table attached (a text)&amp;#34;];&amp;#10;&amp;#10;[dbB executeUpdate:@&amp;#34;insert into attached values (?)&amp;#34;, @&amp;#34;test&amp;#34;];&amp;#10;&amp;#10;[db executeUpdateWithFormat:@&amp;#34;insert into t55 values (%c, %hi, %g)&amp;#34;, &amp;#39;a&amp;#39;, testShort, testFloat];&amp;#10;&amp;#10;[db executeUpdate:@&amp;#34;insert into testOneHundredTwelvePointTwo values (?, ?)&amp;#34; withArgumentsInArray:[NSArray arrayWithObjects:@&amp;#34;one&amp;#34;, [NSNumber numberWithInteger:2], nil]];&amp;#10;&amp;#10;[db executeUpdate:@&amp;#34;insert into namedparamtest values (:a, :b, :c, :d)&amp;#34; withParameterDictionary:dictionaryArgs];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u6267_u884C_u591A_u4E2ASQL_u8BED_u53E5&quot;&gt;&lt;a href=&quot;#u6267_u884C_u591A_u4E2ASQL_u8BED_u53E5&quot; class=&quot;headerlink&quot; title=&quot;执行多个SQL语句&quot;&gt;&lt;/a&gt;执行多个SQL语句&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#20351;&amp;#29992;executeStatements:&amp;#20989;&amp;#25968;&amp;#21487;&amp;#20197;&amp;#23558;&amp;#22810;&amp;#20010;SQL&amp;#25191;&amp;#34892;&amp;#35821;&amp;#21477;&amp;#20889;&amp;#22312;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#20013;&amp;#65292;&amp;#24182;&amp;#25191;&amp;#34892;&amp;#10;- (BOOL)executeStatements:(NSString *)sql &amp;#123;&amp;#10;    return [self executeStatements:sql withResultBlock:nil];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (BOOL)executeStatements:(NSString *)sql withResultBlock:(FMDBExecuteStatementsCallbackBlock)block &amp;#123;&amp;#10;    &amp;#10;    int rc;&amp;#10;    char *errmsg = nil;&amp;#10;    /*&amp;#10;     sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg)&amp;#10;     &amp;#10;     &amp;#35813;&amp;#20363;&amp;#31243;&amp;#25552;&amp;#20379;&amp;#20102;&amp;#19968;&amp;#20010;&amp;#25191;&amp;#34892; SQL &amp;#21629;&amp;#20196;&amp;#30340;&amp;#24555;&amp;#25463;&amp;#26041;&amp;#24335;&amp;#65292;SQL &amp;#21629;&amp;#20196;&amp;#30001; sql &amp;#21442;&amp;#25968;&amp;#25552;&amp;#20379;&amp;#65292;&amp;#21487;&amp;#20197;&amp;#30001;&amp;#22810;&amp;#20010; SQL &amp;#21629;&amp;#20196;&amp;#32452;&amp;#25104;&amp;#12290;&amp;#10;     &amp;#10;     &amp;#22312;&amp;#36825;&amp;#37324;&amp;#65292;&amp;#31532;&amp;#19968;&amp;#20010;&amp;#21442;&amp;#25968; sqlite3 &amp;#26159;&amp;#25171;&amp;#24320;&amp;#30340;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#23545;&amp;#35937;&amp;#65292;sqlite_callback &amp;#26159;&amp;#19968;&amp;#20010;&amp;#22238;&amp;#35843;&amp;#65292;data &amp;#20316;&amp;#20026;&amp;#20854;&amp;#31532;&amp;#19968;&amp;#20010;&amp;#21442;&amp;#25968;&amp;#65292;errmsg &amp;#23558;&amp;#34987;&amp;#36820;&amp;#22238;&amp;#29992;&amp;#26469;&amp;#33719;&amp;#21462;&amp;#31243;&amp;#24207;&amp;#29983;&amp;#25104;&amp;#30340;&amp;#20219;&amp;#20309;&amp;#38169;&amp;#35823;&amp;#12290;&amp;#10;     &amp;#10;     sqlite3_exec() &amp;#31243;&amp;#24207;&amp;#35299;&amp;#26512;&amp;#24182;&amp;#25191;&amp;#34892;&amp;#30001; sql &amp;#21442;&amp;#25968;&amp;#25152;&amp;#32473;&amp;#30340;&amp;#27599;&amp;#20010;&amp;#21629;&amp;#20196;&amp;#65292;&amp;#30452;&amp;#21040;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#32467;&amp;#26463;&amp;#25110;&amp;#32773;&amp;#36935;&amp;#21040;&amp;#38169;&amp;#35823;&amp;#20026;&amp;#27490;&amp;#12290;&amp;#10;     */&amp;#10;    rc = sqlite3_exec([self sqliteHandle], [sql UTF8String], block ? FMDBExecuteBulkSQLCallback : nil, (__bridge void *)(block), &amp;#38;errmsg);&amp;#10;    &amp;#10;    if (errmsg &amp;#38;&amp;#38; [self logsErrors]) &amp;#123;&amp;#10;        NSLog(@&amp;#34;Error inserting batch: %s&amp;#34;, errmsg);&amp;#10;        sqlite3_free(errmsg);&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return (rc == SQLITE_OK);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *sql = @&amp;#34;create table messages1 (id integer primary key messageId, x text);&amp;#34;&amp;#10;                 &amp;#34;create table messages2 (id integer primary key messageId, y text);&amp;#34;&amp;#10;&amp;#9;&amp;#9;&amp;#9;&amp;#9; &amp;#34;insert into messages1 (x) values (&amp;#39;X&amp;#39;);&amp;#34;&amp;#10;                 &amp;#34;insert into messages2 (y) values (&amp;#39;Y&amp;#39;);&amp;#34;;&amp;#10;&amp;#10;success = [db executeStatements:sql];&amp;#10;&amp;#10;sql = @&amp;#34;select count(*) as count from messages1;&amp;#34;&amp;#10;       &amp;#34;select count(*) as count from messages2;&amp;#34;;&amp;#10;&amp;#10;success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) &amp;#123;&amp;#10;    // do something&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u83B7_u53D6_u6700_u540E_u4E00_u6761_u63D2_u5165_u6570_u636E_u7684RowId&quot;&gt;&lt;a href=&quot;#u83B7_u53D6_u6700_u540E_u4E00_u6761_u63D2_u5165_u6570_u636E_u7684RowId&quot; class=&quot;headerlink&quot; title=&quot;获取最后一条插入数据的RowId&quot;&gt;&lt;/a&gt;获取最后一条插入数据的RowId&lt;/h4&gt;&lt;p&gt;可以根据这个&lt;code&gt;id&lt;/code&gt;拿到该数据，并且向上取数据库数据等操作都可以&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (sqlite_int64)lastInsertRowId &amp;#123;&amp;#10;    // &amp;#22914;&amp;#26524;&amp;#26377;&amp;#27491;&amp;#22312;&amp;#25191;&amp;#34892;&amp;#35821;&amp;#21477;&amp;#65292;&amp;#36820;&amp;#22238;&amp;#10;    if (_isExecutingStatement) &amp;#123;&amp;#10;        [self warnInUse];&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    _isExecutingStatement = YES;&amp;#10;    // sqlite3_last_insert_rowid &amp;#33719;&amp;#21462;&amp;#25351;&amp;#23450;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#26368;&amp;#21518;&amp;#19968;&amp;#20010;&amp;#25554;&amp;#20837;&amp;#30340;rowid&amp;#10;    sqlite_int64 ret = sqlite3_last_insert_rowid(_db);&amp;#10;    &amp;#10;    _isExecutingStatement = NO;&amp;#10;    &amp;#10;    return ret;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u7EDF_u8BA1_u4E0A_u4E00_u6B21SQL_u8BED_u53E5_u53D7_u5F71_u54CD_u7684_u884C_u6570&quot;&gt;&lt;a href=&quot;#u7EDF_u8BA1_u4E0A_u4E00_u6B21SQL_u8BED_u53E5_u53D7_u5F71_u54CD_u7684_u884C_u6570&quot; class=&quot;headerlink&quot; title=&quot;统计上一次SQL语句受影响的行数&quot;&gt;&lt;/a&gt;统计上一次SQL语句受影响的行数&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (int)changes &amp;#123;&amp;#10;    if (_isExecutingStatement) &amp;#123;&amp;#10;        [self warnInUse];&amp;#10;        return 0;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    _isExecutingStatement = YES;&amp;#10;    &amp;#10;    int ret = sqlite3_changes(_db);&amp;#10;    &amp;#10;    _isExecutingStatement = NO;&amp;#10;    &amp;#10;    return ret;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;exclusive_u4E8B_u52A1_u548Cdeferred_u4E8B_u52A1&quot;&gt;&lt;a href=&quot;#exclusive_u4E8B_u52A1_u548Cdeferred_u4E8B_u52A1&quot; class=&quot;headerlink&quot; title=&quot;exclusive事务和deferred事务&quot;&gt;&lt;/a&gt;exclusive事务和deferred事务&lt;/h4&gt;&lt;p&gt;事务可以从&lt;code&gt;DEFERRED&lt;/code&gt;，&lt;code&gt;IMMEDIATE&lt;/code&gt;或者&lt;code&gt;EXCLUSIVE&lt;/code&gt;，一个事务的类型在&lt;code&gt;BEGIN&lt;/code&gt;命令中指定：&lt;code&gt;BEGIN [ DEFERRED | IMMEDIATE | EXCLUSIVE ] TRANSACTION&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;deferred&lt;/code&gt;事务不获取任何锁，直到它需要锁的时候，而且&lt;code&gt;BEGIN&lt;/code&gt;语句本身也不会做什么事情——它开始于&lt;code&gt;UNLOCK&lt;/code&gt;状态；默认情况下是这样的。如果仅仅用&lt;code&gt;BEGIN&lt;/code&gt;开始一个事务，那么事务就是&lt;code&gt;DEFERRED&lt;/code&gt;的，同时它不会获取任何锁，当对数据库进行第一次读操作时，它会获取&lt;code&gt;SHARED LOCK&lt;/code&gt;；同样，当进行第一次写操作时，它会获取&lt;code&gt;RESERVED LOCK&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#24320;&amp;#22987;&amp;#24310;&amp;#36831;&amp;#20107;&amp;#21153;&amp;#10;- (BOOL)beginDeferredTransaction &amp;#123;&amp;#10;    &amp;#10;    BOOL b = [self executeUpdate:@&amp;#34;begin deferred transaction&amp;#34;];&amp;#10;    if (b) &amp;#123;&amp;#10;        _inTransaction = YES;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return b;&amp;#10;&amp;#125;&amp;#10;&amp;#10;//Exclusive&amp;#20107;&amp;#21153;&amp;#20250;&amp;#35797;&amp;#30528;&amp;#33719;&amp;#21462;&amp;#23545;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#30340;EXCLUSIVE&amp;#38145;&amp;#12290;&amp;#36825;&amp;#19982;IMMEDIATE&amp;#31867;&amp;#20284;&amp;#65292;&amp;#20294;&amp;#26159;&amp;#19968;&amp;#26086;&amp;#25104;&amp;#21151;&amp;#65292;EXCLUSIVE&amp;#20107;&amp;#21153;&amp;#20445;&amp;#35777;&amp;#27809;&amp;#26377;&amp;#20854;&amp;#23427;&amp;#30340;&amp;#36830;&amp;#25509;&amp;#65292;&amp;#25152;&amp;#20197;&amp;#23601;&amp;#21487;&amp;#23545;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#36827;&amp;#34892;&amp;#35835;&amp;#20889;&amp;#25805;&amp;#20316;&amp;#20102;&amp;#12290;&amp;#10;&amp;#10;// &amp;#24320;&amp;#22987;&amp;#20107;&amp;#21153;&amp;#10;- (BOOL)beginTransaction &amp;#123;&amp;#10;    &amp;#10;    BOOL b = [self executeUpdate:@&amp;#34;begin exclusive transaction&amp;#34;];&amp;#10;    if (b) &amp;#123;&amp;#10;        _inTransaction = YES;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return b;&amp;#10;&amp;#125;&amp;#10;&amp;#10;// &amp;#22238;&amp;#28378;&amp;#20107;&amp;#21153;&amp;#10;- (BOOL)rollback &amp;#123;&amp;#10;    BOOL b = [self executeUpdate:@&amp;#34;rollback transaction&amp;#34;];&amp;#10;    &amp;#10;    if (b) &amp;#123;&amp;#10;        _inTransaction = NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return b;&amp;#10;&amp;#125;&amp;#10;// &amp;#25552;&amp;#20132;&amp;#20107;&amp;#21153;&amp;#10;- (BOOL)commit &amp;#123;&amp;#10;    BOOL b =  [self executeUpdate:@&amp;#34;commit transaction&amp;#34;];&amp;#10;    &amp;#10;    if (b) &amp;#123;&amp;#10;        _inTransaction = NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return b;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u6570_u636E_u5E93_u52A0_u5BC6_u53CA_u91CD_u7F6E&quot;&gt;&lt;a href=&quot;#u6570_u636E_u5E93_u52A0_u5BC6_u53CA_u91CD_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;数据库加密及重置&quot;&gt;&lt;/a&gt;数据库加密及重置&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)setKeyWithData:(NSData *)keyData &amp;#123;&amp;#10;// SQLITE_HAS_CODEC &amp;#29992;&amp;#26469;&amp;#30830;&amp;#23450;&amp;#26159;&amp;#21542;&amp;#25903;&amp;#25345;&amp;#21152;&amp;#23494;&amp;#10;#ifdef SQLITE_HAS_CODEC&amp;#10;    if (!keyData) &amp;#123;&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    // int sqlite3_key( sqlite3 *db, const void *pKey, int nKey)&amp;#10;    // db&amp;#26159;&amp;#25351;&amp;#23450;&amp;#30340;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#65292;pKey&amp;#26159;&amp;#23494;&amp;#38053;&amp;#65292;nKey&amp;#26159;&amp;#23494;&amp;#38053;&amp;#30340;&amp;#38271;&amp;#24230;&amp;#10;    // &amp;#20363;&amp;#22914;&amp;#65306;sqlite3_key(_db, &amp;#34;gongcheng&amp;#34;, 9);&amp;#10;    int rc = sqlite3_key(_db, [keyData bytes], (int)[keyData length]);&amp;#10;    &amp;#10;    return (rc == SQLITE_OK);&amp;#10;#else&amp;#10;#pragma unused(keyData)&amp;#10;    return NO;&amp;#10;#endif&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)rekeyWithData:(NSData *)keyData &amp;#123;&amp;#10;#ifdef SQLITE_HAS_CODEC&amp;#10;    if (!keyData) &amp;#123;&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    // int sqlite3_rekey( sqlite3 *db, const void *pKey, int nKey)&amp;#10;    // db&amp;#26159;&amp;#25351;&amp;#23450;&amp;#30340;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#65292;pKey&amp;#26159;&amp;#23494;&amp;#38053;&amp;#65292;nKey&amp;#26159;&amp;#23494;&amp;#38053;&amp;#30340;&amp;#38271;&amp;#24230;&amp;#10;    // &amp;#20363;&amp;#22914;&amp;#65306;sqlite3_rekey(_db, &amp;#34;yzy&amp;#34;, 3);&amp;#10;    int rc = sqlite3_rekey(_db, [keyData bytes], (int)[keyData length]);&amp;#10;    &amp;#10;    if (rc != SQLITE_OK) &amp;#123;&amp;#10;        NSLog(@&amp;#34;error on rekey: %d&amp;#34;, rc);&amp;#10;        NSLog(@&amp;#34;%@&amp;#34;, [self lastErrorMessage]);&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return (rc == SQLITE_OK);&amp;#10;#else&amp;#10;#pragma unused(keyData)&amp;#10;    return NO;&amp;#10;#endif&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u6570_u636E_u5E93_u56DE_u6EDA_u65F6_u8BBE_u7F6E_u56DE_u6EDA_u8282_u70B9&quot;&gt;&lt;a href=&quot;#u6570_u636E_u5E93_u56DE_u6EDA_u65F6_u8BBE_u7F6E_u56DE_u6EDA_u8282_u70B9&quot; class=&quot;headerlink&quot; title=&quot;数据库回滚时设置回滚节点&quot;&gt;&lt;/a&gt;数据库回滚时设置回滚节点&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSError*)inSavePoint:(void (^)(BOOL *rollback))block &amp;#123;&amp;#10;#if SQLITE_VERSION_NUMBER &amp;#62;= 3007000&amp;#10;    static unsigned long savePointIdx = 0;&amp;#10;    // &amp;#35774;&amp;#32622;&amp;#33410;&amp;#28857;&amp;#21517;&amp;#31216;&amp;#10;    NSString *name = [NSString stringWithFormat:@&amp;#34;dbSavePoint%ld&amp;#34;, savePointIdx++];&amp;#10;    // &amp;#40664;&amp;#35748;&amp;#19981;&amp;#22238;&amp;#28378;&amp;#10;    BOOL shouldRollback = NO;&amp;#10;    &amp;#10;    NSError *err = 0x00;&amp;#10;    // &amp;#20808;&amp;#23545;&amp;#24403;&amp;#21069;&amp;#29366;&amp;#24577;&amp;#36827;&amp;#34892;&amp;#20445;&amp;#23384;&amp;#10;    if (![self startSavePointWithName:name error:&amp;#38;err]) &amp;#123;&amp;#10;        return err;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    if (block) &amp;#123;&amp;#10;        block(&amp;#38;shouldRollback);&amp;#10;    &amp;#125;&amp;#10;    // &amp;#22914;&amp;#26524;&amp;#38656;&amp;#35201;&amp;#22238;&amp;#28378;&amp;#65292;&amp;#21017;&amp;#22238;&amp;#28378;&amp;#24403;&amp;#19978;&amp;#19968;&amp;#20010;&amp;#33410;&amp;#28857;&amp;#10;    if (shouldRollback) &amp;#123;&amp;#10;        // We need to rollback and release this savepoint to remove it&amp;#10;        [self rollbackToSavePointWithName:name error:&amp;#38;err];&amp;#10;    &amp;#125;&amp;#10;    // &amp;#37322;&amp;#25918;&amp;#33410;&amp;#28857;&amp;#10;    [self releaseSavePointWithName:name error:&amp;#38;err];&amp;#10;    &amp;#10;    return err;&amp;#10;#else&amp;#10;    NSString *errorMessage = NSLocalizedString(@&amp;#34;Save point functions require SQLite 3.7&amp;#34;, nil);&amp;#10;    if (self.logsErrors) NSLog(@&amp;#34;%@&amp;#34;, errorMessage);&amp;#10;    return [NSError errorWithDomain:@&amp;#34;FMDatabase&amp;#34; code:0 userInfo:@&amp;#123;NSLocalizedDescriptionKey : errorMessage&amp;#125;];&amp;#10;#endif&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u5173_u95ED_u6570_u636E_u5E93_u8FDE_u63A5&quot;&gt;&lt;a href=&quot;#u5173_u95ED_u6570_u636E_u5E93_u8FDE_u63A5&quot; class=&quot;headerlink&quot; title=&quot;关闭数据库连接&quot;&gt;&lt;/a&gt;关闭数据库连接&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)close &amp;#123;&amp;#10;    // &amp;#28165;&amp;#38500;&amp;#32531;&amp;#23384;&amp;#30340;prepared&amp;#35821;&amp;#21477;&amp;#10;    [self clearCachedStatements];&amp;#10;    // &amp;#20851;&amp;#38381;&amp;#25152;&amp;#26377;&amp;#25171;&amp;#24320;&amp;#30340;FMResultSet&amp;#23545;&amp;#35937;&amp;#10;    [self closeOpenResultSets];&amp;#10;    &amp;#10;    if (!_db) &amp;#123;&amp;#10;        return YES;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    int  rc;&amp;#10;    BOOL retry;&amp;#10;    BOOL triedFinalizingOpenStatements = NO;&amp;#10;    &amp;#10;    do &amp;#123;&amp;#10;        retry   = NO;&amp;#10;        // &amp;#35843;&amp;#29992;sqlite3_close&amp;#23581;&amp;#35797;&amp;#20851;&amp;#38381;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#10;        rc      = sqlite3_close(_db);&amp;#10;        // &amp;#24403;&amp;#36820;&amp;#22238;&amp;#32467;&amp;#26524;&amp;#26159;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#32321;&amp;#24537;&amp;#25110;&amp;#32773;&amp;#34987;&amp;#38145;&amp;#20303;&amp;#20102;&amp;#10;        if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &amp;#123;&amp;#10;            if (!triedFinalizingOpenStatements) &amp;#123;&amp;#10;                triedFinalizingOpenStatements = YES;&amp;#10;                sqlite3_stmt *pStmt;&amp;#10;                // &amp;#20174;&amp;#20851;&amp;#32852;&amp;#30340;pDb&amp;#25968;&amp;#25454;&amp;#37324;&amp;#38754;&amp;#23545;&amp;#24212;&amp;#30340;prepared&amp;#35821;&amp;#21477;&amp;#24320;&amp;#22987;&amp;#24448;&amp;#19979;&amp;#25214;&amp;#30456;&amp;#24212;&amp;#30340;prepared&amp;#35821;&amp;#21477;&amp;#65292;&amp;#10;                // &amp;#22914;&amp;#26524;pStmt&amp;#26159;NULL&amp;#65292;&amp;#21017;&amp;#20174;pDb&amp;#30340;&amp;#31532;&amp;#19968;&amp;#20010;prepared&amp;#35821;&amp;#21477;&amp;#24320;&amp;#22987;&amp;#25214;&amp;#65292;&amp;#10;                // &amp;#22914;&amp;#26524;&amp;#27809;&amp;#26377;&amp;#25214;&amp;#21040;&amp;#65292;&amp;#21017;&amp;#36820;&amp;#22238;NULL&amp;#10;                while ((pStmt = sqlite3_next_stmt(_db, nil)) !=0) &amp;#123;&amp;#10;                    // &amp;#25214;&amp;#21040;&amp;#20043;&amp;#21518;&amp;#65292;&amp;#37322;&amp;#25918;&amp;#36164;&amp;#28304;&amp;#10;                    NSLog(@&amp;#34;Closing leaked statement&amp;#34;);&amp;#10;                    sqlite3_finalize(pStmt);&amp;#10;                    retry = YES;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        else if (SQLITE_OK != rc) &amp;#123;&amp;#10;            NSLog(@&amp;#34;error closing!: %d&amp;#34;, rc);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    while (retry);&amp;#10;    &amp;#10;    _db = nil;&amp;#10;    return YES;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[newDb close];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的&lt;a href=&quot;http://zeeyang.com/2016/06/22/GCDAsyncSocket-socket-optimize/&quot;&gt;iOS Socket重构设计&lt;/a&gt;里面我有提到我们使用了FMDB做消息缓存，在数据库选型方面，我们&lt;a href=&quot;http://broccoliii.me/&quot;&gt;西兰花&lt;/a&gt;也对目前比较流行和成熟的&lt;code&gt;Realm&lt;/code&gt;、&lt;code&gt;FMDB&lt;/code&gt;和&lt;code&gt;Core Data&lt;/code&gt;做了调查，里面包括了安装、使用和性能比较，是个不错的参考例子&lt;/p&gt;
&lt;p&gt;在选型时，我们应该多选取几个作为对比，从使用方面评估学习成本，通过测试不同数据库操作来比较性能差异，了解有哪些大型的App使用了该数据库以及评价来侧面说明该数据库的成熟度和在使用过程中出现的问题，最后根据自己实际的业务需求来选型&lt;/p&gt;
&lt;p&gt;在选定使用&lt;code&gt;FMDB&lt;/code&gt;之后，我也只是简单的了解下&lt;code&gt;FMDB&lt;/code&gt;的使用，并未对内部的实现和设计思路做深入了解，但是在阅读了代码之后，&lt;code&gt;FMDB&lt;/code&gt;确实像其他博客里面提到的那样，是对原生的SQLite API进行了包装，暴露出相对友好的对外接口，只需传入SQL语句即可(但是对于习惯于使用Model操作的我们来说，直接写SQL语句还是比较麻烦的，所以GitHub上也就库对&lt;code&gt;FMDB&lt;/code&gt;进行了封装，省去写SQL语句，直接对Model进行操作)，并且&lt;code&gt;FMDB&lt;/code&gt;内部对SQL语句进行了缓存，再配合上多线程并发执行，在提高效率方面做了不少的优化，另外还扩展了内存/文件的IO操作和虚表的操作&lt;/p&gt;
&lt;p&gt;下面我会将API使用和源码结合起来讲，方便了解&lt;code&gt;FMDB&lt;/code&gt;以及对复习下原生的SQLite API&lt;/p&gt;
    
    </summary>
    
    
      <category term="FMDB" scheme="http://yuzeyang.github.io/tags/FMDB/"/>
    
  </entry>
  
  <entry>
    <title>IM UI性能优化之异步绘制</title>
    <link href="http://yuzeyang.github.io/2016/07/05/IM-UI-optimize/"/>
    <id>http://yuzeyang.github.io/2016/07/05/IM-UI-optimize/</id>
    <published>2016-07-05T14:35:44.000Z</published>
    <updated>2016-07-11T03:44:06.000Z</updated>
    
    <content type="html">&lt;p&gt;重构完Socket之后，最近我们也开始针对IM的UI做了优化，这次的优化我们主要是参考了&lt;a href=&quot;https://github.com/ibireme/YYKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YYKit&lt;/a&gt;对于性能方面的优化，前期我的另一个小伙伴&lt;a href=&quot;http://broccoliii.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;西兰花&lt;/a&gt;也对&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AsyncDisplayKit&lt;/a&gt;做了调研，不过这个库理解起来确实要费一番功夫，由于YYkit的核心思路基本上都是学习AsyncDisplayKit的，相信YYkit这个库大家都已经很熟悉了，不过可能还没有看过这个库，那下面我做一个简单的介绍&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/yykit.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;YYKit的作者是&lt;a href=&quot;http://blog.ibireme.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;郭曜源&lt;/a&gt;，YYKit实际上是将它那些单独的iOS组件整合在了一起，类似于集合一样组成功能比较全面的组件，你也可以根据自己业务的需要单独使用其中的某些部分&lt;/p&gt;
&lt;h2 id=&quot;0x00__u524D_u671F_u51C6_u5907&quot;&gt;&lt;a href=&quot;#0x00__u524D_u671F_u51C6_u5907&quot; class=&quot;headerlink&quot; title=&quot;0x00 前期准备&quot;&gt;&lt;/a&gt;0x00 前期准备&lt;/h2&gt;&lt;p&gt;我们首先阅读了郭曜源在&lt;a href=&quot;http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;对界面流畅性方面的见解&lt;/a&gt;，里面提到了&lt;code&gt;异步绘制&lt;/code&gt;，但是文字表述毕竟是抽象的，然后我们简单看了下他的YYText和YYAsyncLayer组件，看完之后实际上对如何使用他的YYAsyncLayer这个组件来实现异步绘制还是有点模糊的，后来我们直接看他的微博demo，我们逐渐理清了他是如何实现异步绘制以及几个性能优化方面的点&lt;/p&gt;
&lt;p&gt;因为YYLabel Async Display里面加了是否异步绘制开关，所以我们直接用这个例子作为对比，首先我们来看下异步绘制的效果，开始的时候我们关闭异步绘制的开关，你会发现FPS瞬间掉到6了，屏幕滚动开始非常卡，但是打开开关之后，滚动时虽然FPS还是会掉到30-40，但是滑动的流畅度比之前要好很多，感觉这异步绘制的效果杠杠的好啊，那我们一定要看看他是怎么做的了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/YYAsyncLayer.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x01__u5206_u6790&quot;&gt;&lt;a href=&quot;#0x01__u5206_u6790&quot; class=&quot;headerlink&quot; title=&quot;0x01 分析&quot;&gt;&lt;/a&gt;0x01 分析&lt;/h2&gt;&lt;p&gt;其实整一个性能优化关键的点及流程有三个：&lt;/p&gt;
&lt;h5 id=&quot;1-_u6570_u636E_u6E90_u7684_u5F02_u6B65_u5904_u7406&quot;&gt;&lt;a href=&quot;#1-_u6570_u636E_u6E90_u7684_u5F02_u6B65_u5904_u7406&quot; class=&quot;headerlink&quot; title=&quot;1.数据源的异步处理&quot;&gt;&lt;/a&gt;1.数据源的异步处理&lt;/h5&gt;&lt;p&gt;当我们获取到数据源的时候，我们需要对数据源进行计算处理，计算出UI绘制所需要的属性比如宽高、颜色等等，而且这些计算要异步去做，否则会卡住主线程，等这些数据源计算完成之后，再去处理绘制，但是如果数据源过大，计算的耗时还是在的，所以会有较长时间的等待时间，此时我们需要考虑加上等待的友好处理&lt;/p&gt;
&lt;h5 id=&quot;2-_u91C7_u7528_u66F4_u8F7B_u91CF_u7EA7_u7684_u7ED8_u5236&quot;&gt;&lt;a href=&quot;#2-_u91C7_u7528_u66F4_u8F7B_u91CF_u7EA7_u7684_u7ED8_u5236&quot; class=&quot;headerlink&quot; title=&quot;2.采用更轻量级的绘制&quot;&gt;&lt;/a&gt;2.采用更轻量级的绘制&lt;/h5&gt;&lt;p&gt;在绘制时，对于不需要响应触摸事件的控件，我们应该尽量避免创建UIView对象，取而代之的是使用更为轻量的CALayer，并且对于一个layer包含多个subLayer的情况时，我们可以通过图层预合成的方法，将多个subLayer合成渲染成一张图片，通过上述的处理，不仅能减少CPU在创建UIKit对象的消耗，还能减少GPU在合成和渲染上的消耗，内存的占用也会少很多&lt;/p&gt;
&lt;h5 id=&quot;3-_u5F02_u6B65_u7ED8_u5236&quot;&gt;&lt;a href=&quot;#3-_u5F02_u6B65_u7ED8_u5236&quot; class=&quot;headerlink&quot; title=&quot;3.异步绘制&quot;&gt;&lt;/a&gt;3.异步绘制&lt;/h5&gt;&lt;p&gt;我们将使用&lt;code&gt;YYAsyncLayer&lt;/code&gt;组件实现异步绘制&lt;/p&gt;
&lt;h2 id=&quot;0x02_YYAsyncLayer_u4ECB_u7ECD&quot;&gt;&lt;a href=&quot;#0x02_YYAsyncLayer_u4ECB_u7ECD&quot; class=&quot;headerlink&quot; title=&quot;0x02 YYAsyncLayer介绍&quot;&gt;&lt;/a&gt;0x02 YYAsyncLayer介绍&lt;/h2&gt;&lt;p&gt;前面两个优化点，平时在做的时候可能也都会去做，但是异步绘制这个该怎么去实现呢？我们直接来看下&lt;code&gt;YYAsyncLayer&lt;/code&gt;的代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YYAsyncLayer&lt;/code&gt;组件里面一共包含了三个类：&lt;code&gt;YYAsyncLayer&lt;/code&gt;、&lt;code&gt;YYSentinel&lt;/code&gt;、&lt;code&gt;YYTransaction&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YYAsyncLayer&lt;/code&gt;类是我们主要用的类，它是CALayer的子类，是用来异步渲染layer内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YYSentinel&lt;/code&gt;类是用来给线程安全计数的，用于在多线程处理的场景&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YYTransaction&lt;/code&gt;类是利用runloop在休眠前的空闲时间来触发你预设的方法&lt;/p&gt;
&lt;p&gt;因为我们没有用到&lt;code&gt;YYTransaction&lt;/code&gt;类，所以我们直接将&lt;code&gt;YYAsyncLayer&lt;/code&gt;、&lt;code&gt;YYSentinel&lt;/code&gt;合成一个类，并做了混淆，这样可以少引用一个库&lt;/p&gt;
&lt;p&gt;我们首先来看&lt;code&gt;YYAsyncLayer&lt;/code&gt;的头文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YYAsyncLayer&lt;/code&gt;类只有一个&lt;code&gt;displaysAsynchronously&lt;/code&gt;属性，就是设置渲染是否是异步执行的&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property BOOL displaysAsynchronously;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后还有个代理方法，这个代理方法的触发时机是在layer的内容需要更新的时候，此时你有个新的绘制任务，然后返回的是个&lt;code&gt;YYAsyncLayerDisplayTask&lt;/code&gt;对象&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;YYAsyncLayerDisplayTask&lt;/code&gt;类只有三个block，即将绘制、绘制中、绘制完成&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);&amp;#10;@property (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));&amp;#10;@property (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看到实现文件里面，触发这个代理的方法是&lt;code&gt;- setNeedsDisplay&lt;/code&gt;方法，就是当layer需要更新内容的时候，它会向代理发起一个异步绘制的请求，将内容的渲染放到后台队列去做，所以我们在使用&lt;code&gt;YYAsyncLayer&lt;/code&gt;类时，我们需要重写&lt;code&gt;+ layerClass&lt;/code&gt;方法，返回&lt;code&gt;YYAsyncLayer&lt;/code&gt;类，否则会直接调用&lt;code&gt;CALayer&lt;/code&gt;的方法，不会触发代理&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setNeedsDisplay &amp;#123;&amp;#10;    [self _cancelAsyncDisplay];&amp;#10;    [super setNeedsDisplay];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)display &amp;#123;&amp;#10;    super.contents = super.contents;&amp;#10;    [self _displayAsync:_displaysAsynchronously];&amp;#10;&amp;#125;&amp;#10;&amp;#10;#pragma mark - Private&amp;#10;&amp;#10;- (void)_displayAsync:(BOOL)async &amp;#123;&amp;#10;    __strong id&amp;#60;YYAsyncLayerDelegate&amp;#62; delegate = self.delegate;&amp;#10;    YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];&amp;#10;  // ...&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;- _displayAsync&lt;/code&gt;方法里面主要分成三部分：&lt;/p&gt;
&lt;p&gt;如果没有设置display回调，layer的内容会被清空&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (!task.display) &amp;#123;&amp;#10;    if (task.willDisplay) task.willDisplay(self);&amp;#10;    self.contents = nil;&amp;#10;    if (task.didDisplay) task.didDisplay(self, YES);&amp;#10;    return;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据之前&lt;code&gt;displaysAsynchronously&lt;/code&gt;属性设置判断，如果是同步绘制的话，实际上的操作就是在调用完&lt;code&gt;display&lt;/code&gt;block之后，将sublayer合成一张图作为layer的内容&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self increase];&amp;#10;if (task.willDisplay) task.willDisplay(self);&amp;#10;UIGraphicsBeginImageContextWithOptions(self.bounds.size,self.opaque,self.contentsScale);&amp;#10;CGContextRef context = UIGraphicsGetCurrentContext();&amp;#10;task.display(context, self.bounds.size, ^&amp;#123;return NO;&amp;#125;);&amp;#10;UIImage *image = UIGraphicsGetImageFromCurrentImageContext();&amp;#10;UIGraphicsEndImageContext();&amp;#10;self.contents = (__bridge id)(image.CGImage);&amp;#10;if (task.didDisplay) task.didDisplay(self, YES);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而异步渲染的处理和同步渲染大同小异，第一，多了一个&lt;code&gt;BOOL (^isCancelled)()&lt;/code&gt;block，这个block的好处是，在&lt;code&gt;display&lt;/code&gt;block调用绘制前，可以通过判断&lt;code&gt;isCancelled&lt;/code&gt;布尔值的值来停止绘制，减少性能上的消耗，以及避免出现线程阻塞的情况，比如TableView快速滑动的时候，就可以通过这样的判断，来避免不必要的绘制，提升滑动的流畅性，第二，将上面同步的绘制处理放到了异步去做，绘制方式是一样的&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (task.willDisplay) task.willDisplay(self);&amp;#10;int32_t value = self.value;&amp;#10;BOOL (^isCancelled)() = ^BOOL() &amp;#123;&amp;#10;    return value != self.value;&amp;#10;&amp;#125;;&amp;#10;CGSize size = self.bounds.size;&amp;#10;BOOL opaque = self.opaque;&amp;#10;CGFloat scale = self.contentsScale;&amp;#10;if (size.width &amp;#60; 1 || size.height &amp;#60; 1) &amp;#123;&amp;#10;    CGImageRef image = (__bridge_retained CGImageRef)(self.contents);&amp;#10;    self.contents = nil;&amp;#10;    if (image) &amp;#123;&amp;#10;        dispatch_async(FIMAsyncLayerGetReleaseQueue(), ^&amp;#123;&amp;#10;            CFRelease(image);&amp;#10;        &amp;#125;);&amp;#10;    &amp;#125;&amp;#10;    if (task.didDisplay) task.didDisplay(self, YES);&amp;#10;    return;&amp;#10;&amp;#125;&amp;#10;&amp;#10;dispatch_async(FIMAsyncLayerGetDisplayQueue(), ^&amp;#123;&amp;#10;    if (isCancelled()) return;&amp;#10;    UIGraphicsBeginImageContextWithOptions(size, opaque, scale);&amp;#10;    CGContextRef context = UIGraphicsGetCurrentContext();&amp;#10;    task.display(context, size, isCancelled);&amp;#10;    if (isCancelled()) &amp;#123;&amp;#10;        UIGraphicsEndImageContext();&amp;#10;        dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;            if (task.didDisplay) task.didDisplay(self, NO);&amp;#10;        &amp;#125;);&amp;#10;        return;&amp;#10;    &amp;#125;&amp;#10;    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();&amp;#10;    UIGraphicsEndImageContext();&amp;#10;    if (isCancelled()) &amp;#123;&amp;#10;        dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;            if (task.didDisplay) task.didDisplay(self, NO);&amp;#10;        &amp;#125;);&amp;#10;        return;&amp;#10;    &amp;#125;&amp;#10;    dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;        if (isCancelled()) &amp;#123;&amp;#10;            if (task.didDisplay) task.didDisplay(self, NO);&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            self.contents = (__bridge id)(image.CGImage);&amp;#10;            if (task.didDisplay) task.didDisplay(self, YES);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;);&amp;#10;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个异步的队列也是自己创建的，在预设了一个队列最大值之后，通过获取运行该进程的系统处于激活状态的处理器数量来创建队列，使得绘制的效率达到最高&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static dispatch_queue_t FIMAsyncLayerGetDisplayQueue() &amp;#123;&amp;#10;#define MAX_QUEUE_COUNT 16&amp;#10;    static int queueCount;&amp;#10;    static dispatch_queue_t queues[MAX_QUEUE_COUNT];&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    static int32_t counter = 0;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;&amp;#10;        queueCount = queueCount &amp;#60; 1 ? 1 : queueCount &amp;#62; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;&amp;#10;        if ([UIDevice currentDevice].systemVersion.floatValue &amp;#62;= 8.0) &amp;#123;&amp;#10;            for (NSUInteger i = 0; i &amp;#60; queueCount; i++) &amp;#123;&amp;#10;                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);&amp;#10;                queues[i] = dispatch_queue_create(&amp;#34;com.ibireme.FIMkit.render&amp;#34;, attr);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            for (NSUInteger i = 0; i &amp;#60; queueCount; i++) &amp;#123;&amp;#10;                queues[i] = dispatch_queue_create(&amp;#34;com.ibireme.FIMkit.render&amp;#34;, DISPATCH_QUEUE_SERIAL);&amp;#10;                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;);&amp;#10;    int32_t cur = OSAtomicIncrement32(&amp;#38;counter);&amp;#10;    if (cur &amp;#60; 0) cur = -cur;&amp;#10;    return queues[(cur) % queueCount];&amp;#10;#undef MAX_QUEUE_COUNT&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;0x03__u8865_u5145&quot;&gt;&lt;a href=&quot;#0x03__u8865_u5145&quot; class=&quot;headerlink&quot; title=&quot;0x03 补充&quot;&gt;&lt;/a&gt;0x03 补充&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;文本&lt;/code&gt;的实现上，我们更加推荐使用CoreText，CoreText对象占用的内存少，而且适用于文本排版复杂的情况，虽然在实现上较为复杂，但是所带来的好处远远要多&lt;/p&gt;
&lt;p&gt;在渲染&lt;code&gt;图片&lt;/code&gt;时，我们应该在后台把图片绘制到&lt;code&gt;CGBitmapContext&lt;/code&gt;中，然后从&lt;code&gt;Bitmap&lt;/code&gt;直接创建图片，因为如果使用原来ImageView读取Image的方式是，在创建Image或者CGImageSource对象时，图片数据并不会立即解码，而是等到设置到ImageView或者layer.contents，layer被提交到GPU之前，才解码，并且这些操作都是在主线程进行，是相当耗性能的，所以我们应该用推荐的方式去绘制，而且AFNetworking在对图片处理的时候也是这么做的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/AFURLResponseSerializationImage.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x04__u7B80_u5355_u5B9E_u73B0demo&quot;&gt;&lt;a href=&quot;#0x04__u7B80_u5355_u5B9E_u73B0demo&quot; class=&quot;headerlink&quot; title=&quot;0x04 简单实现demo&quot;&gt;&lt;/a&gt;0x04 简单实现demo&lt;/h2&gt;&lt;p&gt;对于上述优化点，我实现了一个简单的&lt;a href=&quot;https://github.com/Yuzeyang/GCAsyncDisplayDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CoreText demo&lt;/a&gt;，可以看一下这个demo做进一步了解~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;重构完Socket之后，最近我们也开始针对IM的UI做了优化，这次的优化我们主要是参考了&lt;a href=&quot;https://github.com/ibireme/YYKit&quot;&gt;YYKit&lt;/a&gt;对于性能方面的优化，前期我的另一个小伙伴&lt;a href=&quot;http://broccoliii.me/&quot;&gt;西兰花&lt;/a&gt;也对&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit&quot;&gt;AsyncDisplayKit&lt;/a&gt;做了调研，不过这个库理解起来确实要费一番功夫，由于YYkit的核心思路基本上都是学习AsyncDisplayKit的，相信YYkit这个库大家都已经很熟悉了，不过可能还没有看过这个库，那下面我做一个简单的介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="IM 异步绘制" scheme="http://yuzeyang.github.io/tags/IM-%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS Socket重构设计</title>
    <link href="http://yuzeyang.github.io/2016/06/22/GCDAsyncSocket-socket-optimize/"/>
    <id>http://yuzeyang.github.io/2016/06/22/GCDAsyncSocket-socket-optimize/</id>
    <published>2016-06-22T15:02:22.000Z</published>
    <updated>2016-06-23T08:48:55.000Z</updated>
    
    <content type="html">&lt;p&gt;之前基于GCDAsyncSocket封装了一个Socket Manager类，但是由于业务复杂度的上升，之前设计的业务接口的数量逐渐增加，代理回调也随之增加，代理的使用也越来越麻烦，所以我们针对socket通信这块，进行了一次重构&lt;/p&gt;
&lt;p&gt;这里有我们的新童鞋&lt;a href=&quot;http://broccoliii.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;西兰花&lt;/a&gt;很大的功劳哈~&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCDAsyncSocketManager&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GCDAsyncSocketManager&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;之前的设计方案可以看这里：&lt;a href=&quot;http://zeeyang.com/2016/01/17/GCDAsyncSocket-socket/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;socket重构前方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;针对老的设计，我们做出了以下几点修改方向：&lt;/p&gt;
&lt;h2 id=&quot;0x00__u62C6_u5206SocketManager&quot;&gt;&lt;a href=&quot;#0x00__u62C6_u5206SocketManager&quot; class=&quot;headerlink&quot; title=&quot;0x00 拆分SocketManager&quot;&gt;&lt;/a&gt;0x00 拆分SocketManager&lt;/h2&gt;&lt;p&gt;首先我们对SocketManager进行开刀，我们将socket相关的操作和业务相关的操作进行拆分，将业务相关的单独放到一个类里面完成，我们命名它为CommunicationManager&lt;/p&gt;
&lt;p&gt;现在在SocketManager里面，我们只保留了&lt;code&gt;服务器读写数据&lt;/code&gt;、&lt;code&gt;断开连接&lt;/code&gt;、&lt;code&gt;心跳&lt;/code&gt;、&lt;code&gt;重连&lt;/code&gt;、&lt;code&gt;GCDAsyncSocket回调设置&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在CommunicationManager里面，我们做所有业务的操作&lt;/p&gt;
&lt;h2 id=&quot;0x01__u4E1A_u52A1_u63A5_u53E3_u6539_u4E3A_u901A_u7528_u63A5_u53E3&quot;&gt;&lt;a href=&quot;#0x01__u4E1A_u52A1_u63A5_u53E3_u6539_u4E3A_u901A_u7528_u63A5_u53E3&quot; class=&quot;headerlink&quot; title=&quot;0x01 业务接口改为通用接口&quot;&gt;&lt;/a&gt;0x01 业务接口改为通用接口&lt;/h2&gt;&lt;p&gt;由于业务请求类型的不断增加，业务接口的数量也在不断增加，这样使得头文件一眼望不到底…自己看起来都很头疼，更别说是使用方了…&lt;/p&gt;
&lt;p&gt;首先我们将不同的业务请求以枚举的方式列出来，方便外部调用的时候查看，并且最好在枚举后面加上注释，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&amp;#10; *  &amp;#19994;&amp;#21153;&amp;#31867;&amp;#22411;&amp;#10; */&amp;#10;typedef NS_ENUM(NSInteger, FIMRequestType) &amp;#123;&amp;#10;    FIMRequestType_Beat = 1,                       //&amp;#24515;&amp;#36339;&amp;#10;    FIMRequestType_ConnectionAuthAppraisal,        //&amp;#36830;&amp;#25509;&amp;#37492;&amp;#26435;&amp;#10;  &amp;#9;FIMRequestType_GetConversationsList,           //&amp;#33719;&amp;#21462;&amp;#20250;&amp;#35805;&amp;#21015;&amp;#34920;&amp;#10;    ...&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样我们就可以将业务接口用下面这一个通用的接口替换掉，只需要传&lt;code&gt;type&lt;/code&gt;业务请求类型，&lt;code&gt;body&lt;/code&gt;请求体和&lt;code&gt;callback&lt;/code&gt;回调&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&amp;#10; *  &amp;#21521;&amp;#26381;&amp;#21153;&amp;#22120;&amp;#21457;&amp;#36865;&amp;#25968;&amp;#25454;&amp;#10; *&amp;#10; *  @param type    &amp;#35831;&amp;#27714;&amp;#31867;&amp;#22411;&amp;#10; *  @param body    &amp;#35831;&amp;#27714;&amp;#20307;&amp;#10; */&amp;#10;- (void)socketWriteDataWithRequestType:(FIMRequestType)type&amp;#10;                           requestBody:(nonnull NSDictionary *)body&amp;#10;                            completion:(nullable SocketDidReadBlock)callback;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如业务方可以如下使用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *requestBody = @&amp;#123; @&amp;#34;limit&amp;#34;: @(10), @&amp;#34;offset&amp;#34;: @(0) &amp;#125;;&amp;#10;[[FIMCommunicationManager sharedInstance]&amp;#10;socketWriteDataWithRequestType:FIMRequestType_GetConversationsList&amp;#10;                   requestBody:requestBody&amp;#10;                    completion:^(NSError *error, id data) &amp;#123;&amp;#10;                        // do something&amp;#10;                    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;0x02__u544A_u522BDelegate_uFF0C_u4F7F_u7528Blcok&quot;&gt;&lt;a href=&quot;#0x02__u544A_u522BDelegate_uFF0C_u4F7F_u7528Blcok&quot; class=&quot;headerlink&quot; title=&quot;0x02 告别Delegate，使用Blcok&quot;&gt;&lt;/a&gt;0x02 告别Delegate，使用Blcok&lt;/h2&gt;&lt;p&gt;前面也提到，之前会对不同的业务请求，设定相应的delegate回调，但是数量一多，使用起来那真的是槽糕，所以我们参考&lt;code&gt;AFNetworking&lt;/code&gt;的做法，发起请求时将block与一个唯一标识进行绑定，同时将这个唯一标识放到请求里面发给服务器（服务器对该标识不做任何处理），在等到GCDAsyncSocket回调回来的时候，我们通过服务器返回的这个标识，找到对应的block回调出去，这样对业务方来说，这个socket接口用起来其实和HTTP请求接口是一模一样的，将请求的上下文也关联起来了&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/replaceDelegate.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体实现：&lt;/p&gt;
&lt;p&gt;发起请求时&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socketWriteDataWithRequestType:(FIMRequestType)type&amp;#10;                           requestBody:(nonnull NSDictionary *)body&amp;#10;                            completion:(nullable SocketDidReadBlock)callback &amp;#123;&amp;#10;  // ...                            &amp;#10;   &amp;#10;  // &amp;#29983;&amp;#25104;&amp;#21807;&amp;#19968;&amp;#26631;&amp;#35782;&amp;#10;  NSString *blockRequestID = [self createRequestID];&amp;#10;  if (callback) &amp;#123;&amp;#10;      // &amp;#23558;block&amp;#21644;&amp;#26631;&amp;#35782;&amp;#36827;&amp;#34892;&amp;#32465;&amp;#23450;&amp;#65292;&amp;#23384;&amp;#21040;&amp;#19968;&amp;#20010;&amp;#20840;&amp;#23616;&amp;#21464;&amp;#37327;&amp;#37324;&amp;#38754;&amp;#10;      [self.requestsMap setObject:callback forKey:blockRequestID];&amp;#10;  &amp;#125;&amp;#10;                              &amp;#10;  // ...&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接收到GCDAsyncSocket回调时&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &amp;#123;&amp;#10;  // ...&amp;#10;  &amp;#10;  // &amp;#26681;&amp;#25454;&amp;#26381;&amp;#21153;&amp;#22120;&amp;#36820;&amp;#22238;&amp;#30340;&amp;#26631;&amp;#35782;&amp;#24471;&amp;#21040;&amp;#30456;&amp;#24212;&amp;#30340;block&amp;#10;  SocketDidReadBlock didReadBlock = self.requestsMap[requestID];&amp;#10;  &amp;#10;  switch (requestType) &amp;#123;&amp;#10;        case FIMRequestType_ConnectionAuthAppraisal: &amp;#123;&amp;#10;            if (didReadBlock) &amp;#123;&amp;#10;                didReadBlock(nil, nil);&amp;#10;            &amp;#125;&amp;#10;        &amp;#125; break;&amp;#10;    &amp;#9;// ...&amp;#10;    &amp;#9;default: &amp;#123;&amp;#10;            // do something&amp;#10;        &amp;#125; break;&amp;#10;  &amp;#125;&amp;#10;  &amp;#10;  // ...&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;0x03__u4F7F_u7528_u6A21_u62DF_u670D_u52A1_u5668_u65F6_u95F4_uFF0C_u6765_u89E3_u51B3_u7F13_u5B58_u6D88_u606F_u4FDD_u5E8F_u95EE_u9898&quot;&gt;&lt;a href=&quot;#0x03__u4F7F_u7528_u6A21_u62DF_u670D_u52A1_u5668_u65F6_u95F4_uFF0C_u6765_u89E3_u51B3_u7F13_u5B58_u6D88_u606F_u4FDD_u5E8F_u95EE_u9898&quot; class=&quot;headerlink&quot; title=&quot;0x03 使用模拟服务器时间，来解决缓存消息保序问题&quot;&gt;&lt;/a&gt;0x03 使用模拟服务器时间，来解决缓存消息保序问题&lt;/h2&gt;&lt;p&gt;在socket模块里面，我们基于FMDB实现了一套缓存机制，但是聊天页面对数据库读写操作的场景非常复杂，而且我们对发送失败的消息也进行了缓存，如果使用msgID对消息进行保序，你要考虑发送成功和失败消息的排序，以及重发消息之后的排序，等等场景，这样实现起来也会很让人头大&lt;/p&gt;
&lt;p&gt;所以我们采用&lt;code&gt;消息的创建时间&lt;/code&gt;来进行保序，这样不管消息是怎么操作的，从数据库里面读出来的数据，我们只需要根据创建时间来排下序返回给业务层，如果业务层对数据进行修改的时候，我们更新消息的创建时间，这样下次取出来的顺序和UI展示的顺序也还是一样的&lt;/p&gt;
&lt;p&gt;那这个创建时间是由服务器生成的，而且消息发送成功之后，服务器也不会返回给我们这条消息的创建时间，而且失败的消息服务器那边是不会存的，所以就需要我们本地模拟服务器来生成这个时间&lt;/p&gt;
&lt;p&gt;因为考虑到本地时间和服务器时间存在偏差，所以我们在socket建立连接成功之后，返回给我们服务器时间，我们拿到服务器时间之后和手机的本地时间做个比较，记录下这个偏差值，然后业务层在调用发送消息的接口时，socket内部模拟出服务器创建时间赋值给该消息，然后存到数据库里面，这样就可以基本保证数据库存储消息的顺序和服务器的顺序是一致的&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/serverCreateTime.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x04__u76D1_u542C_u7F51_u7EDC_u72B6_u6001_u6765_u6539_u53D8socket_u8FDE_u63A5_u72B6_u6001&quot;&gt;&lt;a href=&quot;#0x04__u76D1_u542C_u7F51_u7EDC_u72B6_u6001_u6765_u6539_u53D8socket_u8FDE_u63A5_u72B6_u6001&quot; class=&quot;headerlink&quot; title=&quot;0x04 监听网络状态来改变socket连接状态&quot;&gt;&lt;/a&gt;0x04 监听网络状态来改变socket连接状态&lt;/h2&gt;&lt;p&gt;我们对socket连接状态也做了微调，我们通过测试微信的连接，发现以下两点：&lt;/p&gt;
&lt;p&gt;1、网络断开后，socket直接断开，显示“未连接”&lt;/p&gt;
&lt;p&gt;2、有网但是socket连接不上时，socket会一直重连，重连n次后，休眠几秒后，再重连，如此循环&lt;/p&gt;
&lt;p&gt;所以我们也对socket连接做了调整，用&lt;code&gt;AFNetWorking&lt;/code&gt;库里面监测网络状态类&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt;（&lt;a href=&quot;http://zeeyang.com/2016/05/23/AFNetWorking-four/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AFNetworkReachabilityManager原理&lt;/a&gt;），在无网时，判断如果socket正在连接或者已连接时，我们主动调用&lt;code&gt;disconnect&lt;/code&gt;断开连接，如果有网，判断如果socket未连接，我们主动建立连接，建立连接不成功的情况时，我们走重连的流程，只是我们依旧保持了重连n次后，n次失败后不再重连了，这个是与微信不同的地方&lt;/p&gt;
&lt;h2 id=&quot;0x05__u4F7F_u7528FIMSocketModel&quot;&gt;&lt;a href=&quot;#0x05__u4F7F_u7528FIMSocketModel&quot; class=&quot;headerlink&quot; title=&quot;0x05 使用FIMSocketModel&quot;&gt;&lt;/a&gt;0x05 使用FIMSocketModel&lt;/h2&gt;&lt;p&gt;因为请求的数据结构基本一样，所以我们定义了FIMSocketModel类来方便对数据的转化，我们定义了几个必传的字段，以及可能请求不同所需的一些非必传字段，由于之前我们body体里面的内容是做了2次JSON转化处理的，所以业务层传入body内容时叫苦连天，FIMSocketModel也增加了&lt;code&gt;- socketModelToJSONString&lt;/code&gt;方法，方便Socket内部转化成JSON处理，这样业务层只需要传一个字典进来，Socket内部就会处理好一切，使用起来一下就方便了~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前基于GCDAsyncSocket封装了一个Socket Manager类，但是由于业务复杂度的上升，之前设计的业务接口的数量逐渐增加，代理回调也随之增加，代理的使用也越来越麻烦，所以我们针对socket通信这块，进行了一次重构&lt;/p&gt;
&lt;p&gt;这里有我们的新童鞋&lt;a href=&quot;http://broccoliii.me/&quot;&gt;西兰花&lt;/a&gt;很大的功劳哈~&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCDAsyncSocketManager&quot;&gt;GCDAsyncSocketManager&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Socket" scheme="http://yuzeyang.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>客户端生成七牛上传token</title>
    <link href="http://yuzeyang.github.io/2016/06/13/Qiniu-token/"/>
    <id>http://yuzeyang.github.io/2016/06/13/Qiniu-token/</id>
    <published>2016-06-13T15:07:54.000Z</published>
    <updated>2016-06-13T16:24:10.000Z</updated>
    
    <content type="html">&lt;p&gt;在使用七牛iOS SDK上传图片时需要用到上传的token，虽然七牛建议token不要在客户端生成，这样做是不安全的，但是我们还是需要了解下客户端是如何生成token的&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我简单地对生成token和上传数据做了封装，这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCQiniuUploadManager&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;provide simple interface to create token,upload file and upload files&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先我们需要用到三个参数&lt;code&gt;scope&lt;/code&gt;、&lt;code&gt;AccessKey&lt;/code&gt;和&lt;code&gt;SecretKey&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scope&lt;/code&gt;其实就是资源存放的文件夹名字，例如下图的&lt;code&gt;cmxj&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Qiniu_scope.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AccessKey&lt;/code&gt;和&lt;code&gt;SecretKey&lt;/code&gt;在个人面板 -&amp;gt; 个人中心 -&amp;gt; 密钥管理里面就能看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Qiniu_AK_SK.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来就可以创建token了，首先我们将上传策略中的&lt;code&gt;scope&lt;/code&gt;和&lt;code&gt;deadline&lt;/code&gt;序列化成json格式，里面的&lt;code&gt;liveTime&lt;/code&gt;则是token的有效时间，可以以天为单位&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSMutableDictionary *authInfo = [NSMutableDictionary dictionary];&amp;#10;[authInfo setObject:self.scope forKey:@&amp;#34;scope&amp;#34;];&amp;#10;[authInfo&amp;#10;setObject:[NSNumber numberWithLong:[[NSDate date] timeIntervalSince1970] + self.liveTime * 24 * 3600]&amp;#10;   forKey:@&amp;#34;deadline&amp;#34;];&amp;#10;&amp;#10;NSData *jsonData =&amp;#10;[NSJSONSerialization dataWithJSONObject:authInfo options:NSJSONWritingPrettyPrinted error:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再对json序列化后的上传策略进行URL安全的base64编码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *encodedString = [self urlSafeBase64Encode:jsonData];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;QN_GTM_Base64&lt;/code&gt;是七牛SDK提供给用户用来处理base64和WebSafeBase64编码的类，然后将里面的&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;/&lt;/code&gt;替换成&lt;code&gt;_&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)urlSafeBase64Encode:(NSData *)text &amp;#123;&amp;#10;    NSString *base64 =&amp;#10;    [[NSString alloc] initWithData:[QN_GTM_Base64 encodeData:text] encoding:NSUTF8StringEncoding];&amp;#10;    base64 = [base64 stringByReplacingOccurrencesOfString:@&amp;#34;+&amp;#34; withString:@&amp;#34;-&amp;#34;];&amp;#10;    base64 = [base64 stringByReplacingOccurrencesOfString:@&amp;#34;/&amp;#34; withString:@&amp;#34;_&amp;#34;];&amp;#10;    return base64;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后用secretKey对编码后的上传策略进行HMAC-SHA1加密，并且做安全的base64编码，得到encoded_signed&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *encodedSignedString = [self HMACSHA1:self.secretKey text:encodedString];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)HMACSHA1:(NSString *)key text:(NSString *)text &amp;#123;&amp;#10;    const char *cKey = [key cStringUsingEncoding:NSUTF8StringEncoding];&amp;#10;    const char *cData = [text cStringUsingEncoding:NSUTF8StringEncoding];&amp;#10;&amp;#10;    char cHMAC[CC_SHA1_DIGEST_LENGTH];&amp;#10;&amp;#10;    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), cData, strlen(cData), cHMAC);&amp;#10;&amp;#10;    NSData *HMAC = [[NSData alloc] initWithBytes:cHMAC length:CC_SHA1_DIGEST_LENGTH];&amp;#10;    NSString *hash = [self urlSafeBase64Encode:HMAC];&amp;#10;    return hash;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后将accessKey、encodedSignedString和encodedString拼接，中间用：分开，得到的就是上传的token&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *token =&amp;#10;    [NSString stringWithFormat:@&amp;#34;%@:%@:%@&amp;#34;, self.accessKey, encodedSignedString, encodedString];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在使用七牛iOS SDK上传图片时需要用到上传的token，虽然七牛建议token不要在客户端生成，这样做是不安全的，但是我们还是需要了解下客户端是如何生成token的&lt;/p&gt;
    
    </summary>
    
    
      <category term="七牛 token" scheme="http://yuzeyang.github.io/tags/%E4%B8%83%E7%89%9B-token/"/>
    
  </entry>
  
  <entry>
    <title>模仿iOS7 task switcher的卡片动画</title>
    <link href="http://yuzeyang.github.io/2016/06/11/iOS-card-animation/"/>
    <id>http://yuzeyang.github.io/2016/06/11/iOS-card-animation/</id>
    <published>2016-06-11T02:20:29.000Z</published>
    <updated>2016-06-11T09:25:23.000Z</updated>
    
    <content type="html">&lt;p&gt;最近看到一个iOS9的task switcher开源实现，但是没有删除功能，就想着干脆做一个模仿iOS7系统的效果，加上删除和重用卡片功能，效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCCardViewController.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCCardViewController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Yuzeyang/GCCardViewController&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;实现上可以使用scrollView或者collectionView去做，这个我是用scrollView去做&lt;/p&gt;
&lt;p&gt;功能点上分为三点：&lt;/p&gt;
&lt;p&gt;1.卡片滑动的效果&lt;/p&gt;
&lt;p&gt;2.卡片重用&lt;/p&gt;
&lt;p&gt;3.卡片删除&lt;/p&gt;
&lt;h2 id=&quot;u5361_u7247_u6ED1_u52A8_u6548_u679C&quot;&gt;&lt;a href=&quot;#u5361_u7247_u6ED1_u52A8_u6548_u679C&quot; class=&quot;headerlink&quot; title=&quot;卡片滑动效果&quot;&gt;&lt;/a&gt;卡片滑动效果&lt;/h2&gt;&lt;p&gt;通过- [scrollViewDidScroll:]代理获取scrollView滑动时的contentOffset值，计算当前contentOffset和原先contentOffset之间的差值diff，再算出进度值progress，以及根据差值diff是否大于0来获取卡片的滑动方向&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView &amp;#123;&amp;#10;    CGFloat orginContentOffset = self.currentCardIndex*kGCScrollViewWidth;&amp;#10;    CGFloat diff = scrollView.contentOffset.x - orginContentOffset;&amp;#10;    CGFloat progress = fabs(diff)/(kGCViewWidth*0.8);&amp;#10;    CardMoveDirection direction = diff &amp;#62; 0 ? CardMoveDirectionLeft : CardMoveDirectionRight;&amp;#10;    for (UIView *card in self.cards) &amp;#123;&amp;#10;        [self.cardDelegate updateCard:card withProgress:progress direction:direction];&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    // &amp;#21345;&amp;#29255;&amp;#37325;&amp;#29992;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过调用自己的cardDelegate方法更新卡片的状态&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)updateCard:(UIView *)card withProgress:(CGFloat)progress direction:(CardMoveDirection)direction;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当前卡片不管是左移还是右移，只需要根据progress来更新状态&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;card.layer.transform = CATransform3DMakeScale(1 - 0.1 * progress, 1 - 0.1 * progress, 1.0);&amp;#10;card.layer.opacity = 1 - 0.2*progress;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据左移还是右移，来决定改变当前卡片下一张还是上一张卡片的状态&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSInteger transCardTag = direction == CardMoveDirectionLeft ? [self.cardScrollView currentCard] + 1 : [self.cardScrollView currentCard] - 1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;card.layer.transform = CATransform3DMakeScale(0.9 + 0.1*progress, 0.9 + 0.1*progress, 1.0);&amp;#10;card.layer.opacity = 0.8 + 0.2*progress;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;u5361_u7247_u91CD_u7528&quot;&gt;&lt;a href=&quot;#u5361_u7247_u91CD_u7528&quot; class=&quot;headerlink&quot; title=&quot;卡片重用&quot;&gt;&lt;/a&gt;卡片重用&lt;/h2&gt;&lt;p&gt;由于页面上只显示三张卡片，所以要重用卡片的话，我们需要初始化四张卡片，类似于tableViewCell的重用处理一样，当第一张卡片离开屏幕显示之后，将第一张卡片移到最后一张卡片的后面，反之，同理&lt;/p&gt;
&lt;p&gt;在- [scrollViewDidScroll:]里面，根据contentOffset变化的绝对值大于scrollView宽度的80%时，对卡片进行重用，以及改变当前的index&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (fabs(diff) &amp;#62;= kGCScrollViewWidth*0.8) &amp;#123;&amp;#10;        self.currentCardIndex = direction == CardMoveDirectionLeft ? self.currentCardIndex + 1 : self.currentCardIndex - 1;&amp;#10;        [self reuseCardWithMoveDirection:direction];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在重用之前，并不是所有位置都需要重用，在index（index从0开始计算）小于2或者index大于总卡片数量-3的时候，才需要重用，左移时，取出cards数组里面第一个card，将card移到最后一个card后面，改变它的center就可以，右移时，取出最后一个card，移到第一个card前面&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)reuseCardWithMoveDirection:(CardMoveDirection)moveDirection &amp;#123;&amp;#10;    BOOL isLeft = moveDirection == CardMoveDirectionLeft;&amp;#10;    UIView *card = nil;&amp;#10;    if (isLeft) &amp;#123;&amp;#10;        if (self.currentCardIndex &amp;#62; self.totalNumberOfCards - 3 || self.currentCardIndex &amp;#60; 2) &amp;#123;&amp;#10;            return;&amp;#10;        &amp;#125;&amp;#10;        card = [self.cards objectAtIndex:0];&amp;#10;        card.tag+=4;&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        if (self.currentCardIndex &amp;#62; self.totalNumberOfCards - 4 ||&amp;#10;            self.currentCardIndex &amp;#60; 1) &amp;#123;&amp;#10;            return;&amp;#10;        &amp;#125;&amp;#10;        card = [self.cards objectAtIndex:3];&amp;#10;        card.tag-=4;&amp;#10;    &amp;#125;&amp;#10;    card.center = [self centerForCardWithIndex:card.tag];&amp;#10;    [self.cardDataSource cardReuseView:card atIndex:card.tag];&amp;#10;    [self ascendingSortCards];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并且调用- [cardReuseView:atIndex:]对重用的卡片改变数据源，最后按tag值升序排序&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (UIView *)cardReuseView:(UIView *)reuseView atIndex:(NSInteger)index &amp;#123;&amp;#10;    if (reuseView) &amp;#123;&amp;#10;        // you can set new style&amp;#10;        return reuseView;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    UIView *card = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kGCCardWidth * 0.9, kGCCardHeight)];&amp;#10;    card.layer.backgroundColor = [UIColor whiteColor].CGColor;&amp;#10;    card.layer.cornerRadius = 4;&amp;#10;    card.layer.masksToBounds = YES;&amp;#10;    &amp;#10;    return card;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;u5361_u7247_u5220_u9664&quot;&gt;&lt;a href=&quot;#u5361_u7247_u5220_u9664&quot; class=&quot;headerlink&quot; title=&quot;卡片删除&quot;&gt;&lt;/a&gt;卡片删除&lt;/h2&gt;&lt;p&gt;卡片删除是一个可选功能，通过设置canDeleteCard来添加手势&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign) BOOL canDeleteCard;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (self.canDeleteCard) &amp;#123;&amp;#10;    UIPanGestureRecognizer *deleteGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(deleteCard:)];&amp;#10;    deleteGesture.minimumNumberOfTouches = 1;&amp;#10;    deleteGesture.maximumNumberOfTouches = 1;&amp;#10;    deleteGesture.delegate = self;&amp;#10;    [card addGestureRecognizer:deleteGesture];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于卡片有拖动手势和scrollView也有拖动手势，这两个手势会出现冲突，所以我们需要根据手势的方向来判断到底应该是作用于卡片上还是scrollView上&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &amp;#123;&amp;#10;    if ([gestureRecognizer isKindOfClass:[UIPanGestureRecognizer class]]) &amp;#123;&amp;#10;        CGPoint translatedPoint = [(UIPanGestureRecognizer *)gestureRecognizer translationInView:gestureRecognizer.view];&amp;#10;        if (fabs(translatedPoint.y) &amp;#62; fabs(translatedPoint.x)) &amp;#123;&amp;#10;            return YES;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    return NO;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在调用卡片删除手势时，向下拖动时不做删除，向上拖动屏幕高度的一半后，删除卡片，并且重用删除后的卡片，这部分重用相对比较复杂&lt;/p&gt;
&lt;h5 id=&quot;u5F53_u5361_u7247_u5C0F_u4E8E_u7B49_u4E8E_u56DB_u5F20_u65F6_uFF0C_u6211_u4EEC_u76F4_u63A5_u79FB_u9664_u5F53_u524D_u7684_u5361_u7247&quot;&gt;&lt;a href=&quot;#u5F53_u5361_u7247_u5C0F_u4E8E_u7B49_u4E8E_u56DB_u5F20_u65F6_uFF0C_u6211_u4EEC_u76F4_u63A5_u79FB_u9664_u5F53_u524D_u7684_u5361_u7247&quot; class=&quot;headerlink&quot; title=&quot;当卡片小于等于四张时，我们直接移除当前的卡片&quot;&gt;&lt;/a&gt;当卡片小于等于四张时，我们直接移除当前的卡片&lt;/h5&gt;&lt;p&gt;-&amp;gt; 如果当前卡片index为0时 -&amp;gt; 右边的卡片左移 -&amp;gt; 右边卡片的tag均减1&lt;/p&gt;
&lt;p&gt;-&amp;gt; 如果当前卡片index为最后一张时 -&amp;gt; 左边的卡片右移 -&amp;gt; 左边卡片的tag不变&lt;/p&gt;
&lt;p&gt;-&amp;gt; 如果当前卡片index为中间时 -&amp;gt; 右边的卡片左移 -&amp;gt; 右边卡片的tag均减1&lt;/p&gt;
&lt;p&gt;最后按升序排序&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (self.totalNumberOfCards &amp;#60;= 4) &amp;#123;&amp;#10;    [(UIView *)[self.cards objectAtIndex:index] removeFromSuperview];&amp;#10;    [self resetTagFromIndex:index];&amp;#10;    [self.cards removeObjectAtIndex:index];&amp;#10;    [self ascendingSortCards];&amp;#10;    return;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)resetTagFromIndex:(NSInteger)index &amp;#123;&amp;#10;    [self.cards enumerateObjectsUsingBlock:^(UIView *card, NSUInteger idx, BOOL * _Nonnull stop) &amp;#123;&amp;#10;        if ((NSInteger)idx &amp;#62; index) &amp;#123;&amp;#10;            card.tag-=1;&amp;#10;            [UIView animateWithDuration:0.3 animations:^&amp;#123;&amp;#10;                card.center = [self centerForCardWithIndex:card.tag];&amp;#10;            &amp;#125;];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当卡片超过四张时，我们需要重用删除的卡片&lt;/p&gt;
&lt;p&gt;-&amp;gt; 如果当前卡片index为0时 -&amp;gt; 卡片的tag值加4 -&amp;gt; 右边的卡片左移 -&amp;gt; 右边卡片的tag均减1&lt;/p&gt;
&lt;p&gt;-&amp;gt; 如果当前卡片index为最后一张时 -&amp;gt; 卡片的tag值减4 -&amp;gt; 左边的卡片右移 -&amp;gt; 左边卡片的tag不变&lt;/p&gt;
&lt;p&gt;-&amp;gt; 如果当前卡片index为中间时 -&amp;gt; 以四个卡片为一组，获取第一个卡片和最后一个卡片的tag值 -&amp;gt; 判读最后一个卡片是否是最后一张卡片 -&amp;gt; 如果是，则将卡片移到第一张卡片的左边，如果不是，则将卡片移到最后一张卡片的右边 -&amp;gt; 右边的卡片左移 -&amp;gt; 右边卡片的tag均减1&lt;/p&gt;
&lt;p&gt;最后按升序排序&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIView *card = [self.cards objectAtIndex:index];&amp;#10;NSInteger fromIndex = index;&amp;#10;if (index == 0) &amp;#123;&amp;#10;    card.tag+=4;&amp;#10;    fromIndex = index - 1;&amp;#10;&amp;#125; else if (index == 3) &amp;#123;&amp;#10;    card.tag-=4;&amp;#10;&amp;#125; else &amp;#123;&amp;#10;    NSInteger lastTag = ((UIView *)[self.cards lastObject]).tag;&amp;#10;    NSInteger firstTag = ((UIView *)[self.cards firstObject]).tag;&amp;#10;    if (lastTag == self.totalNumberOfCards - 1) &amp;#123;&amp;#10;        card.tag = firstTag - 1;&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        card.tag = lastTag + 1;&amp;#10;        fromIndex = index - 1;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&amp;#10;card.center = [self centerForCardWithIndex:card.tag];&amp;#10;[self ascendingSortCards];&amp;#10;[self resetTagFromIndex:fromIndex];&amp;#10;[self.cardDataSource cardReuseView:card atIndex:card.tag];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后只要改变scrollView的contentSize和卡片状态即可~&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[UIView animateWithDuration:0.3 animations:^&amp;#123;&amp;#10;    [self.scrollView setContentSize:CGSizeMake(kGCScrollViewWidth*self.totalNumberOfCards, kGCViewHeight)];&amp;#10;    for (UIView *card in self.cards) &amp;#123;&amp;#10;        [self.cardDelegate updateCard:card withProgress:1 direction:CardMoveDirectionNone];&amp;#10;    &amp;#125;&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到一个iOS9的task switcher开源实现，但是没有删除功能，就想着干脆做一个模仿iOS7系统的效果，加上删除和重用卡片功能，效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/GCCardViewController.gif!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是代码地址：&lt;a href=&quot;https://github.com/Yuzeyang/GCCardViewController&quot;&gt;https://github.com/Yuzeyang/GCCardViewController&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="task switcher" scheme="http://yuzeyang.github.io/tags/task-switcher/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（六）</title>
    <link href="http://yuzeyang.github.io/2016/05/27/AFNetWorking-six/"/>
    <id>http://yuzeyang.github.io/2016/05/27/AFNetWorking-six/</id>
    <published>2016-05-27T01:44:43.000Z</published>
    <updated>2016-06-12T15:25:24.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;AFURLResponseSerialization&lt;/code&gt;是用来将返回的response处理成相应的格式，它通过协议对特定response的data进行解码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response&amp;#10;                           data:(nullable NSData *)data&amp;#10;                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;code&gt;AFHTTPResponseSerializer&lt;/code&gt;可以通过&lt;code&gt;+ serializer&lt;/code&gt;和&lt;code&gt;- init&lt;/code&gt;方法进行初始化，实际上&lt;code&gt;+ serializer&lt;/code&gt;内只是调用了&lt;code&gt;- init&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)serializer &amp;#123;&amp;#10;    return [[self alloc] init];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (instancetype)init &amp;#123;&amp;#10;    self = [super init];&amp;#10;    if (!self) &amp;#123;&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;&amp;#9;// &amp;#35774;&amp;#32622;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#32534;&amp;#30721;&amp;#31867;&amp;#22411;&amp;#65292;&amp;#21487;&amp;#25509;&amp;#21463;&amp;#30340;&amp;#29366;&amp;#24577;&amp;#30721;&amp;#65292;&amp;#21487;&amp;#25509;&amp;#21463;&amp;#30340;MIME&amp;#31867;&amp;#22411;&amp;#10;    self.stringEncoding = NSUTF8StringEncoding;&amp;#10;&amp;#9;self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];&amp;#10;    self.acceptableContentTypes = nil;&amp;#10;&amp;#10;    return self;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;acceptableStatusCodes和acceptableContentTypes可以通过外部进行设置&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy, nullable) NSIndexSet *acceptableStatusCodes;&amp;#10;@property (nonatomic, copy, nullable) NSSet &amp;#60;NSString *&amp;#62; *acceptableContentTypes;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后可以调用&lt;code&gt;- [validateResponse:data:error:]&lt;/code&gt;检查这个response是否包含可接受的状态码和可接受MIME类型来验证response的有效性，子类也可以增加特定域名检查，&lt;code&gt;- [responseObjectForResponse:data:error]&lt;/code&gt;也是调用了这个方法，返回data&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)responseObjectForResponse:(NSURLResponse *)response&amp;#10;                           data:(NSData *)data&amp;#10;                          error:(NSError *__autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    // &amp;#35843;&amp;#29992;- [validateResponse:data:error:]&amp;#26041;&amp;#27861;&amp;#65292;&amp;#36820;&amp;#22238;data &amp;#10;    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];&amp;#10;&amp;#10;    return data;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)validateResponse:(NSHTTPURLResponse *)response&amp;#10;                    data:(NSData *)data&amp;#10;                   error:(NSError * __autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    // &amp;#35774;&amp;#32622;&amp;#21021;&amp;#22987;&amp;#20540;&amp;#10;    BOOL responseIsValid = YES;&amp;#10;    NSError *validationError = nil;&amp;#10;&amp;#10;    // &amp;#26816;&amp;#26597;&amp;#36825;&amp;#20010;response&amp;#26159;&amp;#21542;&amp;#21253;&amp;#21547;&amp;#21487;&amp;#25509;&amp;#21463;&amp;#30340;&amp;#29366;&amp;#24577;&amp;#30721;&amp;#21644;&amp;#21487;&amp;#25509;&amp;#21463;MIME&amp;#31867;&amp;#22411;&amp;#10;&amp;#10;    if (error &amp;#38;&amp;#38; !responseIsValid) &amp;#123;&amp;#10;        *error = validationError;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#36820;&amp;#22238;response&amp;#26159;&amp;#21542;&amp;#26377;&amp;#25928;&amp;#24615;&amp;#10;    return responseIsValid;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;检查这个response是否包含可接受的状态码和可接受MIME类型&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#26816;&amp;#26597;response&amp;#26159;&amp;#21542;&amp;#20026;&amp;#31354;&amp;#65292;&amp;#20197;&amp;#21450;response&amp;#26159;&amp;#21542;&amp;#26159;NSHTTPURLResponse&amp;#31867;&amp;#10;    if (response &amp;#38;&amp;#38; [response isKindOfClass:[NSHTTPURLResponse class]]) &amp;#123;&amp;#10;        // acceptableContentTypes&amp;#19981;&amp;#20026;&amp;#31354;&amp;#24182;&amp;#19988;response&amp;#30340;MIME&amp;#31867;&amp;#22411;&amp;#19981;&amp;#22312;&amp;#21487;&amp;#25509;&amp;#21463;&amp;#30340;&amp;#33539;&amp;#22260;&amp;#37324;&amp;#10;        if (self.acceptableContentTypes &amp;#38;&amp;#38; ![self.acceptableContentTypes containsObject:[response MIMEType]]) &amp;#123;&amp;#10;            &amp;#10;            // &amp;#21253;&amp;#35013;&amp;#38169;&amp;#35823;&amp;#20449;&amp;#24687;&amp;#10;            if ([data length] &amp;#62; 0 &amp;#38;&amp;#38; [response URL]) &amp;#123;&amp;#10;                NSMutableDictionary *mutableUserInfo = [@&amp;#123;&amp;#10;                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&amp;#34;Request failed: unacceptable content-type: %@&amp;#34;, @&amp;#34;AFNetworking&amp;#34;, nil), [response MIMEType]],&amp;#10;                                                          NSURLErrorFailingURLErrorKey:[response URL],&amp;#10;                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,&amp;#10;                                                        &amp;#125; mutableCopy];&amp;#10;                if (data) &amp;#123;&amp;#10;                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;&amp;#10;                &amp;#125;&amp;#10;&amp;#10;                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            responseIsValid = NO;&amp;#10;        &amp;#125;&amp;#10;        // acceptableStatusCodes&amp;#19981;&amp;#20026;&amp;#31354;&amp;#24182;&amp;#19988;acceptableStatusCodes&amp;#21253;&amp;#21547;response&amp;#30340;&amp;#29366;&amp;#24577;&amp;#30721;&amp;#65292;response&amp;#30340;URL&amp;#20063;&amp;#23384;&amp;#22312;&amp;#10;        if (self.acceptableStatusCodes &amp;#38;&amp;#38; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;#38;&amp;#38; [response URL]) &amp;#123;&amp;#10;            // &amp;#21253;&amp;#35013;&amp;#38169;&amp;#35823;&amp;#20449;&amp;#24687;&amp;#10;            NSMutableDictionary *mutableUserInfo = [@&amp;#123;&amp;#10;                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&amp;#34;Request failed: %@ (%ld)&amp;#34;, @&amp;#34;AFNetworking&amp;#34;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],&amp;#10;                                               NSURLErrorFailingURLErrorKey:[response URL],&amp;#10;                                               AFNetworkingOperationFailingURLResponseErrorKey: response,&amp;#10;                                       &amp;#125; mutableCopy];&amp;#10;&amp;#10;            if (data) &amp;#123;&amp;#10;                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);&amp;#10;&amp;#10;            responseIsValid = NO;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是这里有个疑问，假如response为nil或者response不是&lt;code&gt;NSHTTPURLResponse&lt;/code&gt;类，那下面的操作均不会对responseIsValid布尔值进行修改，最后返回的是个YES，但是这样的response不应该是NO么？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;AFJSONResponseSerializer&lt;/code&gt;是继承于&lt;code&gt;AFHTTPResponseSerializer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;外部可以设置&lt;code&gt;NSJSONReadingOptions&lt;/code&gt;和是否移除空值的key&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign) NSJSONReadingOptions readingOptions;&amp;#10;@property (nonatomic, assign) BOOL removesKeysWithNullValues;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;转换object的时候，会检查data是否是空格，这个是Safari的一个bug，具体请看&lt;a href=&quot;https://github.com/rails/rails/issues/1742&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Workaround for behavior of Rails to return a single space for &lt;code&gt;head :ok&lt;/code&gt; (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)responseObjectForResponse:(NSURLResponse *)response&amp;#10;                           data:(NSData *)data&amp;#10;                          error:(NSError *__autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &amp;#123;&amp;#10;        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &amp;#123;&amp;#10;            return nil;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    id responseObject = nil;&amp;#10;    NSError *serializationError = nil;&amp;#10;    // &amp;#21028;&amp;#26029;&amp;#26159;&amp;#21542;&amp;#26159;&amp;#31354;&amp;#26684;&amp;#10;    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&amp;#34; &amp;#34; length:1]];&amp;#10;    if (data.length &amp;#62; 0 &amp;#38;&amp;#38; !isSpace) &amp;#123;&amp;#10;        responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;#38;serializationError];&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#35843;&amp;#29992;AFJSONObjectByRemovingKeysWithNullValues&amp;#25226;&amp;#31354;&amp;#20540;&amp;#30340;key&amp;#37117;&amp;#31227;&amp;#38500;&amp;#25481;&amp;#65292;&amp;#36820;&amp;#22238;object&amp;#10;    if (self.removesKeysWithNullValues &amp;#38;&amp;#38; responseObject) &amp;#123;&amp;#10;        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    if (error) &amp;#123;&amp;#10;        *error = AFErrorWithUnderlyingError(serializationError, *error);&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return responseObject;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;AFXMLParserResponseSerializer&lt;/code&gt;则是直接校验response后，用data初始化NSXMLParser对象并返回&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)responseObjectForResponse:(NSHTTPURLResponse *)response&amp;#10;                           data:(NSData *)data&amp;#10;                          error:(NSError *__autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &amp;#123;&amp;#10;        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &amp;#123;&amp;#10;            return nil;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return [[NSXMLParser alloc] initWithData:data];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;AFPropertyListResponseSerializer&lt;/code&gt;也是类似的处理&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)responseObjectForResponse:(NSURLResponse *)response&amp;#10;                           data:(NSData *)data&amp;#10;                          error:(NSError *__autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &amp;#123;&amp;#10;        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &amp;#123;&amp;#10;            return nil;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    id responseObject;&amp;#10;    NSError *serializationError = nil;&amp;#10;&amp;#10;    if (data) &amp;#123;&amp;#10;        responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&amp;#38;serializationError];&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    if (error) &amp;#123;&amp;#10;        *error = AFErrorWithUnderlyingError(serializationError, *error);&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return responseObject;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;AFImageResponseSerializer&lt;/code&gt;在验证response之后，会根据设置是否自动解压automaticallyInflatesResponseImage布尔值，来对imageData按图片比例返回UIImage对象&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign) CGFloat imageScale;&amp;#10;@property (nonatomic, assign) BOOL automaticallyInflatesResponseImage;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)responseObjectForResponse:(NSURLResponse *)response&amp;#10;                           data:(NSData *)data&amp;#10;                          error:(NSError *__autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &amp;#123;&amp;#10;        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &amp;#123;&amp;#10;            return nil;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH&amp;#10;    // iOS&amp;#38656;&amp;#35201;&amp;#25163;&amp;#21160;&amp;#35299;&amp;#21387;&amp;#22270;&amp;#29255;&amp;#10;    if (self.automaticallyInflatesResponseImage) &amp;#123;&amp;#10;        return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        return AFImageWithDataAtScale(data, self.imageScale);&amp;#10;    &amp;#125;&amp;#10;#else&amp;#10;    // MacOS&amp;#21487;&amp;#20197;&amp;#30452;&amp;#25509;&amp;#20351;&amp;#29992;NSBitmapImageRep&amp;#26469;&amp;#35299;&amp;#21387;&amp;#10;    NSBitmapImageRep *bitimage = [[NSBitmapImageRep alloc] initWithData:data];&amp;#10;    NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize([bitimage pixelsWide], [bitimage pixelsHigh])];&amp;#10;    [image addRepresentation:bitimage];&amp;#10;&amp;#10;    return image;&amp;#10;#endif&amp;#10;&amp;#10;    return nil;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果不解压的话，就直接根据imageData和scale来创建Image，但是这有个疑问是，AF为什么要创建两次image，我觉得可以直接使用- [imageWithData:scale:]方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) &amp;#123;&amp;#10;    UIImage *image = [UIImage af_safeImageWithData:data];&amp;#10;    if (image.images) &amp;#123;&amp;#10;        return image;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是如果用imageWithData转成UIImage对象后，由于网络图片PNG和JPG都是压缩格式，需要解压成bitmap后才能渲染到屏幕，这时会在主线程对图片进行解压操作，这是比较耗时的，可能还会对主线程造成阻塞，所以AF还提供了&lt;code&gt;AFInflatedImageFromResponseWithDataAtScale&lt;/code&gt;方法，对PNG和JPG解压后，返回UIImage对象，这样避免了在主线程的解压操作，不会对主线程造成卡顿&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) &amp;#123;&amp;#10;    if (!data || [data length] == 0) &amp;#123;&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;&amp;#9;// &amp;#21019;&amp;#24314;CGImageRef&amp;#10;    CGImageRef imageRef = NULL;&amp;#10;    // &amp;#29992;data&amp;#21019;&amp;#24314;CGDataProviderRef&amp;#10;    CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);&amp;#10;&amp;#10;    if ([response.MIMEType isEqualToString:@&amp;#34;image/png&amp;#34;]) &amp;#123;&amp;#10;        imageRef = CGImageCreateWithPNGDataProvider(dataProvider,  NULL, true, kCGRenderingIntentDefault);&amp;#10;    &amp;#125; else if ([response.MIMEType isEqualToString:@&amp;#34;image/jpeg&amp;#34;]) &amp;#123;&amp;#10;        imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);&amp;#10;&amp;#10;        if (imageRef) &amp;#123;&amp;#10;            CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);&amp;#10;            CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);&amp;#10;&amp;#10;            // &amp;#22914;&amp;#26524;&amp;#33394;&amp;#24425;&amp;#31354;&amp;#38388;&amp;#26159;CMKY&amp;#65292;CGImageCreateWithJPEGDataProvider&amp;#26159;&amp;#19981;&amp;#20250;&amp;#36827;&amp;#34892;&amp;#22788;&amp;#29702;&amp;#30340;&amp;#65292;&amp;#20063;&amp;#23601;&amp;#26159;&amp;#19981;&amp;#36827;&amp;#34892;&amp;#35299;&amp;#21387;&amp;#65292;&amp;#23558;&amp;#35843;&amp;#29992;AFImageWithDataAtScale&amp;#36820;&amp;#22238;image&amp;#10;            if (imageColorSpaceModel == kCGColorSpaceModelCMYK) &amp;#123;&amp;#10;                CGImageRelease(imageRef);&amp;#10;                imageRef = NULL;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    CGDataProviderRelease(dataProvider);&amp;#10;&amp;#9;// &amp;#19981;&amp;#31526;&amp;#21512;&amp;#35299;&amp;#21387;&amp;#26465;&amp;#20214;&amp;#30340;&amp;#65292;&amp;#23558;&amp;#35843;&amp;#29992;AFImageWithDataAtScale&amp;#36820;&amp;#22238;image&amp;#65292;&amp;#20294;&amp;#26159;&amp;#36825;&amp;#37324;&amp;#22914;&amp;#26524;&amp;#31526;&amp;#21512;&amp;#35299;&amp;#21387;&amp;#26465;&amp;#20214;&amp;#30340;&amp;#20063;&amp;#20250;&amp;#35843;&amp;#29992;&amp;#65292;&amp;#20197;&amp;#21450;&amp;#19979;&amp;#38754;&amp;#20250;&amp;#23545;&amp;#36229;&amp;#20986;&amp;#22823;&amp;#23567;&amp;#30340;&amp;#65292;&amp;#30452;&amp;#25509;&amp;#36820;&amp;#22238;image&amp;#65292;&amp;#36825;&amp;#37324;&amp;#25105;&amp;#35273;&amp;#24471;&amp;#24212;&amp;#35813;&amp;#32479;&amp;#19968;&amp;#23545;&amp;#19981;&amp;#31526;&amp;#21512;&amp;#26465;&amp;#20214;&amp;#30340;&amp;#36820;&amp;#22238;image&amp;#65292;&amp;#31526;&amp;#21512;&amp;#26465;&amp;#20214;&amp;#30340;&amp;#23601;&amp;#19981;&amp;#38656;&amp;#35201;&amp;#35843;&amp;#29992;AFImageWithDataAtScale&amp;#10;    UIImage *image = AFImageWithDataAtScale(data, scale);&amp;#10;    if (!imageRef) &amp;#123;&amp;#10;        if (image.images || !image) &amp;#123;&amp;#10;            return image;&amp;#10;        &amp;#125;&amp;#10;&amp;#9;&amp;#9;// &amp;#36825;&amp;#37324;&amp;#35843;&amp;#29992;CGImageCreateCopy&amp;#65292;&amp;#21482;&amp;#20250;&amp;#23545;&amp;#22270;&amp;#24418;&amp;#26412;&amp;#36523;&amp;#32467;&amp;#26500;&amp;#36827;&amp;#34892;&amp;#25335;&amp;#36125;&amp;#65292;&amp;#24213;&amp;#23618;&amp;#30340;&amp;#25968;&amp;#25454;&amp;#26159;&amp;#19981;&amp;#20250;&amp;#25335;&amp;#36125;&amp;#30340;&amp;#10;        imageRef = CGImageCreateCopy([image CGImage]);&amp;#10;        if (!imageRef) &amp;#123;&amp;#10;            return nil;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#9;// &amp;#35774;&amp;#32622;&amp;#22270;&amp;#29255;&amp;#30340;&amp;#23485;&amp;#21644;&amp;#39640;&amp;#21644;&amp;#23384;&amp;#20648;&amp;#19968;&amp;#20010;&amp;#20687;&amp;#32032;&amp;#25152;&amp;#38656;&amp;#35201;&amp;#29992;&amp;#21040;&amp;#30340;&amp;#23383;&amp;#33410;&amp;#10;    size_t width = CGImageGetWidth(imageRef);&amp;#10;    size_t height = CGImageGetHeight(imageRef);&amp;#10;    size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);&amp;#10;&amp;#9;// &amp;#22914;&amp;#26524;&amp;#22270;&amp;#29255;&amp;#22823;&amp;#23567;&amp;#23485;&amp;#39640;&amp;#20056;&amp;#31215;&amp;#36229;&amp;#36807;1024*1024&amp;#25110;&amp;#32773;bitsPerComponent&amp;#22823;&amp;#20110;8&amp;#37117;&amp;#19981;&amp;#35299;&amp;#21387;&amp;#20102;&amp;#65292;&amp;#22240;&amp;#20026;bitmap&amp;#26159;&amp;#19968;&amp;#30452;&amp;#23384;&amp;#22312;UIImage&amp;#23545;&amp;#35937;&amp;#37324;&amp;#30340;&amp;#65292;&amp;#21487;&amp;#33021;&amp;#20250;&amp;#25226;&amp;#20869;&amp;#23384;&amp;#29190;&amp;#20102;&amp;#10;    if (width * height &amp;#62; 1024 * 1024 || bitsPerComponent &amp;#62; 8) &amp;#123;&amp;#10;        CGImageRelease(imageRef);&amp;#10;&amp;#10;        return image;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    // &amp;#30011;&amp;#24067;&amp;#21442;&amp;#25968;&amp;#10;    size_t bytesPerRow = 0;&amp;#10;    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();&amp;#10;    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);&amp;#10;    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);&amp;#10;&amp;#10;    if (colorSpaceModel == kCGColorSpaceModelRGB) &amp;#123;&amp;#10;        uint32_t alpha = (bitmapInfo &amp;#38; kCGBitmapAlphaInfoMask);&amp;#10;#pragma clang diagnostic push&amp;#10;#pragma clang diagnostic ignored &amp;#34;-Wassign-enum&amp;#34;&amp;#10;        if (alpha == kCGImageAlphaNone) &amp;#123;&amp;#10;            bitmapInfo &amp;#38;= ~kCGBitmapAlphaInfoMask;&amp;#10;            bitmapInfo |= kCGImageAlphaNoneSkipFirst;&amp;#10;        &amp;#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &amp;#123;&amp;#10;            bitmapInfo &amp;#38;= ~kCGBitmapAlphaInfoMask;&amp;#10;            bitmapInfo |= kCGImageAlphaPremultipliedFirst;&amp;#10;        &amp;#125;&amp;#10;#pragma clang diagnostic pop&amp;#10;    &amp;#125;&amp;#10;&amp;#9;// &amp;#21019;&amp;#24314;&amp;#30011;&amp;#24067;&amp;#10;    CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);&amp;#10;&amp;#10;    CGColorSpaceRelease(colorSpace);&amp;#10;&amp;#10;    if (!context) &amp;#123;&amp;#10;        CGImageRelease(imageRef);&amp;#10;&amp;#10;        return image;&amp;#10;    &amp;#125;&amp;#10;&amp;#9;// &amp;#22312;&amp;#30011;&amp;#24067;&amp;#19978;&amp;#30011;&amp;#20986;&amp;#22270;&amp;#29255;&amp;#10;    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);&amp;#10;    // &amp;#20445;&amp;#23384;&amp;#25104;CGImageRef&amp;#10;  &amp;#9;CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);&amp;#10;&amp;#10;    CGContextRelease(context);&amp;#10;&amp;#9;// &amp;#20877;&amp;#36716;&amp;#25104;UIImage&amp;#23545;&amp;#35937;&amp;#10;    UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];&amp;#10;&amp;#10;    CGImageRelease(inflatedImageRef);&amp;#10;    CGImageRelease(imageRef);&amp;#10;&amp;#10;    return inflatedImage;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;AFCompoundResponseSerializer&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)responseObjectForResponse:(NSURLResponse *)response&amp;#10;                           data:(NSData *)data&amp;#10;                          error:(NSError *__autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    // &amp;#36941;&amp;#21382;responseSerializers                    &amp;#10;    for (id &amp;#60;AFURLResponseSerialization&amp;#62; serializer in self.responseSerializers) &amp;#123;&amp;#10;        // &amp;#22914;&amp;#26524;serializer&amp;#19981;&amp;#26159;AFHTTPResponseSerializer&amp;#31867;&amp;#65292;&amp;#21017;&amp;#32487;&amp;#32493;&amp;#10;      &amp;#9;if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) &amp;#123;&amp;#10;            continue;&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        NSError *serializerError = nil;&amp;#10;        // &amp;#19968;&amp;#23618;&amp;#19968;&amp;#23618;&amp;#30340;&amp;#35843;&amp;#29992;&amp;#33258;&amp;#24049;&amp;#30340;- [responseObjectForResponse:data:error:]&amp;#65292;&amp;#30452;&amp;#21040;&amp;#36820;&amp;#22238;responseObject&amp;#10;        id responseObject = [serializer responseObjectForResponse:response data:data error:&amp;#38;serializerError];&amp;#10;        if (responseObject) &amp;#123;&amp;#10;            if (error) &amp;#123;&amp;#10;                *error = AFErrorWithUnderlyingError(serializerError, *error);&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            return responseObject;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return [super responseObjectForResponse:response data:data error:error];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFURLResponseSerialization&lt;/code&gt;是用来将返回的response处理成相应的格式，它通过协议对特定response的data进行解码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response&amp;#10;                           data:(nullable NSData *)data&amp;#10;                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（五）</title>
    <link href="http://yuzeyang.github.io/2016/05/25/AFNetWorking-five/"/>
    <id>http://yuzeyang.github.io/2016/05/25/AFNetWorking-five/</id>
    <published>2016-05-25T12:49:32.000Z</published>
    <updated>2016-06-12T15:17:30.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;AFURLRequestSerialization&lt;/code&gt;是用来对发出的请求进行一些处理&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;code&gt;AFPercentEscapedStringFromString&lt;/code&gt;方法将string里面的:#[]@!$&amp;amp;’()*+,;=字符替换成%&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString * AFPercentEscapedStringFromString(NSString *string) &amp;#123;&amp;#10;  &amp;#9;static NSString * const kAFCharactersGeneralDelimitersToEncode = @&amp;#34;:#[]@&amp;#34;; // does not include &amp;#34;?&amp;#34; or &amp;#34;/&amp;#34; due to RFC 3986 - Section 3.4&amp;#10;    static NSString * const kAFCharactersSubDelimitersToEncode = @&amp;#34;!$&amp;#38;&amp;#39;()*+,;=&amp;#34;;&amp;#10;&amp;#9;&amp;#10;  &amp;#9;// &amp;#20174;&amp;#21487;&amp;#29992;&amp;#23383;&amp;#31526;&amp;#26367;&amp;#25442;&amp;#21024;&amp;#38500;&amp;#25481;:#[]@!$&amp;#38;&amp;#39;()*+,;=&amp;#36825;&amp;#20123;&amp;#23383;&amp;#31526;&amp;#10;    NSMutableCharacterSet * allowedCharacterSet = [[NSCharacterSet URLQueryAllowedCharacterSet] mutableCopy];&amp;#10;    [allowedCharacterSet removeCharactersInString:[kAFCharactersGeneralDelimitersToEncode stringByAppendingString:kAFCharactersSubDelimitersToEncode]];&amp;#10;&amp;#10;&amp;#9;// FIXME: https://github.com/AFNetworking/AFNetworking/pull/3028&amp;#10;    // return [string stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet];&amp;#10;&amp;#9;&amp;#10;  &amp;#9;// &amp;#22768;&amp;#26126;&amp;#25209;&amp;#37327;&amp;#22788;&amp;#29702;&amp;#30340;&amp;#22823;&amp;#23567;&amp;#20026;50&amp;#10;    static NSUInteger const batchSize = 50;&amp;#10;&amp;#10;    NSUInteger index = 0;&amp;#10;    NSMutableString *escaped = @&amp;#34;&amp;#34;.mutableCopy;&amp;#10;&amp;#9;&amp;#10;  &amp;#9;// &amp;#24490;&amp;#29615;&amp;#23558;string&amp;#37324;&amp;#38754;:#[]@!$&amp;#38;&amp;#39;()*+,;=&amp;#30340;&amp;#23383;&amp;#31526;&amp;#26367;&amp;#25442;&amp;#25104;%&amp;#10;    while (index &amp;#60; string.length) &amp;#123;&amp;#10;#pragma GCC diagnostic push&amp;#10;#pragma GCC diagnostic ignored &amp;#34;-Wgnu&amp;#34;&amp;#10;        NSUInteger length = MIN(string.length - index, batchSize);&amp;#10;#pragma GCC diagnostic pop&amp;#10;        NSRange range = NSMakeRange(index, length);&amp;#10;&amp;#10;        // To avoid breaking up character sequences such as &amp;#128116;&amp;#127995;&amp;#128110;&amp;#127997;&amp;#10;        range = [string rangeOfComposedCharacterSequencesForRange:range];&amp;#10;&amp;#10;        NSString *substring = [string substringWithRange:range];&amp;#10;        NSString *encoded = [substring stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet];&amp;#10;        [escaped appendString:encoded];&amp;#10;&amp;#10;        index += range.length;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;&amp;#9;return escaped;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;AFQueryStringPair&lt;/code&gt;类里面有个&lt;code&gt;- URLEncodedStringValue&lt;/code&gt;方法，将请求里面的URL参数转成field=value形式&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)URLEncodedStringValue &amp;#123;&amp;#10;    if (!self.value || [self.value isEqual:[NSNull null]]) &amp;#123;&amp;#10;        return AFPercentEscapedStringFromString([self.field description]);&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        return [NSString stringWithFormat:@&amp;#34;%@=%@&amp;#34;, AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])];&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;字典里面是我们查询的key和value，我们通过将字典内容转成&lt;code&gt;AFQueryStringPair&lt;/code&gt;对象，调用&lt;code&gt;- URLEncodedStringValue&lt;/code&gt;方法，转成key=value，放到mutablePairs数组里，最后用&amp;amp;符拼接起来&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString * AFQueryStringFromParameters(NSDictionary *parameters) &amp;#123;&amp;#10;    NSMutableArray *mutablePairs = [NSMutableArray array];&amp;#10;    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &amp;#123;&amp;#10;        [mutablePairs addObject:[pair URLEncodedStringValue]];&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return [mutablePairs componentsJoinedByString:@&amp;#34;&amp;#38;&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &amp;#123;&amp;#10;    NSMutableArray *mutableQueryStringComponents = [NSMutableArray array];&amp;#10;&amp;#10;    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&amp;#34;description&amp;#34; ascending:YES selector:@selector(compare:)];&amp;#10;&amp;#9;&amp;#10;  &amp;#9;// &amp;#22914;&amp;#26524;&amp;#26159;&amp;#23383;&amp;#20856;&amp;#65292;&amp;#36941;&amp;#21382;&amp;#21518;&amp;#36820;&amp;#22238;key[nestedKey]=nestedValue&amp;#10;    if ([value isKindOfClass:[NSDictionary class]]) &amp;#123;&amp;#10;        NSDictionary *dictionary = value;&amp;#10;        // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries&amp;#10;        for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &amp;#123;&amp;#10;            id nestedValue = dictionary[nestedKey];&amp;#10;            if (nestedValue) &amp;#123;&amp;#10;                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&amp;#34;%@[%@]&amp;#34;, key, nestedKey] : nestedKey), nestedValue)];&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125; // &amp;#22914;&amp;#26524;&amp;#26159;&amp;#25968;&amp;#32452;&amp;#65292;&amp;#36941;&amp;#21382;&amp;#21518;&amp;#36820;&amp;#22238;key[]=nestedValue&amp;#10;  &amp;#9;else if ([value isKindOfClass:[NSArray class]]) &amp;#123;&amp;#10;        NSArray *array = value;&amp;#10;        for (id nestedValue in array) &amp;#123;&amp;#10;            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&amp;#34;%@[]&amp;#34;, key], nestedValue)];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125; // &amp;#22914;&amp;#26524;&amp;#26159;&amp;#38598;&amp;#21512;&amp;#65292;&amp;#36941;&amp;#21382;&amp;#21518;&amp;#36820;&amp;#22238;key=obj&amp;#10;  &amp;#9;else if ([value isKindOfClass:[NSSet class]]) &amp;#123;&amp;#10;        NSSet *set = value;&amp;#10;        for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &amp;#123;&amp;#10;            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125; // &amp;#20854;&amp;#20182;&amp;#36820;&amp;#22238;key=value &amp;#10;  &amp;#9;else &amp;#123;&amp;#10;        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return mutableQueryStringComponents;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设传入的是，我将key,value放到数组里面，再放到mutableQueryStringComponents里&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSSet *afSet = [NSSet setWithObjects:@(1),@(2), nil];&amp;#10;NSDictionary *afDic = @&amp;#123;@&amp;#34;dickey&amp;#34;: @&amp;#123;@&amp;#34;nestKey&amp;#34;: @&amp;#34;nestValue&amp;#34;&amp;#125;,&amp;#10;                        @&amp;#34;arrayKey&amp;#34;: @[@[@(1)]],&amp;#10;                        @&amp;#34;setKey&amp;#34;: afSet,&amp;#10;                        @&amp;#34;generalKey&amp;#34;: @&amp;#34;generalValue&amp;#34;&amp;#125;;&amp;#10;NSArray *resultArray = AFQueryStringPairsFromKeyAndValue(nil, afDic);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打印得到的结果是&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[arrayKey, 1],&amp;#10; [dickey[nestKey], nestValue],&amp;#10; [generalKey, generalValue],&amp;#10; [setKey, 1]&amp;#65292;&amp;#10; [setKey,2]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们使用&lt;code&gt;AFHTTPRequestSerializer&lt;/code&gt;对HTTP请求的头部进行处理&lt;/p&gt;
&lt;p&gt;首先调用&lt;code&gt;+ serializer&lt;/code&gt;进行初始化，里面调用了自己init方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)serializer &amp;#123;&amp;#10;    return [[self alloc] init];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;init里面先将Accept-Language存到mutableHTTPRequestHeaders里&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#23558;mainBundle&amp;#37324;&amp;#38754;&amp;#26681;&amp;#25454;&amp;#20351;&amp;#29992;&amp;#35821;&amp;#35328;&amp;#30340;&amp;#20248;&amp;#20808;&amp;#39034;&amp;#24207;&amp;#25918;&amp;#21040;acceptLanguagesComponents&amp;#37324;&amp;#38754;&amp;#65292;&amp;#20877;&amp;#29992;&amp;#34;,&amp;#34;&amp;#20998;&amp;#38548;&amp;#65292;&amp;#23384;&amp;#21040;mutableHTTPRequestHeaders&amp;#23383;&amp;#20856;&amp;#37324;&amp;#38754;&amp;#10;  &amp;#9;NSMutableArray *acceptLanguagesComponents = [NSMutableArray array];&amp;#10;    [[NSLocale preferredLanguages] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &amp;#123;&amp;#10;        float q = 1.0f - (idx * 0.1f);&amp;#10;        [acceptLanguagesComponents addObject:[NSString stringWithFormat:@&amp;#34;%@;q=%0.1g&amp;#34;, obj, q]];&amp;#10;        *stop = q &amp;#60;= 0.5f;&amp;#10;    &amp;#125;];&amp;#10;    [self setValue:[acceptLanguagesComponents componentsJoinedByString:@&amp;#34;, &amp;#34;] forHTTPHeaderField:@&amp;#34;Accept-Language&amp;#34;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后拼接User-Agent，格式为”%@/%@ (%@; iOS %@; Scale/%0.2f)”，里面需要5个参数，第一个参数先获取项目名，如果没有，就用BundleIdentifier，第二个参数先获取短版本号，如果没有就用版本号，第三个参数是当前设备的类型，第四个参数是当前设备的版本号，第五个参数是屏幕的比例&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *userAgent = nil;&amp;#10;#pragma clang diagnostic push&amp;#10;#pragma clang diagnostic ignored &amp;#34;-Wgnu&amp;#34;&amp;#10;#if TARGET_OS_IOS&amp;#10;    userAgent = [NSString stringWithFormat:@&amp;#34;%@/%@ (%@; iOS %@; Scale/%0.2f)&amp;#34;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&amp;#34;CFBundleShortVersionString&amp;#34;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];&amp;#10;#elif TARGET_OS_WATCH&amp;#10;    // ... &amp;#10;#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)&amp;#10;    // ...&amp;#10;#endif&amp;#10;#pragma clang diagnostic pop&amp;#10;if (userAgent) &amp;#123;&amp;#10;        if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &amp;#123;&amp;#10;            NSMutableString *mutableUserAgent = [userAgent mutableCopy];&amp;#10;            if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@&amp;#34;Any-Latin; Latin-ASCII; [:^ASCII:] Remove&amp;#34;, false)) &amp;#123;&amp;#10;                userAgent = mutableUserAgent;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        [self setValue:userAgent forHTTPHeaderField:@&amp;#34;User-Agent&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后设置属性的监听，这些属性在头文件里面都可以找到，实现文件里面也实现了set方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.mutableObservedChangedKeyPaths = [NSMutableSet set];&amp;#10;    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &amp;#123;&amp;#10;        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &amp;#123;&amp;#10;            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &amp;#123;&amp;#10;    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];&amp;#10;    &amp;#125;);&amp;#10;&amp;#10;    return _AFHTTPRequestSerializerObservedKeyPaths;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过KVO判断是否是新值，如果是的话，就加到mutableObservedChangedKeyPaths里面&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)observeValueForKeyPath:(NSString *)keyPath&amp;#10;                      ofObject:(__unused id)object&amp;#10;                        change:(NSDictionary *)change&amp;#10;                       context:(void *)context&amp;#10;&amp;#123;&amp;#10;    if (context == AFHTTPRequestSerializerObserverContext) &amp;#123;&amp;#10;        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &amp;#123;&amp;#10;            [self.mutableObservedChangedKeyPaths removeObject:keyPath];&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;            [self.mutableObservedChangedKeyPaths addObject:keyPath];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置验证字段&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username&amp;#10;                                       password:(NSString *)password&amp;#10;&amp;#123;&amp;#10;    NSData *basicAuthCredentials = [[NSString stringWithFormat:@&amp;#34;%@:%@&amp;#34;, username, password] dataUsingEncoding:NSUTF8StringEncoding];&amp;#10;    NSString *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];&amp;#10;    [self setValue:[NSString stringWithFormat:@&amp;#34;Basic %@&amp;#34;, base64AuthCredentials] forHTTPHeaderField:@&amp;#34;Authorization&amp;#34;];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;初始化之后，需要调用&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSMutableURLRequest *)requestWithMethod:(NSString *)method&amp;#10;                                 URLString:(NSString *)URLString&amp;#10;                                parameters:(id)parameters&amp;#10;                                     error:(NSError *__autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    // &amp;#26029;&amp;#35328;                                     &amp;#10;    NSParameterAssert(method);&amp;#10;    NSParameterAssert(URLString);&amp;#10;&amp;#9;&amp;#10;    NSURL *url = [NSURL URLWithString:URLString];&amp;#10;&amp;#10;    NSParameterAssert(url);&amp;#10;&amp;#9;// &amp;#26681;&amp;#25454;url&amp;#21021;&amp;#22987;&amp;#21270;request&amp;#10;    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];&amp;#10;    // &amp;#35774;&amp;#32622;HTTP&amp;#26041;&amp;#27861;                                   &amp;#10;    mutableRequest.HTTPMethod = method;&amp;#10;&amp;#9;// &amp;#26681;&amp;#25454;mutableObservedChangedKeyPaths&amp;#23384;&amp;#20648;&amp;#30340;&amp;#23646;&amp;#24615;&amp;#65292;&amp;#35774;&amp;#32622;&amp;#21040;mutableRequest&amp;#10;    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &amp;#123;&amp;#10;        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &amp;#123;&amp;#10;            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#9;// &amp;#35843;&amp;#29992;- [requestBySerializingRequest:withParameters:error]&amp;#26041;&amp;#27861;&amp;#10;    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];&amp;#10;&amp;#10;&amp;#9;return mutableRequest;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request&amp;#10;                               withParameters:(id)parameters&amp;#10;                                        error:(NSError *__autoreleasing *)error&amp;#10;&amp;#123;&amp;#10;    // &amp;#26029;&amp;#35328;                                      &amp;#10;    NSParameterAssert(request);&amp;#10;&amp;#10;    NSMutableURLRequest *mutableRequest = [request mutableCopy];&amp;#10;    // &amp;#26681;&amp;#25454;HTTPRequestHeaders&amp;#26469;&amp;#35774;&amp;#32622;mutableRequest&amp;#30340;&amp;#22836;&amp;#37096;&amp;#23383;&amp;#27573;&amp;#10;    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &amp;#123;&amp;#10;        if (![request valueForHTTPHeaderField:field]) &amp;#123;&amp;#10;            [mutableRequest setValue:value forHTTPHeaderField:field];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;];&amp;#10;&amp;#9;&amp;#10;    NSString *query = nil;&amp;#10;    if (parameters) &amp;#123;&amp;#10;        if (self.queryStringSerialization) &amp;#123;&amp;#10;          &amp;#9;// &amp;#22914;&amp;#26524;&amp;#35774;&amp;#32622;&amp;#20102;queryStringSerialization&amp;#36825;&amp;#20010;block&amp;#30340;&amp;#35805;&amp;#65292;&amp;#23601;&amp;#38656;&amp;#35201;&amp;#35774;&amp;#32622;&amp;#19968;&amp;#20010;&amp;#33258;&amp;#23450;&amp;#20041;&amp;#30340;&amp;#26597;&amp;#35810;&amp;#35821;&amp;#21477;&amp;#24207;&amp;#21015;&amp;#21270;&amp;#26041;&amp;#27861;&amp;#65292;&amp;#36716;&amp;#25104;query&amp;#26597;&amp;#35810;&amp;#21442;&amp;#25968;&amp;#10;            NSError *serializationError;&amp;#10;            query = self.queryStringSerialization(request, parameters, &amp;#38;serializationError);&amp;#10;&amp;#10;            if (serializationError) &amp;#123;&amp;#10;                if (error) &amp;#123;&amp;#10;                    *error = serializationError;&amp;#10;                &amp;#125;&amp;#10;&amp;#10;                return nil;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125; else &amp;#123;&amp;#10;          &amp;#9;// &amp;#22914;&amp;#26524;&amp;#27809;&amp;#26377;&amp;#35774;&amp;#32622;&amp;#65292;&amp;#21017;&amp;#35843;&amp;#29992;AFQueryStringFromParameters&amp;#26041;&amp;#27861;&amp;#65292;&amp;#36716;&amp;#25104;query&amp;#26597;&amp;#35810;&amp;#21442;&amp;#25968;&amp;#10;            switch (self.queryStringSerializationStyle) &amp;#123;&amp;#10;                case AFHTTPRequestQueryStringDefaultStyle:&amp;#10;                    query = AFQueryStringFromParameters(parameters);&amp;#10;                    break;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#9;&amp;#10;    // &amp;#23558;&amp;#25340;&amp;#25509;&amp;#22909;&amp;#30340;query&amp;#35821;&amp;#21477;&amp;#25918;&amp;#21040; mutableRequest.URL&amp;#25110;&amp;#32773;&amp;#25918;&amp;#21040;                                    mutableRequest&amp;#30340;HTTPBody&amp;#37324;&amp;#10;    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &amp;#123;&amp;#10;        if (query) &amp;#123;&amp;#10;            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&amp;#34;&amp;#38;%@&amp;#34; : @&amp;#34;?%@&amp;#34;, query]];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        // #2864: an empty string is a valid x-www-form-urlencoded payload&amp;#10;        if (!query) &amp;#123;&amp;#10;            query = @&amp;#34;&amp;#34;;&amp;#10;        &amp;#125;&amp;#10;        if (![mutableRequest valueForHTTPHeaderField:@&amp;#34;Content-Type&amp;#34;]) &amp;#123;&amp;#10;            [mutableRequest setValue:@&amp;#34;application/x-www-form-urlencoded&amp;#34; forHTTPHeaderField:@&amp;#34;Content-Type&amp;#34;];&amp;#10;        &amp;#125;&amp;#10;        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return mutableRequest;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面的话，基本都是对多部分数据进行组装&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFURLRequestSerialization&lt;/code&gt;是用来对发出的请求进行一些处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（四）</title>
    <link href="http://yuzeyang.github.io/2016/05/23/AFNetWorking-four/"/>
    <id>http://yuzeyang.github.io/2016/05/23/AFNetWorking-four/</id>
    <published>2016-05-23T15:24:24.000Z</published>
    <updated>2016-06-21T08:08:16.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt;是用来监测网络状态的类，可以通过设置状态改变回调来获得当前网络状态&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;网络的状态值有以下四种&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &amp;#123;&amp;#10;    AFNetworkReachabilityStatusUnknown          = -1,// &amp;#26410;&amp;#30693;&amp;#10;    AFNetworkReachabilityStatusNotReachable     = 0, // &amp;#19981;&amp;#21487;&amp;#29992;&amp;#10;    AFNetworkReachabilityStatusReachableViaWWAN = 1, // &amp;#26080;&amp;#32447;&amp;#24191;&amp;#22495;&amp;#32593;&amp;#36830;&amp;#25509;&amp;#10;    AFNetworkReachabilityStatusReachableViaWiFi = 2, // WiFi&amp;#36830;&amp;#25509;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt;提供了五种初始化的方法&lt;/p&gt;
&lt;p&gt;可以通过单例方法初始化&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedManager &amp;#123;&amp;#10;    static AFNetworkReachabilityManager *_sharedManager = nil;&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        // &amp;#35843;&amp;#29992;+ manager&amp;#21021;&amp;#22987;&amp;#21270;&amp;#26041;&amp;#27861;&amp;#10;        _sharedManager = [self manager];&amp;#10;    &amp;#125;);&amp;#10;&amp;#10;    return _sharedManager;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;单例里面调用了第二种通过默认的socket地址初始化方法，返回一个manager对象，sin_family表示协议族，AF_INET表示TCP/IP协议族的地址&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)manager&amp;#10;&amp;#123;&amp;#10;#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;#38;&amp;#38; __IPHONE_OS_VERSION_MIN_REQUIRED &amp;#62;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;#38;&amp;#38; __MAC_OS_X_VERSION_MIN_REQUIRED &amp;#62;= 101100)&amp;#10;    struct sockaddr_in6 address;&amp;#10;    bzero(&amp;#38;address, sizeof(address));&amp;#10;    address.sin6_len = sizeof(address);&amp;#10;    address.sin6_family = AF_INET6;&amp;#10;#else&amp;#10;    // &amp;#22768;&amp;#26126;sockaddr_in&amp;#32467;&amp;#26500;&amp;#20307;&amp;#10;    struct sockaddr_in address;&amp;#10;    // address&amp;#28165;&amp;#38646;&amp;#10;    bzero(&amp;#38;address, sizeof(address));&amp;#10;    // address&amp;#36171;&amp;#20540;&amp;#10;    address.sin_len = sizeof(address);&amp;#10;    address.sin_family = AF_INET;&amp;#10;#endif&amp;#10;    // &amp;#35843;&amp;#29992;+ [managerForAddress:]&amp;#26041;&amp;#27861; &amp;#10;    return [self managerForAddress:&amp;#38;address];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里又调用了第三种通过传入一个socket地址来初始化&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)managerForAddress:(const void *)address &amp;#123;&amp;#10;    // &amp;#29983;&amp;#25104;SCNetworkReachabilityRef&amp;#10;    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);&amp;#10;    // &amp;#35843;&amp;#29992;- [initWithReachability:]&amp;#26041;&amp;#27861;&amp;#10;    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];&amp;#10;&amp;#10;    CFRelease(reachability);&amp;#10;    &amp;#10;    return manager;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;里面又调用了第五种初始化方法，因为该方法的后缀里面有&lt;code&gt;NS_DESIGNATED_INITIALIZER&lt;/code&gt;，所以最终都会调到它，这里就是做了初始化的工作，将起始的网络状态定为Unknown&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &amp;#123;&amp;#10;    self = [super init];&amp;#10;    if (!self) &amp;#123;&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    _networkReachability = CFRetain(reachability);&amp;#10;    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;&amp;#10;&amp;#10;    return self;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后剩下一种方法就是可以根据特定的域来初始化&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)managerForDomain:(NSString *)domain &amp;#123;&amp;#10;    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);&amp;#10;&amp;#10;    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];&amp;#10;    &amp;#10;    CFRelease(reachability);&amp;#10;&amp;#10;    return manager;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在初始化结束之后，我们需要设置网络状态改变的回调，在开启监听之后，会将网络状态回调给外部&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setReachabilityStatusChangeBlock:(void (^)(AFNetworkReachabilityStatus status))block &amp;#123;&amp;#10;    self.networkReachabilityStatusBlock = block;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后就是开启监听&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)startMonitoring &amp;#123;&amp;#10;    // &amp;#20572;&amp;#27490;&amp;#30417;&amp;#21548;&amp;#10;    [self stopMonitoring];&amp;#10;&amp;#10;    if (!self.networkReachability) &amp;#123;&amp;#10;        return;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    // &amp;#25910;&amp;#21040;callback&amp;#35843;&amp;#29992;&amp;#21518;&amp;#65292;&amp;#23558;status&amp;#36890;&amp;#36807;networkReachabilityStatusBlock&amp;#22238;&amp;#35843;&amp;#20986;&amp;#21435;&amp;#10;    __weak __typeof(self)weakSelf = self;&amp;#10;    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &amp;#123;&amp;#10;        __strong __typeof(weakSelf)strongSelf = weakSelf;&amp;#10;&amp;#10;        strongSelf.networkReachabilityStatus = status;&amp;#10;        if (strongSelf.networkReachabilityStatusBlock) &amp;#123;&amp;#10;            strongSelf.networkReachabilityStatusBlock(status);&amp;#10;        &amp;#125;&amp;#10;&amp;#10;    &amp;#125;;&amp;#10;&amp;#10;  &amp;#9;// &amp;#22768;&amp;#26126;SCNetworkReachabilityContext&amp;#32467;&amp;#26500;&amp;#20307;&amp;#10;    SCNetworkReachabilityContext context = &amp;#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&amp;#125;;&amp;#10;    // &amp;#35774;&amp;#32622;&amp;#22238;&amp;#35843;&amp;#10;  &amp;#9;SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;#38;context);&amp;#10;    // &amp;#21152;&amp;#21040;Main runloop&amp;#37324;&amp;#38754;&amp;#23545;&amp;#20854;&amp;#36827;&amp;#34892;&amp;#30417;&amp;#27979;&amp;#10;  &amp;#9;SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);&amp;#10;&amp;#9;&amp;#10;  &amp;#9;// &amp;#33719;&amp;#21462;&amp;#24403;&amp;#21069;&amp;#30340;&amp;#32593;&amp;#32476;&amp;#29366;&amp;#24577;&amp;#65292;&amp;#35843;&amp;#29992;callback&amp;#10;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&amp;#123;&amp;#10;        SCNetworkReachabilityFlags flags;&amp;#10;        if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;#38;flags)) &amp;#123;&amp;#10;            AFPostReachabilityStatusChange(flags, callback);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果没有设置回调的话，也可以通过注册通知的方式，收到网络状态的变化&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &amp;#123;&amp;#10;    // &amp;#33719;&amp;#21462;&amp;#24403;&amp;#21069;&amp;#30340;status&amp;#10;  &amp;#9;AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);&amp;#10;    dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;        // &amp;#36820;&amp;#22238;status&amp;#20540;&amp;#10;      &amp;#9;if (block) &amp;#123;&amp;#10;            block(status);&amp;#10;        &amp;#125;&amp;#10;      &amp;#9;// &amp;#21516;&amp;#26102;&amp;#20250;&amp;#21457;&amp;#36865;&amp;#19968;&amp;#20010;&amp;#36890;&amp;#30693;&amp;#10;        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];&amp;#10;        NSDictionary *userInfo = @&amp;#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &amp;#125;;&amp;#10;        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];&amp;#10;    &amp;#125;);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;停止监听的话，就是取消在Main Runloop里面的监听&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)stopMonitoring &amp;#123;&amp;#10;    if (!self.networkReachability) &amp;#123;&amp;#10;        return;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;使用方式例如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AFNetworkReachabilityManager *networkManager = [AFNetworkReachabilityManager sharedManager];&amp;#10;[networkManager startMonitoring];&amp;#10;[networkManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &amp;#123;&amp;#10;    switch (status) &amp;#123;&amp;#10;        case AFNetworkReachabilityStatusNotReachable:&amp;#10;      &amp;#9;&amp;#9;// do something&amp;#10;            break;&amp;#10;        case AFNetworkReachabilityStatusReachableViaWWAN:&amp;#10;      &amp;#9;&amp;#9;// do something&amp;#10;      &amp;#9;&amp;#9;break;&amp;#10;        case AFNetworkReachabilityStatusReachableViaWiFi:&amp;#10;      &amp;#9;&amp;#9;// do something&amp;#10;            break;&amp;#10;        default:&amp;#10;            break;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt;是用来监测网络状态的类，可以通过设置状态改变回调来获得当前网络状态&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（三）</title>
    <link href="http://yuzeyang.github.io/2016/05/22/AFNetWorking-three/"/>
    <id>http://yuzeyang.github.io/2016/05/22/AFNetWorking-three/</id>
    <published>2016-05-22T13:35:11.000Z</published>
    <updated>2016-06-12T15:26:20.000Z</updated>
    
    <content type="html">&lt;p&gt;在iOS9之后，在默认情况下是不能发送HTTP请求，推荐使用HTTPS，当然你可以在plist里面设置&lt;code&gt;NSAppTransportSecurity&lt;/code&gt;的NSAllowsArbitraryLoads为true，App就依然支持HTTP请求&lt;/p&gt;
&lt;p&gt;而AFSecurityPolicy主要的作用就是验证HTTPS请求的证书的有效性&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;AFSecurityPolicy是安全策略类，有三种SSL Pinning模式&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &amp;#123;&amp;#10;    AFSSLPinningModeNone,// &amp;#22312;&amp;#35777;&amp;#20070;&amp;#21015;&amp;#34920;&amp;#20013;&amp;#26657;&amp;#39564;&amp;#26381;&amp;#21153;&amp;#31471;&amp;#36820;&amp;#22238;&amp;#30340;&amp;#35777;&amp;#20070;&amp;#10;    AFSSLPinningModePublicKey,// &amp;#23458;&amp;#25143;&amp;#31471;&amp;#35201;&amp;#26377;&amp;#26381;&amp;#21153;&amp;#31471;&amp;#30340;&amp;#35777;&amp;#20070;&amp;#25335;&amp;#36125;&amp;#65292;&amp;#21482;&amp;#26159;&amp;#39564;&amp;#35777;&amp;#26102;&amp;#21482;&amp;#39564;&amp;#35777;&amp;#35777;&amp;#20070;&amp;#37324;&amp;#30340;&amp;#20844;&amp;#38053;&amp;#10;    AFSSLPinningModeCertificate,// &amp;#23458;&amp;#25143;&amp;#31471;&amp;#35201;&amp;#26377;&amp;#26381;&amp;#21153;&amp;#31471;&amp;#30340;&amp;#35777;&amp;#20070;&amp;#25335;&amp;#36125;&amp;#65292;&amp;#31532;&amp;#19968;&amp;#27493;&amp;#20808;&amp;#39564;&amp;#35777;&amp;#35777;&amp;#20070;&amp;#22495;&amp;#21517;/&amp;#26377;&amp;#25928;&amp;#26399;&amp;#31561;&amp;#20449;&amp;#24687;&amp;#65292;&amp;#31532;&amp;#20108;&amp;#27493;&amp;#23545;&amp;#26381;&amp;#21153;&amp;#31471;&amp;#36820;&amp;#22238;&amp;#30340;&amp;#35777;&amp;#20070;&amp;#21644;&amp;#23458;&amp;#25143;&amp;#31471;&amp;#36820;&amp;#22238;&amp;#30340;&amp;#26159;&amp;#21542;&amp;#19968;&amp;#33268;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个是证书集合，泛型里面表示了集合里面是NSData类型，表明这个是用来存证书数据的集合，这些证书根据SSL Pinning模式来和服务器进行校验，默认是没有证书的，我们需要调用+ certificatesInBundle:方法将bundle里面的证书文件转成里面是data类型的集合&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong, nullable) NSSet &amp;#60;NSData *&amp;#62; *pinnedCertificates;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &amp;#123;&amp;#10;    // &amp;#33719;&amp;#21462;&amp;#35777;&amp;#20070;&amp;#10;  &amp;#9;NSArray *paths = [bundle pathsForResourcesOfType:@&amp;#34;cer&amp;#34; inDirectory:@&amp;#34;.&amp;#34;];&amp;#10;&amp;#10;    NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]];&amp;#10;    // &amp;#23558;&amp;#35777;&amp;#20070;&amp;#25991;&amp;#20214;&amp;#36716;&amp;#25104;data&amp;#10;  &amp;#9;for (NSString *path in paths) &amp;#123;&amp;#10;        NSData *certificateData = [NSData dataWithContentsOfFile:path];&amp;#10;        [certificates addObject:certificateData];&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    return [NSSet setWithSet:certificates];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有三种初始化的方法，一种是默认策略，AFSSLPinningModeNone&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)defaultPolicy &amp;#123;&amp;#10;    AFSecurityPolicy *securityPolicy = [[self alloc] init];&amp;#10;    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;&amp;#10;&amp;#10;    return securityPolicy;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种是自定义一个安全策略，然后读取cer文件放到集合里面&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &amp;#123;&amp;#10;    return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (NSSet *)defaultPinnedCertificates &amp;#123;&amp;#10;    static NSSet *_defaultPinnedCertificates = nil;&amp;#10;    static dispatch_once_t onceToken;&amp;#10;    dispatch_once(&amp;#38;onceToken, ^&amp;#123;&amp;#10;        NSBundle *bundle = [NSBundle bundleForClass:[self class]];&amp;#10;        _defaultPinnedCertificates = [self certificatesInBundle:bundle];&amp;#10;    &amp;#125;);&amp;#10;&amp;#10;    return _defaultPinnedCertificates;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第三种则是需要我们多传入一个证书集合&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &amp;#123;&amp;#10;    AFSecurityPolicy *securityPolicy = [[self alloc] init];&amp;#10;    securityPolicy.SSLPinningMode = pinningMode;&amp;#10;&amp;#10;    [securityPolicy setPinnedCertificates:pinnedCertificates];&amp;#10;&amp;#10;    return securityPolicy;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置证书的时候，就是把上面初始化时传入的证书取出公钥，再把公钥保存到mutablePinnedPublicKeys集合中&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &amp;#123;&amp;#10;    _pinnedCertificates = pinnedCertificates;&amp;#10;&amp;#10;    if (self.pinnedCertificates) &amp;#123;&amp;#10;        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];&amp;#10;        for (NSData *certificate in self.pinnedCertificates) &amp;#123;&amp;#10;            // &amp;#21462;&amp;#20986;&amp;#20844;&amp;#38053;&amp;#10;          &amp;#9;id publicKey = AFPublicKeyForCertificate(certificate);&amp;#10;            if (!publicKey) &amp;#123;&amp;#10;                continue;&amp;#10;            &amp;#125;&amp;#10;            // &amp;#23558;&amp;#20844;&amp;#38053;&amp;#23384;&amp;#21040;&amp;#38598;&amp;#21512;&amp;#10;            [mutablePinnedPublicKeys addObject:publicKey];&amp;#10;        &amp;#125;&amp;#10;        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        self.pinnedPublicKeys = nil;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;AFPublicKeyForCertificate&lt;/code&gt;方法里面，做了一系列操作后返回公钥，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id AFPublicKeyForCertificate(NSData *certificate) &amp;#123;&amp;#10;    id allowedPublicKey = nil;&amp;#10;    SecCertificateRef allowedCertificate;&amp;#10;    SecCertificateRef allowedCertificates[1];&amp;#10;    CFArrayRef tempCertificates = nil;&amp;#10;    SecPolicyRef policy = nil;&amp;#10;    SecTrustRef allowedTrust = nil;&amp;#10;    SecTrustResultType result;&amp;#10;&amp;#10;  &amp;#9;// &amp;#21462;&amp;#20986;&amp;#35777;&amp;#20070;SecCertificateRef&amp;#10;    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);&amp;#10;    __Require_Quiet(allowedCertificate != NULL, _out);&amp;#10;&amp;#9;&amp;#10;  &amp;#9;// &amp;#29983;&amp;#25104;&amp;#35777;&amp;#20070;&amp;#25968;&amp;#32452;&amp;#10;    allowedCertificates[0] = allowedCertificate;&amp;#10;    tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);&amp;#10;&amp;#10;  &amp;#9;// &amp;#29983;&amp;#25104;SecPolicyRef&amp;#10;    policy = SecPolicyCreateBasicX509();&amp;#10;    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;#38;allowedTrust), _out);&amp;#10;    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;#38;result), _out);&amp;#10;&amp;#9;&amp;#10;  &amp;#9;// &amp;#20174;SecPolicyRef&amp;#20013;&amp;#21462;&amp;#20986;&amp;#20844;&amp;#38053;&amp;#10;    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);&amp;#10;&amp;#10;_out:&amp;#10;    // &amp;#19968;&amp;#20123;&amp;#36164;&amp;#28304;&amp;#30340;&amp;#37322;&amp;#25918;&amp;#10;&amp;#10;    return allowedPublicKey;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;-[evaluateServerTrust:forDomain:]&lt;/code&gt;方法是&lt;code&gt;AFSecurityPolicy&lt;/code&gt;类最长也是最重要的方法，它用来验证服务端是否是受信的&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust&amp;#10;                  forDomain:(NSString *)domain&amp;#10;&amp;#123;&amp;#10;    // &amp;#33529;&amp;#26524;&amp;#25991;&amp;#26723;&amp;#20013;&amp;#34920;&amp;#31034;&amp;#19981;&amp;#35201;&amp;#38544;&amp;#24335;&amp;#22320;&amp;#20449;&amp;#20219;&amp;#33258;&amp;#24049;&amp;#31614;&amp;#21517;&amp;#30340;&amp;#35777;&amp;#20070;&amp;#65292;&amp;#21462;&amp;#32780;&amp;#20195;&amp;#20043;&amp;#30340;&amp;#26159;&amp;#24212;&amp;#35813;&amp;#22686;&amp;#21152;&amp;#33258;&amp;#24049;&amp;#30340;CA&amp;#35777;&amp;#20070;&amp;#21040;&amp;#21463;&amp;#20449;&amp;#21015;&amp;#34920;&amp;#37324;&amp;#10;    if (domain &amp;#38;&amp;#38; self.allowInvalidCertificates &amp;#38;&amp;#38; self.validatesDomainName &amp;#38;&amp;#38; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &amp;#123;&amp;#10;        NSLog(@&amp;#34;In order to validate a domain name for self signed certificates, you MUST use pinning.&amp;#34;);&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    // policies&amp;#22686;&amp;#21152;SecPolicyRef&amp;#10;    NSMutableArray *policies = [NSMutableArray array];&amp;#10;    if (self.validatesDomainName) &amp;#123;&amp;#10;        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];&amp;#10;    &amp;#125;&amp;#10;&amp;#9;&amp;#10;    // &amp;#35774;&amp;#32622;&amp;#20449;&amp;#20219;&amp;#30340;policies&amp;#24212;&amp;#24403;&amp;#34987;&amp;#39564;&amp;#35777;&amp;#10;    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);&amp;#10;&amp;#9;&amp;#10;    // &amp;#21521;&amp;#31995;&amp;#32479;&amp;#20869;&amp;#32622;&amp;#30340;&amp;#26681;&amp;#35777;&amp;#20070;&amp;#39564;&amp;#35777;&amp;#26381;&amp;#21153;&amp;#31471;&amp;#36820;&amp;#22238;&amp;#30340;&amp;#35777;&amp;#20070;&amp;#26159;&amp;#21542;&amp;#21512;&amp;#27861;&amp;#10;    if (self.SSLPinningMode == AFSSLPinningModeNone) &amp;#123;&amp;#10;        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);&amp;#10;    &amp;#125; else if (!AFServerTrustIsValid(serverTrust) &amp;#38;&amp;#38; !self.allowInvalidCertificates) &amp;#123;&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;&amp;#9;&amp;#10;    // &amp;#26681;&amp;#25454;SSLPinningMode&amp;#23545;&amp;#26381;&amp;#21153;&amp;#31471;&amp;#26159;&amp;#21542;&amp;#21463;&amp;#20449;&amp;#36827;&amp;#34892;&amp;#26657;&amp;#39564;&amp;#10;    switch (self.SSLPinningMode) &amp;#123;&amp;#10;        case AFSSLPinningModeNone:&amp;#10;        default:&amp;#10;            return NO;&amp;#10;        case AFSSLPinningModeCertificate: &amp;#123;&amp;#10;            NSMutableArray *pinnedCertificates = [NSMutableArray array];&amp;#10;            for (NSData *certificateData in self.pinnedCertificates) &amp;#123;&amp;#10;                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];&amp;#10;            &amp;#125;&amp;#10;            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);&amp;#10;&amp;#10;            if (!AFServerTrustIsValid(serverTrust)) &amp;#123;&amp;#10;                return NO;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&amp;#39;s the Root CA)&amp;#10;            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);&amp;#10;            &amp;#10;            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &amp;#123;&amp;#10;                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &amp;#123;&amp;#10;                    return YES;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;            &amp;#10;            return NO;&amp;#10;        &amp;#125;&amp;#10;        case AFSSLPinningModePublicKey: &amp;#123;&amp;#10;            NSUInteger trustedPublicKeyCount = 0;&amp;#10;            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);&amp;#10;&amp;#10;            for (id trustChainPublicKey in publicKeys) &amp;#123;&amp;#10;                for (id pinnedPublicKey in self.pinnedPublicKeys) &amp;#123;&amp;#10;                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &amp;#123;&amp;#10;                        trustedPublicKeyCount += 1;&amp;#10;                    &amp;#125;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;            return trustedPublicKeyCount &amp;#62; 0;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    return NO;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS9之后，在默认情况下是不能发送HTTP请求，推荐使用HTTPS，当然你可以在plist里面设置&lt;code&gt;NSAppTransportSecurity&lt;/code&gt;的NSAllowsArbitraryLoads为true，App就依然支持HTTP请求&lt;/p&gt;
&lt;p&gt;而AFSecurityPolicy主要的作用就是验证HTTPS请求的证书的有效性&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建GitHub blog</title>
    <link href="http://yuzeyang.github.io/2016/04/29/hexo_build_github_blog/"/>
    <id>http://yuzeyang.github.io/2016/04/29/hexo_build_github_blog/</id>
    <published>2016-04-28T16:00:00.000Z</published>
    <updated>2016-07-06T08:05:28.000Z</updated>
    
    <content type="html">&lt;p&gt;如果你厌倦了使用了第三方的博客平台，你可以考虑一下用hexo和github来搭建自己的博客&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;用hexo来搭建github blog很简单，只需要五步~&lt;/p&gt;
&lt;h2 id=&quot;1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot;&gt;&lt;a href=&quot;#1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot; class=&quot;headerlink&quot; title=&quot;1.在github上面新建一个仓库&quot;&gt;&lt;/a&gt;1.在github上面新建一个仓库&lt;/h2&gt;&lt;p&gt;首先我们需要在自己的github上新建一个仓库，将仓库的命名为xxx.github.io，一定要按该格式命名，否则不能搭建成功&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;2-_u914D_u7F6E_u73AF_u5883&quot;&gt;&lt;a href=&quot;#2-_u914D_u7F6E_u73AF_u5883&quot; class=&quot;headerlink&quot; title=&quot;2.配置环境&quot;&gt;&lt;/a&gt;2.配置环境&lt;/h2&gt;&lt;p&gt;在使用搭建之前，我们需要配置好下面环境&lt;/p&gt;
&lt;h4 id=&quot;u5B89_u88C5Homebrew&quot;&gt;&lt;a href=&quot;#u5B89_u88C5Homebrew&quot; class=&quot;headerlink&quot; title=&quot;安装Homebrew&quot;&gt;&lt;/a&gt;安装Homebrew&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ruby -e &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u5B89_u88C5node-js&quot;&gt;&lt;a href=&quot;#u5B89_u88C5node-js&quot; class=&quot;headerlink&quot; title=&quot;安装node.js&quot;&gt;&lt;/a&gt;安装node.js&lt;/h4&gt;&lt;p&gt;node.js集成带有了npm&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install node&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u5B89_u88C5hexo-cli&quot;&gt;&lt;a href=&quot;#u5B89_u88C5hexo-cli&quot; class=&quot;headerlink&quot; title=&quot;安装hexo-cli&quot;&gt;&lt;/a&gt;安装hexo-cli&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;3-_u5728blog_u76EE_u5F55_u4E0B_uFF0C_u521D_u59CB_u5316hexo&quot;&gt;&lt;a href=&quot;#3-_u5728blog_u76EE_u5F55_u4E0B_uFF0C_u521D_u59CB_u5316hexo&quot; class=&quot;headerlink&quot; title=&quot;3.在blog目录下，初始化hexo&quot;&gt;&lt;/a&gt;3.在blog目录下，初始化hexo&lt;/h2&gt;&lt;p&gt;接下来我们需要新建一个文件夹来存放blog内容，假设我新建了一个blog文件夹，然后我cd到该路径下面，然后我们需要对该目录进行初始化，运行&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init $&amp;#123;blog&amp;#36335;&amp;#24452;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/hexoinit.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（图中中间出现的报错不要在意，因为我使用了插件，提示未找到该插件）&lt;/p&gt;
&lt;h2 id=&quot;4-_u751F_u6210_u9759_u6001_u9875_u9762&quot;&gt;&lt;a href=&quot;#4-_u751F_u6210_u9759_u6001_u9875_u9762&quot; class=&quot;headerlink&quot; title=&quot;4.生成静态页面&quot;&gt;&lt;/a&gt;4.生成静态页面&lt;/h2&gt;&lt;p&gt;初始化好之后，我们先来看看页面是不是能正常显示打开了，运行&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等同于&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u6CE8_u610F_uFF1A&quot;&gt;&lt;a href=&quot;#u6CE8_u610F_uFF1A&quot; class=&quot;headerlink&quot; title=&quot;注意：&quot;&gt;&lt;/a&gt;注意：&lt;/h4&gt;&lt;p&gt;第一次部署的时候会因为找不到git而报错，需要安装下，再提交一次&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo-deployer-git --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/hexog.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-_u521D_u59CB_u5316_u4F9D_u8D56&quot;&gt;&lt;a href=&quot;#5-_u521D_u59CB_u5316_u4F9D_u8D56&quot; class=&quot;headerlink&quot; title=&quot;5.初始化依赖&quot;&gt;&lt;/a&gt;5.初始化依赖&lt;/h2&gt;&lt;p&gt;在第一次安装运行时，我们需要初始化依赖，否则后面启动服务或者生成静态界面会出错…&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;6-_u542F_u52A8_u670D_u52A1&quot;&gt;&lt;a href=&quot;#6-_u542F_u52A8_u670D_u52A1&quot; class=&quot;headerlink&quot; title=&quot;6.启动服务&quot;&gt;&lt;/a&gt;6.启动服务&lt;/h2&gt;&lt;p&gt;然后我们启动一下服务看看，我们的博客是不是能打开了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/hexoserver.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们打开&lt;a href=&quot;http://0.0.0.0:4000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://0.0.0.0:4000/&lt;/a&gt;看看，如果前面一切顺利的话，你就能看到你搭建成功的博客了~（注意此时打开的还不是自己的github博客地址哦，只是hexo默认配置的地址）&lt;/p&gt;
&lt;h2 id=&quot;7-_u4FEE_u6539blog_u76EE_u5F55_u4E0B_u7684_config-yml_u914D_u7F6E_u6587_u4EF6&quot;&gt;&lt;a href=&quot;#7-_u4FEE_u6539blog_u76EE_u5F55_u4E0B_u7684_config-yml_u914D_u7F6E_u6587_u4EF6&quot; class=&quot;headerlink&quot; title=&quot;7.修改blog目录下的_config.yml配置文件&quot;&gt;&lt;/a&gt;7.修改blog目录下的_config.yml配置文件&lt;/h2&gt;&lt;p&gt;接下来我们需要将hexo打开的博客地址改成自己的地址，打开blog目录下面的_config.yml文件，找到deploy，将部署类型改成git或者GItHub，仓库改成自己的github blog地址格式，分支改成master，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&amp;#10;  type: git    #&amp;#37096;&amp;#32626;&amp;#31867;&amp;#22411;&amp;#10;  repository: https://github.com/Yuzeyang/yuzeyang.github.io.git   #&amp;#37096;&amp;#32626;&amp;#30340;&amp;#20179;&amp;#24211;&amp;#30340;SSH&amp;#10;  branch: master   #&amp;#37096;&amp;#32626;&amp;#20998;&amp;#25903;,&amp;#19968;&amp;#33324;&amp;#20351;&amp;#29992;master&amp;#20027;&amp;#20998;&amp;#25903;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：type/repository/branch:和内容之间是有空格的，而且是一定要有的，否则在重新生成静态页面的时候，会找不到仓库路径&lt;/p&gt;
&lt;h2 id=&quot;8-_u9009_u53D6_u559C_u6B22_u7684_u4E3B_u9898&quot;&gt;&lt;a href=&quot;#8-_u9009_u53D6_u559C_u6B22_u7684_u4E3B_u9898&quot; class=&quot;headerlink&quot; title=&quot;8.选取喜欢的主题&quot;&gt;&lt;/a&gt;8.选取喜欢的主题&lt;/h2&gt;&lt;p&gt;作为爱装逼的程序员怎么能用默认的主题呢，我们可以先在hexo主题网赚挑选一个自己喜欢的主题：&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo主题&lt;/a&gt;，当然你有一定的前端基础可以自己写一套主题玩玩，分享给大家&lt;/p&gt;
&lt;h2 id=&quot;9-_u91CD_u65B0_u90E8_u7F72_u4F60_u7684_u9759_u6001_u7F51_u9875&quot;&gt;&lt;a href=&quot;#9-_u91CD_u65B0_u90E8_u7F72_u4F60_u7684_u9759_u6001_u7F51_u9875&quot; class=&quot;headerlink&quot; title=&quot;9.重新部署你的静态网页&quot;&gt;&lt;/a&gt;9.重新部署你的静态网页&lt;/h2&gt;&lt;p&gt;修改完配置之后，我们重新部署一下，看看效果&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo d -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等同于&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy -generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;10-_u518D_u5237_u65B0_u4E00_u4E0B_u4F60_u7684_u7F51_u9875_uFF0CDuang_7E&quot;&gt;&lt;a href=&quot;#10-_u518D_u5237_u65B0_u4E00_u4E0B_u4F60_u7684_u7F51_u9875_uFF0CDuang_7E&quot; class=&quot;headerlink&quot; title=&quot;10.再刷新一下你的网页，Duang~&quot;&gt;&lt;/a&gt;10.再刷新一下你的网页，Duang~&lt;/h2&gt;&lt;p&gt;因为首页图片加载太慢了…我换了个主题…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/blog.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;11-_u4E0A_u4F20_u6587_u7AE0&quot;&gt;&lt;a href=&quot;#11-_u4E0A_u4F20_u6587_u7AE0&quot; class=&quot;headerlink&quot; title=&quot;11.上传文章&quot;&gt;&lt;/a&gt;11.上传文章&lt;/h2&gt;&lt;p&gt;你可以运行&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &amp;#34;&amp;#26032;&amp;#30340;&amp;#25991;&amp;#31456;&amp;#26631;&amp;#39064;&amp;#34;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样会自动生成好&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;title: Hexo搭建GitHub blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2016-4-29 17:00:00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: Hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者， 把文章放到blog/source/._posts目录下面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/upload.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在文章的内容前面需要加上标题、时间和标签，这样才能在首页显示出你的标题，你也可以添加文章的时间和文章的tag，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;title: Hexo搭建GitHub blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2016-4-29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: Hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再起一下服务，看看有没有修改成功&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;修改成功后，再重新部署一下&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo d -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后再确认一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com2.z0.glb.clouddn.com/update.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上传成功~！&lt;/p&gt;
&lt;h2 id=&quot;12-_u7533_u8BF7_u4E2A_u4EBA_u57DF_u540D&quot;&gt;&lt;a href=&quot;#12-_u7533_u8BF7_u4E2A_u4EBA_u57DF_u540D&quot; class=&quot;headerlink&quot; title=&quot;12.申请个人域名&quot;&gt;&lt;/a&gt;12.申请个人域名&lt;/h2&gt;&lt;p&gt;使用xxx.github.io，其实还不是很方便，也没有xxx.com或者xxx.me这样的域名好（zhuang）记（bi），所以一般都会自己去申请一个个人域名&lt;/p&gt;
&lt;p&gt;我们打开google，搜索一下&lt;code&gt;个人域名&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;恩，跳出&lt;a href=&quot;https://wanwang.aliyun.com/?utm_content=se_97054&amp;amp;gclid=CITQ0ce8vs0CFQqkvQodNFUPrA&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;万网&lt;/a&gt;和&lt;a href=&quot;https://sg.godaddy.com/zh/offers/default.aspx?tmskey=1dom_23&amp;amp;isc=gennlcn10&amp;amp;countrview=1&amp;amp;currencytype=CNY&amp;amp;cvosrc=ppc.google.+%C3%A4%C2%B8%C2%AA%C3%A4%C2%BA%C2%BA%C3%A5%C2%9F%C2%9F%C3%A5%C2%90%C2%8D&amp;amp;cvo_crid=103919011486&amp;amp;matchtype=b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GoDaddy&lt;/a&gt;，不过好像GoDaddy续费比较贵，万网好像能查到你的个人信息资料…&lt;/p&gt;
&lt;p&gt;所以我咨询了下同事，他们推荐了我&lt;a href=&quot;https://www.namesilo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;namesilo&lt;/a&gt;，续费便宜，还能开启隐私保护~&lt;/p&gt;
&lt;p&gt;进到首页之后我们在箭头位置搜索下我们想要的域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/namesilo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后我们就能看到哪些是已经注册，哪些是可以使用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/namesiloRes.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在支付前看下价格，这上面显示的价格只是低价，类似于起拍价，实际价格在支付页可以看到，购买前请仔细看下数字…别付了好几万…（可以支持支付宝哦~）&lt;/p&gt;
&lt;p&gt;然后我们到&lt;a href=&quot;https://www.dnspod.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DNSPOD&lt;/a&gt;里，对我们的xxx.github.io进行DNS转移到xxx.com&lt;/p&gt;
&lt;p&gt;登录后，在域名解析里面，添加我们的个人域名，然后将默认的NS类型的记录值拷贝出来，回到我们的namesilo里面，将nameserver修改成NS类型的记录值，保存，然后过一会儿才会生效&lt;/p&gt;
&lt;p&gt;在Github的xxx.github.io仓库的目录下面，新建一个CNAME文件，写上你的个人域名&lt;/p&gt;
&lt;p&gt;在web导航栏里面输出你的个人域名，就可以正常访问了~&lt;/p&gt;
&lt;h2 id=&quot;13-_u589E_u52A0_u8BC4_u8BBA_u529F_u80FD&quot;&gt;&lt;a href=&quot;#13-_u589E_u52A0_u8BC4_u8BBA_u529F_u80FD&quot; class=&quot;headerlink&quot; title=&quot;13.增加评论功能&quot;&gt;&lt;/a&gt;13.增加评论功能&lt;/h2&gt;&lt;p&gt;目前用的比较多的评论插件有&lt;a href=&quot;https://disqus.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;disqus&lt;/a&gt;、&lt;a href=&quot;http://duoshuo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多说&lt;/a&gt;、&lt;a href=&quot;http://www.uyan.cc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;友言&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是多说和友言界面有点丑…相比之下disqus还是比较符合我的口味的~&lt;/p&gt;
&lt;p&gt;那我就来介绍怎么加disqus&lt;/p&gt;
&lt;p&gt;首先注册登录，然后点击右上角的设置按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/SettingsDisqus.png!400x400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择左侧的&lt;code&gt;Account&lt;/code&gt;，在Username里面填上你的域名名称，例如我的域名是&lt;code&gt;zeeyang.com&lt;/code&gt;，那么我就填&lt;code&gt;zeeyang&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/SettingsDisqusUsername.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后打开你的hexo配置文件，在最后加上&lt;/p&gt;
&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;disqus_shortname&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;域名名称(例如：zeeyang)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后打开主题配置文件，也同样加上&lt;/p&gt;
&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;disqus&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;域名名称(例如：zeeyang)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后提交修改，再刷新下网页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/disqusComplete.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这下子别人可以在你的文章下面留言啦~（我后来更换了apollo主题，比较清爽）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如果你厌倦了使用了第三方的博客平台，你可以考虑一下用hexo和github来搭建自己的博客&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;用hexo来搭建github blog很简单，只需要五步~&lt;/p&gt;
&lt;h2 id=&quot;1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot;&gt;&lt;a href=&quot;#1-_u5728github_u4E0A_u9762_u65B0_u5EFA_u4E00_u4E2A_u4ED3_u5E93&quot; class=&quot;headerlink&quot; title=&quot;1.在github上面新建一个仓库&quot;&gt;&lt;/a&gt;1.在github上面新建一个仓库&lt;/h2&gt;&lt;p&gt;首先我们需要在自己的github上新建一个仓库，将仓库的命名为xxx.github.io，一定要按该格式命名，否则不能搭建成功&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yuzeyang.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>iOS 同时修改button位置和文字问题</title>
    <link href="http://yuzeyang.github.io/2016/04/09/button-location-title-bug/"/>
    <id>http://yuzeyang.github.io/2016/04/09/button-location-title-bug/</id>
    <published>2016-04-09T03:27:16.000Z</published>
    <updated>2016-05-21T03:39:19.000Z</updated>
    
    <content type="html">&lt;p&gt;今天在写App的登录注册界面，其中登录和注册之间的切换和印象笔记一样&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Evernote.gif!500x500&quot; alt=&quot;印象笔记登录界面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;中间的登录按钮会有一个下移以及更改文字的操作，但是我在加了下移动画之后，再修改按钮的文字，就出现了很奇怪的现象，按钮会先下移然后修改文字之后，又跳回到最初的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Evernote%20bug.gif!500x500&quot; alt=&quot;问题操作&quot;&gt;&lt;br&gt;这就奇怪了，看逻辑上一点错误也没有，那怎么会这样呢？&lt;/p&gt;
&lt;p&gt;检查了下按钮的类型也是自定义的，那会不会是动画影响的呢？&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在block里面，我在setTitle:forState的方法外面，去掉动画的影响&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[UIView setAnimationsEnabled:NO];&amp;#10;[self.loginButton setTitle:@&amp;#34;&amp;#27880; &amp;#160; &amp;#20876;&amp;#34; forState:UIControlStateNormal];&amp;#10;[self.loginButton layoutIfNeeded];&amp;#10;[UIView setAnimationsEnabled:YES];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[UIView performWithoutAnimation:^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; [self.loginButton setTitle:@&amp;#34;&amp;#27880; &amp;#160; &amp;#20876;&amp;#34; forState:UIControlStateNormal];&amp;#10;        [self.loginButton layoutIfNeeded];&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;都还是不行。。。&lt;/p&gt;
&lt;p&gt;干脆把动画方法去掉，直接改变按钮的位置再试试。。结果还是一样，那就纳闷了。。&lt;/p&gt;
&lt;p&gt;后来找了很久的资料发现，原来是受到了autolayout的影响，因为在广泛开始使用autolayout之后，在storyboard，nib和实现文件里面，我们可能不像以前那样去繁琐的计算坐标了，我们通过自适应的方式，去确定控件的位置&lt;/p&gt;
&lt;p&gt;因为我的登录按钮是自适应的，所以在修改了按钮位置后，再修改文字，就会出现这样的问题，但是我打印了很多方法，都没有发现调用，所以不知道系统在设置文字的时候，又调用了哪个方法&lt;/p&gt;
&lt;p&gt;我试着调用了修改其他的属性的方法，比如背景色，setImage：forState，这些都没事，凡是调用了title相关的三个设置都会这样。。我就满脸黑线了。。&lt;/p&gt;
&lt;p&gt;所以目前能找到的解决办法就是，该按钮&lt;strong&gt;用坐标计算的方式添加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果哪位大神找到更好的解决办法，欢迎留言~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在写App的登录注册界面，其中登录和注册之间的切换和印象笔记一样&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/Evernote.gif!500x500&quot; alt=&quot;印象笔记登录界面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;中
    
    </summary>
    
    
      <category term="button" scheme="http://yuzeyang.github.io/tags/button/"/>
    
  </entry>
  
  <entry>
    <title>iOS 简单下载动画</title>
    <link href="http://yuzeyang.github.io/2016/03/27/simple-download-animation/"/>
    <id>http://yuzeyang.github.io/2016/03/27/simple-download-animation/</id>
    <published>2016-03-27T03:22:17.000Z</published>
    <updated>2016-05-21T03:40:35.000Z</updated>
    
    <content type="html">&lt;p&gt;这个动画比较简单基础，首先我们来看一下这个动画模拟的动图&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/downloadAnimation.gif!500x500&quot; alt=&quot;下载动画&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;动画一共有四个状态，&lt;strong&gt;开始下载&lt;/strong&gt;、&lt;strong&gt;下载结束&lt;/strong&gt;、&lt;strong&gt;下载成功&lt;/strong&gt;和&lt;strong&gt;下载失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么会分有&lt;strong&gt;下载结束&lt;/strong&gt;这样的状态呢？因为考虑到实际场景，可能会有在加载过程中，用户返回上级界面，我们需要结束下载动画&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们按状态来实现，首先先看开始加载&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *rotationZAnimation = [CABasicAnimation animationWithKeyPath:@&amp;#34;transform.rotation.z&amp;#34;];&amp;#10;rotationZAnimation.fromValue = @(0);&amp;#10;rotationZAnimation.toValue = @(M_PI*2);&amp;#10;rotationZAnimation.repeatDuration = HUGE_VAL;&amp;#10;rotationZAnimation.duration = 1.0;&amp;#10;rotationZAnimation.cumulative = YES;&amp;#10;rotationZAnimation.beginTime = CACurrentMediaTime();&amp;#10;[self.loadingLayer addAnimation:rotationZAnimation forKey:@&amp;#34;rotationZAnimation&amp;#34;];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth];&amp;#10;CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];&amp;#10;[self.loadingLayer addAnimation:boundsAnimation forKey:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里分为两个动画，一个是&lt;strong&gt;旋转动画&lt;/strong&gt;，一个是&lt;strong&gt;放大缩小的动画&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;旋转动画&lt;/strong&gt;，我们只有一个初始值和末值，所以我们只需要使用CABasicAnimation就可以了，不需要使用CAKeyframeAnimation，CAKeyframeAnimation是用来处理关键帧动画的，它的values属性用来存储关键帧的值，这就是我们用来做处理&lt;strong&gt;放大缩小动画&lt;/strong&gt;，上面代码可以看到我将它抽成了一个方法来用，因为在下载成功和失败的时候，成功和失败也是有放大缩小的动画，这三个其实是一个动画&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSArray *)valueArrayWithWidth:(CGFloat)width &amp;#123;&amp;#10;&amp;#160; &amp;#160; return @[[NSValue valueWithCGRect:CGRectMake(0, 0, width * 0.7, width * 0.7)],&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSValue valueWithCGRect:CGRectMake(0, 0, width, width)],&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [NSValue valueWithCGRect:CGRectMake(0, 0, width * 0.9, width * 0.9)]];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (CAKeyframeAnimation *)bounsAnimationWithValues:(NSArray *)values &amp;#123;&amp;#10;&amp;#160; &amp;#160; CAKeyframeAnimation *boundsAnimation = [CAKeyframeAnimation animationWithKeyPath:@&amp;#34;bounds&amp;#34;];&amp;#10;&amp;#160; &amp;#160; boundsAnimation.duration = 0.6;&amp;#10;&amp;#160; &amp;#160; boundsAnimation.beginTime = CACurrentMediaTime();&amp;#10;&amp;#160; &amp;#160; boundsAnimation.values = values;&amp;#10;&amp;#160; &amp;#160; boundsAnimation.keyTimes = @[@(0),@(0.3),@(0.6)];&amp;#10;&amp;#160; &amp;#160; boundsAnimation.timingFunctions = @[[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut],&amp;#10;&amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; &amp;#160; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];&amp;#10;&amp;#160; &amp;#160; boundsAnimation.removedOnCompletion = NO;&amp;#10;&amp;#160; &amp;#160; boundsAnimation.fillMode = kCAFillModeForwards;&amp;#10;&amp;#160; &amp;#160; return boundsAnimation;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们统一设置动画的values值，这里传入的width值是下载的背景大小，因为下载圆圈有个放大的过程，所以我们需要圆圈的原始大小要比背景的大小小，所以我默认设置圆圈的大小是背景大小的0.9倍，所以动画的效果是圆圈从背景大小的0.7倍-&amp;gt;背景大小-&amp;gt;背景大小的0.9倍（圆圈的原始大小）&lt;br&gt;在设置这个动画的时候，因为动画的值不止是初始值和末值，还是中间值，所以我使用CAKeyframeAnimation来做，每个关键帧之间的动画时间设置为0.3秒，这是最适合的动画时间，当然这是时间还是由自己反复调试动画决定的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下载结束我们只要将转圈的动画移除掉即可，这样转圈就恢复到原来的状态了&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.loadingLayer removeAllAnimations];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下载成功我们也需要将转圈动画移除，然后出现成功的动画，并且将成功图层的透明度从0变到1&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.loadingLayer removeAllAnimations];&amp;#10;self.failLayer.opacity = 0.0;&amp;#10;NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth * 0.5];&amp;#10;CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];&amp;#10;[self.doneLayer addAnimation:boundsAnimation forKey:nil];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;[UIView animateWithDuration:1.0 animations:^&amp;#123;&amp;#10;&amp;#160; &amp;#160; self.doneLayer.opacity = 1.0;&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下载失败也是同理&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.loadingLayer removeAllAnimations];&amp;#10;self.doneLayer.opacity = 0.0;&amp;#10;NSArray *values = [self valueArrayWithWidth:self.downloadingViewWidth * 0.5];&amp;#10;CAKeyframeAnimation *boundsAnimation = [self bounsAnimationWithValues:values];&amp;#10;[self.failLayer addAnimation:boundsAnimation forKey:nil];&amp;#10;&amp;#160;&amp;#160; &amp;#160; &amp;#160; &amp;#160;&amp;#10;[UIView animateWithDuration:1.0 animations:^&amp;#123;&amp;#10;&amp;#160; &amp;#160; &amp;#160;self.failLayer.opacity = 1.0;&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;好了，动画主要的原理就是这样，具体的代码实现可以看这里：&lt;a href=&quot;https://github.com/Yuzeyang/DownloadingAnimation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Yuzeyang/DownloadingAnimation&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这个动画比较简单基础，首先我们来看一下这个动画模拟的动图&lt;br&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/downloadAnimation.gif!500x500&quot; alt=&quot;下载动画&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;动画
    
    </summary>
    
    
      <category term="下载动画" scheme="http://yuzeyang.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（二）</title>
    <link href="http://yuzeyang.github.io/2016/03/15/AFNetWorking-two/"/>
    <id>http://yuzeyang.github.io/2016/03/15/AFNetWorking-two/</id>
    <published>2016-03-15T07:34:30.000Z</published>
    <updated>2016-06-12T15:28:26.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;继承于&lt;code&gt;AFURLSessionManager&lt;/code&gt;，提供了更方便的HTTP请求方法，包括了GET、POST、PUT、PATCH、DELETE这五种方式，并且AF鼓励我们在&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;再进行一次封装来满足我们自己的业务需求&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;在开始的地方，AF一直提醒到一个属性&lt;code&gt;baseURL&lt;/code&gt;，这个变量你可以在进一步封装的时候，将&lt;code&gt;baseURL&lt;/code&gt;写成你自己的HTTP请求原始地址，比如&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (NSURL *)baseURL &amp;#123;&amp;#10;    return [NSURL URLWithString:kBaseURLString];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在对&lt;code&gt;baseURL&lt;/code&gt;进行拼接的时候，也需要注意一下几点，防止出现请求的URL出现问题&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL *baseURL = [NSURL URLWithString:@&amp;#34;http://example.com/v1/&amp;#34;];&amp;#10;    [NSURL URLWithString:@&amp;#34;foo&amp;#34; relativeToURL:baseURL];                  // http://example.com/v1/foo&amp;#10;    [NSURL URLWithString:@&amp;#34;foo?bar=baz&amp;#34; relativeToURL:baseURL];          // http://example.com/v1/foo?bar=baz&amp;#10;    [NSURL URLWithString:@&amp;#34;/foo&amp;#34; relativeToURL:baseURL];                 // http://example.com/foo&amp;#10;    [NSURL URLWithString:@&amp;#34;foo/&amp;#34; relativeToURL:baseURL];                 // http://example.com/v1/foo&amp;#10;    [NSURL URLWithString:@&amp;#34;/foo/&amp;#34; relativeToURL:baseURL];                // http://example.com/foo/&amp;#10;    [NSURL URLWithString:@&amp;#34;http://example2.com/&amp;#34; relativeToURL:baseURL]; // http://example2.com/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在初始化的方法里面，我们看到这个方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithBaseURL:(nullable NSURL *)url;&amp;#10;- (instancetype)initWithBaseURL:(nullable NSURL *)url&amp;#10;           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;NS_DESIGNATED_INITIALIZER&lt;/code&gt;的作用是什么呢？&lt;br&gt;指定的构造器通过发送初始化消息到父类来保证object被完全初始化，指定构造器有以下几个规则：&lt;/p&gt;
&lt;p&gt;1.指定构造器必须调用父类的指定构造器&lt;/p&gt;
&lt;p&gt;2.任何一个便利构造器必须调用最终指向指定构造器的其他构造器&lt;/p&gt;
&lt;p&gt;3.具有指定构造器的类必须实现父类的所有指定构造器&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)init &amp;#123;&amp;#10;    // &amp;#25351;&amp;#21521;- [initWithBaseURL:]&amp;#10;  &amp;#9;return [self initWithBaseURL:nil];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (instancetype)initWithBaseURL:(NSURL *)url &amp;#123;&amp;#10;    // &amp;#25351;&amp;#21521;- [initWithBaseURL:sessionConfiguration:]&amp;#10;    return [self initWithBaseURL:url sessionConfiguration:nil];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &amp;#123;&amp;#10;    // &amp;#25351;&amp;#21521;- [initWithBaseURL:sessionConfiguration:]&amp;#10;    return [self initWithBaseURL:nil sessionConfiguration:configuration];&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (instancetype)initWithBaseURL:(NSURL *)url&amp;#10;           sessionConfiguration:(NSURLSessionConfiguration *)configuration&amp;#10;&amp;#123;&amp;#10;    // &amp;#35843;&amp;#29992;&amp;#29238;&amp;#31867;&amp;#30340;- [initWithSessionConfiguration:]&amp;#10;    self = [super initWithSessionConfiguration:configuration];&amp;#10;    if (!self) &amp;#123;&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    // baseURL&amp;#36171;&amp;#20540;&amp;#65292;AFHTTPRequestSerializer&amp;#21644;AFJSONResponseSerializer&amp;#24207;&amp;#21015;&amp;#21270;&amp;#10;    &amp;#10;    return self;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;DEPRECATED_ATTRIBUTE&lt;/code&gt;这个相信大家见得比较多了，字面意思就是这个API不建议开发者再使用了，再使用时，会出现编译警告&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString&amp;#10;                   parameters:(nullable id)parameters&amp;#10;                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success&amp;#10;                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;下面POST、GET、PUT、PATCH、DELETE方法传参基本都是大同小异&lt;/p&gt;
&lt;p&gt;&lt;code&gt;URLString&lt;/code&gt;表示请求的URL，&lt;code&gt;parameters&lt;/code&gt;表示客户端请求内容的存储器，&lt;code&gt;progress&lt;/code&gt;表示请求的进度，&lt;code&gt;constructingBodyWithBlock&lt;/code&gt;里面只有一个formData用来拼接到HTTP的请求体，&lt;code&gt;success&lt;/code&gt;表示请求成功后的block回调，&lt;code&gt;failure&lt;/code&gt;表示请求失败的block回调&lt;/p&gt;
&lt;p&gt;那么这几个请求有什么区别呢？&lt;/p&gt;
&lt;p&gt;1、POST请求是向服务端发送数据的，用来更新资源信息，它可以改变数据的种类等资源&lt;/p&gt;
&lt;p&gt;2、GET请求是向服务端发起请求数据，用来获取或查询资源信息&lt;/p&gt;
&lt;p&gt;3、PUT请求和POST请求很像，都是发送数据的，但是PUT请求不能改变数据的种类等资源，它只能修改内容&lt;/p&gt;
&lt;p&gt;4、DELETE请求就是用来删除某个资源的&lt;/p&gt;
&lt;p&gt;5、PATCH请求和PUT请求一样，也是用来进行数据更新的，它是HTTP verb推荐用于更新的&lt;/p&gt;
&lt;p&gt;在实际开发过程中，我们还是使用POST和GET请求是最多的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在请求实现的部分，都是调用了&lt;code&gt;-[dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure]&lt;/code&gt;方法创建&lt;code&gt;NSURLSessionDataTask&lt;/code&gt;对象&lt;/p&gt;
&lt;p&gt;传参的内容基本都是和上一层方法一样，&lt;code&gt;method&lt;/code&gt;指的就是请求的类型&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method&amp;#10;                                       URLString:(NSString *)URLString&amp;#10;                                      parameters:(id)parameters&amp;#10;                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress&amp;#10;                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress&amp;#10;                                         success:(void (^)(NSURLSessionDataTask *, id))success&amp;#10;                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure&amp;#10;&amp;#123;&amp;#10;&amp;#10;    NSError *serializationError = nil;&amp;#10;    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;#38;serializationError];&amp;#10;    if (serializationError) &amp;#123;&amp;#10;        if (failure) &amp;#123;&amp;#10;#pragma clang diagnostic push&amp;#10;#pragma clang diagnostic ignored &amp;#34;-Wgnu&amp;#34;&amp;#10;            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&amp;#123;&amp;#10;                failure(nil, serializationError);&amp;#10;            &amp;#125;);&amp;#10;#pragma clang diagnostic pop&amp;#10;        &amp;#125;&amp;#10;&amp;#10;        return nil;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    __block NSURLSessionDataTask *dataTask = nil;&amp;#10;    dataTask = [self dataTaskWithRequest:request&amp;#10;                          uploadProgress:uploadProgress&amp;#10;                        downloadProgress:downloadProgress&amp;#10;                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &amp;#123;&amp;#10;        // &amp;#22833;&amp;#36133;&amp;#25104;&amp;#21151;&amp;#22788;&amp;#29702;&amp;#10;    &amp;#125;];&amp;#10;&amp;#10;    return dataTask;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;继承于&lt;code&gt;AFURLSessionManager&lt;/code&gt;，提供了更方便的HTTP请求方法，包括了GET、POST、PUT、PATCH、DELETE这五种方式，并且AF鼓励我们在&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;再进行一次封装来满足我们自己的业务需求&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS AFNetWorking源码详解（一）</title>
    <link href="http://yuzeyang.github.io/2016/02/21/AFNetWorking-one/"/>
    <id>http://yuzeyang.github.io/2016/02/21/AFNetWorking-one/</id>
    <published>2016-02-21T03:47:48.000Z</published>
    <updated>2016-06-12T15:23:30.000Z</updated>
    
    <content type="html">&lt;p&gt;首先来介绍下AFNetWorking，官方介绍如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Foundation URL Loading System&lt;/a&gt;, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.&lt;/p&gt;
&lt;p&gt;Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.&lt;/p&gt;
&lt;p&gt;Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来简单来说就是&lt;/p&gt;
&lt;p&gt;AFNetworking是一个适用于iOS和Mac OS X两个平台的网络库，它是基于&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Foundation URL Loading System&lt;/a&gt;上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;相信从star数和fork数来看，大家都能明白这个库是多么的受欢迎了，所以了解这个库对于一个iOS开发来说是极为重要的！&lt;/p&gt;
&lt;p&gt;这个是AFNetworking的github地址：&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub - AFNetworking/AFNetworking: A delightful networking framework for iOS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在使用前阅读README是非常重要的，里面往往包括了这个库的介绍、安装和使用等等，对于快速了解一个库来说，这是非常有帮助的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先我们在&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AFNetWorking源码地址&lt;/a&gt;里download下来，打开工程文件，可以看到里面内容分为两个部分，一个是AFNetworking，另一个是UIKit+AFNetworking&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/AFNetWorking_file.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;很明显，第一个是用来做网络请求相关的，第二个则是和UI使用相关的，我们先看第一个&lt;/p&gt;
&lt;p&gt;在看完头文件和README之后，你会发现&lt;code&gt;AFURLSessionManager&lt;/code&gt;和&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;是里面比较重要的两个类&lt;/p&gt;
&lt;p&gt;这里我先讲&lt;code&gt;AFURLSessionManager&lt;/code&gt;这个类&lt;/p&gt;
&lt;p&gt;首先浏览完这个类从API，发现其主要提供了数据的请求、上传和下载功能&lt;/p&gt;
&lt;p&gt;在属性方面：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property(readonly,nonatomic,strong)NSArray *tasks;&amp;#10;&amp;#10;@property(readonly,nonatomic,strong)NSArray *dataTasks;&amp;#10;&amp;#10;@property(readonly,nonatomic,strong)NSArray *uploadTasks;&amp;#10;&amp;#10;@property(readonly,nonatomic,strong)NSArray *downloadTasks;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过这四个属性，我们分别可以拿到总的任务集合、数据任务集合、上传任务集合和下载任务集合&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property(nonatomic,assign)BOOL attemptsToRecreateUploadTasksForBackgroundSessions;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个属性非常重要，注释里面写到，在iOS7中存在一个bug，在创建后台上传任务时，有时候会返回nil，所以为了解决这个问题，AFNetworking遵照了苹果的建议，在创建失败的时候，会重新尝试创建，次数默认为3次，所以你的应用如果有场景会有在后台上传的情况的话，记得将该值设为YES，避免出现上传失败的问题&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidResumeNotification;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在对外提供的notification key里面，使用了&lt;code&gt;FOUNDATION_EXPORT&lt;/code&gt;来定义常量，使用&lt;code&gt;FOUNDATION_EXPORT&lt;/code&gt;和&lt;code&gt;extern&lt;/code&gt;或者&lt;code&gt;define&lt;/code&gt;有什么区别呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FOUNDATION_EXPORT&lt;/code&gt;在c文件编译下是和extern等同，在c++文件编译下是和extern “C”等同，在32位机的环境下又是另外编译情况，在兼容性方面，&lt;code&gt;FOUNDATION_EXPORT&lt;/code&gt;做的会更好。&lt;/p&gt;
&lt;p&gt;这里还提到了效率方面的问题：&lt;a href=&quot;http://www.jianshu.com/p/f547eb0368c4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS开发的一些奇巧淫技3&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;进入到实现文件里面，我们可以看到在外部API调用dataTask、uploadTask、downloadTask方法实际上都是completionHanlder block返回出来的，但是我们知道网络请求是delegate返回结果的，AF内部做了巧妙的操作，他对每个task都增加代理设置&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request&amp;#10;                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock&amp;#10;                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock&amp;#10;                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &amp;#123;&amp;#10;&amp;#9;__block NSURLSessionDataTask *dataTask = nil;&amp;#10;    url_session_manager_create_task_safely(^&amp;#123;&amp;#10;        dataTask = [self.session dataTaskWithRequest:request];&amp;#10;    &amp;#125;);&amp;#10;    &amp;#10;&amp;#9;// &amp;#27599;&amp;#20010;task&amp;#37324;&amp;#38754;&amp;#37117;&amp;#20250;&amp;#35843;&amp;#29992;addDelegate&amp;#26041;&amp;#27861;&amp;#10;    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];&amp;#10;&amp;#10;    return dataTask;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在设置里面，每个task会在内部创建&lt;code&gt;AFURLSessionManagerTaskDelegate&lt;/code&gt;对象，并设置completionHandler、uploadProgressBlock、downloadProgressBlock回调&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask&amp;#10;                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock&amp;#10;              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock&amp;#10;             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&amp;#10;&amp;#123;&amp;#10;    // &amp;#21021;&amp;#22987;&amp;#21270;delegate&amp;#23545;&amp;#35937;&amp;#10;    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];&amp;#10;    delegate.manager = self;&amp;#10;    // &amp;#23558;task&amp;#30340;completionHandler&amp;#36171;&amp;#32473;delegate&amp;#65292;&amp;#31995;&amp;#32479;&amp;#32593;&amp;#32476;&amp;#35831;&amp;#27714;delegate &amp;#35843;&amp;#29992;&amp;#35813;block&amp;#65292;&amp;#36820;&amp;#22238;&amp;#32467;&amp;#26524;&amp;#10;    delegate.completionHandler = completionHandler;&amp;#10;&amp;#10;    dataTask.taskDescription = self.taskDescriptionForSessionTasks;&amp;#10;    // &amp;#23545;task&amp;#36827;&amp;#34892;delegate&amp;#10;    [self setDelegate:delegate forTask:dataTask];&amp;#10;&amp;#9;// &amp;#35774;&amp;#32622;&amp;#19978;&amp;#20256;&amp;#21644;&amp;#19979;&amp;#36733;&amp;#36827;&amp;#24230;&amp;#22238;&amp;#35843;&amp;#10;    delegate.uploadProgressBlock = uploadProgressBlock;&amp;#10;    delegate.downloadProgressBlock = downloadProgressBlock;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后delegate对象利用kvo将task对一些方法进行监听，并且监听到变化时，通过block返回，将delegate转成block出去&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate&amp;#10;            forTask:(NSURLSessionTask *)task&amp;#10;&amp;#123;&amp;#10;    // &amp;#26029;&amp;#35328;&amp;#10;    NSParameterAssert(task);&amp;#10;    NSParameterAssert(delegate);&amp;#10;&amp;#10;    [self.lock lock];&amp;#10;    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;&amp;#10;    // task&amp;#20351;&amp;#29992;kvo&amp;#23545;&amp;#19968;&amp;#20123;&amp;#26041;&amp;#27861;&amp;#30417;&amp;#21548;&amp;#65292;&amp;#36820;&amp;#22238;&amp;#19978;&amp;#20256;&amp;#25110;&amp;#32773;&amp;#19979;&amp;#36733;&amp;#30340;&amp;#36827;&amp;#24230;&amp;#10;    [delegate setupProgressForTask:task];&amp;#10;    // sessionManager&amp;#23545;&amp;#26242;&amp;#20572;task&amp;#21644;&amp;#24674;&amp;#22797;task&amp;#36827;&amp;#34892;&amp;#27880;&amp;#20876;&amp;#36890;&amp;#30693;&amp;#10;    [self addNotificationObserverForTask:task];&amp;#10;    [self.lock unlock];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在原先IM的设计时，因为接口的数量并不多，所以在AsyncSocket的delegate回调后，我们依旧是采用delegate回调给业务层，但是随着接口数量的增加，业务层对于回调的处理更加困难和不可控，在重构IM的时候，我们也参考学习了AF的做法，我们通过对唯一标识和每个请求做一一绑定，将请求的上下文关联起来，这样让socket长连接的请求的也想http请求一样，都由block回去，对于业务层的处理也方便更多&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setupProgressForTask&lt;/code&gt;方法主要是对task和progress设置监听&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)setupProgressForTask:(NSURLSessionTask *)task &amp;#123;&amp;#10;    __weak __typeof__(task) weakTask = task;&amp;#10;&amp;#10;    // &amp;#35774;&amp;#32622;&amp;#19978;&amp;#20256;&amp;#21644;&amp;#19979;&amp;#36733;&amp;#30340;&amp;#22823;&amp;#23567;&amp;#10;    &amp;#10;    // &amp;#35774;&amp;#32622;&amp;#19978;&amp;#20256;&amp;#21644;&amp;#19979;&amp;#36733;&amp;#20013;&amp;#20801;&amp;#35768;&amp;#21462;&amp;#28040;&amp;#21644;&amp;#26242;&amp;#20572;&amp;#10;  &amp;#10;  &amp;#9;// &amp;#35774;&amp;#32622;&amp;#19978;&amp;#20256;&amp;#21644;&amp;#19979;&amp;#36733;&amp;#21709;&amp;#24212;&amp;#24674;&amp;#22797;&amp;#22788;&amp;#29702;&amp;#26041;&amp;#27861;&amp;#21518;&amp;#24674;&amp;#22797;&amp;#19978;&amp;#20256;&amp;#25110;&amp;#19979;&amp;#36733;&amp;#10;    &amp;#10;    // task&amp;#23545;&amp;#25509;&amp;#25910;&amp;#21040;&amp;#30340;&amp;#23383;&amp;#33410;&amp;#25968;&amp;#12289;&amp;#26399;&amp;#26395;&amp;#25509;&amp;#25910;&amp;#21040;&amp;#30340;&amp;#23383;&amp;#33410;&amp;#25968;&amp;#12289;&amp;#21457;&amp;#36865;&amp;#30340;&amp;#23383;&amp;#33410;&amp;#25968;&amp;#12289;&amp;#26399;&amp;#26395;&amp;#21457;&amp;#36865;&amp;#30340;&amp;#23383;&amp;#33410;&amp;#25968;&amp;#35774;&amp;#32622;&amp;#30417;&amp;#21548;&amp;#10;    [task addObserver:self&amp;#10;           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))&amp;#10;              options:NSKeyValueObservingOptionNew&amp;#10;              context:NULL];&amp;#10;    [task addObserver:self&amp;#10;          forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))&amp;#10;              options:NSKeyValueObservingOptionNew&amp;#10;              context:NULL];&amp;#10;&amp;#10;    [task addObserver:self&amp;#10;           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))&amp;#10;              options:NSKeyValueObservingOptionNew&amp;#10;              context:NULL];&amp;#10;    [task addObserver:self&amp;#10;           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))&amp;#10;              options:NSKeyValueObservingOptionNew&amp;#10;              context:NULL];&amp;#10;&amp;#9;// &amp;#19978;&amp;#20256;&amp;#21644;&amp;#19979;&amp;#36733;&amp;#35774;&amp;#32622;&amp;#23436;&amp;#25104;&amp;#30340;&amp;#20998;&amp;#25968;&amp;#30417;&amp;#21548;&amp;#10;    [self.downloadProgress addObserver:self&amp;#10;                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))&amp;#10;                               options:NSKeyValueObservingOptionNew&amp;#10;                               context:NULL];&amp;#10;    [self.uploadProgress addObserver:self&amp;#10;                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))&amp;#10;                             options:NSKeyValueObservingOptionNew&amp;#10;                             context:NULL];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;#60;NSString *,id&amp;#62; *)change context:(void *)context &amp;#123;&amp;#10;    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &amp;#123;&amp;#10;        // &amp;#35774;&amp;#32622;&amp;#19978;&amp;#20256;&amp;#21644;&amp;#19979;&amp;#36733;&amp;#30340;&amp;#26032;&amp;#20540;&amp;#10;    &amp;#125;&amp;#10;    else if ([object isEqual:self.downloadProgress]) &amp;#123;&amp;#10;        if (self.downloadProgressBlock) &amp;#123;&amp;#10;            self.downloadProgressBlock(object);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    else if ([object isEqual:self.uploadProgress]) &amp;#123;&amp;#10;        if (self.uploadProgressBlock) &amp;#123;&amp;#10;            self.uploadProgressBlock(object);&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在第一个if判断里面，object判断是否是&lt;code&gt;NSURLSessionTask&lt;/code&gt;类或者是否是&lt;code&gt;NSURLSessionDownloadTask&lt;/code&gt;类，但是进到&lt;code&gt;NSURLSessionDownloadTask&lt;/code&gt;的时候，我们可以看到&lt;code&gt;NSURLSessionDownloadTask&lt;/code&gt;是&lt;code&gt;NSURLSessionTask&lt;/code&gt;的子类，那为什么还要判断这个呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSURLSessionTask&lt;/code&gt;实际上是&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ClassCluster.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Class cluster&lt;/a&gt;，通过&lt;code&gt;NSURLSession&lt;/code&gt;生成的task返回的并不一定是指定的task类型。因此kindOfClass并不总会生效，具体可以参见&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L382~L414&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AFURLSessionManager.m在load方法中的说明&lt;/a&gt;。&lt;br&gt;特定于当前问题，是由于iOS 7上&lt;strong&gt;NSCFURLSessionDownloadTask的基类并不是&lt;/strong&gt;&lt;code&gt;NSCFURLSessionTask&lt;/code&gt;，因此isKindOfClass会出错。查看对应的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/commit/a745be4fcd75de75b560dce1d689b6bcc11f42ba#diff-dd81ac1f455a60ac8065ade41f06881f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;commit&lt;/a&gt;就可以知道了。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;NSURLSessionTaskDelegate&lt;/code&gt;的代理里面，只是做了两件事情，第一个是获取数据，将responseSerializer和downloadFileURL或data存到userInfo里面，第二个是根据error是否为空值，做下一步处理&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - NSURLSessionTaskDelegate&amp;#10;&amp;#10;- (void)URLSession:(__unused NSURLSession *)session&amp;#10;              task:(NSURLSessionTask *)task&amp;#10;didCompleteWithError:(NSError *)error&amp;#10;&amp;#123;&amp;#10;#pragma clang diagnostic push&amp;#10;#pragma clang diagnostic ignored &amp;#34;-Wgnu&amp;#34;&amp;#10;    // &amp;#33719;&amp;#21462;&amp;#25968;&amp;#25454;&amp;#65292;&amp;#23558;responseSerializer&amp;#21644;downloadFileURL&amp;#25110;data&amp;#23384;&amp;#21040;userInfo&amp;#37324;&amp;#38754;&amp;#10;    __strong AFURLSessionManager *manager = self.manager;&amp;#10;&amp;#10;    __block id responseObject = nil;&amp;#10;&amp;#10;    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];&amp;#10;    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;&amp;#10;&amp;#10;    //Performance Improvement from #2672&amp;#10;    NSData *data = nil;&amp;#10;    if (self.mutableData) &amp;#123;&amp;#10;        data = [self.mutableData copy];&amp;#10;        //We no longer need the reference, so nil it out to gain back some memory.&amp;#10;        self.mutableData = nil;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    if (self.downloadFileURL) &amp;#123;&amp;#10;        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;&amp;#10;    &amp;#125; else if (data) &amp;#123;&amp;#10;        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    if (error) &amp;#123;&amp;#10;      // &amp;#26377;error&amp;#26102;&amp;#22788;&amp;#29702;&amp;#10;    &amp;#125; else &amp;#123;&amp;#10;      // &amp;#26080;error&amp;#26102;&amp;#27491;&amp;#24120;&amp;#22788;&amp;#29702;&amp;#10;    &amp;#125;&amp;#10;#pragma clang diagnostic pop&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在有error时，userInfo先存储error，然后检查manager是否有completionGroup和completionQueue，没有的话，就创建一个dispatch_group_t和在主线程上做completionHandler的操作，并在主线程中发送一个AFNetworkingTaskDidCompleteNotification通知，这个通知在UIKit+AFNetworking里UIRefreshControl +AFNetworking里也会接收到，用来停止刷新，如果你不使用AF的UI部分，你可以通过接收这个通知来做操作&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;&amp;#10;&amp;#10;dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&amp;#123;&amp;#10;            if (self.completionHandler) &amp;#123;&amp;#10;                self.completionHandler(task.response, responseObject, error);&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];&amp;#10;            &amp;#125;);&amp;#10;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在没有error时，会先对数据进行一次序列化操作，然后下面的处理就和有error的那部分一样了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(url_session_manager_processing_queue(), ^&amp;#123;&amp;#10;            NSError *serializationError = nil;&amp;#10;            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;#38;serializationError];&amp;#10;&amp;#10;            if (self.downloadFileURL) &amp;#123;&amp;#10;                responseObject = self.downloadFileURL;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            if (responseObject) &amp;#123;&amp;#10;                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            if (serializationError) &amp;#123;&amp;#10;                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;&amp;#10;            &amp;#125;&amp;#10;&amp;#10;            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&amp;#123;&amp;#10;                if (self.completionHandler) &amp;#123;&amp;#10;                    self.completionHandler(task.response, responseObject, serializationError);&amp;#10;                &amp;#125;&amp;#10;&amp;#10;                dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&amp;#10;                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];&amp;#10;                &amp;#125;);&amp;#10;            &amp;#125;);&amp;#10;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一开始我们就看到了clang命令，这个的作用是用来消除特定区域的clang的编译警告，-Wgnu则是消除?:警告，这个是clang的警告message列表&lt;a href=&quot;http://fuckingclangwarnings.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Which Clang Warning Is Generating This Message?&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)URLSession:(__unused NSURLSession *)session&amp;#10;              task:(NSURLSessionTask *)task&amp;#10;didCompleteWithError:(NSError *)error&amp;#10;&amp;#123;&amp;#10;#pragma clang diagnostic push&amp;#10;&amp;#10;#pragma clang diagnostic ignored &amp;#34;-Wgnu&amp;#34;&amp;#10;&amp;#10;// some codes&amp;#10;&amp;#10;#pragma clang diagnostic pop&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再下面两个则是收到数据和下载文件的回调处理&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - NSURLSessionDataTaskDelegate&amp;#10;&amp;#10;- (void)URLSession:(__unused NSURLSession *)session&amp;#10;          dataTask:(__unused NSURLSessionDataTask *)dataTask&amp;#10;    didReceiveData:(NSData *)data&amp;#10;&amp;#123;&amp;#10;    [self.mutableData appendData:data];&amp;#10;&amp;#125;&amp;#10;&amp;#10;#pragma mark - NSURLSessionDownloadTaskDelegate&amp;#10;&amp;#10;- (void)URLSession:(NSURLSession *)session&amp;#10;      downloadTask:(NSURLSessionDownloadTask *)downloadTask&amp;#10;didFinishDownloadingToURL:(NSURL *)location&amp;#10;&amp;#123;&amp;#10;    NSError *fileManagerError = nil;&amp;#10;    self.downloadFileURL = nil;&amp;#10;&amp;#10;    if (self.downloadTaskDidFinishDownloading) &amp;#123;&amp;#10;        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);&amp;#10;        if (self.downloadFileURL) &amp;#123;&amp;#10;            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;#38;fileManagerError];&amp;#10;&amp;#10;            if (fileManagerError) &amp;#123;&amp;#10;                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在刚才说到的load方法里面，对系统的resume和suspend方法进行了替换&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &amp;#123;&amp;#10;    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));&amp;#10;    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));&amp;#10;&amp;#10;    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &amp;#123;&amp;#10;        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &amp;#123;&amp;#10;        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;替换之后，只是增加了通知处理而已&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)af_resume &amp;#123;&amp;#10;    NSAssert([self respondsToSelector:@selector(state)], @&amp;#34;Does not respond to state&amp;#34;);&amp;#10;    NSURLSessionTaskState state = [self state];&amp;#10;    [self af_resume];&amp;#10;    &amp;#10;    if (state != NSURLSessionTaskStateRunning) &amp;#123;&amp;#10;        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&amp;#10;&amp;#10;- (void)af_suspend &amp;#123;&amp;#10;    NSAssert([self respondsToSelector:@selector(state)], @&amp;#34;Does not respond to state&amp;#34;);&amp;#10;    NSURLSessionTaskState state = [self state];&amp;#10;    [self af_suspend];&amp;#10;    &amp;#10;    if (state != NSURLSessionTaskStateSuspended) &amp;#123;&amp;#10;        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在调用替换和增加方法时候，用到了关键字inline，inline是为了防止反汇编之后，在符号表里面看不到你所调用的该方法，否则别人可以通过篡改你的返回值来造成攻击，&lt;a href=&quot;http://www.blogfshare.com/ioss-static-inline.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS安全–使用static inline方式编译函数，防止静态分析&lt;/a&gt;，特别是在使用swizzling的时候，那除了使用swizzling动态替换函数方法之外，还有别的方法么？有，修改IMP指针指向的方法，&lt;a href=&quot;http://www.cocoachina.com/ios/20150717/12623.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;轻松学习之 IMP指针的作用 - CocoaChina_让移动开发更简单&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &amp;#123;&amp;#10;    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);&amp;#10;    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);&amp;#10;    method_exchangeImplementations(originalMethod, swizzledMethod);&amp;#10;&amp;#125;&amp;#10;&amp;#10;static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) &amp;#123;&amp;#10;    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在+ load方法中，我们又看到了GCC命令，那clang和GCC在使用的时机有没有什么区别？&lt;a href=&quot;http://stackoverflow.com/questions/11838379/should-i-use-pragma-gcc-or-pragma-clang-in-xcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;通常情况下，在GCC特有的处理或者是在GCC，clang和其他兼容GCC的编译器时，尽量使用&lt;strong&gt;#pragma GCC&lt;/strong&gt;，clang特有的处理时，使用&lt;strong&gt;#pragma clang&lt;/strong&gt;&lt;/a&gt;，这个是&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GCC的message表&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (void)load &amp;#123;&amp;#10;    // ...&amp;#10;#pragma GCC diagnostic push&amp;#10;#pragma GCC diagnostic ignored &amp;#34;-Wnonnull&amp;#34;&amp;#10;        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];&amp;#10;#pragma clang diagnostic pop&amp;#10;    // ...&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;看完之后，有个疑问，查了资料也没有找到：&lt;/p&gt;
&lt;p&gt;在NSURLSessionDelegate的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L974~L979&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;URLSession:didReceiveChallenge:completionHandler:方法里面disposition会对credential对象做非空判断然后再赋值校验类型&lt;/a&gt;，但是NSURLSessionTaskDelegate的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L1025~L1026&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;-  [URLSession:task:didReceiveChallenge:completionHandler:]方法里面disposition并不对credential对象做判断，而是直接就赋值校验类型&lt;/a&gt;，有知道的，欢迎留言交流&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;首先来介绍下AFNetWorking，官方介绍如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot;&gt;Foundation URL Loading System&lt;/a&gt;, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.&lt;/p&gt;
&lt;p&gt;Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.&lt;/p&gt;
&lt;p&gt;Choose AFNetworking for your next project, or migrate over your existing projects—you’ll be happy you did!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来简单来说就是&lt;/p&gt;
&lt;p&gt;AFNetworking是一个适用于iOS和Mac OS X两个平台的网络库，它是基于&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html&quot;&gt;Foundation URL Loading System&lt;/a&gt;上进行了一套封装，并且提供了丰富且优美的API接口给使用者使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetWorking" scheme="http://yuzeyang.github.io/tags/AFNetWorking/"/>
    
  </entry>
  
  <entry>
    <title>iOS 不付费看微信红包照片</title>
    <link href="http://yuzeyang.github.io/2016/01/26/red-packet/"/>
    <id>http://yuzeyang.github.io/2016/01/26/red-packet/</id>
    <published>2016-01-26T15:11:50.000Z</published>
    <updated>2016-05-18T15:26:36.000Z</updated>
    
    <content type="html">&lt;p&gt;相信今天微信红包照片已经席卷了朋友圈，微信这次创意是非常好的，对发布的照片进行了模糊处理，打开一看，是要发红包才能看到照片的，那怎么办呢？&lt;/p&gt;
&lt;p&gt;这怎么能难倒我们这些技术男，一招破解！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;第一种方法Charles&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/hongbaozhaopian.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来我们一起来抓包看看~&lt;/p&gt;
&lt;p&gt;首先设置好自己的WiFi的http代理，绑定好自己的Mac ip地址，打开Charles，选择allow&lt;/p&gt;
&lt;p&gt;然后打开你的微信朋友圈，你在Charles里面可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/zhuabaojieguo.jpg!500x500&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后在overview的URL里面，你就可以看到图片的URL地址了，将其拷贝出来，放到浏览器里面打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/yuanshitu.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;ok~就这么简单~&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;下面讲下第二种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用另一个iOS工具，叫做Replica&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/replica.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;打开Replica之后，启动Start，然后会打开VPN，按操作一步一步即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/replica_start.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后打开微信朋友圈，再返回到Replica，进到Analytics，点击最新的session，里面会有最新的POST/GET的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/post_get_data.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后找到180.163开头的GET请求，点进去，切到Response，可以看到这个GET请求到的数据类型是image，然后打开Image Viewer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/180.163.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/yuanshitu2.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也是可以将图片显示出来的&lt;/p&gt;
&lt;p&gt;我们可以发现照片的模糊处理是在本地做的&lt;/p&gt;
&lt;p&gt;当然这个我们只是娱乐为主，这次的产品设计还是非常不错的，点个赞喔~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;相信今天微信红包照片已经席卷了朋友圈，微信这次创意是非常好的，对发布的照片进行了模糊处理，打开一看，是要发红包才能看到照片的，那怎么办呢？&lt;/p&gt;
&lt;p&gt;这怎么能难倒我们这些技术男，一招破解！&lt;/p&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="http://yuzeyang.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS 给App添加TouchID验证</title>
    <link href="http://yuzeyang.github.io/2016/01/19/TouchID/"/>
    <id>http://yuzeyang.github.io/2016/01/19/TouchID/</id>
    <published>2016-01-19T14:47:27.000Z</published>
    <updated>2016-05-18T15:04:09.000Z</updated>
    
    <content type="html">&lt;p&gt;TouchID验证这个在iOS8中已经对开发者开放使用了，而且需在5s以上真机才能使用，这个出来已经比较早了，相信很多人都应该已经知道怎么使用TouchID了，但是就目前我使用的App来说，看到使用TouchID验证的占得数量并不多，对于一些涉及到安全性的App来说，很有可能你的解锁验证、App登录以及支付验证都是用的TouchID使用TouchID验证还是有风险的，但是有些App增加使用TouchID作为一种验证还是不错的选择，既快捷又方便，对于开发者来说增加的成本也很低&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这个是我所讲的demo的源码&lt;a href=&quot;https://github.com/Yuzeyang/TouchIDDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TouchID demo&lt;/a&gt;，代码量非常少&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面我就来介绍下怎么给App增加TouchID验证吧&lt;/p&gt;
&lt;p&gt;首先，要使用TouchID，得先引入LocalAuthentication.framework这个库，这里面只有四个头文件，但实际使用到的只有LAContext.h和LAError.h这两个头文件&lt;/p&gt;
&lt;p&gt;在做验证时，我们只需要使用到LAContext中的两个方法&lt;/p&gt;
&lt;p&gt;我们先初始化一个LAContext对象&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;LAContext *ctx = [[LAContext alloc] init];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后调用&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError*__autoreleasing*)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法来确定当前指定的验证方法能否使用，LAPolicy是个枚举，里面只有两个值，一个是LAPolicyDeviceOwnerAuthenticationWithBiometrics（使用该设备的TouchID验证），LAPolicyDeviceOwnerAuthentication（使用该设备的TouchID和设备密码验证）&lt;/p&gt;
&lt;p&gt;这里返回的是一个布尔值，错误处理我等下一起说明，当返回可以使用当前指定的验证法方法时，我们调用&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)evaluatePolicy:(LAPolicy)policy localizedReason:(NSString*)localizedReason reply:(void(^)(BOOLsuccess,NSError*__nullableerror))reply;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法开始使用TouchID验证，localizedReason指的是在弹出TouchID验证框时提示的文字，reply指的是在做指纹验证或者密码验证后的结果返回，我将localizedReason用@”通过Home键验证已有手机指纹”作为提示，下图比较直观&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/TouchID1.png!600x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;刚才布尔值的错误对应的是哪些呢？&lt;/p&gt;
&lt;p&gt;这就用到了LAError.h这个类，这个类定义了目前所有的验证失败的错误code，我直接将它copy过来了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedefNS_ENUM(NSInteger, LAError)&amp;#10;&amp;#123;&amp;#10;&amp;#9;/// &amp;#26657;&amp;#39564;&amp;#22833;&amp;#36133;&amp;#10;&amp;#9;LAErrorAuthenticationFailed =kLAErrorAuthenticationFailed,&amp;#10;&amp;#10;    /// &amp;#29992;&amp;#25143;&amp;#21462;&amp;#28040;&amp;#39564;&amp;#35777;&amp;#10;&amp;#9;LAErrorUserCancel=kLAErrorUserCancel,&amp;#10;&amp;#10;&amp;#9;/// &amp;#29992;&amp;#25143;&amp;#22238;&amp;#36864;&amp;#65288;&amp;#36820;&amp;#22238;&amp;#23494;&amp;#30721;&amp;#26657;&amp;#39564;&amp;#65289;&amp;#10;&amp;#9;LAErrorUserFallback=kLAErrorUserFallback,&amp;#10;&amp;#10;&amp;#9;/// &amp;#31995;&amp;#32479;&amp;#21462;&amp;#28040;&amp;#26657;&amp;#39564;&amp;#10;&amp;#9;LAErrorSystemCancel=kLAErrorSystemCancel,&amp;#10;&amp;#10;&amp;#9;/// &amp;#23494;&amp;#30721;&amp;#26410;&amp;#35774;&amp;#32622;&amp;#10;&amp;#9;LAErrorPasscodeNotSet=kLAErrorPasscodeNotSet,&amp;#10;&amp;#10;&amp;#9;/// &amp;#25351;&amp;#32441;&amp;#19981;&amp;#27491;&amp;#30830;&amp;#10;&amp;#9;LAErrorTouchIDNotAvailable=kLAErrorTouchIDNotAvailable,&amp;#10;&amp;#10;&amp;#9;/// &amp;#27809;&amp;#26377;&amp;#24405;&amp;#20837;&amp;#25351;&amp;#32441;&amp;#10;&amp;#9;LAErrorTouchIDNotEnrolled=kLAErrorTouchIDNotEnrolled,&amp;#10;&amp;#10;&amp;#9;/// TouchID&amp;#34987;&amp;#38145;&amp;#23450;&amp;#10;&amp;#9;LAErrorTouchIDLockoutNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorTouchIDLockout,&amp;#10;&amp;#10;&amp;#9;/// App&amp;#21462;&amp;#28040;&amp;#39564;&amp;#35777;&amp;#10;&amp;#9;LAErrorAppCancelNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorAppCancel,&amp;#10;&amp;#10;&amp;#9;/// &amp;#26080;&amp;#25928;&amp;#30340;&amp;#19978;&amp;#19979;&amp;#25991;&amp;#29615;&amp;#22659;&amp;#10;&amp;#9;LAErrorInvalidContextNS_ENUM_AVAILABLE(10_11,9_0) =kLAErrorInvalidContext&amp;#10;&amp;#125;NS_ENUM_AVAILABLE(10_10,8_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而前四种error是针对于能确定使用验证后，在验证后返回的错误&lt;/p&gt;
&lt;p&gt;后六种error是针对于不能使用验证的原因&lt;/p&gt;
&lt;p&gt;你可以针对这些原因做一些相应的操作，比如弹窗等等&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;TouchID验证这个在iOS8中已经对开发者开放使用了，而且需在5s以上真机才能使用，这个出来已经比较早了，相信很多人都应该已经知道怎么使用TouchID了，但是就目前我使用的App来说，看到使用TouchID验证的占得数量并不多，对于一些涉及到安全性的App来说，很有可能你的解锁验证、App登录以及支付验证都是用的TouchID使用TouchID验证还是有风险的，但是有些App增加使用TouchID作为一种验证还是不错的选择，既快捷又方便，对于开发者来说增加的成本也很低&lt;/p&gt;
    
    </summary>
    
    
      <category term="TouchID" scheme="http://yuzeyang.github.io/tags/TouchID/"/>
    
  </entry>
  
  <entry>
    <title>iOS 基于GCDAsyncSocket快速开发Socket通信</title>
    <link href="http://yuzeyang.github.io/2016/01/17/GCDAsyncSocket-socket/"/>
    <id>http://yuzeyang.github.io/2016/01/17/GCDAsyncSocket-socket/</id>
    <published>2016-01-17T14:10:53.000Z</published>
    <updated>2016-08-05T03:31:14.000Z</updated>
    
    <content type="html">&lt;p&gt;GCDAsyncSocket是CocoaAsyncSocket第三方库中的其中一个类，本文介绍的就是基于这一个类来做快速的socket通信开发，而且该库已经支持IPv4和IPv6&lt;/p&gt;
&lt;p&gt;我们对GCDAsyncSocket做了一层封装调用，它包含了建连、断开、重连、心跳、自定义请求&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;首先，介绍一下CocoaAsyncSocket第三方库的用途&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CocoaAsyncSocket provides easy-to-use and powerful asynchronous socket libraries for Mac and iOS. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CocoaAsyncSocket为Mac和iOS提供了易于使用且强大的异步通信库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Podfile文件中，只要加上这句话就可以使用了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;#39;CocoaAsyncSocket&amp;#39;, &amp;#39;7.4.1&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;简单的Socket通信包括了建连、断开连接、发送socket业务请求、重连这四个基本功能&lt;/p&gt;
&lt;p&gt;下面，我就按照这个四个基本功能来讲一下，怎么来使用CocoaAsyncSocket中GCDAsyncSocket这个类来开发Socket通信&lt;/p&gt;
&lt;p&gt;首先，Socket在第一步时，需要建连才能开始通信&lt;/p&gt;
&lt;p&gt;在GCDAsyncSocket中提供了四种初始化的方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)init;&amp;#10;- (id)initWithSocketQueue:(dispatch_queue_t)sq;&amp;#10;- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq;&amp;#10;- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq;&amp;#10;&amp;#10;@property (atomic, weak, readwrite) id delegate;&amp;#10;#if OS_OBJECT_USE_OBJC&amp;#10;@property (atomic, strong, readwrite) dispatch_queue_t delegateQueue;&amp;#10;#else&amp;#10;@property (atomic, assign, readwrite) dispatch_queue_t delegateQueue;&amp;#10;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;sq是socket的线程，这个是可选的设置，如果你写null，GCDAsyncSocket内部会帮你创建一个它自己的socket线程，如果你要自己提供一个socket线程的话，千万不要提供一个并发线程，在频繁socket通信过程中，可能会阻塞掉，个人建议是不用创建&lt;/p&gt;
&lt;p&gt;aDelegate就是socket的代理&lt;/p&gt;
&lt;p&gt;dq是delegate的线程&lt;/p&gt;
&lt;p&gt;必须要需要设置socket的代理以及代理的线程，否则socket的回调你压根儿就不知道了，&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.socket =[[GCDAsyncSocket alloc] initWithDelegate:delegate delegateQueue:dispatch_get_main_queue()];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接着，在设置代理之后，你需要尝试连接到相应的地址来确定你的socket是否能连通了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)connectToHost:(NSString *)host&amp;#10;               onPort:(uint16_t)port&amp;#10;          withTimeout:(NSTimeInterval)timeout&amp;#10;                error:(NSError **)errPtr;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;host是主机地址，port是端口号&lt;/p&gt;
&lt;p&gt;如果建连成功之后，会收到socket成功的回调，在成功里面你可以做你需要做的一些事情，我这边的话，是做了心跳的处理&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果建连失败了，会收到失败的回调，我这边在失败里面做了重连的操作&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重连操作其实比较简单，只需要再调用一次建连请求，我这边设置的重连规则是重连次数为5次，每次的时间间隔为2的n次方，超过次数之后，就不再去重连了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socketDidDisconnect:(GCDAsyncSocket*)sock withError:(NSError*)err &amp;#123;&amp;#10;&amp;#10;&amp;#9;self.status= -1;&amp;#10;&amp;#10;&amp;#9;if(self.reconnection_time&amp;#62;=0 &amp;#38;&amp;#38; self.reconnection_time &amp;#60;= kMaxReconnection_time) &amp;#123;&amp;#10;&amp;#10;&amp;#9;&amp;#9;[self.timer invalidate];&amp;#10;&amp;#10;&amp;#9;&amp;#9;self.timer=nil;&amp;#10;&amp;#10;&amp;#9;&amp;#9;int time =pow(2,self.reconnection_time);&amp;#10;&amp;#10;&amp;#9;&amp;#9;self.timer= [NSTimer scheduledTimerWithTimeInterval:time target:selfselector:@selector(reconnection) userInfo:nil repeats:NO];&amp;#10;&amp;#10;&amp;#9;&amp;#9;self.reconnection_time++;&amp;#10;&amp;#10;&amp;#9;&amp;#9;NSLog(@&amp;#34;socket did reconnection,after %ds try again&amp;#34;,time);&amp;#10;&amp;#10;&amp;#9;&amp;#125; else &amp;#123;&amp;#10;&amp;#10;&amp;#9;&amp;#9;self.reconnection_time=0;&amp;#10;&amp;#10;&amp;#9;&amp;#9;NSLog(@&amp;#34;socketDidDisconnect:%p withError: %@&amp;#34;, sock, err);&amp;#10;&amp;#9;&amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我用status来标记socket的连接状态&lt;/p&gt;
&lt;p&gt;那么socket已经建连了，该怎么发起socket通信呢？&lt;/p&gt;
&lt;p&gt;你需要和后端开发人员商定好socket协议格式，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[NSString stringWithFormat:@&amp;#34;&amp;#123;\&amp;#34;version\&amp;#34;:%d,\&amp;#34;reqType\&amp;#34;:%d,\&amp;#34;body\&amp;#34;:\&amp;#34;%@\&amp;#34;&amp;#125;\r\n&amp;#34;,PROTOCOL_VERSION,reqType,reqBody];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;中间应该大家都能看得懂，那为什么后面需要加上\r\n呢？&lt;/p&gt;
&lt;p&gt;这个\r\n是socket消息的边界符，是为了防止发生消息黏连，没有\r\n的话，可能由于某种原因，后端会收到两条socket请求，但是后端不知道怎么拆分这两个请求&lt;/p&gt;
&lt;p&gt;同理，在收到socket请求回调时，也会根据这个边界符去拆分&lt;/p&gt;
&lt;p&gt;那为什么要用\r\n呢？&lt;/p&gt;
&lt;p&gt;而且GCDAsyncSocket不支持自定义边界符，它提供了四种边界符供你使用\r\n、\r、\n、空字符串&lt;/p&gt;
&lt;p&gt;在拼装好socket请求之后，你需要调用GCDAsyncSocket的写方法，来发送请求，然后在写完成之后你会收到写的回调&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.socket writeData:requestData withTimeout:-1 tag:0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;timeout是超时时间，这个根据实际的需要去设置&lt;/p&gt;
&lt;p&gt;这个是写的回调&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socket:(GCDAsyncSocket*)sock didWriteDataWithTag:(long)tag&amp;#65307;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在写之后，需要再调用读方法，这样才能收到你发出请求后从服务器那边收到的数据&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.socketreadDataToData:[GCDAsyncSocket CRLFData] withTimeout:10 maxLength:50000 tag:0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;[GCDAsyncSocket CRLFData]这里是设置边界符，maxLength是设置你收到的请求数据内容的最大值&lt;/p&gt;
&lt;p&gt;在读回调里面，你可以根据不同业务来执行不同的操作&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)socket:(GCDAsyncSocket*)sock didReadData:(NSData*)data withTag:(long)tag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后一个则是断开连接，这个只需要调用&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.socket disconnect];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ok，这样的话，最简单基础的socket通信，你已经大致能完成了~&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2016.4.26更新&lt;/p&gt;
&lt;p&gt;在网络环境以及其他因素下，很有可能会造成客户端或者后端没有接收到回调或者请求，那该怎么办？&lt;/p&gt;
&lt;p&gt;我们需要加上消息回执的处理&lt;/p&gt;
&lt;p&gt;客户端发出请求的时候，可以将该请求放到存到数组里面，等到后端的相应回调在移除掉，如果该请求超时或者在一段时间内没有收到确认返回，说明后端没有接收到我们的请求，我们可以将该请求重新发送&lt;/p&gt;
&lt;p&gt;客户端接收请求的时候，后端将数据发给客户端，客户端需要增加回执处理，告诉后端，客户端接收到数据了，如果后端没接收到，也重新推一遍数据，客户端和后端双向保护来解决丢失问题&lt;/p&gt;
&lt;p&gt;2016.8.5更新&lt;/p&gt;
&lt;p&gt;有些时候，不能定位是否是后端问题还是客户端/SDK问题的时候，可以用命令行抓一下socket包看看（用Charles只能抓http和https包）&lt;/p&gt;
&lt;p&gt;命令行如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo tcpdump -i any -n -X port 7070&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Tip：7070端口号请根据实际的调试端口号修改&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/socketPacket.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;红色部分就是socket包的内容了&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;GCDAsyncSocket是CocoaAsyncSocket第三方库中的其中一个类，本文介绍的就是基于这一个类来做快速的socket通信开发，而且该库已经支持IPv4和IPv6&lt;/p&gt;
&lt;p&gt;我们对GCDAsyncSocket做了一层封装调用，它包含了建连、断开、重连、心跳、自定义请求&lt;/p&gt;
    
    </summary>
    
    
      <category term="GCDAsyncSocket,Socket" scheme="http://yuzeyang.github.io/tags/GCDAsyncSocket-Socket/"/>
    
  </entry>
  
  <entry>
    <title>零下三十度的哈尔滨之行</title>
    <link href="http://yuzeyang.github.io/2016/01/12/Harbin-travel/"/>
    <id>http://yuzeyang.github.io/2016/01/12/Harbin-travel/</id>
    <published>2016-01-12T11:37:10.000Z</published>
    <updated>2016-05-18T15:01:53.000Z</updated>
    
    <content type="html">&lt;p&gt;在年假过期之前，我和同事们想着用这个年假去哪儿浪，后来商量之后，决定去一趟哈尔滨看看，当然对于一直从未感受过零下十度以下的南方汉子们，特别是IT宅男们来说，那里的冷是根本想象不到的。（多图预警！！！）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/afraid.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们定在1月7日出发，刚好和元旦错开了，但是没办法，冰雪节在元旦之后才开始..哎，不然玩的时间就更长了。&lt;/p&gt;
&lt;p&gt;前期的准备还是很重要的！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.帽子-防风防寒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.口罩-棉/厚（戴眼镜的人极其痛苦…根本不能带口罩）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.围巾-厚&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.耳套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.保暖内衣.羊毛衫.抓绒外套.羽绒服 至少四层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.棉毛裤.棉裤.冲锋裤 至少穿三层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.厚袜子 至少两双&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.手套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9.棉鞋.雪地靴&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10.雪套（这个好像我带去都没有用到）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11.保温杯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12、暖宝宝（这个用到的时间不是很多，不过站在雪地的时候，可以贴一个在脚底抵挡一些寒冷）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;千等万等，终于等到出发的日子了，我们一行人也是高高兴兴的粗发啦，坐的是四川航空，空姐和空少都有点胖胖的…好桑心…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/INeedAV.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从杭州到哈尔滨的飞机需要三个小时左右的行程，快到哈尔滨的时候，从飞机上往下看，地都是雪白雪白的，这叫尔等南方来的汉子们很是激动啊，白茫茫的一片~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/snow.jpeg!600x600&quot; alt=&quot;飞机上俯瞰的雪景&quot;&gt;&lt;/p&gt;
&lt;p&gt;飞机降落之后，我们打车到中央大街，在打车的时候要注意一点，有些司机会向你收取&lt;strong&gt;高速路的过路费&lt;/strong&gt;，并且让你取消订单，用现金支付。现金支付是可以的，因为听说最近某滴已经开始向司机收取好像20%的服务费了，但&lt;strong&gt;你千万不要给司机高速路的过路费&lt;/strong&gt;，因为高速路的过路费，在从哈尔滨到机场的路上，有其他乘客已经帮你付了，这个是没有办法的，但是返程从机场到哈尔滨是不用付的，这个是司机想多赚你的钱！&lt;/p&gt;
&lt;p&gt;在进过的路上，我也不知道什么路…有用冰砖搭的一座城，很是漂亮，从没有近距离的看过…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/snow2.jpeg!600x600&quot; alt=&quot;冰城&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过快一个小时的车程（还是有点堵的），到了中央大街，据说这个一条非常热闹而且有名的街（因为之前吃住全是另外一个同事订好的..所以我都没有提前去了解..），下了飞机之后感觉瞬间变冷，得赶紧去旅馆加上衣服，基本按照上面必备的那么穿就不冷了，哈尔滨的天气衣服穿够了，身上不冷，但是风打在脸上还是很冷的，时间一长，鼻子就受不了了。&lt;/p&gt;
&lt;p&gt;逛中央大街的时候，门口就有个烤肠，非常好吃！但是不要买多…吃了一两根之后我感觉就有点吃不下了…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/xiangchang.jpeg!600x600&quot; alt=&quot;烤肠&quot;&gt;&lt;/p&gt;
&lt;p&gt;在旅馆门口还有一个用冰砖搭起来的滑梯，要收费，10元滑一次，因为想到晚上要去冰雪大世界了，也就没上去玩了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/binghuati.jpeg!600x600&quot; alt=&quot;冰滑梯&quot;&gt;&lt;/p&gt;
&lt;p&gt;中央大街上面有很多非常有特色店：马迭尔冰棍（这个冰棍买的人特别多），华梅西餐厅（据说连哈尔滨人也都排队还吃不上，最后一天我们想去吃，但是排队的人实在太多了，就没吃了，好可惜），老厨家（这个很有历史也很好吃）等等，那里的店大多都很有特色&lt;/p&gt;
&lt;p&gt;沿着中央大街走就可以走到防洪纪念塔，在纪念塔后面就是松花江，江面全部都结冰了，看得我都傻了..上面都是游人在滑冰，玩耍，冰面还是比较滑的，要小心，里面的娱乐项目看情况选择玩吧，出来玩，开心还是最重要的（我一般都是这么想的，飞机票、吃住都花了这么多了，不差这点娱乐的钱了…）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/songhuajiang.jpeg!600x600&quot; alt=&quot;松花江&quot;&gt;&lt;/p&gt;
&lt;p&gt;晚上就出发去了冰雪大世界玩，在那里鞋一定要穿暖，因为有些项目是需要排队的，站那脚特别冷..而且可以考虑先去排队玩大滑梯，据说很刺激，但是因为排队的人太多了，我们就很遗憾的没有去玩了，里面玩的都是滑梯，看冰雕，感受下冰的魅力，对于南方来的我们玩的还是非常开心的~但是很遗憾我没有找到冰雪大世界的照片，不过同事那里有，之后我会更新上来&lt;/p&gt;
&lt;p&gt;在冰雪大世界这么疯狂的消耗体力之后，肯定会饿了，我们用美团搜到了一家非常好吃的烧烤店叫1981烧烤（好像是这个名字），价格也不贵，烤的非常好吃，以致于有个同事一连三天拉着我吃烧烤，别说，北方的烧烤还真的比南方要好吃一点，哈哈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/1981shaokao.jpeg!600x600&quot; alt=&quot;1981烧烤&quot;&gt;&lt;/p&gt;
&lt;p&gt;第二天，我们选择去了雪乡，听说那里是因为拍了爸爸去哪了之后，才火起来的，但是因为客服的原因，把我们的名单弄错了，导致没坐上大巴车，结果搞了辆小面包，后面的事情就更凄惨了…雪乡的路上有个坡，路面滑，怎么都上不去，装防滑条，断了，装防滑链，装不上…啊…真的是日了够了，搞了一两个小时，本来出发时间就耽搁了，这么一搞就更晚了，结果一辆路过的大巴车救了我们，达到雪乡花了我们12个小时…醉了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/zhuangfanghualian.jpeg!600x600&quot; alt=&quot;装防滑链&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是雪乡沿途的风景还是很漂亮的，厚厚的雪，还有雾凇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/xuejing.jpeg!600x600&quot; alt=&quot;雪景&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/wusong.jpeg!600x600&quot; alt=&quot;雾凇&quot;&gt;&lt;/p&gt;
&lt;p&gt;到雪乡之后，就是夜晚了，虽然还是5点多钟，但天黑的特别早，雪乡一进来就给人的感觉是商业化比较严重，已经很难看出原来的风土人情了。雪乡里面能看到雪橇犬，还是马拉车，车还是有牌照的…&lt;/p&gt;
&lt;p&gt;我们因为路途的劳累也没出去逛，雪乡之行还是意外的可惜，草草的就结束了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/xuexiangyejing.jpeg!600x600&quot; alt=&quot;雪乡夜景&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们一行人睡的是五人炕，但是后来听北方的同事说，那个好像是电子炕，不是火烧那种了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/wurenkang.jpeg!600x600&quot; alt=&quot;五人炕&quot;&gt;&lt;/p&gt;
&lt;p&gt;在那里我们买了冰柿子，冰草莓，冰梨，发现太硬了太冷了…后来放那软了就扔了…后来听说那个是要放冷水里化开了再吃的…吃的..的，我们就忧伤了…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/bingcaomei.jpeg!600x600&quot; alt=&quot;冰草莓&quot;&gt;&lt;/p&gt;
&lt;p&gt;第三天我们就从雪乡出发，去往亚布力滑雪，第一次滑雪的我来说可兴奋了ヾ(o◕∀◕)ﾉヾ，同事说去30°坡的滑雪场，我说太平了是不是不好玩，我说要45°的，后来少数服从多数，我们还是去了30°的滑雪场，到那里存好东西之后，有条件的可以请个教练带一带你，没有的，可以让会的同事带你，不然就像我一样，从坡上面一直摔到了坡下面….因为不懂怎么刹车…就一直摔…好疼…而且穿着滑雪鞋，容易崴脚，最后我去了儿童区，还是摔/(ㄒoㄒ)/~~&lt;/p&gt;
&lt;p&gt;回来的晚上我们好好的逛了下中央大街，在老厨家吃了顿放，和北方的同事聚了一下，总结了一下北方的菜有点咸，但是量特足，5个人基本点3个菜就差不多了&lt;/p&gt;
&lt;p&gt;中央大街的夜景也非常漂亮，街道两旁都有大型的冰雕，品牌赞助…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/shengdanshu.jpeg!600x600&quot; alt=&quot;圣诞树&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/beijixiong.jpeg!600x600&quot; alt=&quot;北极熊小屋&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后一天我们就去了圣索菲亚大教堂，据说教堂里面是没有什么好看的，都是买纪念品，只要外面参观下就可以了，而且有鸽子的区域没有我想象中的那么大，就那一小块地方…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/jiaotang.jpeg!600x600&quot; alt=&quot;教堂正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/gezi.jpeg!600x600&quot; alt=&quot;教堂旁的鸽子&quot;&gt;&lt;/p&gt;
&lt;p&gt;匆匆的哈尔滨之行就愉快的结束了，好期待下一次的旅行~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在年假过期之前，我和同事们想着用这个年假去哪儿浪，后来商量之后，决定去一趟哈尔滨看看，当然对于一直从未感受过零下十度以下的南方汉子们，特别是IT宅男们来说，那里的冷是根本想象不到的。（多图预警！！！）&lt;/p&gt;
    
    </summary>
    
    
      <category term="哈尔滨" scheme="http://yuzeyang.github.io/tags/%E5%93%88%E5%B0%94%E6%BB%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS TableView上拉下拉刷新控件（二）</title>
    <link href="http://yuzeyang.github.io/2016/01/06/iOS_TableView_refresh_controller-two/"/>
    <id>http://yuzeyang.github.io/2016/01/06/iOS_TableView_refresh_controller-two/</id>
    <published>2016-01-06T14:59:44.000Z</published>
    <updated>2016-05-17T15:22:07.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇我们来讲如何将loading圆圈动画和TableView结合起来一起使用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先，我们需要将loading圆圈和提示label加到一个view上去显示，实现的主要点有两点：第一，在上拉或者下拉的过程中，我们通过progress值去控制loading圆圈的动画和label的alpha值，第二，通过设置拉动的方向来设置label提示的内容&lt;/p&gt;
&lt;p&gt;然后，我们该怎么去获得这个progress值呢？&lt;/p&gt;
&lt;p&gt;首先，我们在初始化的时候需要监听所关联的scrollView的contentOffset值，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.scrollView addObserver:self forKeyPath:@&amp;#34;contentOffset&amp;#34; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在observeValueForKeyPath里面，我们获取contentOffset的最新值，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGPoint contentOffset = [[change valueForKey:NSKeyValueChangeNewKey] CGPointValue];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后再通过计算来改变progress值，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.progress = MAX(0.0, MIN(fabs((self.originOffset + contentOffset.y)/kMaxPullDownDistance), 1.0));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（注：在这里有个originOffset值，这个是我用来处理是否有导航栏的情况，有则该值为64.0，没有则为0.0）&lt;/p&gt;
&lt;p&gt;计算的思路是我们通过所关联的scrollView的contentOffset与我们所设置的最大的拉动距离值相除作比较，得到的就是拉动的一个范围比例，因为contentOffset会超出我们设置的最大拉动距离，所以我们需要再取最小最大值，来获取到最后的progress值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在这里插一个小的知识点，因为这个是在写上拉时，所必须知道的一个点，contentOffset是怎么算的？&lt;/p&gt;
&lt;p&gt;contentOffset是scrollview当前显示区域顶点相对于frame顶点的偏移量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/contentOffset.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但当上拉刷新之后，此时scrollview的contentSize变化了，（contentSize指的是可显示区域），在计算contentOffset时，需要将contentSize减去scrollView的高度，来和contentOffset作比较。&lt;/p&gt;
&lt;p&gt;拿到progress之后，此时我们离完成这个控件的任务就差不多了。&lt;/p&gt;
&lt;p&gt;首先，我们需要将progress赋值给loading圆圈和提示label，&lt;/p&gt;
&lt;p&gt;然后如果我们拉动的距离超过了设置最大值的时候，我们做loading，并且通过block让外部做一些网络请求或者其他的操作&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self startLoading:self.refreshView];&amp;#10;                &amp;#10;// 0.3s animation time is the best experience&amp;#10;[UIView animateWithDuration:0.3 animations:^&amp;#123;&amp;#10;    self.scrollView.contentInset = UIEdgeInsetsMake(kMaxPullDownDistance + self.originOffset, 0, 0, 0);&amp;#10;&amp;#125; completion:^(BOOL finished) &amp;#123;&amp;#10;    if (self.refreshingBlock) &amp;#123;&amp;#10;        self.refreshingBlock();&amp;#10;    &amp;#125;&amp;#10;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上拉时，有一点不同，scrollView的contentSize可能是会变化的，而我们的控件是要始终显示在它的最下方的，所以我们在上拉时，需要对contentSize也加监听&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.scrollView addObserver:self forKeyPath:@&amp;#34;contentSize&amp;#34; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并且在observeValueForKeyPath里面，需要设置控件的center来改变我们的显示位置，以及progress值，其他操作都和下拉刷新一样。&lt;/p&gt;
&lt;p&gt;ok，我们的上拉下拉刷新控件完成喽~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇我们来讲如何将loading圆圈动画和TableView结合起来一起使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TableView" scheme="http://yuzeyang.github.io/tags/TableView/"/>
    
  </entry>
  
  <entry>
    <title>iOS TableView上拉下拉刷新控件（一）</title>
    <link href="http://yuzeyang.github.io/2016/01/05/iOS_TableView_refresh_controller_one/"/>
    <id>http://yuzeyang.github.io/2016/01/05/iOS_TableView_refresh_controller_one/</id>
    <published>2016-01-05T14:29:07.000Z</published>
    <updated>2016-05-17T15:21:52.000Z</updated>
    
    <content type="html">&lt;p&gt;注：此刷新控件的效果是来自KittenYang的一个GIF图，他有很多动画分析和写得都不错，大家可以关注一下~&lt;/p&gt;
&lt;p&gt;推荐一个非常好的动画效果网站：&lt;a href=&quot;http://uimovement.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI Movement&lt;/a&gt;，里面很多设计出的动画效果都非常好，都可以一一实现看看哦&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;话不多说，先看下我要讲的刷新控件效果：&lt;/p&gt;
&lt;p&gt;1.无导航栏的刷新控件效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/TableRefreshAnimation1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.有导航栏的刷新控件效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/TableRefreshAnimation2.gif&quot; alt=&quot;&quot;&gt;            &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好了，进入正题。&lt;/p&gt;
&lt;p&gt;首先看到这个控件的时候，我们要去分析，这个控件是由哪几部分组成的，可以看到这个控件是只是由一个loading圆圈和label提示文字组成的，而label比较简单，在这里我就不具体说怎么实现了，大家可以直接看源码，这篇文章，我主要讲怎么实现这个loading圆圈的转圈效果。&lt;/p&gt;
&lt;p&gt;首先这个转圈分成两部分，我们将它分成0.0-0.5和0.5-1.0这两个阶段。&lt;/p&gt;
&lt;p&gt;在0.0-0.5这个过程的动画是这样的：&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/refresh0-0.5.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以左边的线为例，上顶点为B点，下顶点为A点，实际上这个过程只是，A，B两点的y值在随着progress的变化而变化，x是不变的，所以我们可以得到A，B两点的坐标&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGPoint leftA = CGPointMake(kCenterX - kLineLength, kCenterY + 2*kLineLength - self.progress/0.5*kLineLength);&amp;#10;CGPoint leftB = CGPointMake(leftA.x, leftA.y - kLineLength);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我们用贝塞尔曲线，将两点连起来，从A点到B点&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[leftPath moveToPoint:leftA];&amp;#10;[leftPath addLineToPoint:leftB];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那这个尖角怎么办呢？我们利用以前学过的数学知识，假设尖角的角度是30°，那x值就是leftB.x-kArrowLength&lt;em&gt;sin(kArrowAngle)，y值就是leftB.y+kArrowLength&lt;/em&gt;cos(kArrowAngle)，假设这个点是C点，最后就是将C点和B点相连&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[arrowPath moveToPoint:leftB];&amp;#10;[arrowPath addLineToPoint:CGPointMake(leftB.x - kArrowLength*sin(kArrowAngle), leftB.y + kArrowLength*cos(kArrowAngle))];&amp;#10;[leftPath appendPath:arrowPath];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样我们就完成了0.0-0.5的动画，这个一部分还是比较简单的。&lt;/p&gt;
&lt;p&gt;下面是0.5-1.0的动画过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtit4.com1.z0.glb.clouddn.com/refresh0.5-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当到达0.5的时候，原先的B点开始保持不动，它的位置始终是CGPointMake(kCenterX-kLineLength,kCenterY)，而A点也渐渐向B点靠近，CGPointMake(kCenterX-kLineLength,kCenterY+kLineLength- (self.progress-0.5)/0.5*kLineLength)，那这个圆弧是怎么出来的？&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在绘制贝塞尔曲线里面，有一个绘制圆弧的方法，center是以某一个点为圆心绘制圆弧，&lt;/p&gt;
&lt;p&gt;radius是半径，startAngle是开始角度，endAngle是结束角度，clockwise是是否以顺时针绘制，ok，我们就用这个来绘制我们的圆弧&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[leftPath moveToPoint:leftA];&amp;#10;[leftPath addLineToPoint:leftB];&amp;#10;[leftPath addArcWithCenter:CGPointMake(kCenterX, kCenterY) radius:kLineLength startAngle:M_PI endAngle:M_PI+M_PI*(self.progress - 0.5)/0.5*9/10 clockwise:YES];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;恩，圆弧也画好了，那我们的尖角是不是也按照刚才的那样写就可以了？恩，差不多哦，只是我们在原有尖角30°的基础上，需要加上我们圆弧旋转的角度，才是真正尖角与圆弧顶点的切线角度&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGPointMake(leftPath.currentPoint.x - kArrowLength*sin(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10),leftPath.currentPoint.y + kArrowLength*cos(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好了，尖角顶点也知道了，那连接只要和原来一样就可以了&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[arrowPath moveToPoint:leftPath.currentPoint];&amp;#10;[arrowPath addLineToPoint:CGPointMake(leftPath.currentPoint.x - kArrowLength*sin(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10),&amp;#10;                                              leftPath.currentPoint.y + kArrowLength*cos(kArrowAngle+M_PI*(self.progress - 0.5)/0.5*9/10))];&amp;#10;[leftPath appendPath:arrowPath];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好了，左边的动画是这样，右边的只要对称即可~&lt;/p&gt;
&lt;p&gt;是不是看上去比较复杂的动画，将它分解开来，就变得简单了呢？&lt;/p&gt;
&lt;p&gt;下一篇，我会讲怎么将这个动画和tableview结合起来使用~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;注：此刷新控件的效果是来自KittenYang的一个GIF图，他有很多动画分析和写得都不错，大家可以关注一下~&lt;/p&gt;
&lt;p&gt;推荐一个非常好的动画效果网站：&lt;a href=&quot;http://uimovement.com/&quot;&gt;UI Movement&lt;/a&gt;，里面很多设计出的动画效果都非常好，都可以一一实现看看哦&lt;/p&gt;
    
    </summary>
    
    
      <category term="TableView" scheme="http://yuzeyang.github.io/tags/TableView/"/>
    
  </entry>
  
  <entry>
    <title>TextField字数限制处理</title>
    <link href="http://yuzeyang.github.io/2015/09/17/TextField_count_limit_handle/"/>
    <id>http://yuzeyang.github.io/2015/09/17/TextField_count_limit_handle/</id>
    <published>2015-09-17T14:40:44.000Z</published>
    <updated>2016-05-16T15:23:06.000Z</updated>
    
    <content type="html">&lt;p&gt;在第三方键盘加入之后，对于字数限制的处理不再像之前那么简单了&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;纯数字、字符输入（不包括粘贴）这样的字数限制还是相对比较简单的，你可以用两种方法进行处理&lt;/p&gt;
&lt;p&gt;第一种是&lt;strong&gt;textfield的delegate&lt;/strong&gt;实现：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &amp;#123;&amp;#10;    if (range.length + range.location &amp;#62; textField.text.length) &amp;#123;&amp;#10;        return NO;&amp;#10;    &amp;#125;&amp;#10;    NSUInteger newLength = textField.text.length + string.length - range.length;&amp;#10;    return newLength&amp;#60;=kMaxCharacterCount;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种&lt;strong&gt;是注册一个通知&lt;/strong&gt;，在textfield编辑时做处理：&lt;/p&gt;
&lt;p&gt;首先你在viewDidLoad中注册通知&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFiledEditChanged:) name:UITextFieldTextDidChangeNotification object:self.shopName];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再实现通知里面的方法，在超过最大值时，取最大的字数&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (self.shopName.text.length &amp;#62; kMaxCharacterCount) &amp;#123;&amp;#10;        self.shopName.text = [self.shopName.text substringToIndex:kMaxCharacterCount];&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，在中文的限制上面情况就复杂了，当时在调试的时候，因为使用的是第三方键盘，所以当时没有发现问题，但是在使用系统键盘的时候，一下子就蛋疼了….&lt;/p&gt;
&lt;p&gt;下面我开始分析一下，两者的区别：&lt;/p&gt;
&lt;p&gt;1、第三方键盘在输入字符时，一般是不会将字符直接输入到textfield中，而是将字符显示在它自己的view上方，但是系统键盘会直接输入到textfield中，而且它会占2个字符长度，比如你输入”abcd”，在textfield中显示的是”a b c d”，并且”a b c d”是处在高亮中的，并不算是真正输入到textfield中，所以我们不应把高亮的字符计算在内，我们应该计算真正输入的字符&lt;/p&gt;
&lt;p&gt;2、如果我们使用的是delegate做处理的时候，系统中文输入的时候会有联想，但是联想的那个字并不会调用delegate，比如你输入一个”你”，在系统的联想里面可能会出现”的”,”们”这样的联想，但是你选择”的”的时候，delegate并不会调用，（尼玛….），我猜想联想输入应该不算做keyboard所触发的事件，所以他并不会触发delegate，但是如果你注册的是通知，他倒是会调用，（还好有救）&lt;/p&gt;
&lt;p&gt;另外提醒一下，有时候在自测输入的时候，要考虑全面，比如粘贴这也是一种输入，当时没考虑，我也是跪了&lt;/p&gt;
&lt;p&gt;好了，分析了主要的区别下面我们就来看看具体怎么实现吧~&lt;/p&gt;
&lt;p&gt;在实现注册通知方法里面：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - UITextViewDelegate&amp;#10;- (void)textViewDidChange:(UITextView *)textView &amp;#123;&amp;#10;    if (textView.text.length == 0) &amp;#123;&amp;#10;        self.recommendTips.hidden = NO;&amp;#10;    &amp;#125;else&amp;#123;&amp;#10;        self.recommendTips.hidden = YES;&amp;#10;    &amp;#125;&amp;#10;    &amp;#10;    NSString *toBeString = textView.text;&amp;#10;    NSString *lang = self.textInputMode.primaryLanguage; // &amp;#38190;&amp;#30424;&amp;#36755;&amp;#20837;&amp;#27169;&amp;#24335;&amp;#10;    if ([lang isEqualToString:@&amp;#34;zh-Hans&amp;#34;]) &amp;#123; // &amp;#31616;&amp;#20307;&amp;#20013;&amp;#25991;&amp;#36755;&amp;#20837;&amp;#65292;&amp;#21253;&amp;#25324;&amp;#31616;&amp;#20307;&amp;#25340;&amp;#38899;&amp;#65292;&amp;#20581;&amp;#20307;&amp;#20116;&amp;#31508;&amp;#65292;&amp;#31616;&amp;#20307;&amp;#25163;&amp;#20889;&amp;#10;        UITextRange *selectedRange = [textView markedTextRange];&amp;#10;        //&amp;#33719;&amp;#21462;&amp;#39640;&amp;#20142;&amp;#37096;&amp;#20998;&amp;#10;        UITextPosition *position = [textView positionFromPosition:selectedRange.start offset:0];&amp;#10;        // &amp;#27809;&amp;#26377;&amp;#39640;&amp;#20142;&amp;#36873;&amp;#25321;&amp;#30340;&amp;#23383;&amp;#65292;&amp;#21017;&amp;#23545;&amp;#24050;&amp;#36755;&amp;#20837;&amp;#30340;&amp;#25991;&amp;#23383;&amp;#36827;&amp;#34892;&amp;#23383;&amp;#25968;&amp;#32479;&amp;#35745;&amp;#21644;&amp;#38480;&amp;#21046;&amp;#10;        if (!position || !selectedRange) &amp;#123;&amp;#10;            if (toBeString.length &amp;#62; 200) &amp;#123;&amp;#10;                textView.text = [toBeString substringToIndex:200];&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;        // &amp;#26377;&amp;#39640;&amp;#20142;&amp;#36873;&amp;#25321;&amp;#30340;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#65292;&amp;#21017;&amp;#26242;&amp;#19981;&amp;#23545;&amp;#25991;&amp;#23383;&amp;#36827;&amp;#34892;&amp;#32479;&amp;#35745;&amp;#21644;&amp;#38480;&amp;#21046;&amp;#10;        else&amp;#123;&amp;#10;            &amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#20013;&amp;#25991;&amp;#36755;&amp;#20837;&amp;#27861;&amp;#20197;&amp;#22806;&amp;#30340;&amp;#30452;&amp;#25509;&amp;#23545;&amp;#20854;&amp;#32479;&amp;#35745;&amp;#38480;&amp;#21046;&amp;#21363;&amp;#21487;&amp;#65292;&amp;#19981;&amp;#32771;&amp;#34385;&amp;#20854;&amp;#20182;&amp;#35821;&amp;#31181;&amp;#24773;&amp;#20917;&amp;#10;    else&amp;#123;&amp;#10;        if (toBeString.length &amp;#62; 200) &amp;#123;&amp;#10;            textView.text = [toBeString substringToIndex:200];&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，我们根据键盘的输入模式进行区分，英文的比较简单就和上面一样，直接取最大的字符数就好了，在中文输入的时候，我们用markedTextRange方法获取到当前的光标位置，再用textField positionFromPosition:selectedRange.start offset:0获取到高亮部分，然后判断是否有高亮，这个时候系统会调用两次通知方法，第一次是将高亮的字符输入，第二次是将高亮的字符转换成中文输入（这个时候就没有高亮了，然后再取最大的字符数），但是在iOS7的设备上测试时发现，position都不会为nil，在iOS8以上都正常，但是获取到光标的range，却是正常的&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NS_CLASS_AVAILABLE_IOS(3_2) @interface UITextRange : NSObject&amp;#10;&amp;#10;@property (nonatomic, readonly, getter=isEmpty) BOOL empty;     //  Whether the range is zero-length.&amp;#10;@property (nonatomic, readonly) UITextPosition *start;&amp;#10;@property (nonatomic, readonly) UITextPosition *end;&amp;#10;&amp;#10;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到系统的UITextRange，有两个变量，一个是start，一个是end，这正是对于的高亮区域！&lt;/p&gt;
&lt;p&gt;所以既然position不能使用，那我们干脆就使用range，通过判断range的存在，来对文字进行限制处理。（粘贴也适用）&lt;/p&gt;
&lt;p&gt;结果也是棒棒的！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在第三方键盘加入之后，对于字数限制的处理不再像之前那么简单了&lt;/p&gt;
    
    </summary>
    
    
      <category term="TextField" scheme="http://yuzeyang.github.io/tags/TextField/"/>
    
  </entry>
  
</feed>
