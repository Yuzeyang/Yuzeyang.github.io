<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 跨平台长连接组件设计及可插拔改造 · 宫城</title><meta name="description" content="跨平台长连接组件设计及可插拔改造 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">跨平台长连接组件设计及可插拔改造</h1><div class="post-info">2018年4月3日</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在提出开发跨平台组件之前， iOS 和 Android 客户端分别使用一套长连接组件，需要双倍的人力开发和维护；在产品需求调整上，为了在实现细节上保持一致性也具有一定的难度；Web 端与客户端长连接的形式不同，前者使用 WebSocket，后者使用 Socket ，无形中也增加了后端的维护成本。为了解决这些问题，我们基于 WebSocket 协议开发了一套跨平台的长连接组件。</p>
<h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p>组件自上而下分为五层：</p>
<ul>
<li><strong>Native 层</strong>：负责业务请求封装和数据解析，与原生进行交互</li>
<li><strong>Chat 层</strong>：负责提供底层通信使用的 c 接口，包含连接、读写和关闭</li>
<li><strong>Websocket 层</strong>：实现 websocket 协议及维护心跳</li>
<li><strong>TLS 层 </strong>：基于 <code>mbedTLS</code> 实现 TLS 协议及数据加解密</li>
<li><strong>TCP 层</strong>：基于 <code>libuv</code> 实现 TCP 连接和数据的读写</li>
</ul>
<p>整体架构如下图所示：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/3681522755222_.pic.jpg!600x600" alt=""></p>
<h3 id="TCP-层"><a href="#TCP-层" class="headerlink" title="TCP 层"></a>TCP 层</h3><p>TCP 层我们是基于 <a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>  进行开发， libuv 是一个异步 I/O 库，并且支持了多个平台（ Linux ，Windows 和 Darwin ），一开始主要应用于开发 Node.js ，后来逐渐在其他项目也开始使用。文件、 网络和管道 等操作是 I/O 操作 ，libuv 为此抽象出了相关的接口，底层使用各平台上最优的 I/O 模型实现。</p>
<p>它的核心是提供了一个 <code>event loop</code> ，每个 event loop 包含了六个阶段：</p>
<ul>
<li><strong>timers 阶段</strong>：这个阶段执行 timer（ <code>setTimeout</code> 、 <code>setInterval</code> ）的回调</li>
<li><strong>I/O callbacks 阶段</strong>：执行一些系统调用错误，比如网络通信的错误回调</li>
<li><strong>idle , prepare 阶段</strong>：仅 node 内部使用</li>
<li><strong>poll 阶段</strong>：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li>
<li><strong>check 阶段</strong>：执行 <code>setImmediate()</code> 的回调</li>
<li><strong>close callbacks 阶段</strong>：执行 <code>socket</code> 的 <code>close</code> 事件回调</li>
</ul>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/libuv-event-loop.png" alt=""></p>
<h3 id="TLS-层"><a href="#TLS-层" class="headerlink" title="TLS 层"></a>TLS 层</h3><p>mbedTLS（前身PolarSSL）是实现了一套易用的加解密算法和 SSL / TLS 库。TLS 以及前身 SSL 是传输层安全协议，给网络通信提供安全和数据完整性的保障，所以它能很好的解决数据明文和劫持篡改的问题。并且其分为记录层和传输层，记录层用来确定传输层数据的封装格式，传输层则用于数据传输，而在传输之前，通信双方需要经过握手，其包含了<code>双方身份验证</code>，<code>协商加密算法</code>，<code>交换加密密钥</code>。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/ssl_handshake.png" alt=""></p>
<h3 id="Websocket-层"><a href="#Websocket-层" class="headerlink" title="Websocket 层"></a>Websocket 层</h3><p>Websocket 层包含了对协议的实现和心跳的维护。</p>
<p>其最新的协议是 <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">13 RFC 6455</a>。协议的实现分为握手，数据发送/读取，关闭连接。</p>
<h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p>握手要从请求头去理解。</p>
<p>WebSocket 首先发起一个 HTTP 请求，在请求头加上 <code>Upgrade</code> 字段，该字段用于改变 HTTP 协议版本或者是换用其他协议，这里我们把 <code>Upgrade</code> 的值设为 <code>websocket</code> ，将它升级为 WebSocket 协议。</p>
<p>同时要注意 <code>Sec-WebSocket-Key</code> 字段，它由客户端生成并发给服务端，用于证明服务端接收到的是一个可受信的连接握手，可以帮助服务端排除自身接收到的由非 WebSocket 客户端发起的连接，该值是一串随机经过 <code>base64</code> 编码的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>收到请求后，服务端也会做一次响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>
<p>里面重要的是 <code>Sec-WebSocket-Accept</code> ，服务端通过从客户端请求头中读取 <code>Sec-WebSocket-Key</code> 与一串全局唯一的标识字符串（俗称魔串）“258EAFA5-E914-47DA- 95CA-C5AB0DC85B11”做拼接，生成长度为160位的 <code>SHA-1</code> 字符串，然后进行 <code>base64</code> 编码，作为 <code>Sec-WebSocket-Accept</code> 的值回传给客户端，客户端再去解析这个值，与自己加密编码后的字符串进行比较。</p>
<p>处理握手 HTTP 响应解析的时候，可以用 <a href="https://github.com/nodejs/http-parser" target="_blank" rel="noopener">http-paser</a> ，解析方式也比较简单，就是对头信息的逐字读取再处理，具体处理你可以看一下它的状态机实现。解析完成后你需要对其内容进行解析，看返回是否正确，同时去管理你的握手状态。</p>
<h4 id="数据发送-读取"><a href="#数据发送-读取" class="headerlink" title="数据发送/读取"></a>数据发送/读取</h4><p>数据的处理需要用帧协议图来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>首先我们来看看数字的含义，数字表示位，0-7表示有8位，等于1个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br></pre></td></tr></table></figure>
<p>所以如果要组装一个帧数据可以这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *rev = (rev *)malloc(4);</span><br><span class="line">rev[0] = (char)(0x81 &amp; 0xff);</span><br><span class="line">rev[1] = 126 &amp; 0x7f;</span><br><span class="line">rev[2] = 1;</span><br><span class="line">rev[3] = 0;</span><br></pre></td></tr></table></figure>
<p>ok，了解了帧数据的样子，我们反过来去理解值对应的帧字段。</p>
<p>首先<code>0x81</code>是什么，这个是十六进制数据，转换成二进制就是<code>1000 0001</code>， 是一个字节的长度，也就是这一段里面每一位的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 </span><br><span class="line">+-+-+-+-+-------+</span><br><span class="line">|F|R|R|R| opcode|</span><br><span class="line">|I|S|S|S|  (4)  |</span><br><span class="line">|N|V|V|V|       |</span><br><span class="line">| |1|2|3|       |</span><br><span class="line">+-+-+-+-+-------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>FIN</code> 表示该帧是不是消息的最后一帧，1表示结束，0表示还有下一帧。</p>
</li>
<li><p><code>RSV1, RSV2, RSV3</code> 必须为0，除非扩展协商定义了一个非0的值，如果没有定义非0值，且收到了非0的 <code>RSV</code> ，那么 WebSocket 的连接会失效，建议是断开连接。</p>
</li>
<li><p><code>opcode</code> 用来描述 <code>Payload data</code> 的定义，如果收到了一个未知的 <code>opcode</code> ，同样会使 WebSocket 连接失效，协议定义了以下值：</p>
<ul>
<li>%x0 表示连续的帧</li>
<li>%x1 表示 text 帧</li>
<li>%x2 表示二进制帧</li>
<li>%x3-7 预留给非控制帧</li>
<li>%x8 表示关闭连接帧</li>
<li>%x9 表示 ping</li>
<li>%xA 表示 pong</li>
<li>%xB-F 预留给控制帧</li>
</ul>
<p>连续帧是和 FIN 值相关联的，它表明可能由于消息分片的原因，将原本一个帧的数据分为多个帧，这时候前一帧的 opcode 就是0，FIN 也是0，最后一帧的 opcode 就不再是0，FIN 就是1了。</p>
<p>再可以看到 opcode 预留了非控制帧和控制帧，这两个又是什么？</p>
<p>控制帧表示 WebSocket 的状态信息，像是定义的分片，关闭连接，ping和pong。</p>
<p>非控制帧就是数据帧，像是 text 帧，二进制帧。</p>
</li>
</ul>
<p><code>0xff</code> 作用就是取出需要的二进制值。</p>
<p>下面再来看<code>126</code>，126则表示的是 <code>Payload len</code> ，也就是 Payload 的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">                +-+-------------+-------------------------------+</span><br><span class="line">                |M| Payload len |    Extended payload length    |</span><br><span class="line">                |A|     (7)     |             (16/64)           |</span><br><span class="line">                |S|             |   (if payload len==126/127)   |</span><br><span class="line">                |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |           Payload Data        |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>MASK</code> 表示<code>Playload data</code> 是否要加掩码，如果设成1，则需要赋值 <code>Masking-key</code> 。所有从客户端发到服务端的帧都要加掩码</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Playload len</span><br></pre></td></tr></table></figure>
<p>表示 Payload 的长度，这里分为三种情况</p>
</li>
<li><p>长度小于126，则只需要7位</p>
</li>
<li>长度是126，则需要额外2个字节的大小，也就是 <code>Extended payload length</code></li>
<li>长度是127，则需要额外8个字节的大小，也就是 <code>Extended payload length</code> + <code>Extended payload length continued</code> ，<code>Extended payload length</code> 是2个字节，<code>Extended payload length continued</code> 是6个字节</li>
<li><code>Playload len</code> 则表示 <code>Extension data</code> 与 <code>Application data</code> 的和</li>
<li><code>Masking-key</code> 是在 <code>MASK</code> 设置成1之后，随机生成的4字节长度的数据，然后和 <code>Payload Data</code>做异或运算</li>
<li><code>Payload Data</code> 就是我们发送的数据</li>
</ul>
<p>而数据的发送和读取就是对帧的封装和解析。</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><p>关闭连接分为两种：服务端发起关闭和客户端主动关闭。</p>
<p>服务端跟客户端的处理基本一致，以服务端为例：</p>
<p>服务端发起关闭的时候，会客户端发送一个关闭帧，客户端在接收到帧的时候通过解析出帧的opcode来判断是否是关闭帧，然后同样向服务端再发送一个关闭帧作为回应。</p>
<h3 id="Chat-层"><a href="#Chat-层" class="headerlink" title="Chat 层"></a>Chat 层</h3><p>Chat 层比较简单，只是提供一些通用的<strong>连接</strong>、<strong>读写数据</strong>和<strong>断开</strong>接口和回调，同时维护一个 loop 用于重连。</p>
<h3 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h3><p>这一层负责和原生进行交互，由于组件是用 c 代码编写的，所以为了调用原生方法，Android 采用 JNI 的方式，iOS 采用 runtime 的方式来实现。</p>
<p>JNI ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_youzan_mobile_im_network_Channel_nativeDisconnect(JNIEnv *env, jobject jobj) &#123;</span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(jobj);</span><br><span class="line">    jfieldID fieldID = env-&gt;GetFieldID(clazz, CONTEXT_VARIABLE, <span class="string">"J"</span>);</span><br><span class="line">    context *c = (context *) env-&gt;GetLongField(jobj, fieldID);</span><br><span class="line">    im_close(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runtime: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">int</span> cId, <span class="keyword">int</span> mId, <span class="keyword">int</span> version, <span class="keyword">int</span> mv, <span class="keyword">const</span> <span class="keyword">char</span> *req_id, <span class="keyword">const</span> <span class="keyword">char</span> *data &#123;</span></span></span><br><span class="line">    context *ctx = (context *)objc_msgSend(g_obj, sel_registerName("ctx"));</span><br><span class="line">    send_request(ctx, cId, mId, version, mv, req_id, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插拔式架构改造"><a href="#插拔式架构改造" class="headerlink" title="插拔式架构改造"></a>插拔式架构改造</h2><p>在实现了一套跨端长连接组件之后，最近我们又完成了其插件化的改造，为什么要做这样的改造呢？由于业务环境复杂和运维的相关限制，有的业务方可以配置 TLS 组成 WSS；有的业务方不能配置，只能以明文 WebSocket 的方式传输；有的业务方甚至连 WebSocket 的承载也不要，转而使用自定义的协议。随着对接的业务方增多，我们没办法进行为他们一一定制。我们当初设计的结构是 Worker (负责和业务层通信) -&gt; WebSocket -&gt; TLS -&gt; TCP ，这四层结构是耦合在一起的，这时候如果需要剔除 TLS 或者扩展一个新的功能，就会改动相当多的代码。基于以上几点，我们发现，原先的定向设计完全不符合要求，为了接下来可能会有新增协议解析的预期，同时又不改变使用 libuv 进行跨平台的初衷，所以我们就实施了插件化的改造，最重要的目的是为了<code>解耦</code>，同时也为了提高组件的灵活性，实现<code>可插拔（冷插拔）</code>。</p>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>首先我们要对四层结构的职责进行明确</p>
<ul>
<li><strong>Worker</strong> ：提供业务接口和回调</li>
<li><strong>WebSocket</strong> ：负责 WebSocket 握手，封装/解析帧数据和维护心跳</li>
<li><strong>TLS</strong> ：负责 TLS 握手和数据的加解密</li>
<li><strong>TCP</strong>：TCP 连接和数据的读写</li>
</ul>
<p>以及整理出结构间的执行调用：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/chat_puggable.png" alt=""></p>
<p>其中 connect 包含了<code>连接</code>和<code>握手</code>两个过程。在完成链路层连接后，我们认为协议层握手完成，才算是真正的连接成功。</p>
<p>同样的，数据读写、连接关闭、连接销毁和重置都会严格按照结构的顺序依次调用。</p>
<h2 id="可插拔改造"><a href="#可插拔改造" class="headerlink" title="可插拔改造"></a>可插拔改造</h2><p>解耦完成之后我们发现对于接口的调用都是显式的，比如 Worker send data 中调用 WebSocket send data ， WebSocket send data 中又调用 TLS send data ，这样的显式调用是因为我们知道这些接口是可用的，但在插件化中某个插件可能没有被使用，这样接口的调用会在某一层中断而导致整个组件的不可用。</p>
<h3 id="结构体改造"><a href="#结构体改造" class="headerlink" title="结构体改造"></a>结构体改造</h3><p>所以我们首先考虑到的是抽象出一个结构体，将插件的接口及回调统一，然后利用<code>函数指针</code>实现插件方法的调用，以下是对函数指针声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_init)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">map_t</span> params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_conn)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_write_data)</span><span class="params">(<span class="keyword">dul_node_t</span> *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *payload,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span> *params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_read_data)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">void</span> *params, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">char</span> *payload, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint64_t</span> size)</span></span>;                    </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_close)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;                           </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_destroy)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_reset)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* callback */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_conn_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_write_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">int</span> status)</span></span>;                         </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_recv_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">void</span> *params, <span class="keyword">uv_buf_t</span> *buf, <span class="keyword">ssize_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_close_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但如果仅仅声明这些函数指针，在使用时还必须知道插件的结构体类型才能调用到函数的实现，这样插件之间仍然是耦合的。所以我们必须将插件提前关联起来，通过结构体指针来寻找上一个或者下一个插件，OK，这样就很容易联想到<code>双向链表</code>正好能够满足我们的需求。所以加上 <code>pre</code>  、 <code>next</code> 以及一些必要参数后，最终我们整理的结构体为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dul_node_s</span> &#123;</span></span><br><span class="line"> 	<span class="comment">// 前、后插件</span></span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre;</span><br><span class="line">    <span class="keyword">dul_node_t</span> *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必要参数</span></span><br><span class="line">    <span class="keyword">char</span> *host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">map_t</span> params;</span><br><span class="line"></span><br><span class="line">    node_init init;</span><br><span class="line">    node_conn conn;</span><br><span class="line">    node_write_data write_data;</span><br><span class="line">    node_read_data read_data;</span><br><span class="line">    node_close close;</span><br><span class="line">    node_destroy destroy;</span><br><span class="line">    node_reset reset;</span><br><span class="line"></span><br><span class="line">    node_conn_cb conn_cb;</span><br><span class="line">    node_write_cb write_cb;</span><br><span class="line">    node_recv_cb recv_cb;</span><br><span class="line">    node_close_cb close_cb;</span><br><span class="line">&#125; <span class="keyword">dul_node_t</span>;</span><br></pre></td></tr></table></figure>
<p>接着我们再对原有的结构体进行调整，将结构体前面的成员调整为 <code>dul_node_s</code> 结构体的成员，后面再加上自己的成员。这样在插件初始化的时候统一以 <code>dul_node_s</code> 结构体初始化，而在用到具体某一个插件时我们进行结构体类型强转即可，这里有点像继承里父类和子类的概念。</p>
<h3 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h3><p>在插件使用前我们按需配置好用到的插件，但如果把插件接口直接暴露给业务方来配置，就需要让业务方接触到 C 代码，这点比较难以控制。基于这个原因，我们讨论了一下，想到前端里面 <code>webpack</code> 对于插件配置的相关操作，于是我们查阅了<a href="https://webpack.js.org/concepts/loaders/#inline" target="_blank" rel="noopener"> webpack 的相关文档</a>，最终我们仿照这个方式实现了我们的插件配置：<code>&quot;ws?path=/!tls!uv&quot;</code> 。不同插件以 <code>!</code> 分割，通过循环将插件依次创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separate_loaders</span><span class="params">(<span class="keyword">tokenizer_t</span> *tokenizer, <span class="keyword">char</span> *loaders, context *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *outer_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p = strtok_r(loaders, <span class="string">"!"</span>, &amp;outer_ptr);</span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre_loader = (<span class="keyword">dul_node_t</span> *)c;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        pre_loader = processor_loader(tokenizer, p, pre_loader);</span><br><span class="line">        p = strtok_r(<span class="literal">NULL</span>, <span class="string">"!"</span>, &amp;outer_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单个插件所需要额外的 params 以 <code>query string</code> 形式拼接，在插件创建中用 <code>?</code> 分割出来 ，以 kv 形式放入到一个 hashmap 中。再根据插件的名称调用对应的初始化方法，并根据传入的 <code>pre_loader</code> 绑定双向链表的前后关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*oper_func[])(<span class="keyword">dul_node_t</span> **) = &#123;</span><br><span class="line">    ws_alloc,</span><br><span class="line">    tls_alloc,</span><br><span class="line">    uv_alloc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *loaders[] = &#123;</span><br><span class="line">    <span class="string">"ws"</span>, <span class="string">"tls"</span>, <span class="string">"uv"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dul_node_t</span> *processor_loader(<span class="keyword">tokenizer_t</span> *tokenizer, <span class="keyword">const</span> <span class="keyword">char</span> *loader, <span class="keyword">dul_node_t</span> *pre_loader) &#123;</span><br><span class="line">    <span class="keyword">char</span> *p = loader;</span><br><span class="line">    <span class="keyword">char</span> *inner_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* params 提取组装 */</span></span><br><span class="line">    p = strtok_r(p, <span class="string">"?"</span>, &amp;inner_ptr);</span><br><span class="line">    <span class="keyword">dul_node_t</span> *node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">map_t</span> params = hashmap_new();</span><br><span class="line">    params_parser(inner_ptr, params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里采用转移表，进行插件初始化 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(loaders[sqe], p) != <span class="number">0</span>) &#123;</span><br><span class="line">        sqe++;</span><br><span class="line">    &#125;</span><br><span class="line">    oper_func[sqe](&amp;node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;init(node, params);</span><br><span class="line">    hashmap_free(params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表前后关系绑定</span></span><br><span class="line">    pre_loader-&gt;next = node;</span><br><span class="line">    node-&gt;pre = pre_loader;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* params string 解析 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">params_parser</span><span class="params">(<span class="keyword">char</span> *query, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *outer_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = strtok_r(query, <span class="string">"&amp;"</span>, &amp;outer_ptr);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">char</span> *inner_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *key =  strtok_r(p, <span class="string">"="</span>, &amp;inner_ptr);</span><br><span class="line">        hashmap_put(params, key, inner_ptr);</span><br><span class="line">        p = strtok_r(<span class="literal">NULL</span>, <span class="string">"&amp;"</span>, &amp;outer_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips：随着插件的增加，对应初始化的代码也会越来越多，而且都是重复代码，为了减少这部分工作，我们可以采取宏来定义函数。后续如果增加一个插件，只需要在底下加一行 <code>LOADER_ALLOC(zim_xx, xx)</code> 即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOADER_ALLOC(type, name)                    \</span></span><br><span class="line">    <span class="keyword">void</span> name##_alloc(<span class="keyword">dul_node_t</span> **ctx) &#123;           \</span><br><span class="line">        type##<span class="keyword">_t</span> **loader = (type##<span class="keyword">_t</span> **)ctx;       \</span><br><span class="line">        (*loader) = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type##<span class="keyword">_t</span>));       \</span><br><span class="line">        (*loader)-&gt;init = &amp;name##_init;             \</span><br><span class="line">        (*loader)-&gt;next = <span class="literal">NULL</span>;                     \</span><br><span class="line">        (*loader)-&gt;pre = <span class="literal">NULL</span>;                      \</span><br><span class="line">    &#125;                       </span><br><span class="line"></span><br><span class="line">LOADER_ALLOC(websocket, ws);</span><br><span class="line">LOADER_ALLOC(zim_tls, tls);</span><br><span class="line">LOADER_ALLOC(zim_uv, uv);</span><br></pre></td></tr></table></figure>
<h3 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h3><p>再回到一开始我们思考接口调用的问题，由于有了函数指针变量，我们就需要在插件的初始化中把函数的地址存储在这些变量中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ws_init</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">websocket_t</span> *ws = (<span class="keyword">websocket_t</span> *)ctx;</span><br><span class="line">    bzero(ws, <span class="keyword">sizeof</span>(<span class="keyword">websocket_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略中间初始化过程</span></span><br><span class="line">  </span><br><span class="line">    ws-&gt;init = &amp;ws_init;</span><br><span class="line">    ws-&gt;conn = &amp;ws_connect;</span><br><span class="line">    ws-&gt;close = &amp;ws_close;</span><br><span class="line">    ws-&gt;destroy = &amp;ws_destroy;</span><br><span class="line">    ws-&gt;reset = &amp;ws_reset;</span><br><span class="line">    ws-&gt;write_data = &amp;ws_send;</span><br><span class="line">    ws-&gt;read_data = &amp;ws_read;</span><br><span class="line">    ws-&gt;conn_cb = &amp;ws_conn_cb;</span><br><span class="line">    ws-&gt;write_cb = &amp;ws_send_cb;</span><br><span class="line">    ws-&gt;recv_cb = &amp;ws_recv_cb;</span><br><span class="line">    ws-&gt;close_cb = &amp;ws_close_cb;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比接口前后调用的方式，前者需要知道下一个 connect 函数，并进行显式调用，如果在 TLS 和 TCP 中新增一层，就需要改动 connect 函数的调用。但后者完全没有这个顾虑，不论是新增还是删除插件，它都可以通过指针找到对应的结构体，调用其 connect 函数，插件内部无需任何改动，岂不妙哉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 改造前 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tls_ws_connect</span><span class="params">(<span class="keyword">tls_ws_t</span> *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                   tls_ws_conn_cb conn_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                   tls_ws_close_cb close_cb)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uv_tls_connect(tls,</span><br><span class="line">                          handle-&gt;host,</span><br><span class="line">                          handle-&gt;port,</span><br><span class="line">                          on__tls_connect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改造后 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tls_connect</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_tls_t</span> *tls = (<span class="keyword">zim_tls_t</span> *)ctx;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tls-&gt;next &amp;&amp; tls-&gt;next-&gt;conn) &#123;</span><br><span class="line">        tls-&gt;next-&gt;host = tls-&gt;host;</span><br><span class="line">        tls-&gt;next-&gt;port = tls-&gt;port;</span><br><span class="line">        tls-&gt;next-&gt;conn(tls-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增插件"><a href="#新增插件" class="headerlink" title="新增插件"></a>新增插件</h3><p>基于改造后组件，新增插件只需要改动三处，以日志插件为例：</p>
<ul>
<li>增加日志文件</li>
</ul>
<p>在头文件中定义 <code>zim_log_s</code> 结构体（这里没有额外的成员）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zim_log_s</span> <span class="title">zim_log_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zim_log_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre;</span><br><span class="line">    <span class="keyword">dul_node_t</span> *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">map_t</span> params;</span><br><span class="line"></span><br><span class="line">    node_init init;</span><br><span class="line">    node_conn conn;</span><br><span class="line">    node_write_data write_data;</span><br><span class="line">    node_read_data read_data;</span><br><span class="line">    node_close close;</span><br><span class="line">    node_destroy destroy;</span><br><span class="line">    node_reset reset;</span><br><span class="line"></span><br><span class="line">    node_conn_cb conn_cb;</span><br><span class="line">    node_write_cb write_cb;</span><br><span class="line">    node_recv_cb recv_cb;</span><br><span class="line">    node_close_cb close_cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在实现文件中实现接口及回调，<strong>注意：即使接口或回调内没有额外的操作，仍然需要实现，例如此处的 log_conn_cb 和 log_connect ，否则上一个插件或下一个插件在日志层调用时会中断</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* callback */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_conn_cb</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;pre &amp;&amp; <span class="built_in">log</span>-&gt;pre-&gt;conn_cb) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;pre-&gt;conn_cb(<span class="built_in">log</span>-&gt;pre, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略中间直接回调 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_recv_cb</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">void</span> *params, <span class="keyword">uv_buf_t</span> *buf, <span class="keyword">ssize_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 收集接收到的数据 */</span></span><br><span class="line">    recv_data_from_server(buf-&gt;base, params, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 继续向上一层插件回调接收到的数据 */</span></span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;pre &amp;&amp; <span class="built_in">log</span>-&gt;pre-&gt;recv_cb) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;pre-&gt;recv_cb(<span class="built_in">log</span>-&gt;pre, opcode, buf, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* log hanlder */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_init</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    bzero(<span class="built_in">log</span>, <span class="keyword">sizeof</span>(<span class="keyword">zim_log_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span>-&gt;init = &amp;log_init;</span><br><span class="line">    <span class="built_in">log</span>-&gt;conn = &amp;log_connect;</span><br><span class="line">    <span class="built_in">log</span>-&gt;write_data = &amp;log_write;</span><br><span class="line">    <span class="built_in">log</span>-&gt;read_data = &amp;log_read;</span><br><span class="line">    <span class="built_in">log</span>-&gt;close = &amp;log_close;</span><br><span class="line">    <span class="built_in">log</span>-&gt;destroy = &amp;log_destroy;</span><br><span class="line">    <span class="built_in">log</span>-&gt;reset = &amp;log_reset;</span><br><span class="line">    <span class="built_in">log</span>-&gt;conn_cb = &amp;log_conn_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;write_cb = &amp;log_write_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;recv_cb = &amp;log_recv_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;close_cb = &amp;log_close_cb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_connect</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;next &amp;&amp; <span class="built_in">log</span>-&gt;next-&gt;conn) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;host = <span class="built_in">log</span>-&gt;host;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;port = <span class="built_in">log</span>-&gt;port;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;conn(<span class="built_in">log</span>-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略中间直接调用 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_write</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">char</span> *payload, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 收集发送数据 */</span></span><br><span class="line">    send_data_to_server(payload, payload_size, params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 继续往下一层插件写入数据 */</span></span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;next &amp;&amp; <span class="built_in">log</span>-&gt;next-&gt;write_data) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;write_data(<span class="built_in">log</span>-&gt;next, payload, payload_size, flags);</span><br><span class="line">    &#125;                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>增加日志初始化函数及修改转移表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOADER_ALLOC(zim_log, <span class="built_in">log</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> (*oper_func[])(<span class="keyword">dul_node_t</span> **) = &#123;</span><br><span class="line">    ws_alloc,</span><br><span class="line">    tls_alloc,</span><br><span class="line">    uv_alloc,</span><br><span class="line">    log_alloc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *loaders[] = &#123;</span><br><span class="line">    <span class="string">"ws"</span>, <span class="string">"tls"</span>, <span class="string">"uv"</span>, <span class="string">"log"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改插件注册</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 增加日志前 */</span></span><br><span class="line"><span class="keyword">char</span> loaders[] = <span class="string">"ws?path=/!tls!uv"</span>;</span><br><span class="line">context_init(c, <span class="string">"127.0.0.1"</span>, <span class="number">443</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="literal">NULL</span>, loaders);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加日志后 */</span></span><br><span class="line"><span class="keyword">char</span> loaders[] = <span class="string">"log!ws?path=/!log!tls!uv"</span>;</span><br><span class="line">context_init(c, <span class="string">"127.0.0.1"</span>, <span class="number">443</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="literal">NULL</span>, loaders);</span><br></pre></td></tr></table></figure>
<p>我们重新运行程序，就能发现日志功能已经成功的配置上去，能够将接受和发送的数据上报：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/zim_log.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下跨平台长连接组件的设计，我们使用 libuv 和 mbedtls 分别实现 TCP 和 TLS ，参照 WebSocket 协议实现了其握手及数据读写，同时抽象出通信接口及回调，为了和原生层交互，iOS 和 Android 分别采用 runtime 消息发送和 JNI 进行原生方法调用。</p>
<p>但这样的定向设计完全不符合后期可能会有新增协议解析的预期，所以我们进行了插件化改造，其三个核心点是<code>结构体改造</code>、<code>双向链表</code>和<code>函数指针</code>。</p>
<p>我们通过将插件行为抽象出一个结构体，利用双向链表将前后插件绑定在一起，使用函数指针调用具体插件的函数或回调。</p>
<p>这样做的优点是使得插件之间不存在耦合关系，只需保持逻辑顺序上的关系，同时通过修改插件的注册提高了灵活性，使得组件具有可插拔性（冷插拔）。</p>
<p>但在新增组件中我们需要实现所有的接口和回调，如果数量多的话，这还真是一件比较繁琐的事情。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/24/https/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2018/04/03/cross-platform-architecture design-and-pluggable/';
var disqus_title = '跨平台长连接组件设计及可插拔改造';
var disqus_url = 'http://yuzeyang.github.io/2018/04/03/cross-platform-architecture design-and-pluggable/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code. <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>