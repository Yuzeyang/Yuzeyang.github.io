<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 跨端长连接的插拔式架构设计与实现 · 宫城</title><meta name="description" content="跨端长连接的插拔式架构设计与实现 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">跨端长连接的插拔式架构设计与实现</h1><div class="post-info">2018年3月27日</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在去年我们按照 WebSocket 协议实现了一套跨端长连接组件之后，最近我们又完成了其插件化的改造，为什么要做这样的改造呢？由于当时业务环境复杂和运维的相关限制，有几个业务可以配置 TSL 组成 WSS ，有的业务方不能配置，只能以明文 WebSocket 的方式传输，随着对接的业务方增多，我们没办法进行一一定制，甚至有的业务方连 WebSocket 的承载也不要，转而使用自定义的协议。而当初我们设计的结构是 Worker (负责和业务层通信) -&gt; WebSocket -&gt; TLS -&gt; TCP ，且这四层结构是耦合在一起的，如果需要剔除 TLS 或者扩展一个新的功能，都会改动相当多的代码。基于以上几点，我们发现，原先的定向设计完全不符合要求，为了接下来可能会有新增协议解析的预期，同时又不改变使用 libuv 进行跨平台的初衷，所以我们就实施了插件化的改造，其目的一个是为了<code>解耦</code>，另一个是为了提高组件的灵活性，实现<code>可插拔（冷插拔）</code>。</p>
<a id="more"></a>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>首先我们要对四层结构的职责进行明确</p>
<ul>
<li>Worker ：提供业务接口和回调</li>
<li>WebSocket ：负责 WebSocket 握手，封装/解析帧数据和维护心跳</li>
<li>TLS ：负责 TLS 握手和数据的加解密</li>
<li>TCP：TCP 连接和数据的读写</li>
</ul>
<p>以及整理出结构间的执行调用：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/chat_puggable.png" alt=""></p>
<p>其中 connect 包含了<code>连接</code>和<code>握手</code>两个过程。在完成链路层连接后，我们认为协议层握手完成，才算是真正的连接成功。</p>
<p>同样的，数据读写、连接关闭、连接销毁和重置都会严格按照结构的顺序依次调用。</p>
<h2 id="可插拔改造"><a href="#可插拔改造" class="headerlink" title="可插拔改造"></a>可插拔改造</h2><p>解耦完成之后我们发现对于接口的调用都是显式的，比如 Worker send data 中调用 WebSocket send data ， WebSocket send data 中又调用 TLS send data ，这样的显式调用是因为我们知道这些接口是可用的，但在插件化中某个插件可能没有被使用，这样接口的调用会在某一层中断而导致整个组件的不可用。</p>
<h3 id="结构体改造"><a href="#结构体改造" class="headerlink" title="结构体改造"></a>结构体改造</h3><p>所以我们首先考虑到的是抽象出一个结构体，将插件的接口及回调统一，然后利用<code>函数指针</code>实现插件方法的调用，以下是对函数指针声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_init)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">map_t</span> params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_conn)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_write_data)</span><span class="params">(<span class="keyword">dul_node_t</span> *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *payload,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span> *params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_read_data)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">void</span> *params, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">char</span> *payload, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint64_t</span> size)</span></span>;                    </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_close)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;                           </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_destroy)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_reset)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* callback */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_conn_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_write_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">int</span> status)</span></span>;                         </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*node_recv_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node, <span class="keyword">void</span> *params, <span class="keyword">uv_buf_t</span> *buf, <span class="keyword">ssize_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*node_close_cb)</span><span class="params">(<span class="keyword">dul_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但如果仅仅声明这些函数指针，在使用时还必须知道插件的结构体类型才能调用到函数的实现，这样插件之间仍然是耦合的。所以我们必须将插件提前关联起来，通过结构体指针来寻找上一个或者下一个插件，OK，这样就很容易联想到<code>双向链表</code>正好能够满足我们的需求。所以加上 <code>pre</code>  、 <code>next</code> 以及一些必要参数后，最终我们整理的结构体为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dul_node_s</span> &#123;</span></span><br><span class="line"> 	<span class="comment">// 前、后插件</span></span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre;</span><br><span class="line">    <span class="keyword">dul_node_t</span> *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必要参数</span></span><br><span class="line">    <span class="keyword">char</span> *host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">map_t</span> params;</span><br><span class="line"></span><br><span class="line">    node_init init;</span><br><span class="line">    node_conn conn;</span><br><span class="line">    node_write_data write_data;</span><br><span class="line">    node_read_data read_data;</span><br><span class="line">    node_close close;</span><br><span class="line">    node_destroy destroy;</span><br><span class="line">    node_reset reset;</span><br><span class="line"></span><br><span class="line">    node_conn_cb conn_cb;</span><br><span class="line">    node_write_cb write_cb;</span><br><span class="line">    node_recv_cb recv_cb;</span><br><span class="line">    node_close_cb close_cb;</span><br><span class="line">&#125; <span class="keyword">dul_node_t</span>;</span><br></pre></td></tr></table></figure>
<p>接着我们再对原有的结构体进行调整，将结构体前面的成员调整为 <code>dul_node_s</code> 结构体的成员，后面再加上自己的成员。这样在插件初始化的时候统一以 <code>dul_node_s</code> 结构体初始化，而在用到具体某一个插件时我们进行结构体类型强转即可，这里有点像继承里父类和子类的概念。</p>
<h3 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h3><p>在插件使用前我们按需配置好用到的插件，但如果把插件接口直接暴露给业务方来配置，就需要让业务方接触到 C 代码，这点比较难以控制。基于这个原因，我们讨论了一下，想到前端里面 <code>webpack</code> 对于插件配置的相关操作，于是我们查阅了<a href="https://webpack.js.org/concepts/loaders/#inline" target="_blank" rel="noopener"> webpack 的相关文档</a>，最终我们仿照这个方式实现了我们的插件配置：<code>&quot;ws?path=/!tls!uv&quot;</code> 。不同插件以 <code>!</code> 分割，通过循环将插件依次创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separate_loaders</span><span class="params">(<span class="keyword">tokenizer_t</span> *tokenizer, <span class="keyword">char</span> *loaders, context *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *outer_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p = strtok_r(loaders, <span class="string">"!"</span>, &amp;outer_ptr);</span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre_loader = (<span class="keyword">dul_node_t</span> *)c;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        pre_loader = processor_loader(tokenizer, p, pre_loader);</span><br><span class="line">        p = strtok_r(<span class="literal">NULL</span>, <span class="string">"!"</span>, &amp;outer_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单个插件所需要额外的 params 以 <code>query string</code> 形式拼接，在插件创建中用 <code>?</code> 分割出来 ，以 kv 形式放入到一个 hashmap 中。再根据插件的名称调用对应的初始化方法，并根据传入的 <code>pre_loader</code> 绑定双向链表的前后关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dul_node_t</span> *processor_loader(<span class="keyword">tokenizer_t</span> *tokenizer, <span class="keyword">const</span> <span class="keyword">char</span> *loader, <span class="keyword">dul_node_t</span> *pre_loader) &#123;</span><br><span class="line">    <span class="keyword">char</span> *p = loader;</span><br><span class="line">    <span class="keyword">char</span> *inner_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* params 提取组装 */</span></span><br><span class="line">    p = strtok_r(p, <span class="string">"?"</span>, &amp;inner_ptr);</span><br><span class="line">    <span class="keyword">dul_node_t</span> *node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">map_t</span> params = hashmap_new();</span><br><span class="line">    params_parser(inner_ptr, params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插件初始化 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p, <span class="string">"ws"</span>) == <span class="number">0</span>) &#123;             </span><br><span class="line">        ws_alloc(&amp;node);                    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p, <span class="string">"tls"</span>) == <span class="number">0</span>) &#123;      </span><br><span class="line">        tls_alloc(&amp;node);                   </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p, <span class="string">"uv"</span>) == <span class="number">0</span>) &#123;       </span><br><span class="line">        uv_alloc(&amp;node);                    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;init(node, params);</span><br><span class="line">    hashmap_free(params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表前后关系绑定</span></span><br><span class="line">    pre_loader-&gt;next = node;</span><br><span class="line">    node-&gt;pre = pre_loader;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* params string 解析 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">params_parser</span><span class="params">(<span class="keyword">char</span> *query, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *outer_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = strtok_r(query, <span class="string">"&amp;"</span>, &amp;outer_ptr);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">char</span> *inner_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">char</span> *key =  strtok_r(p, <span class="string">"="</span>, &amp;inner_ptr);</span><br><span class="line">        hashmap_put(params, key, inner_ptr);</span><br><span class="line">        p = strtok_r(<span class="literal">NULL</span>, <span class="string">"&amp;"</span>, &amp;outer_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips：随着插件的增加，对应初始化的代码也会越来越多，而且都是重复代码，为了减少这部分工作，我们可以采取宏来定义函数。后续如果增加一个插件，只需要在底下加一行 <code>LOADER_ALLOC(zim_xx, xx)</code> 即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOADER_ALLOC(type, name)                    \</span></span><br><span class="line">    <span class="keyword">void</span> name##_alloc(<span class="keyword">dul_node_t</span> **ctx) &#123;           \</span><br><span class="line">        type##<span class="keyword">_t</span> **loader = (type##<span class="keyword">_t</span> **)ctx;       \</span><br><span class="line">        (*loader) = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type##<span class="keyword">_t</span>));       \</span><br><span class="line">        (*loader)-&gt;init = &amp;name##_init;             \</span><br><span class="line">        (*loader)-&gt;next = <span class="literal">NULL</span>;                     \</span><br><span class="line">        (*loader)-&gt;pre = <span class="literal">NULL</span>;                      \</span><br><span class="line">    &#125;                       </span><br><span class="line"></span><br><span class="line">LOADER_ALLOC(websocket, ws);</span><br><span class="line">LOADER_ALLOC(zim_tls, tls);</span><br><span class="line">LOADER_ALLOC(zim_uv, uv);</span><br></pre></td></tr></table></figure>
<h3 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h3><p>再回到一开始我们思考接口调用的问题，由于有了函数指针变量，我们就需要在插件的初始化中把函数的地址存储在这些变量中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ws_init</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">websocket_t</span> *ws = (<span class="keyword">websocket_t</span> *)ctx;</span><br><span class="line">    bzero(ws, <span class="keyword">sizeof</span>(<span class="keyword">websocket_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略中间初始化过程</span></span><br><span class="line">  </span><br><span class="line">    ws-&gt;init = &amp;ws_init;</span><br><span class="line">    ws-&gt;conn = &amp;ws_connect;</span><br><span class="line">    ws-&gt;close = &amp;ws_close;</span><br><span class="line">    ws-&gt;destroy = &amp;ws_destroy;</span><br><span class="line">    ws-&gt;reset = &amp;ws_reset;</span><br><span class="line">    ws-&gt;write_data = &amp;ws_send;</span><br><span class="line">    ws-&gt;read_data = &amp;ws_read;</span><br><span class="line">    ws-&gt;conn_cb = &amp;ws_conn_cb;</span><br><span class="line">    ws-&gt;write_cb = &amp;ws_send_cb;</span><br><span class="line">    ws-&gt;recv_cb = &amp;ws_recv_cb;</span><br><span class="line">    ws-&gt;close_cb = &amp;ws_close_cb;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比接口前后调用的方式，前者需要知道下一个 connect 函数，并进行显式调用，如果在 TLS 和 TCP 中新增一层，就需要改动 connect 函数的调用。但后者完全没有这个顾虑，不论是新增还是删除插件，它都可以通过指针找到对应的结构体，调用其 connect 函数，插件内部无需任何改动，岂不妙哉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 改造前 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tls_ws_connect</span><span class="params">(<span class="keyword">tls_ws_t</span> *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                   tls_ws_conn_cb conn_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                   tls_ws_close_cb close_cb)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uv_tls_connect(tls,</span><br><span class="line">                          handle-&gt;host,</span><br><span class="line">                          handle-&gt;port,</span><br><span class="line">                          on__tls_connect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改造后 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tls_connect</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_tls_t</span> *tls = (<span class="keyword">zim_tls_t</span> *)ctx;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tls-&gt;next &amp;&amp; tls-&gt;next-&gt;conn) &#123;</span><br><span class="line">        tls-&gt;next-&gt;host = tls-&gt;host;</span><br><span class="line">        tls-&gt;next-&gt;port = tls-&gt;port;</span><br><span class="line">        tls-&gt;next-&gt;conn(tls-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增插件"><a href="#新增插件" class="headerlink" title="新增插件"></a>新增插件</h3><p>基于改造后组件，新增插件只需要改动三处，以日志插件为例：</p>
<ul>
<li>增加日志文件</li>
</ul>
<p>在头文件中定义 <code>zim_log_s</code> 结构体（这里没有额外的成员）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zim_log_s</span> <span class="title">zim_log_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zim_log_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">dul_node_t</span> *pre;</span><br><span class="line">    <span class="keyword">dul_node_t</span> *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">map_t</span> params;</span><br><span class="line"></span><br><span class="line">    node_init init;</span><br><span class="line">    node_conn conn;</span><br><span class="line">    node_write_data write_data;</span><br><span class="line">    node_read_data read_data;</span><br><span class="line">    node_close close;</span><br><span class="line">    node_destroy destroy;</span><br><span class="line">    node_reset reset;</span><br><span class="line"></span><br><span class="line">    node_conn_cb conn_cb;</span><br><span class="line">    node_write_cb write_cb;</span><br><span class="line">    node_recv_cb recv_cb;</span><br><span class="line">    node_close_cb close_cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在实现文件中实现接口及回调，<strong>注意：即使接口或回调内没有额外的操作，仍然需要实现，例如此处的 log_conn_cb 和 log_connect ，否则上一个插件或下一个插件在日志层调用时会中断</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* callback */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_conn_cb</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;pre &amp;&amp; <span class="built_in">log</span>-&gt;pre-&gt;conn_cb) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;pre-&gt;conn_cb(<span class="built_in">log</span>-&gt;pre, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略中间直接回调 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_recv_cb</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">void</span> *params, <span class="keyword">uv_buf_t</span> *buf, <span class="keyword">ssize_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 收集接收到的数据 */</span></span><br><span class="line">    recv_data_from_server(buf-&gt;base, params, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 继续向上一层插件回调接收到的数据 */</span></span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;pre &amp;&amp; <span class="built_in">log</span>-&gt;pre-&gt;recv_cb) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;pre-&gt;recv_cb(<span class="built_in">log</span>-&gt;pre, opcode, buf, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* log hanlder */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_init</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, <span class="keyword">map_t</span> params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    bzero(<span class="built_in">log</span>, <span class="keyword">sizeof</span>(<span class="keyword">zim_log_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span>-&gt;init = &amp;log_init;</span><br><span class="line">    <span class="built_in">log</span>-&gt;conn = &amp;log_connect;</span><br><span class="line">    <span class="built_in">log</span>-&gt;write_data = &amp;log_write;</span><br><span class="line">    <span class="built_in">log</span>-&gt;read_data = &amp;log_read;</span><br><span class="line">    <span class="built_in">log</span>-&gt;close = &amp;log_close;</span><br><span class="line">    <span class="built_in">log</span>-&gt;destroy = &amp;log_destroy;</span><br><span class="line">    <span class="built_in">log</span>-&gt;reset = &amp;log_reset;</span><br><span class="line">    <span class="built_in">log</span>-&gt;conn_cb = &amp;log_conn_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;write_cb = &amp;log_write_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;recv_cb = &amp;log_recv_cb;</span><br><span class="line">    <span class="built_in">log</span>-&gt;close_cb = &amp;log_close_cb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_connect</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;next &amp;&amp; <span class="built_in">log</span>-&gt;next-&gt;conn) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;host = <span class="built_in">log</span>-&gt;host;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;port = <span class="built_in">log</span>-&gt;port;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;conn(<span class="built_in">log</span>-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略中间直接调用 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_write</span><span class="params">(<span class="keyword">dul_node_t</span> *ctx, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">char</span> *payload, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> payload_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 收集发送数据 */</span></span><br><span class="line">    send_data_to_server(payload, payload_size, params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 继续往下一层插件写入数据 */</span></span><br><span class="line">    <span class="keyword">zim_log_t</span> *<span class="built_in">log</span> = (<span class="keyword">zim_log_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;next &amp;&amp; <span class="built_in">log</span>-&gt;next-&gt;write_data) &#123;</span><br><span class="line">        <span class="built_in">log</span>-&gt;next-&gt;write_data(<span class="built_in">log</span>-&gt;next, payload, payload_size, flags);</span><br><span class="line">    &#125;                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>增加日志初始化函数及调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LOADER_ALLOC(zim_log, <span class="built_in">log</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">dul_node_t</span> *processor_loader(<span class="keyword">tokenizer_t</span> *tokenizer, <span class="keyword">const</span> <span class="keyword">char</span> *loader, <span class="keyword">dul_node_t</span> *pre_loader) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(p, <span class="string">"ws"</span>)) &#123;             </span><br><span class="line">        ws_alloc(&amp;node);                    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p, <span class="string">"tls"</span>)) &#123;      </span><br><span class="line">        tls_alloc(&amp;node);                   </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p, <span class="string">"uv"</span>)) &#123;       </span><br><span class="line">        uv_alloc(&amp;node);                    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p, <span class="string">"log"</span>)) &#123;</span><br><span class="line">        log_alloc(&amp;node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改插件注册</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 增加日志前 */</span></span><br><span class="line"><span class="keyword">char</span> loaders[] = <span class="string">"ws?path=/!tls!uv"</span>;</span><br><span class="line">context_init(c, <span class="string">"127.0.0.1"</span>, <span class="number">443</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="literal">NULL</span>, loaders);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加日志后 */</span></span><br><span class="line"><span class="keyword">char</span> loaders[] = <span class="string">"log!ws?path=/!log!tls!uv"</span>;</span><br><span class="line">context_init(c, <span class="string">"127.0.0.1"</span>, <span class="number">443</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="literal">NULL</span>, loaders);</span><br></pre></td></tr></table></figure>
<p>我们重新运行程序，就能发现日志功能已经成功的配置上去，能够将接受和发送的数据上报：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/zim_log.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下插件化所做的三个核心点是<code>结构体改造</code>、<code>双向链表</code>和<code>函数指针</code>。</p>
<p>我们通过将插件行为抽象出一个结构体，利用双向链表将前后插件绑定在一起，使用函数指针调用具体插件的函数或回调。</p>
<p>这样做的优点是使得插件之间不存在耦合关系，只需保持逻辑顺序上的关系，同时通过修改插件的注册提高了灵活性，使得组件具有可插拔性（冷插拔）。</p>
<p>但在新增组件中我们需要实现所有的接口和回调，如果数量多的话，这还真是一件比较繁琐的事情。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/24/https/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2018/03/27/c-pluggable/';
var disqus_title = '跨端长连接的插拔式架构设计与实现';
var disqus_url = 'http://yuzeyang.github.io/2018/03/27/c-pluggable/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code. <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>