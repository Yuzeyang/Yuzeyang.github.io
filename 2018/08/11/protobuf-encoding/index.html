<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Protocol Buffers Encoding · 宫城</title><meta name="description" content="Protocol Buffers Encoding - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Protocol Buffers Encoding</h1><div class="post-info">2018年8月11日</div><div class="post-content"><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protocol Buffers</a> 是 Google 提出的一种序列化数据格式，最早的 public release 是在08年的7月份推出。相比于 XML 和 JSON ，它的传输大小更小，速度更快，结构更简单，在数据传输和存储的场景下更具有优势。同时 Google 非常友好的提供了<a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">不同平台的版本</a>供开发者们使用，其对外的简洁性旨在让开发者们更注重业务的细节。不过本文并没有对源码进行剖析，我们重点分析的是 Protocol Buffers 是如何做到减小体积，也就是 Encoding 的过程。</p>
<a id="more"></a>
<p>为了便于理解，以下均已官网例子为例。</p>
<h3 id="Message-定义"><a href="#Message-定义" class="headerlink" title="Message 定义"></a>Message 定义</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从 Message 定义入手，这是一个简单的 Test1 Message 定义，里面有一个 int32 类型的 a 属性。假设我们将</p>
<p>a 赋值为150，那么在序列化后它在流中的内容是<code>08 96 01</code>，大小只有3字节，而经过 JSON 序列化后有17字节。相比之下大小减小了很多，那<code>08 96 01</code>的含义是什么呢？我们先来认识一下 <code>varints</code> 。</p>
<h3 id="Base-128-Varints"><a href="#Base-128-Varints" class="headerlink" title="Base 128 Varints"></a>Base 128 Varints</h3><p>Varints 是一种用一个或多个字节来表示一个整数的方法。</p>
<p>简单一点，比如整数1用一个字节就表示为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
<p>当超过128时，比如整数300，它的表示方式则稍微复杂一点了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1010</span> <span class="number">1100</span> <span class="number">0000</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure>
<p>这个是不是有点看不懂。首先 varint 中<strong>除去最后一个字节</strong>，其余都设有一个<code>最高有效位</code>，用来表示是否有其他的字节出现。而一个字节中的低七位用于保存一个数的二补数码表示。在多组字节进行联合计算的时候，低位有效组优先，也就将字节的顺序反序。</p>
<p>根据 varint 的三条规则，我们推导一下<code>1010 1100 0000 0010</code>是如何得到300的。</p>
<p>首先去掉每个字节中的最高有效位（因为最后一个字节的最高有效位是0，说明这是数字的尾端）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1010</span> <span class="number">1100</span> <span class="number">0000</span> <span class="number">0010</span></span><br><span class="line">→ <span class="number">010</span> <span class="number">1100</span>  <span class="number">000</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure>
<p>再将字节反序后拼接计算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> <span class="number">0010</span>  <span class="number">010</span> <span class="number">1100</span></span><br><span class="line">→  <span class="number">000</span> <span class="number">0010</span> ++ <span class="number">010</span> <span class="number">1100</span></span><br><span class="line">→  <span class="number">100101100</span></span><br><span class="line">→  <span class="number">256</span> + <span class="number">32</span> + <span class="number">8</span> + <span class="number">4</span> = <span class="number">300</span></span><br></pre></td></tr></table></figure>
<h3 id="Message-结构"><a href="#Message-结构" class="headerlink" title="Message 结构"></a>Message 结构</h3><p>回到最初的例子，我们可以看到每个字段由四部分组成：<code>field rule</code> 、 <code>field type</code> 、<code>field name</code> 和 <code>field number</code>。具体可见：<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">Language Guide (proto3)</a></p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 protocol buffer message 是由一系列的键值对组成，在转换成二进制的过程中只用 <code>field number</code> 和 <code>wire type</code> 作为键，name 和定义的 type 需配合 <code>.proto</code> 文件解析得到，这样可以极大的减小传输体积，不过需要留意的是 .proto 文件中字段的定义和顺序，否则会解析出错。</p>
<p>wire type 这里实在不知道该如何翻译…暂且叫做<code>编码后的类型</code>。下表是定义的 type 和编码后类型的对应的关系：</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/PB_wire_types" alt=""></p>
<p>上面提到的键则是经过 <code>(field_number &lt;&lt; 3) | wire_type</code> 的计算得出，也就是后三位表示 wire type。</p>
<p>现在我们来分析一下<code>08 96 01</code> 。它是一个 key/value 对，我们将其拆成两块<code>08</code> 和 <code>96 01</code>。</p>
<p>08转换为二进制表示<code>0000 1000</code>，首先后三位的值为0，对应上表中 Varint，用于 int32， int64等等，a 定义的类型 int32 属于其中。然后再右移三位得到<code>0000 0001</code> ，值为1，也就是 a 的 field numer 。对照 <code>.proto</code> 文件就解析出 a 字段的位置了。</p>
<p>96 01转换为二进制表示<code>1001 0110  0000 0001</code>，根据 varint 的三条规则，我们来还原它的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">96</span> <span class="number">01</span> = <span class="number">1001</span> <span class="number">0110</span>  <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">       → <span class="number">000</span> <span class="number">0001</span>  ++  <span class="number">001</span> <span class="number">0110</span></span><br><span class="line">       → <span class="number">10010110</span></span><br><span class="line">       → <span class="number">128</span> + <span class="number">16</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">150</span></span><br></pre></td></tr></table></figure>
<p>综合一下这就是我们想要得到的 <code>a = 150</code>。</p>
<h3 id="Messages-嵌套"><a href="#Messages-嵌套" class="headerlink" title="Messages 嵌套"></a>Messages 嵌套</h3><p>Message 定义也支持嵌套，比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Test3 &#123;</span><br><span class="line">  optional Test1 c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样 Test1 中 a 的值为150，它在流中的内容是<code>1a 03 08 96 01</code> ，最后三个字节就是上面 a 的内容。<code>1a 03</code> 我们同样拆分为<code>1a</code> 和 <code>03</code>。</p>
<p>1a 转换为二进制表示<code>0001 1010</code>，对应的 wire type 为2，包含了 <code>embedded messages</code>，对应的 field number 为3。</p>
<p>03 这个的含义有所不同 ，它表示后面有三个字节，也就是<code>08 96 01</code>。</p>
<h3 id="WebSocket-Protocol-Buffer"><a href="#WebSocket-Protocol-Buffer" class="headerlink" title="WebSocket + Protocol Buffer"></a>WebSocket + Protocol Buffer</h3><p>客户端用 <a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a> ，服务端用 Node ，搭建一套 WebSocket 的环境。</p>
<p>以及用 Pods 安装 <a href="https://github.com/google/protobuf/tree/master/objectivec" target="_blank" rel="noopener">protobuf OC 版本</a>，npm 安装 <a href="https://github.com/dcodeIO/ProtoBuf.js/" target="_blank" rel="noopener">JS 版本</a>。</p>
<p>首先我们定义一个简单的 Message 结构 Person，里面包含了 name 和 age 两个字段，生成 .proto 文件，在客户端和服务端各自维护一份。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们启动后端服务，监听1234端口，并对接收到的数据根据 Person.proto 文件定义的结构进行 decode，然后打印数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"><span class="keyword">const</span> pro = <span class="built_in">require</span>(<span class="string">'protobufjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>: <span class="number">1234</span>&#125;);</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"conntected"</span>);</span><br><span class="line">  </span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    pro.load(<span class="string">'Person.proto'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, root</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> Person = root.lookupType(<span class="string">'personPackage.Person'</span>);</span><br><span class="line">      <span class="keyword">var</span> data = Person.decode(message);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'name is %s'</span>, data.name);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'age is %i'</span>, data.age);</span><br><span class="line">    &#125;);</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'received: %s'</span>, message);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  ws.send(<span class="string">'something'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>服务启动成功之后，开始在客户端建立连接，在收到连接成功的回调之后，将 person 对象进行encode 并发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_ws = [[SRWebSocket alloc] initWithURL:[NSURL URLWithString:@&quot;ws://localhost:1234&quot;]];</span><br><span class="line">_ws.delegate = self;</span><br><span class="line">[_ws open];</span><br><span class="line"></span><br><span class="line">#pragma mark - SRWebSocketDelegate</span><br><span class="line">- (void)webSocketDidOpen:(SRWebSocket *)webSocket &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    Person *person = [Person new];</span><br><span class="line">    person.name = @&quot;yzy&quot;;</span><br><span class="line">    person.age = 28;</span><br><span class="line"></span><br><span class="line">    NSData *data = [person data];</span><br><span class="line">    NSLog(@&quot;%@&quot;, data);</span><br><span class="line">    </span><br><span class="line">    [webSocket send:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端 log 中我们看到输出的 data 内容为 <code>0a03797a 79101c</code> ，你可以尝试一下对其 decode ，看它和定义的是否一致。</p>
<p>在服务端对应的 log 中也正确输出了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name is yzy</span><br><span class="line">age is 28</span><br></pre></td></tr></table></figure>
<p>这样一个简单的 Protobuf 的使用就完成了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/03/cross-platform-architecture design-and-pluggable/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2018/08/11/protobuf-encoding/';
var disqus_title = 'Protocol Buffers Encoding';
var disqus_url = 'http://yuzeyang.github.io/2018/08/11/protobuf-encoding/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code. <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>