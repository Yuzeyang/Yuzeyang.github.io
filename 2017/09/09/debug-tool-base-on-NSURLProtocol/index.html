<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 基于 NSURLProtocol 实现 Debug 环境切换工具 · 宫城</title><meta name="description" content="基于 NSURLProtocol 实现 Debug 环境切换工具 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yuzeyang.github.io/atom.xml" title="宫城"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">基于 NSURLProtocol 实现 Debug 环境切换工具</h1><div class="post-info">2017年9月9日</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司内一般对调试环境会分为<code>线上</code>、<code>预发布</code>和<code>QA测试</code>三种，而在切换环境的时候大多还是通过网页或桌面应用，当在调试客户端应用时这样的方式就比较麻烦了，所以我们组<code>社会光哥</code>将整套环境切换和请求转发的原理理清晰之后实现了 Android 版的 Debug 环境切换工具，而我则根据其原理实现了 iOS 版。客户端接入该工具之后，只需在应用内即可切换环境和指定调试目录（每个目录独立部署代码）。</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h3><p>先简单介绍下环境切换原理（From 光哥）</p>
<p>不同环境对应不同的内网 IP 机器，它是一台反向代理服务器，将网络请求代理到对应环境的云端机器上处理，处理完成之后通过反向代理服务器再返回给请求方。</p>
<p><img src="http://7xtit4.com1.z0.glb.clouddn.com/proxy.png" alt=""></p>
<p>环境设置实际是向对应的地址发送一个网络请求，携带上自己的 WiFi IP（如果开启 Charles 等代理工具后，则是电脑的 WiFi IP），以及云端机器的 IP 和 Port进行绑定，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *URLString = [@&quot;http://&quot; stringByAppendingFormat:@&quot;%@:12345/index&quot;, [self IPByEnv:self.env]];</span><br><span class="line">NSURL *URL = [NSURL URLWithString:URLString];</span><br><span class="line">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];</span><br><span class="line">request.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">[request setValue:self.proxyIP forHTTPHeaderField:@&quot;X-Forward-For&quot;];</span><br><span class="line"></span><br><span class="line">GCCarmenModel *carmenModel = [self carmenConfig];</span><br><span class="line">[request setHTTPBody:[[carmenModel toPostBodyString] dataUsingEncoding:NSUTF8StringEncoding]];</span><br></pre></td></tr></table></figure>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>我们需要使用 <code>NSURLProtocol</code> 拦截客户端发出的所有请求，我们继承 <code>NSURLProtocol</code> 后需要在 AppDelegate 中注册其子类，而  <code>NSURLProtocol</code>  的执行顺序和注册顺序是相反的，所以一般情况我们把它放在最后注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">    [NSURLProtocol registerClass:NSClassFromString(@&quot;ZanDNSProtocol&quot;)];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>目前大多数网络库我们用的都是 <code>AFNetworking</code> ，是基于 <code>NSURLSession</code> 的网络请求，所以在构造 <code>NSURLSessionConfiguration</code> 之后，需要指定它的 <code>protocolClasses</code> ，但为了不破坏 AF 源码，我们可以 <code>Swizzling</code> 系统 <code>NSURLSession</code> 的 API <code>sessionWithConfiguration:delegate:delegateQueue:</code> ，做到对网络库无侵入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSURLSession (DNSSwizzling)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">  #ifdef DEBUG</span><br><span class="line">      dns_classMethodSwizzle(self, @selector(sessionWithConfiguration:delegate:delegateQueue:), @selector(zan_sessionWithConfiguration:delegate:delegateQueue:));</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSURLSession *)zan_sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue &#123;</span><br><span class="line">    configuration.protocolClasses = @[NSClassFromString(@&quot;ZanDNSProtocol&quot;)];</span><br><span class="line">    return [self zan_sessionWithConfiguration:configuration delegate:delegate delegateQueue:queue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接着在 <code>ZanDNSProtocol</code> （ NSURLProtocol 子类）中实现父类方法，一共四步：</p>
<p>第一步判断是否需要拦截，本地我们维护了一份 DNS 列表，我们只拦截在列表中的域名请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    NSString *host = request.URL.host;</span><br><span class="line">    NSDictionary *DNSConfig = [ZanDNSManager sharedInstance].DNSConfig;</span><br><span class="line">    if ([[DNSConfig allKeys] containsObject:host]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步我们修改拦截到的请求，我们解析出当前环境下 Host 对应列表中的 IP 地址，然后在 <code>URL</code> 中用 IP 替换掉 Host，并在请求头中加上 <code>Host</code>，目的是为了防止开启代理之后，代理工具做 DNS 解析，解析到线上的 IP 地址，这样转发的请求还是往线上发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    NSMutableURLRequest *forwardRequest = [request mutableCopy];</span><br><span class="line">    </span><br><span class="line">    NSString *URLString = forwardRequest.URL.absoluteString;</span><br><span class="line">    NSString *originalHost = forwardRequest.URL.host;</span><br><span class="line">    NSDictionary *DNSConfig = [ZanDNSManager sharedInstance].DNSConfig;</span><br><span class="line">    NSString *IP = DNSConfig[originalHost];</span><br><span class="line">    URLString = [URLString stringByReplacingOccurrencesOfString:originalHost withString:IP];</span><br><span class="line">    forwardRequest.URL = [NSURL URLWithString:URLString];</span><br><span class="line">    [forwardRequest setValue:originalHost forHTTPHeaderField:@&quot;Host&quot;];</span><br><span class="line">    [forwardRequest setValue:[ZanDNSManager sharedInstance].proxyIP forHTTPHeaderField:@&quot;X-Forward-For&quot;];</span><br><span class="line">    </span><br><span class="line">    return forwardRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步就是发送请求，如果我们开启了代理，可以配置 <code>NSURLSessionConfiguration</code> 的 <code>connectionProxyDictionary</code> ，好处是我们可以不用再下载 Charles 证书到手机，可以直接代理到 Charles 来抓包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)startLoading &#123;</span><br><span class="line">    [NSURLProtocol setProperty:@(YES) forKey:propertyKey inRequest:[self.request mutableCopy]];</span><br><span class="line">    NSURLSessionConfiguration *configuration;</span><br><span class="line">    if ([ZanDNSManager sharedInstance].openProxy) &#123;</span><br><span class="line">        NSDictionary *proxyDic = @&#123;@&quot;HTTPEnable&quot;: @(YES),</span><br><span class="line">                                   (NSString *)kCFStreamPropertyHTTPProxyHost: [ZanDNSManager sharedInstance].proxyIP,</span><br><span class="line">                                   (NSString *)kCFStreamPropertyHTTPProxyPort: @([ZanDNSManager sharedInstance].proxyPort),</span><br><span class="line">                                   @&quot;HTTPSEnable&quot;: @(YES),</span><br><span class="line">                                   (NSString *)kCFStreamPropertyHTTPSProxyHost: [ZanDNSManager sharedInstance].proxyIP,</span><br><span class="line">                                   (NSString *)kCFStreamPropertyHTTPSProxyPort: @([ZanDNSManager sharedInstance].proxyPort)&#125;;</span><br><span class="line">        configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">        configuration.connectionProxyDictionary = proxyDic;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    self.session = [NSURLSession zan_sessionWithConfiguration:configuration delegate:self delegateQueue:nil];</span><br><span class="line">    NSURLSessionDataTask *task = [self.session dataTaskWithRequest:self.request];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步是我们对请求过程中信任所有证书</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *_Nullable))completionHandler &#123;</span><br><span class="line">    if (!challenge) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    NSString *host = self.request.allHTTPHeaderFields[@&quot;host&quot;];</span><br><span class="line">    if (![challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">        completionHandler(disposition, nil);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSURLCredential *credential = nil;</span><br><span class="line">    if ([self evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:host]) &#123;</span><br><span class="line">        disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">        credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(disposition, credential);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们完成了一整套环境切换和请求拦截转发的方案，但是该工具还未能做到拦截转发 <code>WKWebView</code> 的请求，欢迎大家一起来交流交流~</p>
<h3 id="2018年9月24日更新："><a href="#2018年9月24日更新：" class="headerlink" title="2018年9月24日更新："></a>2018年9月24日更新：</h3><p>看到<a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">腾讯在使用 WK 时遇到的坑</a>里面提到对 WK 的网络拦截，简单的说可以通过注册 http(s) scheme 来拦截到 WK 的网络请求，但是由于 WK 是在独立进程中进行网络通信的，使用 NSURLProtocol 将网络请求拦截到 App 进程时，出于性能原因，IPC 会将 HTTPBody 和 HTTPStream 丢弃，所以 POST 请求的 Body 内容会丢失，不能做到完美的拦截。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/09/fastlane-pod-spec-upgrade/" class="prev">PREV</a><a href="/2017/07/02/websocket/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2017/09/09/debug-tool-base-on-NSURLProtocol/';
var disqus_title = '基于 NSURLProtocol 实现 Debug 环境切换工具';
var disqus_url = 'http://yuzeyang.github.io/2017/09/09/debug-tool-base-on-NSURLProtocol/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code. <p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>