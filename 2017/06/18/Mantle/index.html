<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Mantle 解析 · 宫城</title><meta name="description" content="Mantle 解析 - 宫城"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/CaptainAmerica.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/CaptainAmerica.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yuzeyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Mantle 解析</h1><div class="post-info">2017年6月18日</div><div class="post-content"><p>对 JSON 解析库目前流行的也是非常的多，<a href="https://github.com/jsonmodel/jsonmodel" target="_blank" rel="external">jsonmodel</a> 、<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a> 、<a href="https://github.com/ibireme/YYModel" target="_blank" rel="external">YYModel</a> 等都是大家常用的，使用这些库的好处就是你无需关心数据解析转换和复杂的类型判断处理，你只需要确定好客户端的数据结构能够与后端数据结构相对应即可，而这些库里面对于解析的处理也都是大同小异，无非是在使用、性能和异常处理上有些差别，这里推荐一下郭曜源大神（ YYModel 的作者）的文章，内容是对<a href="http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/" target="_blank" rel="external">各大解析库进行了比较</a>，对于开发者来说，了解其解析过程是最为基础的，这次看完 Mantle 的解析处理，我也做个简单的总结，大家可以互相学习交流。</p>
<a id="more"></a>
<p>首先 Mantle 对于 JSON 解析的过程分为三步：</p>
<p>第一步是对 Model 字段的转换处理</p>
<p>第二步是对 JSON Dictionary 值的转换处理</p>
<p>第三步是对 Model 的赋值</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>对于解析 JSON 数据，我们比较常用是以下这个方法，<code>modelClass</code> 指的是继承于 <code>MTLModel</code> 的子类，也是我们需要解析成的目标 Model 类， <code>JSONDictionary</code> 则是需要解析的 JSON 数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</div><div class="line">	MTLJSONAdapter *adapter = [[self alloc] initWithModelClass:modelClass];</div><div class="line"></div><div class="line">	return [adapter modelFromJSONDictionary:JSONDictionary error:error];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现上看就两步，先根据 modelClass 初始化一个适配器，再根据 JSON 数据返回 model 对象。</p>
<p>初始化适配器的内容比较多，我们分段来说几个关键的地方。</p>
<p>首先检查的就是 Model 是否实现了 <code>MTLJSONSerializing</code> 协议，未实现的话会触发断言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (id)initWithModelClass:(Class)modelClass &#123;</div><div class="line">	NSParameterAssert(modelClass != nil);</div><div class="line">	NSParameterAssert([modelClass conformsToProtocol:@protocol(MTLJSONSerializing)]);</div><div class="line">  </div><div class="line">  	self = [super init];</div><div class="line">	if (self == nil) return nil;</div><div class="line"></div><div class="line">	_modelClass = modelClass;</div><div class="line"></div><div class="line">	_JSONKeyPathsByPropertyKey = [modelClass JSONKeyPathsByPropertyKey];</div><div class="line">  	</div><div class="line">  	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么先来看下  <code>MTLJSONSerializing</code> 协议，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@protocol MTLJSONSerializing &lt;MTLModel&gt;</div><div class="line">@required</div><div class="line">+ (NSDictionary *)JSONKeyPathsByPropertyKey;</div><div class="line"></div><div class="line">@optional</div><div class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;</div><div class="line">+ (Class)classForParsingJSONDictionary:(NSDictionary *)JSONDictionary;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p> <code>JSONKeyPathsByPropertyKey</code> 方法是里面唯一一个必须要实现的，它是用于将属性和 JSON 的解析路径做关联，它不仅仅可以用于给属性起“别名”，还可以用于多级解析和多层嵌套，用官方例子来举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (NSDictionary *)JSONKeyPathsByPropertyKey &#123;</div><div class="line">   return @&#123;</div><div class="line">       @&quot;name&quot;: @&quot;POI.name&quot;,</div><div class="line">       @&quot;point&quot;: @[ @&quot;latitude&quot;, @&quot;longitude&quot; ],</div><div class="line">       @&quot;starred&quot;: @&quot;starred&quot;</div><div class="line">   &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">在映射过程中 starred 与 JSONDictionary[@&quot;starred&quot;] 做映射，</div><div class="line">name 与 JSONDictionary[@&quot;POI&quot;][@&quot;name&quot;] 做映射，</div><div class="line">point 则等同于以下这个 dictionary</div><div class="line">@&#123;</div><div class="line">   @&quot;latitude&quot;: JSONDictionary[@&quot;latitude&quot;],</div><div class="line">   @&quot;longitude&quot;: JSONDictionary[@&quot;longitude&quot;]</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这样的设计很是方便，可以自由定义映射解析之间的关系，但是在实现的时候会发现，我们在处理对于像 starred 这样普通的解析关系时，仍旧需要一个一个重新在定义一遍，如果我们的数据结构内容非常的多，那就是个体力活了，而且不定义就无法解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (id)initWithModelClass:(Class)modelClass &#123;</div><div class="line">	...</div><div class="line">  	</div><div class="line">    NSSet *propertyKeys = [self.modelClass propertyKeys];</div><div class="line">      </div><div class="line">  	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)propertyKeys &#123;</div><div class="line">	NSSet *cachedKeys = objc_getAssociatedObject(self, MTLModelCachedPropertyKeysKey);</div><div class="line">	if (cachedKeys != nil) return cachedKeys;</div><div class="line"></div><div class="line">	NSMutableSet *keys = [NSMutableSet set];</div><div class="line"></div><div class="line">	[self enumeratePropertiesUsingBlock:^(objc_property_t property, BOOL *stop) &#123;</div><div class="line">		NSString *key = @(property_getName(property));</div><div class="line"></div><div class="line">		if ([self storageBehaviorForPropertyWithKey:key] != MTLPropertyStorageNone) &#123;</div><div class="line">			 [keys addObject:key];</div><div class="line">		&#125;</div><div class="line">	&#125;];</div><div class="line"></div><div class="line">	objc_setAssociatedObject(self, MTLModelCachedPropertyKeysKey, keys, OBJC_ASSOCIATION_COPY);</div><div class="line"></div><div class="line">	return keys;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>propertyKeys</code> 是遍历 MTLModel 子类的属性，判断其拷贝行为，过滤掉不做存储的属性，注意它同时会对 hash 、 superclass 、 description 、 debugDescription 这四个属性进行判断，在 NSObject 内这四个都是 readonly 的，如果你不去将它设为 readwrite 的话，它们是不做存储的。</p>
<p>说到存储行为，MTLModel用了一个枚举 <code>MTLPropertyStorage</code> 来标记一个属性的拷贝行为，分为三类，</p>
<p>第一类 <code>MTLPropertyStorageNone</code> ：属性不做任何存储，在 MTLModel里判断不存储的条件是1.没有该属性，自然不用存储 2.该属性没有使用 @dynamic 指令，但是没有成员变量，并且没有对应的setter和getter方法 3. MTLModel 类中属性是只读，且没有成员变量。</p>
<p>第二类 <code>MTLPropertyStorageTransitory</code> ：属性只做暂时性的存储，在官方解释里看到一句话 <code>It may disappear at any time</code> ，感觉指的是弱引用的属性，但是在 MTLModel 里并没有看到返回  MTLPropertyStorageTransitory 的处理，但在 MTLTestModel 中可以找到， MTLTestModel 对 <code>storageBehaviorForPropertyWithKey:</code> 进行了重写，其中它对属性名进行了判断，在对应的头文件里我们也可以找到这个属性的说明：<code>Should not be stored in JSON, has MTLPropertyStorageTransitory.</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (MTLPropertyStorage)storageBehaviorForPropertyWithKey:(NSString *)propertyKey &#123;</div><div class="line">  if ([propertyKey isEqual:@&quot;weakModel&quot;]) &#123;</div><div class="line">  	return MTLPropertyStorageTransitory;</div><div class="line">  &#125; else &#123;</div><div class="line">  	return [super storageBehaviorForPropertyWithKey:propertyKey];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三类 <code>MTLPropertyStoragePermanen</code> ，属性做永久存储， MTLModel 里判断只要不是 MTLPropertyStorageNone 就是 MTLPropertyStoragePermanen，需要做暂时存储的，就需要在子类里重写了。</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)initWithModelClass:(Class)modelClass &#123;</div><div class="line">	...</div><div class="line">  	</div><div class="line">    _valueTransformersByPropertyKey = [self.class valueTransformersForModelClass:modelClass];</div><div class="line">	_JSONAdaptersByModelClass = [NSMapTable strongToStrongObjectsMapTable];</div><div class="line"></div><div class="line">	return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在遍历完之后开始对属性的值进行转换操作，对于转换操作也提供了三种方式，</p>
<p>第一种是自定义方式，在子类里定义实现方法名为 <code>key（属性名）</code> + <code>JSONTransformer</code>  的方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSValueTransformer *)URLJSONTransformer &#123;</div><div class="line">    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种是重写 MTLJSONSerializing 的 optional 协议，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key &#123;</div><div class="line">	return @&#123;</div><div class="line">		// Not provided transformer for self.URL</div><div class="line">		@&quot;otherURL&quot;: [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName],</div><div class="line">	&#125;[key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三种则是根据属性的类型做相应的转换。</p>
<p>在以上两部转换完成之后剩下的就是赋值了，因为实现了 JSONKeyPathsByPropertyKey 方法，所以从 JSONDictionary 取值时如果碰到以数组形式定义的 key 时，会以<code>.</code>进行拆分，例如 <code>@&quot;name&quot;: @&quot;POI.name&quot;</code> ，则对应的取值处理是 <code>JSONDictionary[@&quot;POI&quot;][@&quot;name”]</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</div><div class="line">	...</div><div class="line">      </div><div class="line">      for (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;</div><div class="line">		id JSONKeyPaths = self.JSONKeyPathsByPropertyKey[propertyKey];</div><div class="line"></div><div class="line">		if (JSONKeyPaths == nil) continue;</div><div class="line"></div><div class="line">		id value;</div><div class="line"></div><div class="line">		if ([JSONKeyPaths isKindOfClass:NSArray.class]) &#123;</div><div class="line">			NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];</div><div class="line"></div><div class="line">			for (NSString *keyPath in JSONKeyPaths) &#123;</div><div class="line">				BOOL success = NO;</div><div class="line">				id value = [JSONDictionary mtl_valueForJSONKeyPath:keyPath success:&amp;success error:error];</div><div class="line"></div><div class="line">				if (!success) return nil;</div><div class="line"></div><div class="line">				if (value != nil) dictionary[keyPath] = value;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			value = dictionary;</div><div class="line">		&#125; else &#123;</div><div class="line">			BOOL success = NO;</div><div class="line">			value = [JSONDictionary mtl_valueForJSONKeyPath:JSONKeyPaths success:&amp;success error:error];</div><div class="line"></div><div class="line">			if (!success) return nil;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">  </div><div class="line">  	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还记得我们在子类里定义的 keyTransform 方法么，在取值之后这些值都会做相应的转换，注意一点就是NSNull对象会先转换成nil，然后将nil转换成NSNull对象插入到新的 dictionaryValue 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;</div><div class="line">	...</div><div class="line">      </div><div class="line">      for (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;</div><div class="line">		...</div><div class="line">          </div><div class="line">         @try &#123;</div><div class="line">            NSValueTransformer *transformer = self.valueTransformersByPropertyKey[propertyKey];</div><div class="line">            if (transformer != nil) &#123;</div><div class="line">                // Map NSNull -&gt; nil for the transformer, and then back for the</div><div class="line">                // dictionary we&apos;re going to insert into.</div><div class="line">                if ([value isEqual:NSNull.null]) value = nil;</div><div class="line"></div><div class="line">                if ([transformer respondsToSelector:@selector(transformedValue:success:error:)]) &#123;</div><div class="line">                    id&lt;MTLTransformerErrorHandling&gt; errorHandlingTransformer = (id)transformer;</div><div class="line"></div><div class="line">                    BOOL success = YES;</div><div class="line">                    value = [errorHandlingTransformer transformedValue:value success:&amp;success error:error];</div><div class="line"></div><div class="line">                    if (!success) return nil;</div><div class="line">                &#125; else &#123;</div><div class="line">                    value = [transformer transformedValue:value];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (value == nil) value = NSNull.null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dictionaryValue[propertyKey] = value;</div><div class="line">        &#125; @catch (NSException *ex) &#123;</div><div class="line">            NSLog(@&quot;*** Caught exception %@ parsing JSON key path \&quot;%@\&quot; from: %@&quot;, ex, JSONKeyPaths, JSONDictionary);</div><div class="line"></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">  </div><div class="line">  	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>在生成 dictionaryValue 之后，开始调用 <code>- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error</code> 来对子类进行初始化，并调用 <code>MTLValidateAndSetValue</code> 来赋值，至此从 JSONDictionary 到 model 的解析算是完成了~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;</div><div class="line">	self = [self init];</div><div class="line">	if (self == nil) return nil;</div><div class="line"></div><div class="line">	for (NSString *key in dictionary) &#123;</div><div class="line">		// Mark this as being autoreleased, because validateValue may return</div><div class="line">		// a new object to be stored in this variable (and we don&apos;t want ARC to</div><div class="line">		// double-free or leak the old or new values).</div><div class="line">		__autoreleasing id value = [dictionary objectForKey:key];</div><div class="line"></div><div class="line">		if ([value isEqual:NSNull.null]) value = nil;</div><div class="line"></div><div class="line">		BOOL success = MTLValidateAndSetValue(self, key, value, YES, error);</div><div class="line">		if (!success) return nil;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2017/04/06/Youzan-App-Config-Center/" class="prev">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zeeyang';
var disqus_identifier = '2017/06/18/Mantle/';
var disqus_title = 'Mantle 解析';
var disqus_url = 'http://yuzeyang.github.io/2017/06/18/Mantle/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zeeyang.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yuzeyang.github.io">宫城</a>, Talk is cheap, show me the code.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>